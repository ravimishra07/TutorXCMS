import {
  AddIcon,
  AddLinkIcon,
  Alert,
  ArrowDropDownIcon,
  ArrowForwardIcon,
  ArrowUpwardIcon,
  AssignmentIcon,
  AutoFixHighIcon,
  Avatar,
  Badge,
  BallotIcon,
  BooleanSwitch,
  BooleanSwitchWithLabel,
  BrightnessMediumIcon,
  Button,
  CHIP_COLORS,
  Card,
  CenteredView,
  CheckBoxIcon,
  CheckIcon,
  Checkbox,
  ChevronLeftIcon,
  Chip,
  CircleIcon,
  CircularProgress,
  CloseIcon,
  CodeIcon,
  Collapse,
  Container,
  ContentCopyIcon,
  DarkModeIcon,
  DateTimeField,
  DeleteIcon,
  DescriptionIcon,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  DoNotDisturbOnIcon,
  DriveFolderUploadIcon,
  EditIcon,
  ErrorIcon,
  ExpandablePanel,
  FileCopyIcon,
  FilterListIcon,
  FilterListOffIcon,
  FlagIcon,
  FormatBoldIcon,
  FormatItalicIcon,
  FormatListBulletedIcon,
  FormatListNumberedIcon,
  FormatQuoteIcon,
  FormatStrikethroughIcon,
  FormatUnderlinedIcon,
  FunctionsIcon,
  HandleIcon,
  HttpIcon,
  Icon,
  IconButton,
  ImageIcon,
  InfoIcon,
  KeyboardArrowDownIcon,
  KeyboardArrowUpIcon,
  KeyboardTabIcon,
  Label,
  LightModeIcon,
  LinkIcon,
  ListAltIcon,
  ListIcon,
  LoadingButton,
  LogoutIcon,
  Looks3Icon,
  LooksOneIcon,
  LooksTwoIcon,
  MailIcon,
  Markdown,
  Menu,
  MenuIcon,
  MenuItem,
  MoreVertIcon,
  MultiSelect,
  MultiSelectItem,
  NotesIcon,
  NumbersIcon,
  OpenInFullIcon,
  OpenInNewIcon,
  Popover,
  RemoveIcon,
  RepeatIcon,
  Root,
  ScheduleIcon,
  SearchBar,
  SearchIcon,
  Select,
  SelectItem,
  Separator,
  Sheet,
  ShortTextIcon,
  Skeleton,
  Slot,
  StarIcon,
  SubjectIcon,
  Tab,
  Tabs,
  TextField,
  TextFieldsIcon,
  TextareaAutosize,
  Tooltip,
  Typography,
  UploadFileIcon,
  ViewStreamIcon,
  _extends,
  cardClickableMixin,
  cardMixin,
  cls,
  clsx_default,
  coolIconKeys,
  debounce,
  defaultBorderMixin,
  fieldBackgroundDisabledMixin,
  fieldBackgroundHoverMixin,
  fieldBackgroundMixin,
  focusedDisabled,
  getColorSchemeForSeed,
  iconKeys,
  lib_default,
  paperMixin,
  require_dist,
  require_react_fast_compare,
  useDropzone,
  useInjectStyles,
  useOutsideAlerter
} from "./chunk-ODXTNR6Y.js";
import {
  require_jsx_runtime
} from "./chunk-4MC7CHVX.js";
import {
  require_react_dom
} from "./chunk-VNKJSTVO.js";
import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM,
  require_react
} from "./chunk-BXKINJMQ.js";

// ../../../node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "../../../node_modules/object-hash/dist/object_hash.js"(exports, module) {
    !function(e2) {
      var t2;
      "object" == typeof exports ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : ("undefined" != typeof window ? t2 = window : "undefined" != typeof global ? t2 = global : "undefined" != typeof self && (t2 = self), t2.objectHash = e2());
    }(function() {
      return function r2(o2, i2, u3) {
        function s2(n2, e3) {
          if (!i2[n2]) {
            if (!o2[n2]) {
              var t2 = "function" == typeof __require && __require;
              if (!e3 && t2) return t2(n2, true);
              if (a2) return a2(n2, true);
              throw new Error("Cannot find module '" + n2 + "'");
            }
            e3 = i2[n2] = { exports: {} };
            o2[n2][0].call(e3.exports, function(e4) {
              var t3 = o2[n2][1][e4];
              return s2(t3 || e4);
            }, e3, e3.exports, r2, o2, i2, u3);
          }
          return i2[n2].exports;
        }
        for (var a2 = "function" == typeof __require && __require, e2 = 0; e2 < u3.length; e2++) s2(u3[e2]);
        return s2;
      }({ 1: [function(w, b2, m) {
        !(function(e2, n2, s2, c5, d, h2, p3, g2, y) {
          "use strict";
          var r2 = w("crypto");
          function t2(e3, t3) {
            t3 = u3(e3, t3);
            var n3;
            return void 0 === (n3 = "passthrough" !== t3.algorithm ? r2.createHash(t3.algorithm) : new l2()).write && (n3.write = n3.update, n3.end = n3.update), f(t3, n3).dispatch(e3), n3.update || n3.end(""), n3.digest ? n3.digest("buffer" === t3.encoding ? void 0 : t3.encoding) : (e3 = n3.read(), "buffer" !== t3.encoding ? e3.toString(t3.encoding) : e3);
          }
          (m = b2.exports = t2).sha1 = function(e3) {
            return t2(e3);
          }, m.keys = function(e3) {
            return t2(e3, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m.MD5 = function(e3) {
            return t2(e3, { algorithm: "md5", encoding: "hex" });
          }, m.keysMD5 = function(e3) {
            return t2(e3, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o2 = r2.getHashes ? r2.getHashes().slice() : ["sha1", "md5"], i2 = (o2.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u3(e3, t3) {
            var n3 = {};
            if (n3.algorithm = (t3 = t3 || {}).algorithm || "sha1", n3.encoding = t3.encoding || "hex", n3.excludeValues = !!t3.excludeValues, n3.algorithm = n3.algorithm.toLowerCase(), n3.encoding = n3.encoding.toLowerCase(), n3.ignoreUnknown = true === t3.ignoreUnknown, n3.respectType = false !== t3.respectType, n3.respectFunctionNames = false !== t3.respectFunctionNames, n3.respectFunctionProperties = false !== t3.respectFunctionProperties, n3.unorderedArrays = true === t3.unorderedArrays, n3.unorderedSets = false !== t3.unorderedSets, n3.unorderedObjects = false !== t3.unorderedObjects, n3.replacer = t3.replacer || void 0, n3.excludeKeys = t3.excludeKeys || void 0, void 0 === e3) throw new Error("Object argument required.");
            for (var r3 = 0; r3 < o2.length; ++r3) o2[r3].toLowerCase() === n3.algorithm.toLowerCase() && (n3.algorithm = o2[r3]);
            if (-1 === o2.indexOf(n3.algorithm)) throw new Error('Algorithm "' + n3.algorithm + '"  not supported. supported values: ' + o2.join(", "));
            if (-1 === i2.indexOf(n3.encoding) && "passthrough" !== n3.algorithm) throw new Error('Encoding "' + n3.encoding + '"  not supported. supported values: ' + i2.join(", "));
            return n3;
          }
          function a2(e3) {
            if ("function" == typeof e3) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e3));
          }
          function f(o3, t3, i3) {
            i3 = i3 || [];
            function u4(e3) {
              return t3.update ? t3.update(e3, "utf8") : t3.write(e3, "utf8");
            }
            return { dispatch: function(e3) {
              return this["_" + (null === (e3 = o3.replacer ? o3.replacer(e3) : e3) ? "null" : typeof e3)](e3);
            }, _object: function(t4) {
              var n3, e3 = Object.prototype.toString.call(t4), r3 = /\[object (.*)\]/i.exec(e3);
              r3 = (r3 = r3 ? r3[1] : "unknown:[" + e3 + "]").toLowerCase();
              if (0 <= (e3 = i3.indexOf(t4))) return this.dispatch("[CIRCULAR:" + e3 + "]");
              if (i3.push(t4), void 0 !== s2 && s2.isBuffer && s2.isBuffer(t4)) return u4("buffer:"), u4(t4);
              if ("object" === r3 || "function" === r3 || "asyncfunction" === r3) return e3 = Object.keys(t4), o3.unorderedObjects && (e3 = e3.sort()), false === o3.respectType || a2(t4) || e3.splice(0, 0, "prototype", "__proto__", "constructor"), o3.excludeKeys && (e3 = e3.filter(function(e4) {
                return !o3.excludeKeys(e4);
              })), u4("object:" + e3.length + ":"), n3 = this, e3.forEach(function(e4) {
                n3.dispatch(e4), u4(":"), o3.excludeValues || n3.dispatch(t4[e4]), u4(",");
              });
              if (!this["_" + r3]) {
                if (o3.ignoreUnknown) return u4("[" + r3 + "]");
                throw new Error('Unknown object type "' + r3 + '"');
              }
              this["_" + r3](t4);
            }, _array: function(e3, t4) {
              t4 = void 0 !== t4 ? t4 : false !== o3.unorderedArrays;
              var n3 = this;
              if (u4("array:" + e3.length + ":"), !t4 || e3.length <= 1) return e3.forEach(function(e4) {
                return n3.dispatch(e4);
              });
              var r3 = [], t4 = e3.map(function(e4) {
                var t5 = new l2(), n4 = i3.slice();
                return f(o3, t5, n4).dispatch(e4), r3 = r3.concat(n4.slice(i3.length)), t5.read().toString();
              });
              return i3 = i3.concat(r3), t4.sort(), this._array(t4, false);
            }, _date: function(e3) {
              return u4("date:" + e3.toJSON());
            }, _symbol: function(e3) {
              return u4("symbol:" + e3.toString());
            }, _error: function(e3) {
              return u4("error:" + e3.toString());
            }, _boolean: function(e3) {
              return u4("bool:" + e3.toString());
            }, _string: function(e3) {
              u4("string:" + e3.length + ":"), u4(e3.toString());
            }, _function: function(e3) {
              u4("fn:"), a2(e3) ? this.dispatch("[native]") : this.dispatch(e3.toString()), false !== o3.respectFunctionNames && this.dispatch("function-name:" + String(e3.name)), o3.respectFunctionProperties && this._object(e3);
            }, _number: function(e3) {
              return u4("number:" + e3.toString());
            }, _xml: function(e3) {
              return u4("xml:" + e3.toString());
            }, _null: function() {
              return u4("Null");
            }, _undefined: function() {
              return u4("Undefined");
            }, _regexp: function(e3) {
              return u4("regex:" + e3.toString());
            }, _uint8array: function(e3) {
              return u4("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint8clampedarray: function(e3) {
              return u4("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int8array: function(e3) {
              return u4("int8array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint16array: function(e3) {
              return u4("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int16array: function(e3) {
              return u4("int16array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _uint32array: function(e3) {
              return u4("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _int32array: function(e3) {
              return u4("int32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _float32array: function(e3) {
              return u4("float32array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _float64array: function(e3) {
              return u4("float64array:"), this.dispatch(Array.prototype.slice.call(e3));
            }, _arraybuffer: function(e3) {
              return u4("arraybuffer:"), this.dispatch(new Uint8Array(e3));
            }, _url: function(e3) {
              return u4("url:" + e3.toString());
            }, _map: function(e3) {
              u4("map:");
              e3 = Array.from(e3);
              return this._array(e3, false !== o3.unorderedSets);
            }, _set: function(e3) {
              u4("set:");
              e3 = Array.from(e3);
              return this._array(e3, false !== o3.unorderedSets);
            }, _file: function(e3) {
              return u4("file:"), this.dispatch([e3.name, e3.size, e3.type, e3.lastModfied]);
            }, _blob: function() {
              if (o3.ignoreUnknown) return u4("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u4("domwindow");
            }, _bigint: function(e3) {
              return u4("bigint:" + e3.toString());
            }, _process: function() {
              return u4("process");
            }, _timer: function() {
              return u4("timer");
            }, _pipe: function() {
              return u4("pipe");
            }, _tcp: function() {
              return u4("tcp");
            }, _udp: function() {
              return u4("udp");
            }, _tty: function() {
              return u4("tty");
            }, _statwatcher: function() {
              return u4("statwatcher");
            }, _securecontext: function() {
              return u4("securecontext");
            }, _connection: function() {
              return u4("connection");
            }, _zlib: function() {
              return u4("zlib");
            }, _context: function() {
              return u4("context");
            }, _nodescript: function() {
              return u4("nodescript");
            }, _httpparser: function() {
              return u4("httpparser");
            }, _dataview: function() {
              return u4("dataview");
            }, _signal: function() {
              return u4("signal");
            }, _fsevent: function() {
              return u4("fsevent");
            }, _tlswrap: function() {
              return u4("tlswrap");
            } };
          }
          function l2() {
            return { buf: "", write: function(e3) {
              this.buf += e3;
            }, end: function(e3) {
              this.buf += e3;
            }, read: function() {
              return this.buf;
            } };
          }
          m.writeToStream = function(e3, t3, n3) {
            return void 0 === n3 && (n3 = t3, t3 = {}), f(t3 = u3(e3, t3), n3).dispatch(e3);
          };
        }).call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e2, t2, f) {
        !(function(e3, t3, n2, r2, o2, i2, u3, s2, a2) {
          !function(e4) {
            "use strict";
            var a3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t4 = "+".charCodeAt(0), n3 = "/".charCodeAt(0), r3 = "0".charCodeAt(0), o3 = "a".charCodeAt(0), i3 = "A".charCodeAt(0), u4 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
            function f2(e5) {
              e5 = e5.charCodeAt(0);
              return e5 === t4 || e5 === u4 ? 62 : e5 === n3 || e5 === s3 ? 63 : e5 < r3 ? -1 : e5 < r3 + 10 ? e5 - r3 + 26 + 26 : e5 < i3 + 26 ? e5 - i3 : e5 < o3 + 26 ? e5 - o3 + 26 : void 0;
            }
            e4.toByteArray = function(e5) {
              var t5, n4;
              if (0 < e5.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
              var r4 = e5.length, r4 = "=" === e5.charAt(r4 - 2) ? 2 : "=" === e5.charAt(r4 - 1) ? 1 : 0, o4 = new a3(3 * e5.length / 4 - r4), i4 = 0 < r4 ? e5.length - 4 : e5.length, u5 = 0;
              function s4(e6) {
                o4[u5++] = e6;
              }
              for (t5 = 0; t5 < i4; t5 += 4, 0) s4((16711680 & (n4 = f2(e5.charAt(t5)) << 18 | f2(e5.charAt(t5 + 1)) << 12 | f2(e5.charAt(t5 + 2)) << 6 | f2(e5.charAt(t5 + 3)))) >> 16), s4((65280 & n4) >> 8), s4(255 & n4);
              return 2 == r4 ? s4(255 & (n4 = f2(e5.charAt(t5)) << 2 | f2(e5.charAt(t5 + 1)) >> 4)) : 1 == r4 && (s4((n4 = f2(e5.charAt(t5)) << 10 | f2(e5.charAt(t5 + 1)) << 4 | f2(e5.charAt(t5 + 2)) >> 2) >> 8 & 255), s4(255 & n4)), o4;
            }, e4.fromByteArray = function(e5) {
              var t5, n4, r4, o4, i4 = e5.length % 3, u5 = "";
              function s4(e6) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e6);
              }
              for (t5 = 0, r4 = e5.length - i4; t5 < r4; t5 += 3) n4 = (e5[t5] << 16) + (e5[t5 + 1] << 8) + e5[t5 + 2], u5 += s4((o4 = n4) >> 18 & 63) + s4(o4 >> 12 & 63) + s4(o4 >> 6 & 63) + s4(63 & o4);
              switch (i4) {
                case 1:
                  u5 = (u5 += s4((n4 = e5[e5.length - 1]) >> 2)) + s4(n4 << 4 & 63) + "==";
                  break;
                case 2:
                  u5 = (u5 = (u5 += s4((n4 = (e5[e5.length - 2] << 8) + e5[e5.length - 1]) >> 10)) + s4(n4 >> 4 & 63)) + s4(n4 << 2 & 63) + "=";
              }
              return u5;
            };
          }(void 0 === f ? this.base64js = {} : f);
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O, e2, H) {
        !(function(e3, n2, f, r2, h2, p3, g2, y, w) {
          var a2 = O("base64-js"), i2 = O("ieee754");
          function f(e4, t3, n3) {
            if (!(this instanceof f)) return new f(e4, t3, n3);
            var r3, o3, i3, u4, s3 = typeof e4;
            if ("base64" === t3 && "string" == s3) for (e4 = (u4 = e4).trim ? u4.trim() : u4.replace(/^\s+|\s+$/g, ""); e4.length % 4 != 0; ) e4 += "=";
            if ("number" == s3) r3 = j2(e4);
            else if ("string" == s3) r3 = f.byteLength(e4, t3);
            else {
              if ("object" != s3) throw new Error("First argument needs to be a number, array or string.");
              r3 = j2(e4.length);
            }
            if (f._useTypedArrays ? o3 = f._augment(new Uint8Array(r3)) : ((o3 = this).length = r3, o3._isBuffer = true), f._useTypedArrays && "number" == typeof e4.byteLength) o3._set(e4);
            else if (C(u4 = e4) || f.isBuffer(u4) || u4 && "object" == typeof u4 && "number" == typeof u4.length) for (i3 = 0; i3 < r3; i3++) f.isBuffer(e4) ? o3[i3] = e4.readUInt8(i3) : o3[i3] = e4[i3];
            else if ("string" == s3) o3.write(e4, 0, t3);
            else if ("number" == s3 && !f._useTypedArrays && !n3) for (i3 = 0; i3 < r3; i3++) o3[i3] = 0;
            return o3;
          }
          function b2(e4, t3, n3, r3) {
            return f._charsWritten = c5(function(e5) {
              for (var t4 = [], n4 = 0; n4 < e5.length; n4++) t4.push(255 & e5.charCodeAt(n4));
              return t4;
            }(t3), e4, n3, r3);
          }
          function m(e4, t3, n3, r3) {
            return f._charsWritten = c5(function(e5) {
              for (var t4, n4, r4 = [], o3 = 0; o3 < e5.length; o3++) n4 = e5.charCodeAt(o3), t4 = n4 >> 8, n4 = n4 % 256, r4.push(n4), r4.push(t4);
              return r4;
            }(t3), e4, n3, r3);
          }
          function v(e4, t3, n3) {
            var r3 = "";
            n3 = Math.min(e4.length, n3);
            for (var o3 = t3; o3 < n3; o3++) r3 += String.fromCharCode(e4[o3]);
            return r3;
          }
          function o2(e4, t3, n3, r3) {
            r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t3, "missing offset"), d(t3 + 1 < e4.length, "Trying to read beyond buffer length"));
            var o3, r3 = e4.length;
            if (!(r3 <= t3)) return n3 ? (o3 = e4[t3], t3 + 1 < r3 && (o3 |= e4[t3 + 1] << 8)) : (o3 = e4[t3] << 8, t3 + 1 < r3 && (o3 |= e4[t3 + 1])), o3;
          }
          function u3(e4, t3, n3, r3) {
            r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t3, "missing offset"), d(t3 + 3 < e4.length, "Trying to read beyond buffer length"));
            var o3, r3 = e4.length;
            if (!(r3 <= t3)) return n3 ? (t3 + 2 < r3 && (o3 = e4[t3 + 2] << 16), t3 + 1 < r3 && (o3 |= e4[t3 + 1] << 8), o3 |= e4[t3], t3 + 3 < r3 && (o3 += e4[t3 + 3] << 24 >>> 0)) : (t3 + 1 < r3 && (o3 = e4[t3 + 1] << 16), t3 + 2 < r3 && (o3 |= e4[t3 + 2] << 8), t3 + 3 < r3 && (o3 |= e4[t3 + 3]), o3 += e4[t3] << 24 >>> 0), o3;
          }
          function _(e4, t3, n3, r3) {
            if (r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t3, "missing offset"), d(t3 + 1 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) return r3 = o2(e4, t3, n3, true), 32768 & r3 ? -1 * (65535 - r3 + 1) : r3;
          }
          function E2(e4, t3, n3, r3) {
            if (r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(null != t3, "missing offset"), d(t3 + 3 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) return r3 = u3(e4, t3, n3, true), 2147483648 & r3 ? -1 * (4294967295 - r3 + 1) : r3;
          }
          function I(e4, t3, n3, r3) {
            return r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(t3 + 3 < e4.length, "Trying to read beyond buffer length")), i2.read(e4, t3, n3, 23, 4);
          }
          function A(e4, t3, n3, r3) {
            return r3 || (d("boolean" == typeof n3, "missing or invalid endian"), d(t3 + 7 < e4.length, "Trying to read beyond buffer length")), i2.read(e4, t3, n3, 52, 8);
          }
          function s2(e4, t3, n3, r3, o3) {
            o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 1 < e4.length, "trying to write beyond buffer length"), Y(t3, 65535));
            o3 = e4.length;
            if (!(o3 <= n3)) for (var i3 = 0, u4 = Math.min(o3 - n3, 2); i3 < u4; i3++) e4[n3 + i3] = (t3 & 255 << 8 * (r3 ? i3 : 1 - i3)) >>> 8 * (r3 ? i3 : 1 - i3);
          }
          function l2(e4, t3, n3, r3, o3) {
            o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e4.length, "trying to write beyond buffer length"), Y(t3, 4294967295));
            o3 = e4.length;
            if (!(o3 <= n3)) for (var i3 = 0, u4 = Math.min(o3 - n3, 4); i3 < u4; i3++) e4[n3 + i3] = t3 >>> 8 * (r3 ? i3 : 3 - i3) & 255;
          }
          function B(e4, t3, n3, r3, o3) {
            o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 1 < e4.length, "Trying to write beyond buffer length"), F(t3, 32767, -32768)), e4.length <= n3 || s2(e4, 0 <= t3 ? t3 : 65535 + t3 + 1, n3, r3, o3);
          }
          function L(e4, t3, n3, r3, o3) {
            o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e4.length, "Trying to write beyond buffer length"), F(t3, 2147483647, -2147483648)), e4.length <= n3 || l2(e4, 0 <= t3 ? t3 : 4294967295 + t3 + 1, n3, r3, o3);
          }
          function U(e4, t3, n3, r3, o3) {
            o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 3 < e4.length, "Trying to write beyond buffer length"), D2(t3, 34028234663852886e22, -34028234663852886e22)), e4.length <= n3 || i2.write(e4, t3, n3, r3, 23, 4);
          }
          function x(e4, t3, n3, r3, o3) {
            o3 || (d(null != t3, "missing value"), d("boolean" == typeof r3, "missing or invalid endian"), d(null != n3, "missing offset"), d(n3 + 7 < e4.length, "Trying to write beyond buffer length"), D2(t3, 17976931348623157e292, -17976931348623157e292)), e4.length <= n3 || i2.write(e4, t3, n3, r3, 52, 8);
          }
          H.Buffer = f, H.SlowBuffer = f, H.INSPECT_MAX_BYTES = 50, f.poolSize = 8192, f._useTypedArrays = function() {
            try {
              var e4 = new ArrayBuffer(0), t3 = new Uint8Array(e4);
              return t3.foo = function() {
                return 42;
              }, 42 === t3.foo() && "function" == typeof t3.subarray;
            } catch (e5) {
              return false;
            }
          }(), f.isEncoding = function(e4) {
            switch (String(e4).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f.isBuffer = function(e4) {
            return !(null == e4 || !e4._isBuffer);
          }, f.byteLength = function(e4, t3) {
            var n3;
            switch (e4 += "", t3 || "utf8") {
              case "hex":
                n3 = e4.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n3 = T2(e4).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n3 = e4.length;
                break;
              case "base64":
                n3 = M2(e4).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n3 = 2 * e4.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n3;
          }, f.concat = function(e4, t3) {
            if (d(C(e4), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e4.length) return new f(0);
            if (1 === e4.length) return e4[0];
            if ("number" != typeof t3) for (o3 = t3 = 0; o3 < e4.length; o3++) t3 += e4[o3].length;
            for (var n3 = new f(t3), r3 = 0, o3 = 0; o3 < e4.length; o3++) {
              var i3 = e4[o3];
              i3.copy(n3, r3), r3 += i3.length;
            }
            return n3;
          }, f.prototype.write = function(e4, t3, n3, r3) {
            isFinite(t3) ? isFinite(n3) || (r3 = n3, n3 = void 0) : (a3 = r3, r3 = t3, t3 = n3, n3 = a3), t3 = Number(t3) || 0;
            var o3, i3, u4, s3, a3 = this.length - t3;
            switch ((!n3 || a3 < (n3 = Number(n3))) && (n3 = a3), r3 = String(r3 || "utf8").toLowerCase()) {
              case "hex":
                o3 = function(e5, t4, n4, r4) {
                  n4 = Number(n4) || 0;
                  var o4 = e5.length - n4;
                  (!r4 || o4 < (r4 = Number(r4))) && (r4 = o4), d((o4 = t4.length) % 2 == 0, "Invalid hex string"), o4 / 2 < r4 && (r4 = o4 / 2);
                  for (var i4 = 0; i4 < r4; i4++) {
                    var u5 = parseInt(t4.substr(2 * i4, 2), 16);
                    d(!isNaN(u5), "Invalid hex string"), e5[n4 + i4] = u5;
                  }
                  return f._charsWritten = 2 * i4, i4;
                }(this, e4, t3, n3);
                break;
              case "utf8":
              case "utf-8":
                i3 = this, u4 = t3, s3 = n3, o3 = f._charsWritten = c5(T2(e4), i3, u4, s3);
                break;
              case "ascii":
              case "binary":
                o3 = b2(this, e4, t3, n3);
                break;
              case "base64":
                i3 = this, u4 = t3, s3 = n3, o3 = f._charsWritten = c5(M2(e4), i3, u4, s3);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o3 = m(this, e4, t3, n3);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o3;
          }, f.prototype.toString = function(e4, t3, n3) {
            var r3, o3, i3, u4, s3 = this;
            if (e4 = String(e4 || "utf8").toLowerCase(), t3 = Number(t3) || 0, (n3 = void 0 !== n3 ? Number(n3) : s3.length) === t3) return "";
            switch (e4) {
              case "hex":
                r3 = function(e5, t4, n4) {
                  var r4 = e5.length;
                  (!t4 || t4 < 0) && (t4 = 0);
                  (!n4 || n4 < 0 || r4 < n4) && (n4 = r4);
                  for (var o4 = "", i4 = t4; i4 < n4; i4++) o4 += k2(e5[i4]);
                  return o4;
                }(s3, t3, n3);
                break;
              case "utf8":
              case "utf-8":
                r3 = function(e5, t4, n4) {
                  var r4 = "", o4 = "";
                  n4 = Math.min(e5.length, n4);
                  for (var i4 = t4; i4 < n4; i4++) e5[i4] <= 127 ? (r4 += N(o4) + String.fromCharCode(e5[i4]), o4 = "") : o4 += "%" + e5[i4].toString(16);
                  return r4 + N(o4);
                }(s3, t3, n3);
                break;
              case "ascii":
              case "binary":
                r3 = v(s3, t3, n3);
                break;
              case "base64":
                o3 = s3, u4 = n3, r3 = 0 === (i3 = t3) && u4 === o3.length ? a2.fromByteArray(o3) : a2.fromByteArray(o3.slice(i3, u4));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r3 = function(e5, t4, n4) {
                  for (var r4 = e5.slice(t4, n4), o4 = "", i4 = 0; i4 < r4.length; i4 += 2) o4 += String.fromCharCode(r4[i4] + 256 * r4[i4 + 1]);
                  return o4;
                }(s3, t3, n3);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r3;
          }, f.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f.prototype.copy = function(e4, t3, n3, r3) {
            if (t3 = t3 || 0, (r3 = r3 || 0 === r3 ? r3 : this.length) !== (n3 = n3 || 0) && 0 !== e4.length && 0 !== this.length) {
              d(n3 <= r3, "sourceEnd < sourceStart"), d(0 <= t3 && t3 < e4.length, "targetStart out of bounds"), d(0 <= n3 && n3 < this.length, "sourceStart out of bounds"), d(0 <= r3 && r3 <= this.length, "sourceEnd out of bounds"), r3 > this.length && (r3 = this.length);
              var o3 = (r3 = e4.length - t3 < r3 - n3 ? e4.length - t3 + n3 : r3) - n3;
              if (o3 < 100 || !f._useTypedArrays) for (var i3 = 0; i3 < o3; i3++) e4[i3 + t3] = this[i3 + n3];
              else e4._set(this.subarray(n3, n3 + o3), t3);
            }
          }, f.prototype.slice = function(e4, t3) {
            var n3 = this.length;
            if (e4 = S(e4, n3, 0), t3 = S(t3, n3, n3), f._useTypedArrays) return f._augment(this.subarray(e4, t3));
            for (var r3 = t3 - e4, o3 = new f(r3, void 0, true), i3 = 0; i3 < r3; i3++) o3[i3] = this[i3 + e4];
            return o3;
          }, f.prototype.get = function(e4) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e4);
          }, f.prototype.set = function(e4, t3) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e4, t3);
          }, f.prototype.readUInt8 = function(e4, t3) {
            if (t3 || (d(null != e4, "missing offset"), d(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length)) return this[e4];
          }, f.prototype.readUInt16LE = function(e4, t3) {
            return o2(this, e4, true, t3);
          }, f.prototype.readUInt16BE = function(e4, t3) {
            return o2(this, e4, false, t3);
          }, f.prototype.readUInt32LE = function(e4, t3) {
            return u3(this, e4, true, t3);
          }, f.prototype.readUInt32BE = function(e4, t3) {
            return u3(this, e4, false, t3);
          }, f.prototype.readInt8 = function(e4, t3) {
            if (t3 || (d(null != e4, "missing offset"), d(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length)) return 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
          }, f.prototype.readInt16LE = function(e4, t3) {
            return _(this, e4, true, t3);
          }, f.prototype.readInt16BE = function(e4, t3) {
            return _(this, e4, false, t3);
          }, f.prototype.readInt32LE = function(e4, t3) {
            return E2(this, e4, true, t3);
          }, f.prototype.readInt32BE = function(e4, t3) {
            return E2(this, e4, false, t3);
          }, f.prototype.readFloatLE = function(e4, t3) {
            return I(this, e4, true, t3);
          }, f.prototype.readFloatBE = function(e4, t3) {
            return I(this, e4, false, t3);
          }, f.prototype.readDoubleLE = function(e4, t3) {
            return A(this, e4, true, t3);
          }, f.prototype.readDoubleBE = function(e4, t3) {
            return A(this, e4, false, t3);
          }, f.prototype.writeUInt8 = function(e4, t3, n3) {
            n3 || (d(null != e4, "missing value"), d(null != t3, "missing offset"), d(t3 < this.length, "trying to write beyond buffer length"), Y(e4, 255)), t3 >= this.length || (this[t3] = e4);
          }, f.prototype.writeUInt16LE = function(e4, t3, n3) {
            s2(this, e4, t3, true, n3);
          }, f.prototype.writeUInt16BE = function(e4, t3, n3) {
            s2(this, e4, t3, false, n3);
          }, f.prototype.writeUInt32LE = function(e4, t3, n3) {
            l2(this, e4, t3, true, n3);
          }, f.prototype.writeUInt32BE = function(e4, t3, n3) {
            l2(this, e4, t3, false, n3);
          }, f.prototype.writeInt8 = function(e4, t3, n3) {
            n3 || (d(null != e4, "missing value"), d(null != t3, "missing offset"), d(t3 < this.length, "Trying to write beyond buffer length"), F(e4, 127, -128)), t3 >= this.length || (0 <= e4 ? this.writeUInt8(e4, t3, n3) : this.writeUInt8(255 + e4 + 1, t3, n3));
          }, f.prototype.writeInt16LE = function(e4, t3, n3) {
            B(this, e4, t3, true, n3);
          }, f.prototype.writeInt16BE = function(e4, t3, n3) {
            B(this, e4, t3, false, n3);
          }, f.prototype.writeInt32LE = function(e4, t3, n3) {
            L(this, e4, t3, true, n3);
          }, f.prototype.writeInt32BE = function(e4, t3, n3) {
            L(this, e4, t3, false, n3);
          }, f.prototype.writeFloatLE = function(e4, t3, n3) {
            U(this, e4, t3, true, n3);
          }, f.prototype.writeFloatBE = function(e4, t3, n3) {
            U(this, e4, t3, false, n3);
          }, f.prototype.writeDoubleLE = function(e4, t3, n3) {
            x(this, e4, t3, true, n3);
          }, f.prototype.writeDoubleBE = function(e4, t3, n3) {
            x(this, e4, t3, false, n3);
          }, f.prototype.fill = function(e4, t3, n3) {
            if (t3 = t3 || 0, n3 = n3 || this.length, d("number" == typeof (e4 = "string" == typeof (e4 = e4 || 0) ? e4.charCodeAt(0) : e4) && !isNaN(e4), "value is not a number"), d(t3 <= n3, "end < start"), n3 !== t3 && 0 !== this.length) {
              d(0 <= t3 && t3 < this.length, "start out of bounds"), d(0 <= n3 && n3 <= this.length, "end out of bounds");
              for (var r3 = t3; r3 < n3; r3++) this[r3] = e4;
            }
          }, f.prototype.inspect = function() {
            for (var e4 = [], t3 = this.length, n3 = 0; n3 < t3; n3++) if (e4[n3] = k2(this[n3]), n3 === H.INSPECT_MAX_BYTES) {
              e4[n3 + 1] = "...";
              break;
            }
            return "<Buffer " + e4.join(" ") + ">";
          }, f.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f._useTypedArrays) return new f(this).buffer;
            for (var e4 = new Uint8Array(this.length), t3 = 0, n3 = e4.length; t3 < n3; t3 += 1) e4[t3] = this[t3];
            return e4.buffer;
          };
          var t2 = f.prototype;
          function S(e4, t3, n3) {
            return "number" != typeof e4 ? n3 : t3 <= (e4 = ~~e4) ? t3 : 0 <= e4 || 0 <= (e4 += t3) ? e4 : 0;
          }
          function j2(e4) {
            return (e4 = ~~Math.ceil(+e4)) < 0 ? 0 : e4;
          }
          function C(e4) {
            return (Array.isArray || function(e5) {
              return "[object Array]" === Object.prototype.toString.call(e5);
            })(e4);
          }
          function k2(e4) {
            return e4 < 16 ? "0" + e4.toString(16) : e4.toString(16);
          }
          function T2(e4) {
            for (var t3 = [], n3 = 0; n3 < e4.length; n3++) {
              var r3 = e4.charCodeAt(n3);
              if (r3 <= 127) t3.push(e4.charCodeAt(n3));
              else for (var o3 = n3, i3 = (55296 <= r3 && r3 <= 57343 && n3++, encodeURIComponent(e4.slice(o3, n3 + 1)).substr(1).split("%")), u4 = 0; u4 < i3.length; u4++) t3.push(parseInt(i3[u4], 16));
            }
            return t3;
          }
          function M2(e4) {
            return a2.toByteArray(e4);
          }
          function c5(e4, t3, n3, r3) {
            for (var o3 = 0; o3 < r3 && !(o3 + n3 >= t3.length || o3 >= e4.length); o3++) t3[o3 + n3] = e4[o3];
            return o3;
          }
          function N(e4) {
            try {
              return decodeURIComponent(e4);
            } catch (e5) {
              return String.fromCharCode(65533);
            }
          }
          function Y(e4, t3) {
            d("number" == typeof e4, "cannot write a non-number as a number"), d(0 <= e4, "specified a negative value for writing an unsigned value"), d(e4 <= t3, "value is larger than maximum value for type"), d(Math.floor(e4) === e4, "value has a fractional component");
          }
          function F(e4, t3, n3) {
            d("number" == typeof e4, "cannot write a non-number as a number"), d(e4 <= t3, "value larger than maximum allowed value"), d(n3 <= e4, "value smaller than minimum allowed value"), d(Math.floor(e4) === e4, "value has a fractional component");
          }
          function D2(e4, t3, n3) {
            d("number" == typeof e4, "cannot write a non-number as a number"), d(e4 <= t3, "value larger than maximum allowed value"), d(n3 <= e4, "value smaller than minimum allowed value");
          }
          function d(e4, t3) {
            if (!e4) throw new Error(t3 || "Failed assertion");
          }
          f._augment = function(e4) {
            return e4._isBuffer = true, e4._get = e4.get, e4._set = e4.set, e4.get = t2.get, e4.set = t2.set, e4.write = t2.write, e4.toString = t2.toString, e4.toLocaleString = t2.toString, e4.toJSON = t2.toJSON, e4.copy = t2.copy, e4.slice = t2.slice, e4.readUInt8 = t2.readUInt8, e4.readUInt16LE = t2.readUInt16LE, e4.readUInt16BE = t2.readUInt16BE, e4.readUInt32LE = t2.readUInt32LE, e4.readUInt32BE = t2.readUInt32BE, e4.readInt8 = t2.readInt8, e4.readInt16LE = t2.readInt16LE, e4.readInt16BE = t2.readInt16BE, e4.readInt32LE = t2.readInt32LE, e4.readInt32BE = t2.readInt32BE, e4.readFloatLE = t2.readFloatLE, e4.readFloatBE = t2.readFloatBE, e4.readDoubleLE = t2.readDoubleLE, e4.readDoubleBE = t2.readDoubleBE, e4.writeUInt8 = t2.writeUInt8, e4.writeUInt16LE = t2.writeUInt16LE, e4.writeUInt16BE = t2.writeUInt16BE, e4.writeUInt32LE = t2.writeUInt32LE, e4.writeUInt32BE = t2.writeUInt32BE, e4.writeInt8 = t2.writeInt8, e4.writeInt16LE = t2.writeInt16LE, e4.writeInt16BE = t2.writeInt16BE, e4.writeInt32LE = t2.writeInt32LE, e4.writeInt32BE = t2.writeInt32BE, e4.writeFloatLE = t2.writeFloatLE, e4.writeFloatBE = t2.writeFloatBE, e4.writeDoubleLE = t2.writeDoubleLE, e4.writeDoubleBE = t2.writeDoubleBE, e4.fill = t2.fill, e4.inspect = t2.inspect, e4.toArrayBuffer = t2.toArrayBuffer, e4;
          };
        }).call(this, O("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c5, d, e2) {
        !(function(e3, t2, a2, n2, r2, o2, i2, u3, s2) {
          var a2 = c5("buffer").Buffer, f = 4, l2 = new a2(f);
          l2.fill(0);
          d.exports = { hash: function(e4, t3, n3, r3) {
            for (var o3 = t3(function(e5, t4) {
              e5.length % f != 0 && (n4 = e5.length + (f - e5.length % f), e5 = a2.concat([e5, l2], n4));
              for (var n4, r4 = [], o4 = t4 ? e5.readInt32BE : e5.readInt32LE, i4 = 0; i4 < e5.length; i4 += f) r4.push(o4.call(e5, i4));
              return r4;
            }(e4 = a2.isBuffer(e4) ? e4 : new a2(e4), r3), 8 * e4.length), t3 = r3, i3 = new a2(n3), u4 = t3 ? i3.writeInt32BE : i3.writeInt32LE, s3 = 0; s3 < o3.length; s3++) u4.call(i3, o3[s3], 4 * s3, true);
            return i3;
          } };
        }).call(this, c5("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c5("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v, e2, _) {
        !(function(l2, c5, u3, d, h2, p3, g2, y, w) {
          var u3 = v("buffer").Buffer, e3 = v("./sha"), t2 = v("./sha256"), n2 = v("./rng"), b2 = { sha1: e3, sha256: t2, md5: v("./md5") }, s2 = 64, a2 = new u3(s2);
          function r2(e4, n3) {
            var r3 = b2[e4 = e4 || "sha1"], o3 = [];
            return r3 || i2("algorithm:", e4, "is not yet supported"), { update: function(e5) {
              return u3.isBuffer(e5) || (e5 = new u3(e5)), o3.push(e5), e5.length, this;
            }, digest: function(e5) {
              var t3 = u3.concat(o3), t3 = n3 ? function(e6, t4, n4) {
                u3.isBuffer(t4) || (t4 = new u3(t4)), u3.isBuffer(n4) || (n4 = new u3(n4)), t4.length > s2 ? t4 = e6(t4) : t4.length < s2 && (t4 = u3.concat([t4, a2], s2));
                for (var r4 = new u3(s2), o4 = new u3(s2), i3 = 0; i3 < s2; i3++) r4[i3] = 54 ^ t4[i3], o4[i3] = 92 ^ t4[i3];
                return n4 = e6(u3.concat([r4, n4])), e6(u3.concat([o4, n4]));
              }(r3, n3, t3) : r3(t3);
              return o3 = null, e5 ? t3.toString(e5) : t3;
            } };
          }
          function i2() {
            var e4 = [].slice.call(arguments).join(" ");
            throw new Error([e4, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a2.fill(0), _.createHash = function(e4) {
            return r2(e4);
          }, _.createHmac = r2, _.randomBytes = function(e4, t3) {
            if (!t3 || !t3.call) return new u3(n2(e4));
            try {
              t3.call(this, void 0, new u3(n2(e4)));
            } catch (e5) {
              t3(e5);
            }
          };
          var o2, f = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m = function(e4) {
            _[e4] = function() {
              i2("sorry,", e4, "is not implemented yet");
            };
          };
          for (o2 in f) m(f[o2], o2);
        }).call(this, v("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w, b2, e2) {
        !(function(e3, r2, o2, i2, u3, a2, f, l2, y) {
          var t2 = w("./helpers");
          function n2(e4, t3) {
            e4[t3 >> 5] |= 128 << t3 % 32, e4[14 + (t3 + 64 >>> 9 << 4)] = t3;
            for (var n3 = 1732584193, r3 = -271733879, o3 = -1732584194, i3 = 271733878, u4 = 0; u4 < e4.length; u4 += 16) {
              var s3 = n3, a3 = r3, f2 = o3, l3 = i3, n3 = c5(n3, r3, o3, i3, e4[u4 + 0], 7, -680876936), i3 = c5(i3, n3, r3, o3, e4[u4 + 1], 12, -389564586), o3 = c5(o3, i3, n3, r3, e4[u4 + 2], 17, 606105819), r3 = c5(r3, o3, i3, n3, e4[u4 + 3], 22, -1044525330);
              n3 = c5(n3, r3, o3, i3, e4[u4 + 4], 7, -176418897), i3 = c5(i3, n3, r3, o3, e4[u4 + 5], 12, 1200080426), o3 = c5(o3, i3, n3, r3, e4[u4 + 6], 17, -1473231341), r3 = c5(r3, o3, i3, n3, e4[u4 + 7], 22, -45705983), n3 = c5(n3, r3, o3, i3, e4[u4 + 8], 7, 1770035416), i3 = c5(i3, n3, r3, o3, e4[u4 + 9], 12, -1958414417), o3 = c5(o3, i3, n3, r3, e4[u4 + 10], 17, -42063), r3 = c5(r3, o3, i3, n3, e4[u4 + 11], 22, -1990404162), n3 = c5(n3, r3, o3, i3, e4[u4 + 12], 7, 1804603682), i3 = c5(i3, n3, r3, o3, e4[u4 + 13], 12, -40341101), o3 = c5(o3, i3, n3, r3, e4[u4 + 14], 17, -1502002290), n3 = d(n3, r3 = c5(r3, o3, i3, n3, e4[u4 + 15], 22, 1236535329), o3, i3, e4[u4 + 1], 5, -165796510), i3 = d(i3, n3, r3, o3, e4[u4 + 6], 9, -1069501632), o3 = d(o3, i3, n3, r3, e4[u4 + 11], 14, 643717713), r3 = d(r3, o3, i3, n3, e4[u4 + 0], 20, -373897302), n3 = d(n3, r3, o3, i3, e4[u4 + 5], 5, -701558691), i3 = d(i3, n3, r3, o3, e4[u4 + 10], 9, 38016083), o3 = d(o3, i3, n3, r3, e4[u4 + 15], 14, -660478335), r3 = d(r3, o3, i3, n3, e4[u4 + 4], 20, -405537848), n3 = d(n3, r3, o3, i3, e4[u4 + 9], 5, 568446438), i3 = d(i3, n3, r3, o3, e4[u4 + 14], 9, -1019803690), o3 = d(o3, i3, n3, r3, e4[u4 + 3], 14, -187363961), r3 = d(r3, o3, i3, n3, e4[u4 + 8], 20, 1163531501), n3 = d(n3, r3, o3, i3, e4[u4 + 13], 5, -1444681467), i3 = d(i3, n3, r3, o3, e4[u4 + 2], 9, -51403784), o3 = d(o3, i3, n3, r3, e4[u4 + 7], 14, 1735328473), n3 = h2(n3, r3 = d(r3, o3, i3, n3, e4[u4 + 12], 20, -1926607734), o3, i3, e4[u4 + 5], 4, -378558), i3 = h2(i3, n3, r3, o3, e4[u4 + 8], 11, -2022574463), o3 = h2(o3, i3, n3, r3, e4[u4 + 11], 16, 1839030562), r3 = h2(r3, o3, i3, n3, e4[u4 + 14], 23, -35309556), n3 = h2(n3, r3, o3, i3, e4[u4 + 1], 4, -1530992060), i3 = h2(i3, n3, r3, o3, e4[u4 + 4], 11, 1272893353), o3 = h2(o3, i3, n3, r3, e4[u4 + 7], 16, -155497632), r3 = h2(r3, o3, i3, n3, e4[u4 + 10], 23, -1094730640), n3 = h2(n3, r3, o3, i3, e4[u4 + 13], 4, 681279174), i3 = h2(i3, n3, r3, o3, e4[u4 + 0], 11, -358537222), o3 = h2(o3, i3, n3, r3, e4[u4 + 3], 16, -722521979), r3 = h2(r3, o3, i3, n3, e4[u4 + 6], 23, 76029189), n3 = h2(n3, r3, o3, i3, e4[u4 + 9], 4, -640364487), i3 = h2(i3, n3, r3, o3, e4[u4 + 12], 11, -421815835), o3 = h2(o3, i3, n3, r3, e4[u4 + 15], 16, 530742520), n3 = p3(n3, r3 = h2(r3, o3, i3, n3, e4[u4 + 2], 23, -995338651), o3, i3, e4[u4 + 0], 6, -198630844), i3 = p3(i3, n3, r3, o3, e4[u4 + 7], 10, 1126891415), o3 = p3(o3, i3, n3, r3, e4[u4 + 14], 15, -1416354905), r3 = p3(r3, o3, i3, n3, e4[u4 + 5], 21, -57434055), n3 = p3(n3, r3, o3, i3, e4[u4 + 12], 6, 1700485571), i3 = p3(i3, n3, r3, o3, e4[u4 + 3], 10, -1894986606), o3 = p3(o3, i3, n3, r3, e4[u4 + 10], 15, -1051523), r3 = p3(r3, o3, i3, n3, e4[u4 + 1], 21, -2054922799), n3 = p3(n3, r3, o3, i3, e4[u4 + 8], 6, 1873313359), i3 = p3(i3, n3, r3, o3, e4[u4 + 15], 10, -30611744), o3 = p3(o3, i3, n3, r3, e4[u4 + 6], 15, -1560198380), r3 = p3(r3, o3, i3, n3, e4[u4 + 13], 21, 1309151649), n3 = p3(n3, r3, o3, i3, e4[u4 + 4], 6, -145523070), i3 = p3(i3, n3, r3, o3, e4[u4 + 11], 10, -1120210379), o3 = p3(o3, i3, n3, r3, e4[u4 + 2], 15, 718787259), r3 = p3(r3, o3, i3, n3, e4[u4 + 9], 21, -343485551), n3 = g2(n3, s3), r3 = g2(r3, a3), o3 = g2(o3, f2), i3 = g2(i3, l3);
            }
            return Array(n3, r3, o3, i3);
          }
          function s2(e4, t3, n3, r3, o3, i3) {
            return g2((t3 = g2(g2(t3, e4), g2(r3, i3))) << o3 | t3 >>> 32 - o3, n3);
          }
          function c5(e4, t3, n3, r3, o3, i3, u4) {
            return s2(t3 & n3 | ~t3 & r3, e4, t3, o3, i3, u4);
          }
          function d(e4, t3, n3, r3, o3, i3, u4) {
            return s2(t3 & r3 | n3 & ~r3, e4, t3, o3, i3, u4);
          }
          function h2(e4, t3, n3, r3, o3, i3, u4) {
            return s2(t3 ^ n3 ^ r3, e4, t3, o3, i3, u4);
          }
          function p3(e4, t3, n3, r3, o3, i3, u4) {
            return s2(n3 ^ (t3 | ~r3), e4, t3, o3, i3, u4);
          }
          function g2(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          b2.exports = function(e4) {
            return t2.hash(e4, n2, 16);
          };
        }).call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e2, l2, t2) {
        !(function(e3, t3, n2, r2, o2, i2, u3, s2, f) {
          var a2;
          l2.exports = a2 || function(e4) {
            for (var t4, n3 = new Array(e4), r3 = 0; r3 < e4; r3++) 0 == (3 & r3) && (t4 = 4294967296 * Math.random()), n3[r3] = t4 >>> ((3 & r3) << 3) & 255;
            return n3;
          };
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c5, d, e2) {
        !(function(e3, t2, n2, r2, o2, s2, a2, f, l2) {
          var i2 = c5("./helpers");
          function u3(l3, c6) {
            l3[c6 >> 5] |= 128 << 24 - c6 % 32, l3[15 + (c6 + 64 >> 9 << 4)] = c6;
            for (var e4, t3, n3, r3 = Array(80), o3 = 1732584193, i3 = -271733879, u4 = -1732584194, s3 = 271733878, d2 = -1009589776, h2 = 0; h2 < l3.length; h2 += 16) {
              for (var p3 = o3, g2 = i3, y = u4, w = s3, b2 = d2, a3 = 0; a3 < 80; a3++) {
                r3[a3] = a3 < 16 ? l3[h2 + a3] : v(r3[a3 - 3] ^ r3[a3 - 8] ^ r3[a3 - 14] ^ r3[a3 - 16], 1);
                var f2 = m(m(v(o3, 5), (f2 = i3, t3 = u4, n3 = s3, (e4 = a3) < 20 ? f2 & t3 | ~f2 & n3 : !(e4 < 40) && e4 < 60 ? f2 & t3 | f2 & n3 | t3 & n3 : f2 ^ t3 ^ n3)), m(m(d2, r3[a3]), (e4 = a3) < 20 ? 1518500249 : e4 < 40 ? 1859775393 : e4 < 60 ? -1894007588 : -899497514)), d2 = s3, s3 = u4, u4 = v(i3, 30), i3 = o3, o3 = f2;
              }
              o3 = m(o3, p3), i3 = m(i3, g2), u4 = m(u4, y), s3 = m(s3, w), d2 = m(d2, b2);
            }
            return Array(o3, i3, u4, s3, d2);
          }
          function m(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          function v(e4, t3) {
            return e4 << t3 | e4 >>> 32 - t3;
          }
          d.exports = function(e4) {
            return i2.hash(e4, u3, 20, true);
          };
        }).call(this, c5("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c5("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c5, d, e2) {
        !(function(e3, t2, n2, r2, u3, s2, a2, f, l2) {
          function b2(e4, t3) {
            var n3 = (65535 & e4) + (65535 & t3);
            return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
          }
          function o2(e4, l3) {
            var c6, d2 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t3 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n3 = new Array(64);
            e4[l3 >> 5] |= 128 << 24 - l3 % 32, e4[15 + (l3 + 64 >> 9 << 4)] = l3;
            for (var r3, o3, h2 = 0; h2 < e4.length; h2 += 16) {
              for (var i3 = t3[0], u4 = t3[1], s3 = t3[2], p3 = t3[3], a3 = t3[4], g2 = t3[5], y = t3[6], w = t3[7], f2 = 0; f2 < 64; f2++) n3[f2] = f2 < 16 ? e4[f2 + h2] : b2(b2(b2((o3 = n3[f2 - 2], m(o3, 17) ^ m(o3, 19) ^ v(o3, 10)), n3[f2 - 7]), (o3 = n3[f2 - 15], m(o3, 7) ^ m(o3, 18) ^ v(o3, 3))), n3[f2 - 16]), c6 = b2(b2(b2(b2(w, m(o3 = a3, 6) ^ m(o3, 11) ^ m(o3, 25)), a3 & g2 ^ ~a3 & y), d2[f2]), n3[f2]), r3 = b2(m(r3 = i3, 2) ^ m(r3, 13) ^ m(r3, 22), i3 & u4 ^ i3 & s3 ^ u4 & s3), w = y, y = g2, g2 = a3, a3 = b2(p3, c6), p3 = s3, s3 = u4, u4 = i3, i3 = b2(c6, r3);
              t3[0] = b2(i3, t3[0]), t3[1] = b2(u4, t3[1]), t3[2] = b2(s3, t3[2]), t3[3] = b2(p3, t3[3]), t3[4] = b2(a3, t3[4]), t3[5] = b2(g2, t3[5]), t3[6] = b2(y, t3[6]), t3[7] = b2(w, t3[7]);
            }
            return t3;
          }
          var i2 = c5("./helpers"), m = function(e4, t3) {
            return e4 >>> t3 | e4 << 32 - t3;
          }, v = function(e4, t3) {
            return e4 >>> t3;
          };
          d.exports = function(e4) {
            return i2.hash(e4, o2, 32, true);
          };
        }).call(this, c5("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c5("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e2, t2, f) {
        !(function(e3, t3, n2, r2, o2, i2, u3, s2, a2) {
          f.read = function(e4, t4, n3, r3, o3) {
            var i3, u4, l2 = 8 * o3 - r3 - 1, c5 = (1 << l2) - 1, d = c5 >> 1, s3 = -7, a3 = n3 ? o3 - 1 : 0, f2 = n3 ? -1 : 1, o3 = e4[t4 + a3];
            for (a3 += f2, i3 = o3 & (1 << -s3) - 1, o3 >>= -s3, s3 += l2; 0 < s3; i3 = 256 * i3 + e4[t4 + a3], a3 += f2, s3 -= 8) ;
            for (u4 = i3 & (1 << -s3) - 1, i3 >>= -s3, s3 += r3; 0 < s3; u4 = 256 * u4 + e4[t4 + a3], a3 += f2, s3 -= 8) ;
            if (0 === i3) i3 = 1 - d;
            else {
              if (i3 === c5) return u4 ? NaN : 1 / 0 * (o3 ? -1 : 1);
              u4 += Math.pow(2, r3), i3 -= d;
            }
            return (o3 ? -1 : 1) * u4 * Math.pow(2, i3 - r3);
          }, f.write = function(e4, t4, l2, n3, r3, c5) {
            var o3, i3, u4 = 8 * c5 - r3 - 1, s3 = (1 << u4) - 1, a3 = s3 >> 1, d = 23 === r3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n3 ? 0 : c5 - 1, h2 = n3 ? 1 : -1, c5 = t4 < 0 || 0 === t4 && 1 / t4 < 0 ? 1 : 0;
            for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (i3 = isNaN(t4) ? 1 : 0, o3 = s3) : (o3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (n3 = Math.pow(2, -o3)) < 1 && (o3--, n3 *= 2), 2 <= (t4 += 1 <= o3 + a3 ? d / n3 : d * Math.pow(2, 1 - a3)) * n3 && (o3++, n3 /= 2), s3 <= o3 + a3 ? (i3 = 0, o3 = s3) : 1 <= o3 + a3 ? (i3 = (t4 * n3 - 1) * Math.pow(2, r3), o3 += a3) : (i3 = t4 * Math.pow(2, a3 - 1) * Math.pow(2, r3), o3 = 0)); 8 <= r3; e4[l2 + f2] = 255 & i3, f2 += h2, i3 /= 256, r3 -= 8) ;
            for (o3 = o3 << r3 | i3, u4 += r3; 0 < u4; e4[l2 + f2] = 255 & o3, f2 += h2, o3 /= 256, u4 -= 8) ;
            e4[l2 + f2 - h2] |= 128 * c5;
          };
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e2, h2, t2) {
        !(function(e3, t3, n2, r2, o2, f, l2, c5, d) {
          var i2, u3, s2;
          function a2() {
          }
          (e3 = h2.exports = {}).nextTick = (u3 = "undefined" != typeof window && window.setImmediate, s2 = "undefined" != typeof window && window.postMessage && window.addEventListener, u3 ? function(e4) {
            return window.setImmediate(e4);
          } : s2 ? (i2 = [], window.addEventListener("message", function(e4) {
            var t4 = e4.source;
            t4 !== window && null !== t4 || "process-tick" !== e4.data || (e4.stopPropagation(), 0 < i2.length && i2.shift()());
          }, true), function(e4) {
            i2.push(e4), window.postMessage("process-tick", "*");
          }) : function(e4) {
            setTimeout(e4, 0);
          }), e3.title = "browser", e3.browser = true, e3.env = {}, e3.argv = [], e3.on = a2, e3.addListener = a2, e3.once = a2, e3.off = a2, e3.removeListener = a2, e3.removeAllListeners = a2, e3.emit = a2, e3.binding = function(e4) {
            throw new Error("process.binding is not supported");
          }, e3.cwd = function() {
            return "/";
          }, e3.chdir = function(e4) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// ../../../node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "../../../node_modules/lodash/_baseHas.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseHas(object2, key) {
      return object2 != null && hasOwnProperty2.call(object2, key);
    }
    module.exports = baseHas;
  }
});

// ../../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../../node_modules/lodash/isArray.js"(exports, module) {
    var isArray2 = Array.isArray;
    module.exports = isArray2;
  }
});

// ../../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../../node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// ../../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../../node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// ../../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../../node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// ../../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../../node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// ../../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../../node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// ../../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../../node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// ../../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../../node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike2(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike2;
  }
});

// ../../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../../node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// ../../../node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../../node_modules/lodash/_isKey.js"(exports, module) {
    var isArray2 = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray2(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    module.exports = isKey;
  }
});

// ../../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../../node_modules/lodash/isObject.js"(exports, module) {
    function isObject5(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject5;
  }
});

// ../../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../../node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject5 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction3(value) {
      if (!isObject5(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction3;
  }
});

// ../../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../../node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// ../../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../../node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// ../../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../../node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// ../../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../../node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction3 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject5 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject5(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// ../../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../../node_modules/lodash/_getValue.js"(exports, module) {
    function getValue2(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    module.exports = getValue2;
  }
});

// ../../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../../node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue2 = require_getValue();
    function getNative(object2, key) {
      var value = getValue2(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// ../../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../../node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// ../../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../../node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// ../../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../../node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// ../../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../../node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// ../../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../../node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    module.exports = hashHas;
  }
});

// ../../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../../node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// ../../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../../node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// ../../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../../node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// ../../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../../node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// ../../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../../node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// ../../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../../node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// ../../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../../node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    module.exports = listCacheGet;
  }
});

// ../../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../../node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// ../../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../../node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// ../../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../../node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// ../../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../../node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// ../../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../../node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// ../../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../../node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// ../../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../../node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map4, key) {
      var data = map4.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// ../../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../../node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// ../../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../../node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// ../../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../../node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// ../../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../../node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// ../../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../../node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// ../../../node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../../node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// ../../../node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../../node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// ../../../node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../../node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match85, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match85);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// ../../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../../node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// ../../../node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../../node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray2 = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY2 = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
    function baseToString2(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray2(value)) {
        return arrayMap(value, baseToString2) + "";
      }
      if (isSymbol(value)) {
        return symbolToString2 ? symbolToString2.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
    }
    module.exports = baseToString2;
  }
});

// ../../../node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../../node_modules/lodash/toString.js"(exports, module) {
    var baseToString2 = require_baseToString();
    function toString4(value) {
      return value == null ? "" : baseToString2(value);
    }
    module.exports = toString4;
  }
});

// ../../../node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../../node_modules/lodash/_castPath.js"(exports, module) {
    var isArray2 = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString4 = require_toString();
    function castPath(value, object2) {
      if (isArray2(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath(toString4(value));
    }
    module.exports = castPath;
  }
});

// ../../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../../node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike2(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// ../../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../../node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike2 = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// ../../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../../node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// ../../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../../node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// ../../../node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../../node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var INFINITY2 = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// ../../../node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../../../node_modules/lodash/_hasPath.js"(exports, module) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray2 = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object2, path, hasFunc) {
      path = castPath(path, object2);
      var index2 = -1, length = path.length, result = false;
      while (++index2 < length) {
        var key = toKey(path[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length) {
        return result;
      }
      length = object2 == null ? 0 : object2.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray2(object2) || isArguments(object2));
    }
    module.exports = hasPath;
  }
});

// ../../../node_modules/lodash/has.js
var require_has = __commonJS({
  "../../../node_modules/lodash/has.js"(exports, module) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has4(object2, path) {
      return object2 != null && hasPath(object2, path, baseHas);
    }
    module.exports = has4;
  }
});

// ../../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../../node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty2 = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    module.exports = defineProperty2;
  }
});

// ../../../node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../../node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty2 = require_defineProperty();
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty2) {
        defineProperty2(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// ../../../node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../../node_modules/lodash/_createBaseFor.js"(exports, module) {
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    module.exports = createBaseFor;
  }
});

// ../../../node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../../node_modules/lodash/_baseFor.js"(exports, module) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// ../../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../../node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// ../../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../../node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// ../../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../../node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// ../../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../../node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike2 = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// ../../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../../node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// ../../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../../node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// ../../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../../node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// ../../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../../node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray2 = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// ../../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../../node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// ../../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../../node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// ../../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../../node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// ../../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../../node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// ../../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../../node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction3 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    module.exports = isArrayLike;
  }
});

// ../../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../../node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    module.exports = keys2;
  }
});

// ../../../node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../../node_modules/lodash/_baseForOwn.js"(exports, module) {
    var baseFor = require_baseFor();
    var keys2 = require_keys();
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor(object2, iteratee, keys2);
    }
    module.exports = baseForOwn;
  }
});

// ../../../node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../../node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// ../../../node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../../node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// ../../../node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../../node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// ../../../node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../../node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// ../../../node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../../node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// ../../../node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../../node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// ../../../node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../../node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// ../../../node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../../node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// ../../../node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../../node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// ../../../node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../../node_modules/lodash/_arraySome.js"(exports, module) {
    function arraySome(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// ../../../node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../../node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  }
});

// ../../../node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../../node_modules/lodash/_equalArrays.js"(exports, module) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// ../../../node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../../node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// ../../../node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../../node_modules/lodash/_mapToArray.js"(exports, module) {
    function mapToArray(map4) {
      var index2 = -1, result = Array(map4.size);
      map4.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// ../../../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../../node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// ../../../node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../../node_modules/lodash/_equalByTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// ../../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../../node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array2, values) {
      var index2 = -1, length = values.length, offset4 = array2.length;
      while (++index2 < length) {
        array2[offset4 + index2] = values[index2];
      }
      return array2;
    }
    module.exports = arrayPush;
  }
});

// ../../../node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../../node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray2 = require_isArray();
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    module.exports = baseGetAllKeys;
  }
});

// ../../../node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../../node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// ../../../node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../../node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// ../../../node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../../node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// ../../../node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../../node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys2 = require_keys();
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys2, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// ../../../node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../../node_modules/lodash/_equalObjects.js"(exports, module) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// ../../../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../../node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module.exports = DataView;
  }
});

// ../../../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../../node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// ../../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../../node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// ../../../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../../node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// ../../../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../../node_modules/lodash/_getTag.js"(exports, module) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag2 = baseGetTag;
    if (DataView && getTag2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
      getTag2 = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag2;
  }
});

// ../../../node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../../node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag2 = require_getTag();
    var isArray2 = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag2(object2), othTag = othIsArr ? arrayTag : getTag2(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// ../../../node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../../node_modules/lodash/_baseIsEqual.js"(exports, module) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike2 = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// ../../../node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../../../node_modules/lodash/_baseIsMatch.js"(exports, module) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index2 = matchData.length, length = index2, noCustomizer = !customizer;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (index2--) {
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length) {
        data = matchData[index2];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module.exports = baseIsMatch;
  }
});

// ../../../node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../../../node_modules/lodash/_isStrictComparable.js"(exports, module) {
    var isObject5 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject5(value);
    }
    module.exports = isStrictComparable;
  }
});

// ../../../node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../../../node_modules/lodash/_getMatchData.js"(exports, module) {
    var isStrictComparable = require_isStrictComparable();
    var keys2 = require_keys();
    function getMatchData(object2) {
      var result = keys2(object2), length = result.length;
      while (length--) {
        var key = result[length], value = object2[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module.exports = getMatchData;
  }
});

// ../../../node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../../../node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    module.exports = matchesStrictComparable;
  }
});

// ../../../node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../../../node_modules/lodash/_baseMatches.js"(exports, module) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    module.exports = baseMatches;
  }
});

// ../../../node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../../../node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index2 = 0, length = path.length;
      while (object2 != null && index2 < length) {
        object2 = object2[toKey(path[index2++])];
      }
      return index2 && index2 == length ? object2 : void 0;
    }
    module.exports = baseGet;
  }
});

// ../../../node_modules/lodash/get.js
var require_get = __commonJS({
  "../../../node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get3(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get3;
  }
});

// ../../../node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../../../node_modules/lodash/_baseHasIn.js"(exports, module) {
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    module.exports = baseHasIn;
  }
});

// ../../../node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../../../node_modules/lodash/hasIn.js"(exports, module) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    module.exports = hasIn;
  }
});

// ../../../node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../../../node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    var get3 = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object2) {
        var objValue = get3(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module.exports = baseMatchesProperty;
  }
});

// ../../../node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../../node_modules/lodash/identity.js"(exports, module) {
    function identity(value) {
      return value;
    }
    module.exports = identity;
  }
});

// ../../../node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../../../node_modules/lodash/_baseProperty.js"(exports, module) {
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module.exports = baseProperty;
  }
});

// ../../../node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../../../node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object2) {
        return baseGet(object2, path);
      };
    }
    module.exports = basePropertyDeep;
  }
});

// ../../../node_modules/lodash/property.js
var require_property = __commonJS({
  "../../../node_modules/lodash/property.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = property;
  }
});

// ../../../node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../../../node_modules/lodash/_baseIteratee.js"(exports, module) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray2 = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module.exports = baseIteratee;
  }
});

// ../../../node_modules/lodash/mapValues.js
var require_mapValues = __commonJS({
  "../../../node_modules/lodash/mapValues.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapValues3(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result, key, iteratee(value, key, object3));
      });
      return result;
    }
    module.exports = mapValues3;
  }
});

// ../../../node_modules/property-expr/index.js
var require_property_expr = __commonJS({
  "../../../node_modules/property-expr/index.js"(exports, module) {
    "use strict";
    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function() {
      this._size = 0;
      this._values = /* @__PURE__ */ Object.create(null);
    };
    Cache.prototype.get = function(key) {
      return this._values[key];
    };
    Cache.prototype.set = function(key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values)) this._size++;
      return this._values[key] = value;
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
    var DIGIT_REGEX = /^\d+$/;
    var LEAD_DIGIT_REGEX = /^\d/;
    var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
    var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
    var MAX_CACHE_SIZE = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE);
    var setCache = new Cache(MAX_CACHE_SIZE);
    var getCache = new Cache(MAX_CACHE_SIZE);
    module.exports = {
      Cache,
      split: split3,
      normalizePath,
      setter: function(path) {
        var parts = normalizePath(path);
        return setCache.get(path) || setCache.set(path, function setter(obj, value) {
          var index2 = 0;
          var len = parts.length;
          var data = obj;
          while (index2 < len - 1) {
            var part = parts[index2];
            if (part === "__proto__" || part === "constructor" || part === "prototype") {
              return obj;
            }
            data = data[parts[index2++]];
          }
          data[parts[index2]] = value;
        });
      },
      getter: function(path, safe) {
        var parts = normalizePath(path);
        return getCache.get(path) || getCache.set(path, function getter3(data) {
          var index2 = 0, len = parts.length;
          while (index2 < len) {
            if (data != null || !safe) data = data[parts[index2++]];
            else return;
          }
          return data;
        });
      },
      join: function(segments) {
        return segments.reduce(function(path, part) {
          return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
        }, "");
      },
      forEach: function(path, cb, thisArg) {
        forEach4(Array.isArray(path) ? path : split3(path), cb, thisArg);
      }
    };
    function normalizePath(path) {
      return pathCache.get(path) || pathCache.set(
        path,
        split3(path).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        })
      );
    }
    function split3(path) {
      return path.match(SPLIT_REGEX) || [""];
    }
    function forEach4(parts, iter, thisArg) {
      var len = parts.length, part, idx, isArray2, isBracket;
      for (idx = 0; idx < len; idx++) {
        part = parts[idx];
        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }
          isBracket = isQuoted(part);
          isArray2 = !isBracket && /^\d+$/.test(part);
          iter.call(thisArg, part, isBracket, isArray2, idx, parts);
        }
      }
    }
    function isQuoted(str) {
      return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
    }
    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
  }
});

// ../../../node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "../../../node_modules/lodash/_arrayReduce.js"(exports, module) {
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array2[index2], index2, array2);
      }
      return accumulator;
    }
    module.exports = arrayReduce;
  }
});

// ../../../node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "../../../node_modules/lodash/_basePropertyOf.js"(exports, module) {
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module.exports = basePropertyOf;
  }
});

// ../../../node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "../../../node_modules/lodash/_deburrLetter.js"(exports, module) {
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module.exports = deburrLetter;
  }
});

// ../../../node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "../../../node_modules/lodash/deburr.js"(exports, module) {
    var deburrLetter = require_deburrLetter();
    var toString4 = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string2) {
      string2 = toString4(string2);
      return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// ../../../node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "../../../node_modules/lodash/_asciiWords.js"(exports, module) {
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    module.exports = asciiWords;
  }
});

// ../../../node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "../../../node_modules/lodash/_hasUnicodeWord.js"(exports, module) {
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    module.exports = hasUnicodeWord;
  }
});

// ../../../node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "../../../node_modules/lodash/_unicodeWords.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    module.exports = unicodeWords;
  }
});

// ../../../node_modules/lodash/words.js
var require_words = __commonJS({
  "../../../node_modules/lodash/words.js"(exports, module) {
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString4 = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string2, pattern, guard2) {
      string2 = toString4(string2);
      pattern = guard2 ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
      }
      return string2.match(pattern) || [];
    }
    module.exports = words;
  }
});

// ../../../node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "../../../node_modules/lodash/_createCompounder.js"(exports, module) {
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "['’]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string2) {
        return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
      };
    }
    module.exports = createCompounder;
  }
});

// ../../../node_modules/lodash/snakeCase.js
var require_snakeCase = __commonJS({
  "../../../node_modules/lodash/snakeCase.js"(exports, module) {
    var createCompounder = require_createCompounder();
    var snakeCase2 = createCompounder(function(result, word, index2) {
      return result + (index2 ? "_" : "") + word.toLowerCase();
    });
    module.exports = snakeCase2;
  }
});

// ../../../node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "../../../node_modules/lodash/_baseSlice.js"(exports, module) {
    function baseSlice(array2, start3, end3) {
      var index2 = -1, length = array2.length;
      if (start3 < 0) {
        start3 = -start3 > length ? 0 : length + start3;
      }
      end3 = end3 > length ? length : end3;
      if (end3 < 0) {
        end3 += length;
      }
      length = start3 > end3 ? 0 : end3 - start3 >>> 0;
      start3 >>>= 0;
      var result = Array(length);
      while (++index2 < length) {
        result[index2] = array2[index2 + start3];
      }
      return result;
    }
    module.exports = baseSlice;
  }
});

// ../../../node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "../../../node_modules/lodash/_castSlice.js"(exports, module) {
    var baseSlice = require_baseSlice();
    function castSlice(array2, start3, end3) {
      var length = array2.length;
      end3 = end3 === void 0 ? length : end3;
      return !start3 && end3 >= length ? array2 : baseSlice(array2, start3, end3);
    }
    module.exports = castSlice;
  }
});

// ../../../node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "../../../node_modules/lodash/_hasUnicode.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    module.exports = hasUnicode;
  }
});

// ../../../node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "../../../node_modules/lodash/_asciiToArray.js"(exports, module) {
    function asciiToArray(string2) {
      return string2.split("");
    }
    module.exports = asciiToArray;
  }
});

// ../../../node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "../../../node_modules/lodash/_unicodeToArray.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    module.exports = unicodeToArray;
  }
});

// ../../../node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "../../../node_modules/lodash/_stringToArray.js"(exports, module) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray2(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    module.exports = stringToArray2;
  }
});

// ../../../node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "../../../node_modules/lodash/_createCaseFirst.js"(exports, module) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray2 = require_stringToArray();
    var toString4 = require_toString();
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString4(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray2(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module.exports = createCaseFirst;
  }
});

// ../../../node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "../../../node_modules/lodash/upperFirst.js"(exports, module) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module.exports = upperFirst;
  }
});

// ../../../node_modules/lodash/capitalize.js
var require_capitalize = __commonJS({
  "../../../node_modules/lodash/capitalize.js"(exports, module) {
    var toString4 = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize(string2) {
      return upperFirst(toString4(string2).toLowerCase());
    }
    module.exports = capitalize;
  }
});

// ../../../node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "../../../node_modules/lodash/camelCase.js"(exports, module) {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase2 = createCompounder(function(result, word, index2) {
      word = word.toLowerCase();
      return result + (index2 ? capitalize(word) : word);
    });
    module.exports = camelCase2;
  }
});

// ../../../node_modules/lodash/mapKeys.js
var require_mapKeys = __commonJS({
  "../../../node_modules/lodash/mapKeys.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapKeys2(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result, iteratee(value, key, object3), value);
      });
      return result;
    }
    module.exports = mapKeys2;
  }
});

// ../../../node_modules/toposort/index.js
var require_toposort = __commonJS({
  "../../../node_modules/toposort/index.js"(exports, module) {
    module.exports = function(edges) {
      return toposort2(uniqueNodes(edges), edges);
    };
    module.exports.array = toposort2;
    function toposort2(nodes, edges) {
      var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i2 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error("Unknown node. There is an unknown node in the supplied edges.");
        }
      });
      while (i2--) {
        if (!visited[i2]) visit(nodes[i2], i2, /* @__PURE__ */ new Set());
      }
      return sorted;
      function visit(node, i3, predecessors) {
        if (predecessors.has(node)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node);
          } catch (e2) {
            nodeRep = "";
          }
          throw new Error("Cyclic dependency" + nodeRep);
        }
        if (!nodesHash.has(node)) {
          throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
        }
        if (visited[i3]) return;
        visited[i3] = true;
        var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
        outgoing = Array.from(outgoing);
        if (i3 = outgoing.length) {
          predecessors.add(node);
          do {
            var child = outgoing[--i3];
            visit(child, nodesHash.get(child), predecessors);
          } while (i3);
          predecessors.delete(node);
        }
        sorted[--cursor] = node;
      }
    }
    function uniqueNodes(arr) {
      var res = /* @__PURE__ */ new Set();
      for (var i2 = 0, len = arr.length; i2 < len; i2++) {
        var edge = arr[i2];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res);
    }
    function makeOutgoingEdges(arr) {
      var edges = /* @__PURE__ */ new Map();
      for (var i2 = 0, len = arr.length; i2 < len; i2++) {
        var edge = arr[i2];
        if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
        if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges;
    }
    function makeNodesHash(arr) {
      var res = /* @__PURE__ */ new Map();
      for (var i2 = 0, len = arr.length; i2 < len; i2++) {
        res.set(arr[i2], i2);
      }
      return res;
    }
  }
});

// ../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = __commonJS({
  "../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is3(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React9 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is3, useSyncExternalStore2 = React9.useSyncExternalStore, useRef11 = React9.useRef, useEffect11 = React9.useEffect, useMemo11 = React9.useMemo, useDebugValue3 = React9.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual4) {
        var instRef = useRef11(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo11(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual4 && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual4(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual4 && isEqual4(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual4]
        );
        var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
        useEffect11(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue3(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../../../node_modules/use-sync-external-store/with-selector.js
var require_with_selector = __commonJS({
  "../../../node_modules/use-sync-external-store/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_with_selector_development();
    }
  }
});

// ../../../node_modules/react-image-file-resizer/build/index.js
var require_build = __commonJS({
  "../../../node_modules/react-image-file-resizer/build/index.js"(exports, module) {
    (() => {
      "use strict";
      var e2 = { d: (t3, a3) => {
        for (var r3 in a3) e2.o(a3, r3) && !e2.o(t3, r3) && Object.defineProperty(t3, r3, { enumerable: true, get: a3[r3] });
      }, o: (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), r: (e3) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      } }, t2 = {};
      function a2(e3, t3) {
        for (var a3 = 0; a3 < t3.length; a3++) {
          var r3 = t3[a3];
          r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e3, r3.key, r3);
        }
      }
      e2.r(t2), e2.d(t2, { default: () => n2 });
      var r2 = function() {
        function e3() {
          !function(e4, t4) {
            if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          }(this, e3);
        }
        var t3, r3;
        return t3 = e3, r3 = [{ key: "changeHeightWidth", value: function(e4, t4, a3, r4, n3, i2) {
          return a3 > r4 && (e4 = Math.round(e4 * r4 / a3), a3 = r4), e4 > t4 && (a3 = Math.round(a3 * t4 / e4), e4 = t4), n3 && a3 < n3 && (e4 = Math.round(e4 * n3 / a3), a3 = n3), i2 && e4 < i2 && (a3 = Math.round(a3 * i2 / e4), e4 = i2), { height: e4, width: a3 };
        } }, { key: "resizeAndRotateImage", value: function(e4, t4, a3, r4, n3) {
          var i2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "jpeg", o2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 100, l2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, h2 = o2 / 100, g2 = document.createElement("canvas"), u3 = e4.width, d = e4.height, c5 = this.changeHeightWidth(d, a3, u3, t4, r4, n3);
          !l2 || 90 !== l2 && 270 !== l2 ? (g2.width = c5.width, g2.height = c5.height) : (g2.width = c5.height, g2.height = c5.width), u3 = c5.width, d = c5.height;
          var s2 = g2.getContext("2d");
          return s2.fillStyle = "rgba(0, 0, 0, 0)", s2.fillRect(0, 0, u3, d), s2.imageSmoothingEnabled && s2.imageSmoothingQuality && (s2.imageSmoothingQuality = "high"), l2 && (s2.rotate(l2 * Math.PI / 180), 90 === l2 ? s2.translate(0, -g2.width) : 180 === l2 ? s2.translate(-g2.width, -g2.height) : 270 === l2 ? s2.translate(-g2.height, 0) : 0 !== l2 && 360 !== l2 || s2.translate(0, 0)), s2.drawImage(e4, 0, 0, u3, d), g2.toDataURL("image/".concat(i2), h2);
        } }, { key: "b64toByteArrays", value: function(e4, t4) {
          t4 = t4 || "image/jpeg";
          for (var a3 = atob(e4.toString().replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, "")), r4 = [], n3 = 0; n3 < a3.length; n3 += 512) {
            for (var i2 = a3.slice(n3, n3 + 512), o2 = new Array(i2.length), l2 = 0; l2 < i2.length; l2++) o2[l2] = i2.charCodeAt(l2);
            var h2 = new Uint8Array(o2);
            r4.push(h2);
          }
          return r4;
        } }, { key: "b64toBlob", value: function(e4, t4) {
          var a3 = this.b64toByteArrays(e4, t4);
          return new Blob(a3, { type: t4, lastModified: /* @__PURE__ */ new Date() });
        } }, { key: "b64toFile", value: function(e4, t4, a3) {
          var r4 = this.b64toByteArrays(e4, a3);
          return new File(r4, t4, { type: a3, lastModified: /* @__PURE__ */ new Date() });
        } }, { key: "createResizedImage", value: function(t4, a3, r4, n3, i2, o2, l2) {
          var h2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "base64", g2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, u3 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : null, d = new FileReader();
          if (!t4) throw Error("File Not Found!");
          if (t4.type && !t4.type.includes("image")) throw Error("File Is NOT Image!");
          d.readAsDataURL(t4), d.onload = function() {
            var c5 = new Image();
            c5.src = d.result, c5.onload = function() {
              var d2 = e3.resizeAndRotateImage(c5, a3, r4, g2, u3, n3, i2, o2), s2 = "image/".concat(n3);
              switch (h2) {
                case "blob":
                  var f = e3.b64toBlob(d2, s2);
                  l2(f);
                  break;
                case "base64":
                  l2(d2);
                  break;
                case "file":
                  var b2 = t4.name.toString().replace(/(png|jpeg|jpg|webp)$/i, "").concat(n3.toString()), v = e3.b64toFile(d2, b2, s2);
                  l2(v);
                  break;
                default:
                  l2(d2);
              }
            };
          }, d.onerror = function(e4) {
            throw Error(e4);
          };
        } }], null, r3 && a2(t3, r3), e3;
      }();
      const n2 = { imageFileResizer: function(e3, t3, a3, n3, i2, o2, l2, h2, g2, u3) {
        return r2.createResizedImage(e3, t3, a3, n3, i2, o2, l2, h2, g2, u3);
      } };
      module.exports = t2;
    })();
  }
});

// ../../../node_modules/markdown-it-task-lists/index.js
var require_markdown_it_task_lists = __commonJS({
  "../../../node_modules/markdown-it-task-lists/index.js"(exports, module) {
    var disableCheckboxes = true;
    var useLabelWrapper = false;
    var useLabelAfter = false;
    module.exports = function(md2, options2) {
      if (options2) {
        disableCheckboxes = !options2.enabled;
        useLabelWrapper = !!options2.label;
        useLabelAfter = !!options2.labelAfter;
      }
      md2.core.ruler.after("inline", "github-task-lists", function(state) {
        var tokens = state.tokens;
        for (var i2 = 2; i2 < tokens.length; i2++) {
          if (isTodoItem(tokens, i2)) {
            todoify(tokens[i2], state.Token);
            attrSet(tokens[i2 - 2], "class", "task-list-item" + (!disableCheckboxes ? " enabled" : ""));
            attrSet(tokens[parentToken(tokens, i2 - 2)], "class", "contains-task-list");
          }
        }
      });
    };
    function attrSet(token, name, value) {
      var index2 = token.attrIndex(name);
      var attr = [name, value];
      if (index2 < 0) {
        token.attrPush(attr);
      } else {
        token.attrs[index2] = attr;
      }
    }
    function parentToken(tokens, index2) {
      var targetLevel = tokens[index2].level - 1;
      for (var i2 = index2 - 1; i2 >= 0; i2--) {
        if (tokens[i2].level === targetLevel) {
          return i2;
        }
      }
      return -1;
    }
    function isTodoItem(tokens, index2) {
      return isInline2(tokens[index2]) && isParagraph(tokens[index2 - 1]) && isListItem(tokens[index2 - 2]) && startsWithTodoMarkdown(tokens[index2]);
    }
    function todoify(token, TokenConstructor) {
      token.children.unshift(makeCheckbox(token, TokenConstructor));
      token.children[1].content = token.children[1].content.slice(3);
      token.content = token.content.slice(3);
      if (useLabelWrapper) {
        if (useLabelAfter) {
          token.children.pop();
          var id2 = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
          token.children[0].content = token.children[0].content.slice(0, -1) + ' id="' + id2 + '">';
          token.children.push(afterLabel(token.content, id2, TokenConstructor));
        } else {
          token.children.unshift(beginLabel(TokenConstructor));
          token.children.push(endLabel(TokenConstructor));
        }
      }
    }
    function makeCheckbox(token, TokenConstructor) {
      var checkbox = new TokenConstructor("html_inline", "", 0);
      var disabledAttr = disableCheckboxes ? ' disabled="" ' : "";
      if (token.content.indexOf("[ ] ") === 0) {
        checkbox.content = '<input class="task-list-item-checkbox"' + disabledAttr + 'type="checkbox">';
      } else if (token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0) {
        checkbox.content = '<input class="task-list-item-checkbox" checked=""' + disabledAttr + 'type="checkbox">';
      }
      return checkbox;
    }
    function beginLabel(TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = "<label>";
      return token;
    }
    function endLabel(TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = "</label>";
      return token;
    }
    function afterLabel(content, id2, TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = '<label class="task-list-item-label" for="' + id2 + '">' + content + "</label>";
      token.attrs = [{ for: id2 }];
      return token;
    }
    function isInline2(token) {
      return token.type === "inline";
    }
    function isParagraph(token) {
      return token.type === "paragraph_open";
    }
    function isListItem(token) {
      return token.type === "list_item_open";
    }
    function startsWithTodoMarkdown(token) {
      return token.content.indexOf("[ ] ") === 0 || token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0;
    }
  }
});

// ../../../node_modules/@firecms/core/dist/index.es.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react_compiler_runtime3 = __toESM(require_dist());
var React8 = __toESM(require_react());
var import_react14 = __toESM(require_react());

// ../../../node_modules/notistack/notistack.esm.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// ../../../node_modules/notistack/node_modules/clsx/dist/clsx.m.js
function r(e2) {
  var t2, f, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) for (t2 = 0; t2 < e2.length; t2++) e2[t2] && (f = r(e2[t2])) && (n2 && (n2 += " "), n2 += f);
  else for (t2 in e2) e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f = 0, n2 = ""; f < arguments.length; ) (e2 = arguments[f++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var clsx_m_default = clsx;

// ../../../node_modules/goober/dist/goober.modern.js
var e = { data: "" };
var t = (t2) => "object" == typeof window ? ((t2 ? t2.querySelector("#_goober") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t2 || e;
var l = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g;
var a = /\/\*[^]*?\*\/|  +/g;
var n = /\n+/g;
var o = (e2, t2) => {
  let r2 = "", l2 = "", a2 = "";
  for (let n2 in e2) {
    let c5 = e2[n2];
    "@" == n2[0] ? "i" == n2[1] ? r2 = n2 + " " + c5 + ";" : l2 += "f" == n2[1] ? o(c5, n2) : n2 + "{" + o(c5, "k" == n2[1] ? "" : t2) + "}" : "object" == typeof c5 ? l2 += o(c5, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + " " + t3 : t3)) : n2) : null != c5 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, "-$&").toLowerCase(), a2 += o.p ? o.p(n2, c5) : n2 + ":" + c5 + ";");
  }
  return r2 + (t2 && a2 ? t2 + "{" + a2 + "}" : a2) + l2;
};
var c = {};
var s = (e2) => {
  if ("object" == typeof e2) {
    let t2 = "";
    for (let r2 in e2) t2 += r2 + s(e2[r2]);
    return t2;
  }
  return e2;
};
var i = (e2, t2, r2, i2, p3) => {
  let u3 = s(e2), d = c[u3] || (c[u3] = ((e3) => {
    let t3 = 0, r3 = 11;
    for (; t3 < e3.length; ) r3 = 101 * r3 + e3.charCodeAt(t3++) >>> 0;
    return "go" + r3;
  })(u3));
  if (!c[d]) {
    let t3 = u3 !== e2 ? e2 : ((e3) => {
      let t4, r3, o2 = [{}];
      for (; t4 = l.exec(e3.replace(a, "")); ) t4[4] ? o2.shift() : t4[3] ? (r3 = t4[3].replace(n, " ").trim(), o2.unshift(o2[0][r3] = o2[0][r3] || {})) : o2[0][t4[1]] = t4[2].replace(n, " ").trim();
      return o2[0];
    })(e2);
    c[d] = o(p3 ? { ["@keyframes " + d]: t3 } : t3, r2 ? "" : "." + d);
  }
  let f = r2 && c.g ? c.g : null;
  return r2 && (c.g = c[d]), ((e3, t3, r3, l2) => {
    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r3 ? e3 + t3.data : t3.data + e3);
  })(c[d], t2, i2, f), d;
};
var p = (e2, t2, r2) => e2.reduce((e3, l2, a2) => {
  let n2 = t2[a2];
  if (n2 && n2.call) {
    let e4 = n2(r2), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;
    n2 = t3 ? "." + t3 : e4 && "object" == typeof e4 ? e4.props ? "" : o(e4, "") : false === e4 ? "" : e4;
  }
  return e3 + l2 + (null == n2 ? "" : n2);
}, "");
function u(e2) {
  let r2 = this || {}, l2 = e2.call ? e2(r2.p) : e2;
  return i(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r2.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r2.p) : t2), {}) : l2, t(r2.target), r2.g, r2.o, r2.k);
}
var b = u.bind({ g: 1 });
var h = u.bind({ k: 1 });

// ../../../node_modules/notistack/notistack.esm.js
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var noOp = function noOp2() {
  return "";
};
var SnackbarContext = import_react.default.createContext({
  enqueueSnackbar: noOp,
  closeSnackbar: noOp
});
var breakpoints = {
  downXs: "@media (max-width:599.95px)",
  upSm: "@media (min-width:600px)"
};
var capitalise = function capitalise2(text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
var originKeyExtractor = function originKeyExtractor2(anchor) {
  return "" + capitalise(anchor.vertical) + capitalise(anchor.horizontal);
};
var isDefined = function isDefined2(value) {
  return !!value || value === 0;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    var appear = props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props["in"]) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else if (props.unmountOnExit || props.mountOnEnter) {
      initialStatus = UNMOUNTED;
    } else {
      initialStatus = EXITED;
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref["in"];
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props["in"]) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else if (status === ENTERING || status === ENTERED) {
        nextStatus = EXITING;
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var enter3 = timeout2;
    var exit = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number" && typeof timeout2 !== "string") {
      exit = timeout2.exit;
      enter3 = timeout2.enter;
    }
    return {
      exit,
      enter: enter3
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter3 = this.props.enter;
    var isAppearing = mounting;
    var timeouts = this.getTimeouts();
    if (!mounting && !enter3) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        if (_this2.props.onEntered) {
          _this2.props.onEntered(_this2.node, isAppearing);
        }
      });
      return;
    }
    if (this.props.onEnter) {
      this.props.onEnter(this.node, isAppearing);
    }
    this.safeSetState({
      status: ENTERING
    }, function() {
      if (_this2.props.onEntering) {
        _this2.props.onEntering(_this2.node, isAppearing);
      }
      _this2.onTransitionEnd(timeouts.enter, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          if (_this2.props.onEntered) {
            _this2.props.onEntered(_this2.node, isAppearing);
          }
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    if (!exit) {
      this.safeSetState({
        status: EXITED
      }, function() {
        if (_this3.props.onExited) {
          _this3.props.onExited(_this3.node);
        }
      });
      return;
    }
    if (this.props.onExit) {
      this.props.onExit(this.node);
    }
    this.safeSetState({
      status: EXITING
    }, function() {
      if (_this3.props.onExiting) {
        _this3.props.onExiting(_this3.node);
      }
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          if (_this3.props.onExited) {
            _this3.props.onExited(_this3.node);
          }
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null && this.nextCallback.cancel) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function() {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback();
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!this.node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      this.props.addEndListener(this.node, this.nextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return children(status, childProps);
  };
  _createClass(Transition2, [{
    key: "node",
    get: function get3() {
      var _this$props$nodeRef;
      var node = (_this$props$nodeRef = this.props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current;
      if (!node) {
        throw new Error("notistack - Custom snackbar is not refForwarding");
      }
      return node;
    }
  }]);
  return Transition2;
}(import_react.default.Component);
function noop() {
}
Transition.defaultProps = {
  "in": false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2) {
    ref2.current = value;
  }
}
function useForkRef(refA, refB) {
  return (0, import_react.useMemo)(function() {
    if (refA == null && refB == null) {
      return null;
    }
    return function(refValue) {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
}
function getTransitionProps(props) {
  var timeout2 = props.timeout, _props$style = props.style, style3 = _props$style === void 0 ? {} : _props$style, mode = props.mode;
  return {
    duration: typeof timeout2 === "object" ? timeout2[mode] || 0 : timeout2,
    easing: style3.transitionTimingFunction,
    delay: style3.transitionDelay
  };
}
var defaultEasing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
var reflow = function reflow2(node) {
  node.scrollTop = node.scrollTop;
};
var formatMs = function formatMs2(milliseconds) {
  return Math.round(milliseconds) + "ms";
};
function createTransition(props, options2) {
  if (props === void 0) {
    props = ["all"];
  }
  var _ref = options2 || {}, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 300 : _ref$duration, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? defaultEasing.easeInOut : _ref$easing, _ref$delay = _ref.delay, delay = _ref$delay === void 0 ? 0 : _ref$delay;
  var properties = Array.isArray(props) ? props : [props];
  return properties.map(function(animatedProp) {
    var formattedDuration = typeof duration === "string" ? duration : formatMs(duration);
    var formattedDelay = typeof delay === "string" ? delay : formatMs(delay);
    return animatedProp + " " + formattedDuration + " " + easing + " " + formattedDelay;
  }).join(",");
}
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}
function ownerWindow(node) {
  var doc3 = ownerDocument(node);
  return doc3.defaultView || window;
}
function debounce2(func, wait) {
  if (wait === void 0) {
    wait = 166;
  }
  var timeout2;
  function debounced() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var later = function later2() {
      func.apply(_this, args);
    };
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
  }
  debounced.clear = function() {
    clearTimeout(timeout2);
  };
  return debounced;
}
function getTranslateValue(direction2, node) {
  var rect = node.getBoundingClientRect();
  var containerWindow = ownerWindow(node);
  var transform;
  if (node.fakeTransform) {
    transform = node.fakeTransform;
  } else {
    var computedStyle = containerWindow.getComputedStyle(node);
    transform = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
  }
  var offsetX = 0;
  var offsetY = 0;
  if (transform && transform !== "none" && typeof transform === "string") {
    var transformValues = transform.split("(")[1].split(")")[0].split(",");
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }
  switch (direction2) {
    case "left":
      return "translateX(" + (containerWindow.innerWidth + offsetX - rect.left) + "px)";
    case "right":
      return "translateX(-" + (rect.left + rect.width - offsetX) + "px)";
    case "up":
      return "translateY(" + (containerWindow.innerHeight + offsetY - rect.top) + "px)";
    default:
      return "translateY(-" + (rect.top + rect.height - offsetY) + "px)";
  }
}
function setTranslateValue(direction2, node) {
  if (!node) return;
  var transform = getTranslateValue(direction2, node);
  if (transform) {
    node.style.webkitTransform = transform;
    node.style.transform = transform;
  }
}
var Slide = (0, import_react.forwardRef)(function(props, ref2) {
  var children = props.children, _props$direction = props.direction, direction2 = _props$direction === void 0 ? "down" : _props$direction, inProp = props["in"], style3 = props.style, _props$timeout = props.timeout, timeout2 = _props$timeout === void 0 ? 0 : _props$timeout, onEnter = props.onEnter, onEntered = props.onEntered, onExit = props.onExit, onExited = props.onExited, other = _objectWithoutPropertiesLoose(props, ["children", "direction", "in", "style", "timeout", "onEnter", "onEntered", "onExit", "onExited"]);
  var nodeRef = (0, import_react.useRef)(null);
  var handleRefIntermediary = useForkRef(children.ref, nodeRef);
  var handleRef = useForkRef(handleRefIntermediary, ref2);
  var handleEnter = function handleEnter2(node, isAppearing) {
    setTranslateValue(direction2, node);
    reflow(node);
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  };
  var handleEntering = function handleEntering2(node) {
    var easing = (style3 === null || style3 === void 0 ? void 0 : style3.transitionTimingFunction) || defaultEasing.easeOut;
    var transitionProps = getTransitionProps({
      timeout: timeout2,
      mode: "enter",
      style: _extends2({}, style3, {
        transitionTimingFunction: easing
      })
    });
    node.style.webkitTransition = createTransition("-webkit-transform", transitionProps);
    node.style.transition = createTransition("transform", transitionProps);
    node.style.webkitTransform = "none";
    node.style.transform = "none";
  };
  var handleExit = function handleExit2(node) {
    var easing = (style3 === null || style3 === void 0 ? void 0 : style3.transitionTimingFunction) || defaultEasing.sharp;
    var transitionProps = getTransitionProps({
      timeout: timeout2,
      mode: "exit",
      style: _extends2({}, style3, {
        transitionTimingFunction: easing
      })
    });
    node.style.webkitTransition = createTransition("-webkit-transform", transitionProps);
    node.style.transition = createTransition("transform", transitionProps);
    setTranslateValue(direction2, node);
    if (onExit) {
      onExit(node);
    }
  };
  var handleExited = function handleExited2(node) {
    node.style.webkitTransition = "";
    node.style.transition = "";
    if (onExited) {
      onExited(node);
    }
  };
  var updatePosition = (0, import_react.useCallback)(function() {
    if (nodeRef.current) {
      setTranslateValue(direction2, nodeRef.current);
    }
  }, [direction2]);
  (0, import_react.useEffect)(function() {
    if (inProp || direction2 === "down" || direction2 === "right") {
      return void 0;
    }
    var handleResize = debounce2(function() {
      if (nodeRef.current) {
        setTranslateValue(direction2, nodeRef.current);
      }
    });
    var containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return function() {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [direction2, inProp]);
  (0, import_react.useEffect)(function() {
    if (!inProp) {
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return (0, import_react.createElement)(Transition, Object.assign({
    appear: true,
    nodeRef,
    onEnter: handleEnter,
    onEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    "in": inProp,
    timeout: timeout2
  }, other), function(state, childProps) {
    return (0, import_react.cloneElement)(children, _extends2({
      ref: handleRef,
      style: _extends2({
        visibility: state === "exited" && !inProp ? "hidden" : void 0
      }, style3, {}, children.props.style)
    }, childProps));
  });
});
Slide.displayName = "Slide";
var SvgIcon = function SvgIcon2(props) {
  return import_react.default.createElement("svg", Object.assign({
    viewBox: "0 0 24 24",
    focusable: "false",
    style: {
      fontSize: 20,
      marginInlineEnd: 8,
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: "currentColor",
      flexShrink: 0
    }
  }, props));
};
var CheckIcon2 = function CheckIcon3() {
  return import_react.default.createElement(SvgIcon, null, import_react.default.createElement("path", {
    d: "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41\n        10.59L10 14.17L17.59 6.58L19 8L10 17Z"
  }));
};
var WarningIcon = function WarningIcon2() {
  return import_react.default.createElement(SvgIcon, null, import_react.default.createElement("path", {
    d: "M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z"
  }));
};
var ErrorIcon2 = function ErrorIcon3() {
  return import_react.default.createElement(SvgIcon, null, import_react.default.createElement("path", {
    d: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,\n        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,\n        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z"
  }));
};
var InfoIcon2 = function InfoIcon3() {
  return import_react.default.createElement(SvgIcon, null, import_react.default.createElement("path", {
    d: "M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,\n        0 22,12A10,10 0 0,0 12,2Z"
  }));
};
var defaultIconVariants = {
  "default": void 0,
  success: import_react.default.createElement(CheckIcon2, null),
  warning: import_react.default.createElement(WarningIcon, null),
  error: import_react.default.createElement(ErrorIcon2, null),
  info: import_react.default.createElement(InfoIcon2, null)
};
var defaults = {
  maxSnack: 3,
  persist: false,
  hideIconVariant: false,
  disableWindowBlurListener: false,
  variant: "default",
  autoHideDuration: 5e3,
  iconVariant: defaultIconVariants,
  anchorOrigin: {
    vertical: "bottom",
    horizontal: "left"
  },
  TransitionComponent: Slide,
  transitionDuration: {
    enter: 225,
    exit: 195
  }
};
var getAutoHideDuration = function getAutoHideDuration2(optionsDuration, propsDuration) {
  var isNumberOrNull = function isNumberOrNull2(numberish) {
    return typeof numberish === "number" || numberish === null;
  };
  if (isNumberOrNull(optionsDuration)) return optionsDuration;
  if (isNumberOrNull(propsDuration)) return propsDuration;
  return defaults.autoHideDuration;
};
var getTransitionDuration = function getTransitionDuration2(optionsDuration, propsDuration) {
  var is3 = function is4(item, types) {
    return types.some(function(t2) {
      return typeof item === t2;
    });
  };
  if (is3(optionsDuration, ["string", "number"])) {
    return optionsDuration;
  }
  if (is3(optionsDuration, ["object"])) {
    return _extends2({}, defaults.transitionDuration, {}, is3(propsDuration, ["object"]) && propsDuration, {}, optionsDuration);
  }
  if (is3(propsDuration, ["string", "number"])) {
    return propsDuration;
  }
  if (is3(propsDuration, ["object"])) {
    return _extends2({}, defaults.transitionDuration, {}, propsDuration);
  }
  return defaults.transitionDuration;
};
var merge = function merge2(options2, props) {
  return function(name, shouldObjectMerge) {
    if (shouldObjectMerge === void 0) {
      shouldObjectMerge = false;
    }
    if (shouldObjectMerge) {
      return _extends2({}, defaults[name], {}, props[name], {}, options2[name]);
    }
    if (name === "autoHideDuration") {
      return getAutoHideDuration(options2.autoHideDuration, props.autoHideDuration);
    }
    if (name === "transitionDuration") {
      return getTransitionDuration(options2.transitionDuration, props.transitionDuration);
    }
    return options2[name] || props[name] || defaults[name];
  };
};
function makeStyles(styles2) {
  return Object.entries(styles2).reduce(function(acc, _ref) {
    var _extends22;
    var key = _ref[0], value = _ref[1];
    return _extends2({}, acc, (_extends22 = {}, _extends22[key] = u(value), _extends22));
  }, {});
}
var ComponentClasses = {
  SnackbarContainer: "notistack-SnackbarContainer",
  Snackbar: "notistack-Snackbar",
  CollapseWrapper: "notistack-CollapseWrapper",
  MuiContent: "notistack-MuiContent",
  MuiContentVariant: function MuiContentVariant(variant) {
    return "notistack-MuiContent-" + variant;
  }
};
var classes = makeStyles({
  root: {
    height: 0
  },
  entered: {
    height: "auto"
  }
});
var collapsedSize = "0px";
var timeout = 175;
var Collapse2 = (0, import_react.forwardRef)(function(props, ref2) {
  var children = props.children, inProp = props["in"], onExited = props.onExited;
  var wrapperRef = (0, import_react.useRef)(null);
  var nodeRef = (0, import_react.useRef)(null);
  var handleRef = useForkRef(ref2, nodeRef);
  var getWrapperSize = function getWrapperSize2() {
    return wrapperRef.current ? wrapperRef.current.clientHeight : 0;
  };
  var handleEnter = function handleEnter2(node) {
    node.style.height = collapsedSize;
  };
  var handleEntering = function handleEntering2(node) {
    var wrapperSize = getWrapperSize();
    var _getTransitionProps = getTransitionProps({
      timeout,
      mode: "enter"
    }), transitionDuration = _getTransitionProps.duration, easing = _getTransitionProps.easing;
    node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : transitionDuration + "ms";
    node.style.height = wrapperSize + "px";
    node.style.transitionTimingFunction = easing || "";
  };
  var handleEntered = function handleEntered2(node) {
    node.style.height = "auto";
  };
  var handleExit = function handleExit2(node) {
    node.style.height = getWrapperSize() + "px";
  };
  var handleExiting = function handleExiting2(node) {
    reflow(node);
    var _getTransitionProps2 = getTransitionProps({
      timeout,
      mode: "exit"
    }), transitionDuration = _getTransitionProps2.duration, easing = _getTransitionProps2.easing;
    node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : transitionDuration + "ms";
    node.style.height = collapsedSize;
    node.style.transitionTimingFunction = easing || "";
  };
  return (0, import_react.createElement)(Transition, {
    "in": inProp,
    unmountOnExit: true,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited,
    onExiting: handleExiting,
    nodeRef,
    timeout
  }, function(state, childProps) {
    return (0, import_react.createElement)("div", Object.assign({
      ref: handleRef,
      className: clsx_m_default(classes.root, state === "entered" && classes.entered),
      style: _extends2({
        pointerEvents: "all",
        overflow: "hidden",
        minHeight: collapsedSize,
        transition: createTransition("height")
      }, state === "entered" && {
        overflow: "visible"
      }, {}, state === "exited" && !inProp && {
        visibility: "hidden"
      })
    }, childProps), (0, import_react.createElement)("div", {
      ref: wrapperRef,
      className: ComponentClasses.CollapseWrapper,
      // Hack to get children with a negative margin to not falsify the height computation.
      style: {
        display: "flex",
        width: "100%"
      }
    }, children));
  });
});
Collapse2.displayName = "Collapse";
var direction = {
  right: "left",
  left: "right",
  bottom: "up",
  top: "down"
};
var getSlideDirection = function getSlideDirection2(anchorOrigin) {
  if (anchorOrigin.horizontal !== "center") {
    return direction[anchorOrigin.horizontal];
  }
  return direction[anchorOrigin.vertical];
};
var toSnackbarAnchorOrigin = function toSnackbarAnchorOrigin2(anchorOrigin) {
  return "anchorOrigin" + originKeyExtractor(anchorOrigin);
};
var keepSnackbarClassKeys = function keepSnackbarClassKeys2(classes2) {
  if (classes2 === void 0) {
    classes2 = {};
  }
  var containerClasses = {
    containerRoot: true,
    containerAnchorOriginTopCenter: true,
    containerAnchorOriginBottomCenter: true,
    containerAnchorOriginTopRight: true,
    containerAnchorOriginBottomRight: true,
    containerAnchorOriginTopLeft: true,
    containerAnchorOriginBottomLeft: true
  };
  return Object.keys(classes2).filter(function(key) {
    return !containerClasses[key];
  }).reduce(function(obj, key) {
    var _extends22;
    return _extends2({}, obj, (_extends22 = {}, _extends22[key] = classes2[key], _extends22));
  }, {});
};
var noOp$1 = function noOp3() {
};
function createChainedFunction(funcs, snackbarId) {
  return funcs.reduce(function(acc, func) {
    if (func === null || func === void 0) {
      return acc;
    }
    return function chainedFunction() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argums = [].concat(args);
      if (snackbarId && argums.indexOf(snackbarId) === -1) {
        argums.push(snackbarId);
      }
      acc.apply(this, argums);
      func.apply(this, argums);
    };
  }, noOp$1);
}
var useEnhancedEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function useEventCallback(fn2) {
  var ref2 = (0, import_react.useRef)(fn2);
  useEnhancedEffect(function() {
    ref2.current = fn2;
  });
  return (0, import_react.useCallback)(function() {
    return (
      // @ts-expect-error hide `this`
      ref2.current.apply(void 0, arguments)
    );
  }, []);
}
var Snackbar = (0, import_react.forwardRef)(function(props, ref2) {
  var children = props.children, className = props.className, autoHideDuration = props.autoHideDuration, _props$disableWindowB = props.disableWindowBlurListener, disableWindowBlurListener = _props$disableWindowB === void 0 ? false : _props$disableWindowB, onClose = props.onClose, id2 = props.id, open = props.open, _props$SnackbarProps = props.SnackbarProps, SnackbarProps = _props$SnackbarProps === void 0 ? {} : _props$SnackbarProps;
  var timerAutoHide = (0, import_react.useRef)();
  var handleClose = useEventCallback(function() {
    if (onClose) {
      onClose.apply(void 0, arguments);
    }
  });
  var setAutoHideTimer = useEventCallback(function(autoHideDurationParam) {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    if (timerAutoHide.current) {
      clearTimeout(timerAutoHide.current);
    }
    timerAutoHide.current = setTimeout(function() {
      handleClose(null, "timeout", id2);
    }, autoHideDurationParam);
  });
  (0, import_react.useEffect)(function() {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return function() {
      if (timerAutoHide.current) {
        clearTimeout(timerAutoHide.current);
      }
    };
  }, [open, autoHideDuration, setAutoHideTimer]);
  var handlePause = function handlePause2() {
    if (timerAutoHide.current) {
      clearTimeout(timerAutoHide.current);
    }
  };
  var handleResume = (0, import_react.useCallback)(function() {
    if (autoHideDuration != null) {
      setAutoHideTimer(autoHideDuration * 0.5);
    }
  }, [autoHideDuration, setAutoHideTimer]);
  var handleMouseEnter = function handleMouseEnter2(event) {
    if (SnackbarProps.onMouseEnter) {
      SnackbarProps.onMouseEnter(event);
    }
    handlePause();
  };
  var handleMouseLeave = function handleMouseLeave2(event) {
    if (SnackbarProps.onMouseLeave) {
      SnackbarProps.onMouseLeave(event);
    }
    handleResume();
  };
  (0, import_react.useEffect)(function() {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return function() {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, handleResume, open]);
  return (0, import_react.createElement)("div", Object.assign({
    ref: ref2
  }, SnackbarProps, {
    className: clsx_m_default(ComponentClasses.Snackbar, className),
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }), children);
});
Snackbar.displayName = "Snackbar";
var _root;
var classes$1 = makeStyles({
  root: (_root = {
    display: "flex",
    flexWrap: "wrap",
    flexGrow: 1
  }, _root[breakpoints.upSm] = {
    flexGrow: "initial",
    minWidth: "288px"
  }, _root)
});
var SnackbarContent = (0, import_react.forwardRef)(function(_ref, ref2) {
  var className = _ref.className, props = _objectWithoutPropertiesLoose(_ref, ["className"]);
  return import_react.default.createElement("div", Object.assign({
    ref: ref2,
    className: clsx_m_default(classes$1.root, className)
  }, props));
});
SnackbarContent.displayName = "SnackbarContent";
var classes$2 = makeStyles({
  root: {
    backgroundColor: "#313131",
    fontSize: "0.875rem",
    lineHeight: 1.43,
    letterSpacing: "0.01071em",
    color: "#fff",
    alignItems: "center",
    padding: "6px 16px",
    borderRadius: "4px",
    boxShadow: "0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)"
  },
  lessPadding: {
    paddingLeft: 8 * 2.5 + "px"
  },
  "default": {
    backgroundColor: "#313131"
  },
  success: {
    backgroundColor: "#43a047"
  },
  error: {
    backgroundColor: "#d32f2f"
  },
  warning: {
    backgroundColor: "#ff9800"
  },
  info: {
    backgroundColor: "#2196f3"
  },
  message: {
    display: "flex",
    alignItems: "center",
    padding: "8px 0"
  },
  action: {
    display: "flex",
    alignItems: "center",
    marginLeft: "auto",
    paddingLeft: "16px",
    marginRight: "-8px"
  }
});
var ariaDescribedby = "notistack-snackbar";
var MaterialDesignContent = (0, import_react.forwardRef)(function(props, forwardedRef) {
  var id2 = props.id, message2 = props.message, componentOrFunctionAction = props.action, iconVariant = props.iconVariant, variant = props.variant, hideIconVariant = props.hideIconVariant, style3 = props.style, className = props.className;
  var icon = iconVariant[variant];
  var action = componentOrFunctionAction;
  if (typeof action === "function") {
    action = action(id2);
  }
  return import_react.default.createElement(SnackbarContent, {
    ref: forwardedRef,
    role: "alert",
    "aria-describedby": ariaDescribedby,
    style: style3,
    className: clsx_m_default(ComponentClasses.MuiContent, ComponentClasses.MuiContentVariant(variant), classes$2.root, classes$2[variant], className, !hideIconVariant && icon && classes$2.lessPadding)
  }, import_react.default.createElement("div", {
    id: ariaDescribedby,
    className: classes$2.message
  }, !hideIconVariant ? icon : null, message2), action && import_react.default.createElement("div", {
    className: classes$2.action
  }, action));
});
MaterialDesignContent.displayName = "MaterialDesignContent";
var MaterialDesignContent$1 = (0, import_react.memo)(MaterialDesignContent);
var styles = makeStyles({
  wrappedRoot: {
    width: "100%",
    position: "relative",
    transform: "translateX(0)",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    minWidth: "288px"
  }
});
var SnackbarItem = function SnackbarItem2(props) {
  var timeout2 = (0, import_react.useRef)();
  var _useState = (0, import_react.useState)(true), collapsed = _useState[0], setCollapsed = _useState[1];
  var handleClose = createChainedFunction([props.snack.onClose, props.onClose]);
  var handleEntered = function handleEntered2() {
    if (props.snack.requestClose) {
      handleClose(null, "instructed", props.snack.id);
    }
  };
  var handleExitedScreen = (0, import_react.useCallback)(function() {
    timeout2.current = setTimeout(function() {
      setCollapsed(function(col) {
        return !col;
      });
    }, 125);
  }, []);
  (0, import_react.useEffect)(function() {
    return function() {
      if (timeout2.current) {
        clearTimeout(timeout2.current);
      }
    };
  }, []);
  var snack = props.snack, allClasses = props.classes, _props$Component = props.Component, Component3 = _props$Component === void 0 ? MaterialDesignContent$1 : _props$Component;
  var classes2 = (0, import_react.useMemo)(function() {
    return keepSnackbarClassKeys(allClasses);
  }, [allClasses]);
  var open = snack.open, SnackbarProps = snack.SnackbarProps, TransitionComponent = snack.TransitionComponent, TransitionProps = snack.TransitionProps, transitionDuration = snack.transitionDuration, disableWindowBlurListener = snack.disableWindowBlurListener, componentOrFunctionContent = snack.content, otherSnack = _objectWithoutPropertiesLoose(snack, ["open", "SnackbarProps", "TransitionComponent", "TransitionProps", "transitionDuration", "disableWindowBlurListener", "content", "entered", "requestClose", "onEnter", "onEntered", "onExit", "onExited"]);
  var transitionProps = _extends2({
    direction: getSlideDirection(otherSnack.anchorOrigin),
    timeout: transitionDuration
  }, TransitionProps);
  var content = componentOrFunctionContent;
  if (typeof content === "function") {
    content = content(otherSnack.id, otherSnack.message);
  }
  var callbacks = ["onEnter", "onEntered", "onExit", "onExited"].reduce(function(acc, cbName) {
    var _extends22;
    return _extends2({}, acc, (_extends22 = {}, _extends22[cbName] = createChainedFunction([props.snack[cbName], props[cbName]], otherSnack.id), _extends22));
  }, {});
  return import_react.default.createElement(Collapse2, {
    "in": collapsed,
    onExited: callbacks.onExited
  }, import_react.default.createElement(Snackbar, {
    open,
    id: otherSnack.id,
    disableWindowBlurListener,
    autoHideDuration: otherSnack.autoHideDuration,
    className: clsx_m_default(styles.wrappedRoot, classes2.root, classes2[toSnackbarAnchorOrigin(otherSnack.anchorOrigin)]),
    SnackbarProps,
    onClose: handleClose
  }, import_react.default.createElement(TransitionComponent, Object.assign({}, transitionProps, {
    appear: true,
    "in": open,
    onExit: callbacks.onExit,
    onExited: handleExitedScreen,
    onEnter: callbacks.onEnter,
    // order matters. first callbacks.onEntered to set entered: true,
    // then handleEntered to check if there's a request for closing
    onEntered: createChainedFunction([callbacks.onEntered, handleEntered], otherSnack.id)
  }), content || import_react.default.createElement(Component3, Object.assign({}, otherSnack)))));
};
var _root$1;
var _rootDense;
var _left;
var _right;
var _center;
var indents = {
  view: {
    "default": 20,
    dense: 4
  },
  snackbar: {
    "default": 6,
    dense: 2
  }
};
var collapseWrapper = "." + ComponentClasses.CollapseWrapper;
var xsWidthMargin = 16;
var styles$1 = makeStyles({
  root: (_root$1 = {
    boxSizing: "border-box",
    display: "flex",
    maxHeight: "100%",
    position: "fixed",
    zIndex: 1400,
    height: "auto",
    width: "auto",
    transition: createTransition(["top", "right", "bottom", "left", "max-width"], {
      duration: 300,
      easing: "ease"
    }),
    // container itself is invisible and should not block clicks, clicks should be passed to its children
    // a pointerEvents: all is applied in the collapse component
    pointerEvents: "none"
  }, _root$1[collapseWrapper] = {
    padding: indents.snackbar["default"] + "px 0px",
    transition: "padding 300ms ease 0ms"
  }, _root$1.maxWidth = "calc(100% - " + indents.view["default"] * 2 + "px)", _root$1[breakpoints.downXs] = {
    width: "100%",
    maxWidth: "calc(100% - " + xsWidthMargin * 2 + "px)"
  }, _root$1),
  rootDense: (_rootDense = {}, _rootDense[collapseWrapper] = {
    padding: indents.snackbar.dense + "px 0px"
  }, _rootDense),
  top: {
    top: indents.view["default"] - indents.snackbar["default"] + "px",
    flexDirection: "column"
  },
  bottom: {
    bottom: indents.view["default"] - indents.snackbar["default"] + "px",
    flexDirection: "column-reverse"
  },
  left: (_left = {
    left: indents.view["default"] + "px"
  }, _left[breakpoints.upSm] = {
    alignItems: "flex-start"
  }, _left[breakpoints.downXs] = {
    left: xsWidthMargin + "px"
  }, _left),
  right: (_right = {
    right: indents.view["default"] + "px"
  }, _right[breakpoints.upSm] = {
    alignItems: "flex-end"
  }, _right[breakpoints.downXs] = {
    right: xsWidthMargin + "px"
  }, _right),
  center: (_center = {
    left: "50%",
    transform: "translateX(-50%)"
  }, _center[breakpoints.upSm] = {
    alignItems: "center"
  }, _center)
});
var SnackbarContainer = function SnackbarContainer2(props) {
  var _props$classes = props.classes, classes2 = _props$classes === void 0 ? {} : _props$classes, anchorOrigin = props.anchorOrigin, dense = props.dense, children = props.children;
  var combinedClassname = clsx_m_default(
    ComponentClasses.SnackbarContainer,
    styles$1[anchorOrigin.vertical],
    styles$1[anchorOrigin.horizontal],
    styles$1.root,
    // root should come after others to override maxWidth
    classes2.containerRoot,
    classes2["containerAnchorOrigin" + originKeyExtractor(anchorOrigin)],
    dense && styles$1.rootDense
  );
  return import_react.default.createElement("div", {
    className: combinedClassname
  }, children);
};
var SnackbarContainer$1 = (0, import_react.memo)(SnackbarContainer);
var __DEV__ = true;
var messages = {
  NO_PERSIST_ALL: "Reached maxSnack while all enqueued snackbars have 'persist' flag. Notistack will dismiss the oldest snackbar anyway to allow other ones in the queue to be presented."
};
var warning = function(messageKey) {
  if (!__DEV__) return;
  var message2 = messages[messageKey];
  if (typeof console !== "undefined") {
    console.error("WARNING - notistack: " + message2);
  }
  try {
    throw new Error(message2);
  } catch (x) {
  }
};
var isOptions = function isOptions2(messageOrOptions) {
  var isMessage = typeof messageOrOptions === "string" || (0, import_react.isValidElement)(messageOrOptions);
  return !isMessage;
};
var enqueueSnackbar;
var closeSnackbar;
var SnackbarProvider = function(_Component) {
  _inheritsLoose(SnackbarProvider3, _Component);
  function SnackbarProvider3(props) {
    var _this;
    _this = _Component.call(this, props) || this;
    _this.enqueueSnackbar = function(messageOrOptions, optsOrUndefined) {
      if (optsOrUndefined === void 0) {
        optsOrUndefined = {};
      }
      if (messageOrOptions === void 0 || messageOrOptions === null) {
        throw new Error("enqueueSnackbar called with invalid argument");
      }
      var opts = isOptions(messageOrOptions) ? messageOrOptions : optsOrUndefined;
      var message2 = isOptions(messageOrOptions) ? messageOrOptions.message : messageOrOptions;
      var key = opts.key, preventDuplicate = opts.preventDuplicate, options2 = _objectWithoutPropertiesLoose(opts, ["key", "preventDuplicate"]);
      var hasSpecifiedKey = isDefined(key);
      var id2 = hasSpecifiedKey ? key : (/* @__PURE__ */ new Date()).getTime() + Math.random();
      var merger = merge(options2, _this.props);
      var snack = _extends2({
        id: id2
      }, options2, {
        message: message2,
        open: true,
        entered: false,
        requestClose: false,
        persist: merger("persist"),
        action: merger("action"),
        content: merger("content"),
        variant: merger("variant"),
        anchorOrigin: merger("anchorOrigin"),
        disableWindowBlurListener: merger("disableWindowBlurListener"),
        autoHideDuration: merger("autoHideDuration"),
        hideIconVariant: merger("hideIconVariant"),
        TransitionComponent: merger("TransitionComponent"),
        transitionDuration: merger("transitionDuration"),
        TransitionProps: merger("TransitionProps", true),
        iconVariant: merger("iconVariant", true),
        style: merger("style", true),
        SnackbarProps: merger("SnackbarProps", true),
        className: clsx_m_default(_this.props.className, options2.className)
      });
      if (snack.persist) {
        snack.autoHideDuration = void 0;
      }
      _this.setState(function(state) {
        if (preventDuplicate === void 0 && _this.props.preventDuplicate || preventDuplicate) {
          var compareFunction = function compareFunction2(item) {
            return hasSpecifiedKey ? item.id === id2 : item.message === message2;
          };
          var inQueue = state.queue.findIndex(compareFunction) > -1;
          var inView = state.snacks.findIndex(compareFunction) > -1;
          if (inQueue || inView) {
            return state;
          }
        }
        return _this.handleDisplaySnack(_extends2({}, state, {
          queue: [].concat(state.queue, [snack])
        }));
      });
      return id2;
    };
    _this.handleDisplaySnack = function(state) {
      var snacks = state.snacks;
      if (snacks.length >= _this.maxSnack) {
        return _this.handleDismissOldest(state);
      }
      return _this.processQueue(state);
    };
    _this.processQueue = function(state) {
      var queue = state.queue, snacks = state.snacks;
      if (queue.length > 0) {
        return _extends2({}, state, {
          snacks: [].concat(snacks, [queue[0]]),
          queue: queue.slice(1, queue.length)
        });
      }
      return state;
    };
    _this.handleDismissOldest = function(state) {
      if (state.snacks.some(function(item) {
        return !item.open || item.requestClose;
      })) {
        return state;
      }
      var popped = false;
      var ignore = false;
      var persistentCount = state.snacks.reduce(function(acc, current) {
        return acc + (current.open && current.persist ? 1 : 0);
      }, 0);
      if (persistentCount === _this.maxSnack) {
        true ? warning("NO_PERSIST_ALL") : void 0;
        ignore = true;
      }
      var snacks = state.snacks.map(function(item) {
        if (!popped && (!item.persist || ignore)) {
          popped = true;
          if (!item.entered) {
            return _extends2({}, item, {
              requestClose: true
            });
          }
          if (item.onClose) {
            item.onClose(null, "maxsnack", item.id);
          }
          if (_this.props.onClose) {
            _this.props.onClose(null, "maxsnack", item.id);
          }
          return _extends2({}, item, {
            open: false
          });
        }
        return _extends2({}, item);
      });
      return _extends2({}, state, {
        snacks
      });
    };
    _this.handleEnteredSnack = function(node, isAppearing, key) {
      if (!isDefined(key)) {
        throw new Error("handleEnteredSnack Cannot be called with undefined key");
      }
      _this.setState(function(_ref) {
        var snacks = _ref.snacks;
        return {
          snacks: snacks.map(function(item) {
            return item.id === key ? _extends2({}, item, {
              entered: true
            }) : _extends2({}, item);
          })
        };
      });
    };
    _this.handleCloseSnack = function(event, reason, key) {
      if (_this.props.onClose) {
        _this.props.onClose(event, reason, key);
      }
      var shouldCloseAll = key === void 0;
      _this.setState(function(_ref2) {
        var snacks = _ref2.snacks, queue = _ref2.queue;
        return {
          snacks: snacks.map(function(item) {
            if (!shouldCloseAll && item.id !== key) {
              return _extends2({}, item);
            }
            return item.entered ? _extends2({}, item, {
              open: false
            }) : _extends2({}, item, {
              requestClose: true
            });
          }),
          queue: queue.filter(function(item) {
            return item.id !== key;
          })
        };
      });
    };
    _this.closeSnackbar = function(key) {
      var toBeClosed = _this.state.snacks.find(function(item) {
        return item.id === key;
      });
      if (isDefined(key) && toBeClosed && toBeClosed.onClose) {
        toBeClosed.onClose(null, "instructed", key);
      }
      _this.handleCloseSnack(null, "instructed", key);
    };
    _this.handleExitedSnack = function(node, key) {
      if (!isDefined(key)) {
        throw new Error("handleExitedSnack Cannot be called with undefined key");
      }
      _this.setState(function(state) {
        var newState = _this.processQueue(_extends2({}, state, {
          snacks: state.snacks.filter(function(item) {
            return item.id !== key;
          })
        }));
        if (newState.queue.length === 0) {
          return newState;
        }
        return _this.handleDismissOldest(newState);
      });
    };
    enqueueSnackbar = _this.enqueueSnackbar;
    closeSnackbar = _this.closeSnackbar;
    _this.state = {
      snacks: [],
      queue: [],
      contextValue: {
        enqueueSnackbar: _this.enqueueSnackbar.bind(_assertThisInitialized(_this)),
        closeSnackbar: _this.closeSnackbar.bind(_assertThisInitialized(_this))
      }
    };
    return _this;
  }
  var _proto = SnackbarProvider3.prototype;
  _proto.render = function render2() {
    var _this2 = this;
    var contextValue = this.state.contextValue;
    var _this$props = this.props, domRoot = _this$props.domRoot, children = _this$props.children, _this$props$dense = _this$props.dense, dense = _this$props$dense === void 0 ? false : _this$props$dense, _this$props$Component = _this$props.Components, Components = _this$props$Component === void 0 ? {} : _this$props$Component, classes2 = _this$props.classes;
    var categ = this.state.snacks.reduce(function(acc, current) {
      var _extends22;
      var category = originKeyExtractor(current.anchorOrigin);
      var existingOfCategory = acc[category] || [];
      return _extends2({}, acc, (_extends22 = {}, _extends22[category] = [].concat(existingOfCategory, [current]), _extends22));
    }, {});
    var snackbars = Object.keys(categ).map(function(origin2) {
      var snacks = categ[origin2];
      var nomineeSnack = snacks[0];
      return import_react.default.createElement(SnackbarContainer$1, {
        key: origin2,
        dense,
        anchorOrigin: nomineeSnack.anchorOrigin,
        classes: classes2
      }, snacks.map(function(snack) {
        return import_react.default.createElement(SnackbarItem, {
          key: snack.id,
          snack,
          classes: classes2,
          Component: Components[snack.variant],
          onClose: _this2.handleCloseSnack,
          onEnter: _this2.props.onEnter,
          onExit: _this2.props.onExit,
          onExited: createChainedFunction([_this2.handleExitedSnack, _this2.props.onExited], snack.id),
          onEntered: createChainedFunction([_this2.handleEnteredSnack, _this2.props.onEntered], snack.id)
        });
      }));
    });
    return import_react.default.createElement(SnackbarContext.Provider, {
      value: contextValue
    }, children, domRoot ? (0, import_react_dom.createPortal)(snackbars, domRoot) : snackbars);
  };
  _createClass(SnackbarProvider3, [{
    key: "maxSnack",
    get: function get3() {
      return this.props.maxSnack || defaults.maxSnack;
    }
  }]);
  return SnackbarProvider3;
}(import_react.Component);
var useSnackbar = function() {
  return (0, import_react.useContext)(SnackbarContext);
};

// ../../../node_modules/@firecms/core/dist/index.es.js
var import_object_hash = __toESM(require_object_hash());

// ../../../node_modules/@firecms/formex/dist/index.es.js
var import_react_compiler_runtime = __toESM(require_dist());
var React = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_react_fast_compare = __toESM(require_react_fast_compare());
var FormexContext = import_react2.default.createContext({});
var useFormex = () => {
  return (0, import_react2.useContext)(FormexContext);
};
var Formex = FormexContext.Provider;
var isFunction = (obj) => typeof obj === "function";
var isObject = (obj) => obj !== null && typeof obj === "object";
var isInteger = (obj) => String(Math.floor(Number(obj))) === obj;
function getIn(obj, key, def, p3 = 0) {
  const path = toPath(key);
  while (obj && p3 < path.length) {
    obj = obj[path[p3++]];
  }
  if (p3 !== path.length && !obj) {
    return def;
  }
  return obj === void 0 ? def : obj;
}
function setIn(obj, path, value) {
  const res = clone(obj);
  let resVal = res;
  let i2 = 0;
  const pathArray = toPath(path);
  for (; i2 < pathArray.length - 1; i2++) {
    const currentPath = pathArray[i2];
    const currentObj = getIn(obj, pathArray.slice(0, i2 + 1));
    if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {
      resVal = resVal[currentPath] = clone(currentObj);
    } else {
      const nextPath = pathArray[i2 + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  }
  if ((i2 === 0 ? obj : resVal)[pathArray[i2]] === value) {
    return obj;
  }
  if (value === void 0) {
    delete resVal[pathArray[i2]];
  } else {
    resVal[pathArray[i2]] = value;
  }
  if (i2 === 0 && value === void 0) {
    delete res[pathArray[i2]];
  }
  return res;
}
function clone(value) {
  if (Array.isArray(value)) {
    return [...value];
  } else if (typeof value === "object" && value !== null) {
    return {
      ...value
    };
  } else {
    return value;
  }
}
function toPath(value) {
  if (Array.isArray(value)) return value;
  return value.replace(/\[(\d+)]/g, ".$1").replace(/^\./, "").replace(/\.$/, "").split(".");
}
function Field(t0) {
  const $ = (0, import_react_compiler_runtime.c)(37);
  let children;
  let className;
  let is3;
  let name;
  let props;
  if ($[0] !== t0) {
    const {
      validate,
      name: t12,
      children: t22,
      as: t3,
      className: t4,
      ...t5
    } = t0;
    name = t12;
    children = t22;
    is3 = t3;
    className = t4;
    props = t5;
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = is3;
    $[4] = name;
    $[5] = props;
  } else {
    children = $[1];
    className = $[2];
    is3 = $[3];
    name = $[4];
    props = $[5];
  }
  const formex = useFormex();
  let field;
  let t1;
  if ($[6] !== children || $[7] !== formex || $[8] !== name || $[9] !== props) {
    t1 = Symbol.for("react.early_return_sentinel");
    bb0: {
      field = getFieldProps({
        name,
        ...props
      }, formex);
      if (isFunction(children)) {
        t1 = children({
          field,
          form: formex
        });
        break bb0;
      }
    }
    $[6] = children;
    $[7] = formex;
    $[8] = name;
    $[9] = props;
    $[10] = field;
    $[11] = t1;
  } else {
    field = $[10];
    t1 = $[11];
  }
  if (t1 !== Symbol.for("react.early_return_sentinel")) {
    return t1;
  }
  const asElement = is3 || "input";
  if (typeof asElement === "string") {
    let innerRef;
    let rest;
    if ($[12] !== props) {
      ({
        innerRef,
        ...rest
      } = props);
      $[12] = props;
      $[13] = innerRef;
      $[14] = rest;
    } else {
      innerRef = $[13];
      rest = $[14];
    }
    let t22;
    if ($[15] !== asElement || $[16] !== children || $[17] !== className || $[18] !== field || $[19] !== innerRef || $[20] !== rest) {
      let t3;
      if ($[22] !== className || $[23] !== field || $[24] !== innerRef || $[25] !== rest) {
        t3 = {
          ref: innerRef,
          ...field,
          ...rest,
          className
        };
        $[22] = className;
        $[23] = field;
        $[24] = innerRef;
        $[25] = rest;
        $[26] = t3;
      } else {
        t3 = $[26];
      }
      t22 = React.createElement(asElement, t3, children);
      $[15] = asElement;
      $[16] = children;
      $[17] = className;
      $[18] = field;
      $[19] = innerRef;
      $[20] = rest;
      $[21] = t22;
    } else {
      t22 = $[21];
    }
    return t22;
  }
  let t2;
  if ($[27] !== asElement || $[28] !== children || $[29] !== className || $[30] !== field || $[31] !== props) {
    let t3;
    if ($[33] !== className || $[34] !== field || $[35] !== props) {
      t3 = {
        ...field,
        ...props,
        className
      };
      $[33] = className;
      $[34] = field;
      $[35] = props;
      $[36] = t3;
    } else {
      t3 = $[36];
    }
    t2 = React.createElement(asElement, t3, children);
    $[27] = asElement;
    $[28] = children;
    $[29] = className;
    $[30] = field;
    $[31] = props;
    $[32] = t2;
  } else {
    t2 = $[32];
  }
  return t2;
}
var getFieldProps = (nameOrOptions, formex) => {
  const isAnObject = isObject(nameOrOptions);
  const name = isAnObject ? nameOrOptions.name : nameOrOptions;
  const valueState = getIn(formex.values, name);
  const field = {
    name,
    value: valueState,
    onChange: formex.handleChange,
    onBlur: formex.handleBlur
  };
  if (isAnObject) {
    const {
      type,
      value: valueProp,
      // value is special for checkboxes
      as: is3,
      multiple
    } = nameOrOptions;
    if (type === "checkbox") {
      if (valueProp === void 0) {
        field.checked = !!valueState;
      } else {
        field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
        field.value = valueProp;
      }
    } else if (type === "radio") {
      field.checked = valueState === valueProp;
      field.value = valueProp;
    } else if (is3 === "select" && multiple) {
      field.value = field.value || [];
      field.multiple = true;
    }
  }
  return field;
};
function useCreateFormex({
  initialValues,
  initialErrors,
  initialDirty,
  validation,
  validateOnChange = false,
  validateOnInitialRender = false,
  onSubmit,
  onReset,
  debugId
}) {
  const initialValuesRef = (0, import_react2.useRef)(initialValues);
  const valuesRef = (0, import_react2.useRef)(initialValues);
  const debugIdRef = (0, import_react2.useRef)(debugId);
  const [values, setValuesInner] = (0, import_react2.useState)(initialValues);
  const [touchedState, setTouchedState] = (0, import_react2.useState)({});
  const [errors, setErrors] = (0, import_react2.useState)(initialErrors ?? {});
  const [dirty, setDirty] = (0, import_react2.useState)(initialDirty ?? false);
  const [submitCount, setSubmitCount] = (0, import_react2.useState)(0);
  const [isSubmitting, setIsSubmitting] = (0, import_react2.useState)(false);
  const [isValidating, setIsValidating] = (0, import_react2.useState)(false);
  const [version2, setVersion] = (0, import_react2.useState)(0);
  const historyRef = (0, import_react2.useRef)([initialValues]);
  const historyIndexRef = (0, import_react2.useRef)(0);
  (0, import_react2.useEffect)(() => {
    if (validateOnInitialRender) {
      validate();
    }
  }, []);
  const setValues = (0, import_react2.useCallback)((newValues) => {
    valuesRef.current = newValues;
    setValuesInner(newValues);
    setDirty(!(0, import_react_fast_compare.default)(initialValuesRef.current, newValues));
    const newHistory = historyRef.current.slice(0, historyIndexRef.current + 1);
    newHistory.push(newValues);
    historyRef.current = newHistory;
    historyIndexRef.current = newHistory.length - 1;
  }, []);
  const validate = (0, import_react2.useCallback)(async () => {
    setIsValidating(true);
    const validationErrors = await (validation == null ? void 0 : validation(valuesRef.current));
    setErrors(validationErrors ?? {});
    setIsValidating(false);
    return validationErrors;
  }, [validation]);
  const setFieldValue = (0, import_react2.useCallback)((key, value, shouldValidate) => {
    const newValues_0 = setIn(valuesRef.current, key, value);
    valuesRef.current = newValues_0;
    setValuesInner(newValues_0);
    if (!(0, import_react_fast_compare.default)(getIn(initialValuesRef.current, key), value)) {
      setDirty(true);
    }
    if (shouldValidate) {
      validate();
    }
    const newHistory_0 = historyRef.current.slice(0, historyIndexRef.current + 1);
    newHistory_0.push(newValues_0);
    historyRef.current = newHistory_0;
    historyIndexRef.current = newHistory_0.length - 1;
  }, [validate]);
  const setFieldError = (0, import_react2.useCallback)((key_0, error2) => {
    setErrors((prevErrors) => {
      const newErrors = {
        ...prevErrors
      };
      if (error2) {
        newErrors[key_0] = error2;
      } else {
        delete newErrors[key_0];
      }
      return newErrors;
    });
  }, []);
  const setFieldTouched = (0, import_react2.useCallback)((key_1, touched, shouldValidate_0) => {
    setTouchedState((prev) => ({
      ...prev,
      [key_1]: touched
    }));
    if (shouldValidate_0) {
      validate();
    }
  }, [validate]);
  const handleChange = (0, import_react2.useCallback)((event) => {
    const target = event.target;
    let value_0;
    if (target.type === "checkbox") {
      value_0 = target.checked;
    } else if (target.type === "number") {
      value_0 = target.valueAsNumber;
    } else {
      value_0 = target.value;
    }
    const name = target.name;
    setFieldValue(name, value_0, validateOnChange);
    setFieldTouched(name, true);
  }, [setFieldValue, setFieldTouched, validateOnChange]);
  const handleBlur = (0, import_react2.useCallback)((event_0) => {
    const target_0 = event_0.target;
    const name_0 = target_0.name;
    setFieldTouched(name_0, true);
  }, [setFieldTouched]);
  const submit = (0, import_react2.useCallback)(async (e2) => {
    e2 == null ? void 0 : e2.preventDefault();
    e2 == null ? void 0 : e2.stopPropagation();
    setIsSubmitting(true);
    setSubmitCount((prev_0) => prev_0 + 1);
    const validationErrors_0 = await (validation == null ? void 0 : validation(valuesRef.current));
    if (validationErrors_0 && Object.keys(validationErrors_0).length > 0) {
      setErrors(validationErrors_0);
    } else {
      setErrors({});
      await (onSubmit == null ? void 0 : onSubmit(valuesRef.current, controllerRef.current));
    }
    setIsSubmitting(false);
    setVersion((prev_1) => prev_1 + 1);
  }, [onSubmit, validation]);
  const resetForm = (0, import_react2.useCallback)((props) => {
    const {
      submitCount: submitCountProp,
      values: valuesProp,
      errors: errorsProp,
      touched: touchedProp
    } = props ?? {};
    valuesRef.current = valuesProp ?? initialValuesRef.current;
    initialValuesRef.current = valuesProp ?? initialValuesRef.current;
    setValuesInner(valuesProp ?? initialValuesRef.current);
    setErrors(errorsProp ?? {});
    setTouchedState(touchedProp ?? {});
    setDirty(false);
    setSubmitCount(submitCountProp ?? 0);
    setVersion((prev_2) => prev_2 + 1);
    onReset == null ? void 0 : onReset(controllerRef.current);
    historyRef.current = [valuesProp ?? initialValuesRef.current];
    historyIndexRef.current = 0;
  }, [onReset]);
  const undo2 = (0, import_react2.useCallback)(() => {
    if (historyIndexRef.current > 0) {
      const newIndex = historyIndexRef.current - 1;
      const newValues_1 = historyRef.current[newIndex];
      setValuesInner(newValues_1);
      valuesRef.current = newValues_1;
      historyIndexRef.current = newIndex;
    }
  }, []);
  const redo2 = (0, import_react2.useCallback)(() => {
    if (historyIndexRef.current < historyRef.current.length - 1) {
      const newIndex_0 = historyIndexRef.current + 1;
      const newValues_2 = historyRef.current[newIndex_0];
      setValuesInner(newValues_2);
      valuesRef.current = newValues_2;
      historyIndexRef.current = newIndex_0;
    }
  }, []);
  const controllerRef = (0, import_react2.useRef)({});
  const controller = (0, import_react2.useMemo)(() => ({
    values,
    initialValues: initialValuesRef.current,
    handleChange,
    isSubmitting,
    setSubmitting: setIsSubmitting,
    setValues,
    setFieldValue,
    errors,
    setFieldError,
    touched: touchedState,
    setFieldTouched,
    dirty,
    setDirty,
    handleSubmit: submit,
    submitCount,
    setSubmitCount,
    handleBlur,
    validate,
    isValidating,
    resetForm,
    version: version2,
    debugId: debugIdRef.current,
    undo: undo2,
    redo: redo2,
    canUndo: historyIndexRef.current > 0,
    canRedo: historyIndexRef.current < historyRef.current.length - 1
  }), [values, errors, touchedState, dirty, isSubmitting, submitCount, isValidating, version2, handleChange, handleBlur, setValues, setFieldValue, setFieldTouched, setFieldError, validate, submit, resetForm, undo2, redo2]);
  (0, import_react2.useEffect)(() => {
    controllerRef.current = controller;
  }, [controller]);
  return controller;
}

// ../../../node_modules/react-router-dom/dist/index.js
var React3 = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());

// ../../../node_modules/react-router/dist/index.js
var React2 = __toESM(require_react());

// ../../../node_modules/@remix-run/router/dist/router.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var PopStateEventType = "popstate";
function createBrowserHistory(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search: search2,
      hash: hash4
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search: search2,
        hash: hash4
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options2);
}
function invariant(value, message2) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message2);
  }
}
function warning2(cond, message2) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message2);
    try {
      throw new Error(message2);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends3({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search: search2 = "",
    hash: hash4 = ""
  } = _ref;
  if (search2 && search2 !== "?") pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
  if (hash4 && hash4 !== "#") pathname += hash4.charAt(0) === "#" ? hash4 : "#" + hash4;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options2;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends3({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history2.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history2.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history2.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error2) {
      if (error2 instanceof DOMException && error2.name === "DataCloneError") {
        throw error2;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history2.location,
        delta: 1
      });
    }
  }
  function replace3(to, state) {
    action = Action.Replace;
    let location = createLocation(history2.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history2.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history2.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base2 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant(base2, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base2);
  }
  let history2 = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace3,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history2;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
var immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index2) => {
    let treePath = [...parentPath, String(index2)];
    let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
    if (isIndexRoute(route)) {
      let indexRoute = _extends3({}, route, mapRouteProperties2(route), {
        id: id2
      });
      manifest[id2] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends3({}, route, mapRouteProperties2(route), {
        id: id2,
        children: void 0
      });
      manifest[id2] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches2 = null;
  for (let i2 = 0; matches2 == null && i2 < branches.length; ++i2) {
    let decoded = decodePath(pathname);
    matches2 = matchRouteBranch(branches[i2], decoded, allowPartial);
  }
  return matches2;
}
function convertRouteMatchToUiMatch(match85, loaderData) {
  let {
    route,
    pathname,
    params
  } = match85;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first2, ...rest] = segments;
  let isOptional = first2.endsWith("?");
  let required2 = first2.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required2, ""] : [required2];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required2 : [required2, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  if (allowPartial === void 0) {
    allowPartial = false;
  }
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches2 = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end3 = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match85 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end3
    }, remainingPathname);
    let route = meta.route;
    if (!match85 && end3 && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match85 = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end: false
      }, remainingPathname);
    }
    if (!match85) {
      return null;
    }
    Object.assign(matchedParams, match85.params);
    matches2.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match85.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match85.pathnameBase])),
      route
    });
    if (match85.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match85.pathnameBase]);
    }
  }
  return matches2;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match85 = pathname.match(matcher);
  if (!match85) return null;
  let matchedPathname = match85[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match85.slice(1);
  let params = compiledParams.reduce((memo5, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo5[paramName] = void 0;
    } else {
      memo5[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo5;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end3) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end3 === void 0) {
    end3 = true;
  }
  warning2(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end3) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error2) {
    warning2(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error2 + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search: search2 = "",
    hash: hash4 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search2),
    hash: normalizeHash(hash4)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches2) {
  return matches2.filter((match85, index2) => index2 === 0 || match85.route.path && match85.route.path.length > 0);
}
function getResolveToMatches(matches2, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches2);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match85, idx) => idx === pathMatches.length - 1 ? match85.pathname : match85.pathnameBase);
  }
  return pathMatches.map((match85) => match85.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends3({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search2) => !search2 || search2 === "?" ? "" : search2.startsWith("?") ? search2 : "?" + search2;
var normalizeHash = (hash4) => !hash4 || hash4 === "#" ? "" : hash4.startsWith("#") ? hash4 : "#" + hash4;
var ErrorResponseImpl = class {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
};
function isRouteErrorResponse(error2) {
  return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
}
var validMutationMethodsArr = ["post", "put", "patch", "delete"];
var validMutationMethods = new Set(validMutationMethodsArr);
var validRequestMethodsArr = ["get", ...validMutationMethodsArr];
var validRequestMethods = new Set(validRequestMethodsArr);
var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
var IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
var IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
var IDLE_BLOCKER = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
};
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var defaultMapRouteProperties = (route) => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
var TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
function createRouter(init2) {
  const routerWindow = init2.window ? init2.window : typeof window !== "undefined" ? window : void 0;
  const isBrowser3 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer = !isBrowser3;
  invariant(init2.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties2;
  if (init2.mapRouteProperties) {
    mapRouteProperties2 = init2.mapRouteProperties;
  } else if (init2.detectErrorBoundary) {
    let detectErrorBoundary = init2.detectErrorBoundary;
    mapRouteProperties2 = (route) => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties2 = defaultMapRouteProperties;
  }
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(init2.routes, mapRouteProperties2, void 0, manifest);
  let inFlightDataRoutes;
  let basename = init2.basename || "/";
  let dataStrategyImpl = init2.dataStrategy || defaultDataStrategy;
  let patchRoutesOnNavigationImpl = init2.patchRoutesOnNavigation;
  let future = _extends3({
    v7_fetcherPersist: false,
    v7_normalizeFormMethod: false,
    v7_partialHydration: false,
    v7_prependBasename: false,
    v7_relativeSplatPath: false,
    v7_skipActionErrorRevalidation: false
  }, init2.future);
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */ new Set();
  let savedScrollPositions2 = null;
  let getScrollRestorationKey = null;
  let getScrollPosition = null;
  let initialScrollRestored = init2.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init2.history.location, basename);
  let initialMatchesIsFOW = false;
  let initialErrors = null;
  if (initialMatches == null && !patchRoutesOnNavigationImpl) {
    let error2 = getInternalRouterError(404, {
      pathname: init2.history.location.pathname
    });
    let {
      matches: matches2,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches2;
    initialErrors = {
      [route.id]: error2
    };
  }
  if (initialMatches && !init2.hydrationData) {
    let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init2.history.location.pathname);
    if (fogOfWar.active) {
      initialMatches = null;
    }
  }
  let initialized;
  if (!initialMatches) {
    initialized = false;
    initialMatches = [];
    if (future.v7_partialHydration) {
      let fogOfWar = checkFogOfWar(null, dataRoutes, init2.history.location.pathname);
      if (fogOfWar.active && fogOfWar.matches) {
        initialMatchesIsFOW = true;
        initialMatches = fogOfWar.matches;
      }
    }
  } else if (initialMatches.some((m) => m.route.lazy)) {
    initialized = false;
  } else if (!initialMatches.some((m) => m.route.loader)) {
    initialized = true;
  } else if (future.v7_partialHydration) {
    let loaderData = init2.hydrationData ? init2.hydrationData.loaderData : null;
    let errors = init2.hydrationData ? init2.hydrationData.errors : null;
    if (errors) {
      let idx = initialMatches.findIndex((m) => errors[m.route.id] !== void 0);
      initialized = initialMatches.slice(0, idx + 1).every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
    } else {
      initialized = initialMatches.every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
    }
  } else {
    initialized = init2.hydrationData != null;
  }
  let router;
  let state = {
    historyAction: init2.history.action,
    location: init2.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init2.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init2.hydrationData && init2.hydrationData.loaderData || {},
    actionData: init2.hydrationData && init2.hydrationData.actionData || null,
    errors: init2.hydrationData && init2.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  };
  let pendingAction = Action.Pop;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let pendingViewTransitionEnabled = false;
  let appliedViewTransitions = /* @__PURE__ */ new Map();
  let removePageHideEventListener = null;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledDeferredRoutes = [];
  let cancelledFetcherLoads = /* @__PURE__ */ new Set();
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let fetchRedirectIds = /* @__PURE__ */ new Set();
  let fetchLoadMatches = /* @__PURE__ */ new Map();
  let activeFetchers = /* @__PURE__ */ new Map();
  let deletedFetchers = /* @__PURE__ */ new Set();
  let activeDeferreds = /* @__PURE__ */ new Map();
  let blockerFunctions = /* @__PURE__ */ new Map();
  let unblockBlockerHistoryUpdate = void 0;
  function initialize() {
    unlistenHistory = init2.history.listen((_ref) => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      if (unblockBlockerHistoryUpdate) {
        unblockBlockerHistoryUpdate();
        unblockBlockerHistoryUpdate = void 0;
        return;
      }
      warning2(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        let nextHistoryUpdatePromise = new Promise((resolve) => {
          unblockBlockerHistoryUpdate = resolve;
        });
        init2.history.go(delta * -1);
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location
            });
            nextHistoryUpdatePromise.then(() => init2.history.go(delta));
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (isBrowser3) {
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location, {
        initialHydration: true
      });
    }
    return router;
  }
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  }
  function subscribe(fn2) {
    subscribers.add(fn2);
    return () => subscribers.delete(fn2);
  }
  function updateState(newState, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state = _extends3({}, state, newState);
    let completedFetchers = [];
    let deletedFetchersKeys = [];
    if (future.v7_fetcherPersist) {
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (deletedFetchers.has(key)) {
            deletedFetchersKeys.push(key);
          } else {
            completedFetchers.push(key);
          }
        }
      });
    }
    deletedFetchers.forEach((key) => {
      if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
        deletedFetchersKeys.push(key);
      }
    });
    [...subscribers].forEach((subscriber) => subscriber(state, {
      deletedFetchers: deletedFetchersKeys,
      viewTransitionOpts: opts.viewTransitionOpts,
      flushSync: opts.flushSync === true
    }));
    if (future.v7_fetcherPersist) {
      completedFetchers.forEach((key) => state.fetchers.delete(key));
      deletedFetchersKeys.forEach((key) => deleteFetcher(key));
    } else {
      deletedFetchersKeys.forEach((key) => deletedFetchers.delete(key));
    }
  }
  function completeNavigation(location, newState, _temp12) {
    var _location$state, _location$state2;
    let {
      flushSync: flushSync3
    } = _temp12 === void 0 ? {} : _temp12;
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        actionData = null;
      }
    } else if (isActionReload) {
      actionData = state.actionData;
    } else {
      actionData = null;
    }
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_, k2) => blockers.set(k2, IDLE_BLOCKER));
    }
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = void 0;
    }
    if (isUninterruptedRevalidation) ;
    else if (pendingAction === Action.Pop) ;
    else if (pendingAction === Action.Push) {
      init2.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init2.history.replace(location, location.state);
    }
    let viewTransitionOpts;
    if (pendingAction === Action.Pop) {
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = /* @__PURE__ */ new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(_extends3({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }), {
      viewTransitionOpts,
      flushSync: flushSync3 === true
    });
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
  }
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init2.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error: error2
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = _extends3({}, nextLocation, init2.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : void 0;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false) ;
    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    let flushSync3 = (opts && opts.flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          });
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error2,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.viewTransition,
      flushSync: flushSync3
    });
  }
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    if (state.navigation.state === "submitting") {
      return;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation,
      // Proxy through any rending view transition
      enableViewTransition: pendingViewTransitionEnabled === true
    });
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches2 = opts != null && opts.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      state.matches
    ) : matchRoutes(routesToUse, location, basename);
    let flushSync3 = (opts && opts.flushSync) === true;
    if (matches2 && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches: matches2
      }, {
        flushSync: flushSync3
      });
      return;
    }
    let fogOfWar = checkFogOfWar(matches2, routesToUse, location.pathname);
    if (fogOfWar.active && fogOfWar.matches) {
      matches2 = fogOfWar.matches;
    }
    if (!matches2) {
      let {
        error: error2,
        notFoundMatches,
        route
      } = handleNavigational404(location.pathname);
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error2
        }
      }, {
        flushSync: flushSync3
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init2.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionResult;
    if (opts && opts.pendingError) {
      pendingActionResult = [findNearestBoundary(matches2).route.id, {
        type: ResultType.error,
        error: opts.pendingError
      }];
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionResult = await handleAction(request, location, opts.submission, matches2, fogOfWar.active, {
        replace: opts.replace,
        flushSync: flushSync3
      });
      if (actionResult.shortCircuited) {
        return;
      }
      if (actionResult.pendingActionResult) {
        let [routeId, result] = actionResult.pendingActionResult;
        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
          pendingNavigationController = null;
          completeNavigation(location, {
            matches: actionResult.matches,
            loaderData: {},
            errors: {
              [routeId]: result.error
            }
          });
          return;
        }
      }
      matches2 = actionResult.matches || matches2;
      pendingActionResult = actionResult.pendingActionResult;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync3 = false;
      fogOfWar.active = false;
      request = createClientSideRequest(init2.history, request.url, request.signal);
    }
    let {
      shortCircuited,
      matches: updatedMatches,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches2, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync3, pendingActionResult);
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location, _extends3({
      matches: updatedMatches || matches2
    }, getActionDataForCommit(pendingActionResult), {
      loaderData,
      errors
    }));
  }
  async function handleAction(request, location, submission, matches2, isFogOfWar, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    }, {
      flushSync: opts.flushSync === true
    });
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches2, location.pathname, request.signal);
      if (discoverResult.type === "aborted") {
        return {
          shortCircuited: true
        };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          pendingActionResult: [boundaryId, {
            type: ResultType.error,
            error: discoverResult.error
          }]
        };
      } else if (!discoverResult.matches) {
        let {
          notFoundMatches,
          error: error2,
          route
        } = handleNavigational404(location.pathname);
        return {
          matches: notFoundMatches,
          pendingActionResult: [route.id, {
            type: ResultType.error,
            error: error2
          }]
        };
      } else {
        matches2 = discoverResult.matches;
      }
    }
    let result;
    let actionMatch = getTargetMatch(matches2, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      let results = await callDataStrategy("action", state, request, [actionMatch], matches2, null);
      result = results[actionMatch.route.id];
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace3;
      if (opts && opts.replace != null) {
        replace3 = opts.replace;
      } else {
        let location2 = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request.url), basename);
        replace3 = location2 === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(request, result, true, {
        submission,
        replace: replace3
      });
      return {
        shortCircuited: true
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches2, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        matches: matches2,
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      matches: matches2,
      pendingActionResult: [actionMatch.route.id, result]
    };
  }
  async function handleLoaders(request, location, matches2, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace3, initialHydration, flushSync3, pendingActionResult) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let shouldUpdateNavigationState = !isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration);
    if (isFogOfWar) {
      if (shouldUpdateNavigationState) {
        let actionData = getUpdatedActionData(pendingActionResult);
        updateState(_extends3({
          navigation: loadingNavigation
        }, actionData !== void 0 ? {
          actionData
        } : {}), {
          flushSync: flushSync3
        });
      }
      let discoverResult = await discoverRoutes(matches2, location.pathname, request.signal);
      if (discoverResult.type === "aborted") {
        return {
          shortCircuited: true
        };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          loaderData: {},
          errors: {
            [boundaryId]: discoverResult.error
          }
        };
      } else if (!discoverResult.matches) {
        let {
          error: error2,
          notFoundMatches,
          route
        } = handleNavigational404(location.pathname);
        return {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error2
          }
        };
      } else {
        matches2 = discoverResult.matches;
      }
    }
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init2.history, state, matches2, activeSubmission, location, future.v7_partialHydration && initialHydration === true, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);
    cancelActiveDeferreds((routeId) => !(matches2 && matches2.some((m) => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      completeNavigation(location, _extends3({
        matches: matches2,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null
      }, getActionDataForCommit(pendingActionResult), updatedFetchers2 ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync: flushSync3
      });
      return {
        shortCircuited: true
      };
    }
    if (shouldUpdateNavigationState) {
      let updates = {};
      if (!isFogOfWar) {
        updates.navigation = loadingNavigation;
        let actionData = getUpdatedActionData(pendingActionResult);
        if (actionData !== void 0) {
          updates.actionData = actionData;
        }
      }
      if (revalidatingFetchers.length > 0) {
        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
      }
      updateState(updates, {
        flushSync: flushSync3
      });
    }
    revalidatingFetchers.forEach((rf) => {
      abortFetcher(rf.key);
      if (rf.controller) {
        fetchControllers.set(rf.key, rf.controller);
      }
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state, matches2, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
    let redirect2 = findRedirect(loaderResults);
    if (redirect2) {
      await startRedirectNavigation(request, redirect2.result, true, {
        replace: replace3
      });
      return {
        shortCircuited: true
      };
    }
    redirect2 = findRedirect(fetcherResults);
    if (redirect2) {
      fetchRedirectIds.add(redirect2.key);
      await startRedirectNavigation(request, redirect2.result, true, {
        replace: replace3
      });
      return {
        shortCircuited: true
      };
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches2, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe((aborted) => {
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    if (future.v7_partialHydration && initialHydration && state.errors) {
      errors = _extends3({}, state.errors, errors);
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends3({
      matches: matches2,
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getUpdatedActionData(pendingActionResult) {
    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
      return {
        [pendingActionResult[0]]: pendingActionResult[1].data
      };
    } else if (state.actionData) {
      if (Object.keys(state.actionData).length === 0) {
        return null;
      } else {
        return state.actionData;
      }
    }
  }
  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
    revalidatingFetchers.forEach((rf) => {
      let fetcher = state.fetchers.get(rf.key);
      let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
      state.fetchers.set(rf.key, revalidatingFetcher);
    });
    return new Map(state.fetchers);
  }
  function fetch2(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    }
    abortFetcher(key);
    let flushSync3 = (opts && opts.flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
    let matches2 = matchRoutes(routesToUse, normalizedPath, basename);
    let fogOfWar = checkFogOfWar(matches2, routesToUse, normalizedPath);
    if (fogOfWar.active && fogOfWar.matches) {
      matches2 = fogOfWar.matches;
    }
    if (!matches2) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync: flushSync3
      });
      return;
    }
    let {
      path,
      submission,
      error: error2
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error2) {
      setFetcherError(key, routeId, error2, {
        flushSync: flushSync3
      });
      return;
    }
    let match85 = getTargetMatch(matches2, path);
    let preventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match85, matches2, fogOfWar.active, flushSync3, preventScrollReset, submission);
      return;
    }
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match85, matches2, fogOfWar.active, flushSync3, preventScrollReset, submission);
  }
  async function handleFetcherAction(key, routeId, path, match85, requestMatches, isFogOfWar, flushSync3, preventScrollReset, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    function detectAndHandle405Error(m) {
      if (!m.route.action && !m.route.lazy) {
        let error2 = getInternalRouterError(405, {
          method: submission.formMethod,
          pathname: path,
          routeId
        });
        setFetcherError(key, routeId, error2, {
          flushSync: flushSync3
        });
        return true;
      }
      return false;
    }
    if (!isFogOfWar && detectAndHandle405Error(match85)) {
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync: flushSync3
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init2.history, path, abortController.signal, submission);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(requestMatches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, {
          flushSync: flushSync3
        });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync: flushSync3
        });
        return;
      } else {
        requestMatches = discoverResult.matches;
        match85 = getTargetMatch(requestMatches, path);
        if (detectAndHandle405Error(match85)) {
          return;
        }
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResults = await callDataStrategy("action", state, fetchRequest, [match85], requestMatches, key);
    let actionResult = actionResults[match85.route.id];
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(fetchRequest, actionResult, false, {
            fetcherSubmission: submission,
            preventScrollReset
          });
        }
      }
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init2.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches2 = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches2, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init2.history, state, matches2, submission, nextLocation, false, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match85.route.id, actionResult]);
    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
      let staleKey = rf.key;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
      state.fetchers.set(staleKey, revalidatingFetcher);
      abortFetcher(staleKey);
      if (rf.controller) {
        fetchControllers.set(staleKey, rf.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state, matches2, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
    let redirect2 = findRedirect(loaderResults);
    if (redirect2) {
      return startRedirectNavigation(revalidationRequest, redirect2.result, false, {
        preventScrollReset
      });
    }
    redirect2 = findRedirect(fetcherResults);
    if (redirect2) {
      fetchRedirectIds.add(redirect2.key);
      return startRedirectNavigation(revalidationRequest, redirect2.result, false, {
        preventScrollReset
      });
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches2, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches: matches2,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches2, errors),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  async function handleFetcherLoader(key, routeId, path, match85, matches2, isFogOfWar, flushSync3, preventScrollReset, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
      flushSync: flushSync3
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init2.history, path, abortController.signal);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches2, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, {
          flushSync: flushSync3
        });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync: flushSync3
        });
        return;
      } else {
        matches2 = discoverResult.matches;
        match85 = getTargetMatch(matches2, path);
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let results = await callDataStrategy("loader", state, fetchRequest, [match85], matches2, key);
    let result = results[match85.route.id];
    if (isDeferredResult(result)) {
      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
    }
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (deletedFetchers.has(key)) {
      updateFetcherState(key, getDoneFetcher(void 0));
      return;
    }
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(fetchRequest, result, false, {
          preventScrollReset
        });
        return;
      }
    }
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  async function startRedirectNavigation(request, redirect2, isNavigation, _temp23) {
    let {
      submission,
      fetcherSubmission,
      preventScrollReset,
      replace: replace3
    } = _temp23 === void 0 ? {} : _temp23;
    if (redirect2.response.headers.has("X-Remix-Revalidate")) {
      isRevalidationRequired = true;
    }
    let location = redirect2.response.headers.get("Location");
    invariant(location, "Expected a Location header on the redirect Response");
    location = normalizeRedirectLocation(location, new URL(request.url), basename);
    let redirectLocation = createLocation(state.location, location, {
      _isRedirect: true
    });
    if (isBrowser3) {
      let isDocumentReload = false;
      if (redirect2.response.headers.has("X-Remix-Reload-Document")) {
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(location)) {
        const url = init2.history.createURL(location);
        isDocumentReload = // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace3) {
          routerWindow.location.replace(location);
        } else {
          routerWindow.location.assign(location);
        }
        return;
      }
    }
    pendingNavigationController = null;
    let redirectHistoryAction = replace3 === true || redirect2.response.headers.has("X-Remix-Replace") ? Action.Replace : Action.Push;
    let {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends3({}, activeSubmission, {
          formAction: location
        }),
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    } else {
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    }
  }
  async function callDataStrategy(type, state2, request, matchesToLoad, matches2, fetcherKey) {
    let results;
    let dataResults = {};
    try {
      results = await callDataStrategyImpl(dataStrategyImpl, type, state2, request, matchesToLoad, matches2, fetcherKey, manifest, mapRouteProperties2);
    } catch (e2) {
      matchesToLoad.forEach((m) => {
        dataResults[m.route.id] = {
          type: ResultType.error,
          error: e2
        };
      });
      return dataResults;
    }
    for (let [routeId, result] of Object.entries(results)) {
      if (isRedirectDataStrategyResultResult(result)) {
        let response = result.result;
        dataResults[routeId] = {
          type: ResultType.redirect,
          response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches2, basename, future.v7_relativeSplatPath)
        };
      } else {
        dataResults[routeId] = await convertDataStrategyResultToDataResult(result);
      }
    }
    return dataResults;
  }
  async function callLoadersAndMaybeResolveData(state2, matches2, matchesToLoad, fetchersToLoad, request) {
    let currentMatches = state2.matches;
    let loaderResultsPromise = callDataStrategy("loader", state2, request, matchesToLoad, matches2, null);
    let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async (f) => {
      if (f.matches && f.match && f.controller) {
        let results = await callDataStrategy("loader", state2, createClientSideRequest(init2.history, f.path, f.controller.signal), [f.match], f.matches, f.key);
        let result = results[f.match.route.id];
        return {
          [f.key]: result
        };
      } else {
        return Promise.resolve({
          [f.key]: {
            type: ResultType.error,
            error: getInternalRouterError(404, {
              pathname: f.path
            })
          }
        });
      }
    }));
    let loaderResults = await loaderResultsPromise;
    let fetcherResults = (await fetcherResultsPromise).reduce((acc, r2) => Object.assign(acc, r2), {});
    await Promise.all([resolveNavigationDeferredResults(matches2, loaderResults, request.signal, currentMatches, state2.loaderData), resolveFetcherDeferredResults(matches2, fetcherResults, fetchersToLoad)]);
    return {
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.add(key);
      }
      abortFetcher(key);
    });
  }
  function updateFetcherState(key, fetcher, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function setFetcherError(key, routeId, error2, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error2
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function getFetcher(key) {
    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
    if (deletedFetchers.has(key)) {
      deletedFetchers.delete(key);
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    if (future.v7_fetcherPersist) {
      deletedFetchers.delete(key);
    }
    cancelledFetcherLoads.delete(key);
    state.fetchers.delete(key);
  }
  function deleteFetcherAndUpdateState(key) {
    let count = (activeFetchers.get(key) || 0) - 1;
    if (count <= 0) {
      activeFetchers.delete(key);
      deletedFetchers.add(key);
      if (!future.v7_fetcherPersist) {
        deleteFetcher(key);
      }
    } else {
      activeFetchers.set(key, count);
    }
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    if (controller) {
      controller.abort();
      fetchControllers.delete(key);
    }
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id2] of fetchReloadIds) {
      if (id2 < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn2) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn2) {
      blockerFunctions.set(key, fn2);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0) {
      return;
    }
    if (blockerFunctions.size > 1) {
      warning2(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      return;
    }
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function handleNavigational404(pathname) {
    let error2 = getInternalRouterError(404, {
      pathname
    });
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let {
      matches: matches2,
      route
    } = getShortCircuitMatches(routesToUse);
    cancelActiveDeferreds();
    return {
      notFoundMatches: matches2,
      route,
      error: error2
    };
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions2 = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || null;
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions2 = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location, matches2) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location, matches2.map((m) => convertRouteMatchToUiMatch(m, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches2) {
    if (savedScrollPositions2 && getScrollPosition) {
      let key = getScrollKey(location, matches2);
      savedScrollPositions2[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches2) {
    if (savedScrollPositions2) {
      let key = getScrollKey(location, matches2);
      let y = savedScrollPositions2[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function checkFogOfWar(matches2, routesToUse, pathname) {
    if (patchRoutesOnNavigationImpl) {
      if (!matches2) {
        let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
        return {
          active: true,
          matches: fogMatches || []
        };
      } else {
        if (Object.keys(matches2[0].params).length > 0) {
          let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
          return {
            active: true,
            matches: partialMatches
          };
        }
      }
    }
    return {
      active: false,
      matches: null
    };
  }
  async function discoverRoutes(matches2, pathname, signal, fetcherKey) {
    if (!patchRoutesOnNavigationImpl) {
      return {
        type: "success",
        matches: matches2
      };
    }
    let partialMatches = matches2;
    while (true) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let localManifest = manifest;
      try {
        await patchRoutesOnNavigationImpl({
          signal,
          path: pathname,
          matches: partialMatches,
          fetcherKey,
          patch: (routeId, children) => {
            if (signal.aborted) return;
            patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);
          }
        });
      } catch (e2) {
        return {
          type: "error",
          error: e2,
          partialMatches
        };
      } finally {
        if (isNonHMR && !signal.aborted) {
          dataRoutes = [...dataRoutes];
        }
      }
      if (signal.aborted) {
        return {
          type: "aborted"
        };
      }
      let newMatches = matchRoutes(routesToUse, pathname, basename);
      if (newMatches) {
        return {
          type: "success",
          matches: newMatches
        };
      }
      let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i2) => m.route.id === newPartialMatches[i2].route.id)) {
        return {
          type: "success",
          matches: null
        };
      }
      partialMatches = newPartialMatches;
    }
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
  }
  function patchRoutes(routeId, children) {
    let isNonHMR = inFlightDataRoutes == null;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);
    if (isNonHMR) {
      dataRoutes = [...dataRoutes];
      updateState({});
    }
  }
  router = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to) => init2.history.createHref(to),
    encodeLocation: (to) => init2.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: deleteFetcherAndUpdateState,
    dispose,
    getBlocker,
    deleteBlocker,
    patchRoutes,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
var UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
function normalizeTo(location, matches2, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    contextualMatches = [];
    for (let match85 of matches2) {
      contextualMatches.push(match85);
      if (match85.route.id === fromRouteId) {
        activeRouteMatch = match85;
        break;
      }
    }
  } else {
    contextualMatches = matches2;
    activeRouteMatch = matches2[matches2.length - 1];
  }
  let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  if ((to == null || to === "" || to === ".") && activeRouteMatch) {
    let nakedIndex = hasNakedIndexQuery(path.search);
    if (activeRouteMatch.route.index && !nakedIndex) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    } else if (!activeRouteMatch.route.index && nakedIndex) {
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? "?" + qs : "";
    }
  }
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(opts.body.entries()).reduce((acc, _ref3) => {
          let [name, value] = _ref3;
          return "" + acc + name + "=" + value + "\n";
        }, "")
      ) : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json2 = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json: json2,
            text: void 0
          }
        };
      } catch (e2) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e2) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  let parsedPath = parsePath(path);
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
}
function getLoaderMatchesUntilBoundary(matches2, boundaryId, includeBoundary) {
  if (includeBoundary === void 0) {
    includeBoundary = false;
  }
  let index2 = matches2.findIndex((m) => m.route.id === boundaryId);
  if (index2 >= 0) {
    return matches2.slice(0, includeBoundary ? index2 + 1 : index2);
  }
  return matches2;
}
function getMatchesToLoad(history2, state, matches2, submission, location, initialHydration, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
  let currentUrl = history2.createURL(state.location);
  let nextUrl = history2.createURL(location);
  let boundaryMatches = matches2;
  if (initialHydration && state.errors) {
    boundaryMatches = getLoaderMatchesUntilBoundary(matches2, Object.keys(state.errors)[0], true);
  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
    boundaryMatches = getLoaderMatchesUntilBoundary(matches2, pendingActionResult[0]);
  }
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
  let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;
  let navigationMatches = boundaryMatches.filter((match85, index2) => {
    let {
      route
    } = match85;
    if (route.lazy) {
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (initialHydration) {
      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
    }
    if (isNewLoader(state.loaderData, state.matches[index2], match85) || cancelledDeferredRoutes.some((id2) => id2 === match85.route.id)) {
      return true;
    }
    let currentRouteMatch = state.matches[index2];
    let nextRouteMatch = match85;
    return shouldRevalidateLoader(match85, _extends3({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? false : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
      )
    }));
  });
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    if (initialHydration || !matches2.some((m) => m.route.id === f.routeId) || deletedFetchers.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.has(key)) {
      cancelledFetcherLoads.delete(key);
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
      shouldRevalidate = isRevalidationRequired;
    } else {
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends3({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches2[matches2.length - 1].params
      }, submission, {
        actionResult,
        actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function shouldLoadRouteOnHydration(route, loaderData, errors) {
  if (route.lazy) {
    return true;
  }
  if (!route.loader) {
    return false;
  }
  let hasData = loaderData != null && loaderData[route.id] !== void 0;
  let hasError = errors != null && errors[route.id] !== void 0;
  if (!hasData && hasError) {
    return false;
  }
  if (typeof route.loader === "function" && route.loader.hydrate === true) {
    return true;
  }
  return !hasData && !hasError;
}
function isNewLoader(currentLoaderData, currentMatch, match85) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match85.route.id !== currentMatch.route.id
  );
  let isMissingData = currentLoaderData[match85.route.id] === void 0;
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match85) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match85.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match85.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
  var _childrenToPatch;
  let childrenToPatch;
  if (routeId) {
    let route = manifest[routeId];
    invariant(route, "No route found to patch children into: routeId = " + routeId);
    if (!route.children) {
      route.children = [];
    }
    childrenToPatch = route.children;
  } else {
    childrenToPatch = routesToUse;
  }
  let uniqueChildren = children.filter((newRoute) => !childrenToPatch.some((existingRoute) => isSameRoute(newRoute, existingRoute)));
  let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [routeId || "_", "patch", String(((_childrenToPatch = childrenToPatch) == null ? void 0 : _childrenToPatch.length) || "0")], manifest);
  childrenToPatch.push(...newRoutes);
}
function isSameRoute(newRoute, existingRoute) {
  if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
    return true;
  }
  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
    return false;
  }
  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
    return true;
  }
  return newRoute.children.every((aChild, i2) => {
    var _existingRoute$childr;
    return (_existingRoute$childr = existingRoute.children) == null ? void 0 : _existingRoute$childr.some((bChild) => isSameRoute(aChild, bChild));
  });
}
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning2(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  Object.assign(routeToUpdate, routeUpdates);
  Object.assign(routeToUpdate, _extends3({}, mapRouteProperties2(routeToUpdate), {
    lazy: void 0
  }));
}
async function defaultDataStrategy(_ref4) {
  let {
    matches: matches2
  } = _ref4;
  let matchesToLoad = matches2.filter((m) => m.shouldLoad);
  let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));
  return results.reduce((acc, result, i2) => Object.assign(acc, {
    [matchesToLoad[i2].route.id]: result
  }), {});
}
async function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches2, fetcherKey, manifest, mapRouteProperties2, requestContext) {
  let loadRouteDefinitionsPromises = matches2.map((m) => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties2, manifest) : void 0);
  let dsMatches = matches2.map((match85, i2) => {
    let loadRoutePromise = loadRouteDefinitionsPromises[i2];
    let shouldLoad = matchesToLoad.some((m) => m.route.id === match85.route.id);
    let resolve = async (handlerOverride) => {
      if (handlerOverride && request.method === "GET" && (match85.route.lazy || match85.route.loader)) {
        shouldLoad = true;
      }
      return shouldLoad ? callLoaderOrAction(type, request, match85, loadRoutePromise, handlerOverride, requestContext) : Promise.resolve({
        type: ResultType.data,
        result: void 0
      });
    };
    return _extends3({}, match85, {
      shouldLoad,
      resolve
    });
  });
  let results = await dataStrategyImpl({
    matches: dsMatches,
    request,
    params: matches2[0].params,
    fetcherKey,
    context: requestContext
  });
  try {
    await Promise.all(loadRouteDefinitionsPromises);
  } catch (e2) {
  }
  return results;
}
async function callLoaderOrAction(type, request, match85, loadRoutePromise, handlerOverride, staticContext) {
  let result;
  let onReject;
  let runHandler = (handler) => {
    let reject;
    let abortPromise = new Promise((_, r2) => reject = r2);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    let actualHandler = (ctx) => {
      if (typeof handler !== "function") {
        return Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + type + '" [routeId: ' + match85.route.id + "]")));
      }
      return handler({
        request,
        params: match85.params,
        context: staticContext
      }, ...ctx !== void 0 ? [ctx] : []);
    };
    let handlerPromise = (async () => {
      try {
        let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
        return {
          type: "data",
          result: val
        };
      } catch (e2) {
        return {
          type: "error",
          result: e2
        };
      }
    })();
    return Promise.race([handlerPromise, abortPromise]);
  };
  try {
    let handler = match85.route[type];
    if (loadRoutePromise) {
      if (handler) {
        let handlerError;
        let [value] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          runHandler(handler).catch((e2) => {
            handlerError = e2;
          }),
          loadRoutePromise
        ]);
        if (handlerError !== void 0) {
          throw handlerError;
        }
        result = value;
      } else {
        await loadRoutePromise;
        handler = match85.route[type];
        if (handler) {
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match85.route.id
          });
        } else {
          return {
            type: ResultType.data,
            result: void 0
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant(result.result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match85.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e2) {
    return {
      type: ResultType.error,
      result: e2
    };
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  return result;
}
async function convertDataStrategyResultToDataResult(dataStrategyResult) {
  let {
    result,
    type
  } = dataStrategyResult;
  if (isResponse(result)) {
    let data;
    try {
      let contentType = result.headers.get("Content-Type");
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data = null;
        } else {
          data = await result.json();
        }
      } else {
        data = await result.text();
      }
    } catch (e2) {
      return {
        type: ResultType.error,
        error: e2
      };
    }
    if (type === ResultType.error) {
      return {
        type: ResultType.error,
        error: new ErrorResponseImpl(result.status, result.statusText, data),
        statusCode: result.status,
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === ResultType.error) {
    if (isDataWithResponseInit(result)) {
      var _result$init3, _result$init4;
      if (result.data instanceof Error) {
        var _result$init, _result$init2;
        return {
          type: ResultType.error,
          error: result.data,
          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
          headers: (_result$init2 = result.init) != null && _result$init2.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: ResultType.error,
        error: new ErrorResponseImpl(((_result$init3 = result.init) == null ? void 0 : _result$init3.status) || 500, void 0, result.data),
        statusCode: isRouteErrorResponse(result) ? result.status : void 0,
        headers: (_result$init4 = result.init) != null && _result$init4.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return {
      type: ResultType.error,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : void 0
    };
  }
  if (isDeferredData(result)) {
    var _result$init5, _result$init6;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init5 = result.init) == null ? void 0 : _result$init5.status,
      headers: ((_result$init6 = result.init) == null ? void 0 : _result$init6.headers) && new Headers(result.init.headers)
    };
  }
  if (isDataWithResponseInit(result)) {
    var _result$init7, _result$init8;
    return {
      type: ResultType.data,
      data: result.data,
      statusCode: (_result$init7 = result.init) == null ? void 0 : _result$init7.status,
      headers: (_result$init8 = result.init) != null && _result$init8.headers ? new Headers(result.init.headers) : void 0
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
}
function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches2, basename, v7_relativeSplatPath) {
  let location = response.headers.get("Location");
  invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
  if (!ABSOLUTE_URL_REGEX.test(location)) {
    let trimmedMatches = matches2.slice(0, matches2.findIndex((m) => m.route.id === routeId) + 1);
    location = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location, v7_relativeSplatPath);
    response.headers.set("Location", location);
  }
  return response;
}
function normalizeRedirectLocation(location, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX.test(location)) {
    let normalizedLocation = location;
    let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
    let isSameBasename = stripBasename(url.pathname, basename) != null;
    if (url.origin === currentUrl.origin && isSameBasename) {
      return url.pathname + url.search + url.hash;
    }
  }
  return location;
}
function createClientSideRequest(history2, location, signal, submission) {
  let url = history2.createURL(stripHashFromPath(location)).toString();
  let init2 = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    init2.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init2.headers = new Headers({
        "Content-Type": formEncType
      });
      init2.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      init2.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      init2.body = convertFormDataToSearchParams(submission.formData);
    } else {
      init2.body = submission.formData;
    }
  }
  return new Request(url, init2);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches2, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
  matches2.forEach((match85) => {
    if (!(match85.route.id in results)) {
      return;
    }
    let id2 = match85.route.id;
    let result = results[id2];
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let error2 = result.error;
      if (pendingError !== void 0) {
        error2 = pendingError;
        pendingError = void 0;
      }
      errors = errors || {};
      if (skipLoaderErrorBubbling) {
        errors[id2] = error2;
      } else {
        let boundaryMatch = findNearestBoundary(matches2, id2);
        if (errors[boundaryMatch.route.id] == null) {
          errors[boundaryMatch.route.id] = error2;
        }
      }
      loaderData[id2] = void 0;
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id2, result.deferredData);
        loaderData[id2] = result.deferredData.data;
        if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id2] = result.headers;
        }
      } else {
        loaderData[id2] = result.data;
        if (result.statusCode && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id2] = result.headers;
        }
      }
    }
  });
  if (pendingError !== void 0 && pendingActionResult) {
    errors = {
      [pendingActionResult[0]]: pendingError
    };
    loaderData[pendingActionResult[0]] = void 0;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches2, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(
    matches2,
    results,
    pendingActionResult,
    activeDeferreds,
    false
    // This method is only called client side so we always want to bubble
  );
  revalidatingFetchers.forEach((rf) => {
    let {
      key,
      match: match85,
      controller
    } = rf;
    let result = fetcherResults[key];
    invariant(result, "Did not find corresponding fetcher result");
    if (controller && controller.signal.aborted) {
      return;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match85 == null ? void 0 : match85.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends3({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  });
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches2, errors) {
  let mergedLoaderData = _extends3({}, newLoaderData);
  for (let match85 of matches2) {
    let id2 = match85.route.id;
    if (newLoaderData.hasOwnProperty(id2)) {
      if (newLoaderData[id2] !== void 0) {
        mergedLoaderData[id2] = newLoaderData[id2];
      }
    } else if (loaderData[id2] !== void 0 && match85.route.loader) {
      mergedLoaderData[id2] = loaderData[id2];
    }
    if (errors && errors.hasOwnProperty(id2)) {
      break;
    }
  }
  return mergedLoaderData;
}
function getActionDataForCommit(pendingActionResult) {
  if (!pendingActionResult) {
    return {};
  }
  return isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  };
}
function findNearestBoundary(matches2, routeId) {
  let eligibleMatches = routeId ? matches2.slice(0, matches2.findIndex((m) => m.route.id === routeId) + 1) : [...matches2];
  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches2[0];
}
function getShortCircuitMatches(routes) {
  let route = routes.length === 1 ? routes[0] : routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp53) {
  let {
    pathname,
    routeId,
    method,
    type,
    message: message2
  } = _temp53 === void 0 ? {} : _temp53;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = 'No route matches URL "' + pathname + '"';
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
    }
  }
  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
}
function findRedirect(results) {
  let entries = Object.entries(results);
  for (let i2 = entries.length - 1; i2 >= 0; i2--) {
    let [key, result] = entries[i2];
    if (isRedirectResult(result)) {
      return {
        key,
        result
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends3({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a2, b2) {
  if (a2.pathname !== b2.pathname || a2.search !== b2.search) {
    return false;
  }
  if (a2.hash === "") {
    return b2.hash !== "";
  } else if (a2.hash === b2.hash) {
    return true;
  } else if (b2.hash !== "") {
    return true;
  }
  return false;
}
function isRedirectDataStrategyResultResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDataWithResponseInit(value) {
  return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveNavigationDeferredResults(matches2, results, signal, currentMatches, currentLoaderData) {
  let entries = Object.entries(results);
  for (let index2 = 0; index2 < entries.length; index2++) {
    let [routeId, result] = entries[index2];
    let match85 = matches2.find((m) => (m == null ? void 0 : m.route.id) === routeId);
    if (!match85) {
      continue;
    }
    let currentMatch = currentMatches.find((m) => m.route.id === match85.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match85) && (currentLoaderData && currentLoaderData[match85.route.id]) !== void 0;
    if (isDeferredResult(result) && isRevalidatingLoader) {
      await resolveDeferredData(result, signal, false).then((result2) => {
        if (result2) {
          results[routeId] = result2;
        }
      });
    }
  }
}
async function resolveFetcherDeferredResults(matches2, results, revalidatingFetchers) {
  for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
    let {
      key,
      routeId,
      controller
    } = revalidatingFetchers[index2];
    let result = results[key];
    let match85 = matches2.find((m) => (m == null ? void 0 : m.route.id) === routeId);
    if (!match85) {
      continue;
    }
    if (isDeferredResult(result)) {
      invariant(controller, "Expected an AbortController for revalidating fetcher deferred result");
      await resolveDeferredData(result, controller.signal, true).then((result2) => {
        if (result2) {
          results[key] = result2;
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e2) {
      return {
        type: ResultType.error,
        error: e2
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search2) {
  return new URLSearchParams(search2).getAll("index").some((v) => v === "");
}
function getTargetMatch(matches2, location) {
  let search2 = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches2[matches2.length - 1].route.index && hasNakedIndexQuery(search2 || "")) {
    return matches2[matches2.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches2);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json: json2
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: void 0,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: void 0,
      text: void 0
    };
  } else if (json2 !== void 0) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: json2,
      text: void 0
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0
  };
  return fetcher;
}
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions2) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json2 = JSON.parse(sessionPositions);
      for (let [k2, v] of Object.entries(json2 || {})) {
        if (v && Array.isArray(v)) {
          transitions2.set(k2, new Set(v || []));
        }
      }
    }
  } catch (e2) {
  }
}
function persistAppliedTransitions(_window, transitions2) {
  if (transitions2.size > 0) {
    let json2 = {};
    for (let [k2, v] of transitions2) {
      json2[k2] = [...v];
    }
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json2));
    } catch (error2) {
      warning2(false, "Failed to save applied view transitions in sessionStorage (" + error2 + ").");
    }
  }
}

// ../../../node_modules/react-router/dist/index.js
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
var DataRouterContext = React2.createContext(null);
if (true) {
  DataRouterContext.displayName = "DataRouter";
}
var DataRouterStateContext = React2.createContext(null);
if (true) {
  DataRouterStateContext.displayName = "DataRouterState";
}
var AwaitContext = React2.createContext(null);
if (true) {
  AwaitContext.displayName = "Await";
}
var NavigationContext = React2.createContext(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = React2.createContext(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = React2.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
if (true) {
  RouteContext.displayName = "Route";
}
var RouteErrorContext = React2.createContext(null);
if (true) {
  RouteErrorContext.displayName = "RouteError";
}
function useHref(to, _temp12) {
  let {
    relative
  } = _temp12 === void 0 ? {} : _temp12;
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = React2.useContext(NavigationContext);
  let {
    hash: hash4,
    pathname,
    search: search2
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search: search2,
    hash: hash4
  });
}
function useInRouterContext() {
  return React2.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  return React2.useContext(LocationContext).location;
}
var navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function useIsomorphicLayoutEffect(cb) {
  let isStatic = React2.useContext(NavigationContext).static;
  if (!isStatic) {
    React2.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = React2.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let dataRouterContext = React2.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = React2.useContext(NavigationContext);
  let {
    matches: matches2
  } = React2.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future.v7_relativeSplatPath));
  let activeRef = React2.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React2.useCallback(function(to, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    true ? warning2(activeRef.current, navigateEffectWarning) : void 0;
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options2.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options2.replace ? navigator2.replace : navigator2.push)(path, options2.state, options2);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
var OutletContext = React2.createContext(null);
function useResolvedPath(to, _temp23) {
  let {
    relative
  } = _temp23 === void 0 ? {} : _temp23;
  let {
    future
  } = React2.useContext(NavigationContext);
  let {
    matches: matches2
  } = React2.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future.v7_relativeSplatPath));
  return React2.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let {
    navigator: navigator2,
    static: isStatic
  } = React2.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = React2.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches2 = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : matchRoutes(routes, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning2(parentRoute || matches2 != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ') : void 0;
    true ? warning2(matches2 == null || matches2[matches2.length - 1].route.element !== void 0 || matches2[matches2.length - 1].route.Component !== void 0 || matches2[matches2.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  let renderedMatches = _renderMatches(matches2 && matches2.map((match85) => Object.assign({}, match85, {
    params: Object.assign({}, parentParams, match85.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match85.pathname).pathname : match85.pathname
    ]),
    pathnameBase: match85.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match85.pathnameBase).pathname : match85.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return React2.createElement(LocationContext.Provider, {
      value: {
        location: _extends4({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error2 = useRouteError();
  let message2 = isRouteErrorResponse(error2) ? error2.status + " " + error2.statusText : error2 instanceof Error ? error2.message : JSON.stringify(error2);
  let stack = error2 instanceof Error ? error2.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (true) {
    console.error("Error handled by React Router default ErrorBoundary:", error2);
    devInfo = React2.createElement(React2.Fragment, null, React2.createElement("p", null, "💿 Hey developer 👋"), React2.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", React2.createElement("code", {
      style: codeStyles
    }, "ErrorBoundary"), " or", " ", React2.createElement("code", {
      style: codeStyles
    }, "errorElement"), " prop on your route."));
  }
  return React2.createElement(React2.Fragment, null, React2.createElement("h2", null, "Unexpected Application Error!"), React2.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message2), stack ? React2.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
var defaultErrorElement = React2.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends React2.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error2) {
    return {
      error: error2
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error2, errorInfo) {
    console.error("React Router caught the following error during render", error2, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? React2.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, React2.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
};
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match85,
    children
  } = _ref;
  let dataRouterContext = React2.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match85.route.errorElement || match85.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match85.route.id;
  }
  return React2.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches2, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches2 == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches2 = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches2 = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches2;
  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0);
    !(errorIndex >= 0) ? true ? invariant(false, "Could not find a matching route for errors on route IDs: " + Object.keys(errors).join(",")) : invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i2 = 0; i2 < renderedMatches.length; i2++) {
      let match85 = renderedMatches[i2];
      if (match85.route.HydrateFallback || match85.route.hydrateFallbackElement) {
        fallbackIndex = i2;
      }
      if (match85.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match85.route.loader && loaderData[match85.route.id] === void 0 && (!errors2 || errors2[match85.route.id] === void 0);
        if (match85.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match85, index2) => {
    let error2;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error2 = errors && match85.route.id ? errors[match85.route.id] : void 0;
      errorElement = match85.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match85.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches3 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren2 = () => {
      let children;
      if (error2) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match85.route.Component) {
        children = React2.createElement(match85.route.Component, null);
      } else if (match85.route.element) {
        children = match85.route.element;
      } else {
        children = outlet;
      }
      return React2.createElement(RenderedRoute, {
        match: match85,
        routeContext: {
          outlet,
          matches: matches3,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match85.route.ErrorBoundary || match85.route.errorElement || index2 === 0) ? React2.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error: error2,
      children: getChildren2(),
      routeContext: {
        outlet: null,
        matches: matches3,
        isDataRoute: true
      }
    }) : getChildren2();
  }, null);
}
var DataRouterHook = function(DataRouterHook3) {
  DataRouterHook3["UseBlocker"] = "useBlocker";
  DataRouterHook3["UseRevalidator"] = "useRevalidator";
  DataRouterHook3["UseNavigateStable"] = "useNavigate";
  return DataRouterHook3;
}(DataRouterHook || {});
var DataRouterStateHook = function(DataRouterStateHook3) {
  DataRouterStateHook3["UseBlocker"] = "useBlocker";
  DataRouterStateHook3["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook3["UseActionData"] = "useActionData";
  DataRouterStateHook3["UseRouteError"] = "useRouteError";
  DataRouterStateHook3["UseNavigation"] = "useNavigation";
  DataRouterStateHook3["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook3["UseMatches"] = "useMatches";
  DataRouterStateHook3["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook3["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook3["UseRouteId"] = "useRouteId";
  return DataRouterStateHook3;
}(DataRouterStateHook || {});
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = React2.useContext(DataRouterContext);
  !ctx ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = React2.useContext(DataRouterStateContext);
  !state ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = React2.useContext(RouteContext);
  !route ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? true ? invariant(false, hookName + ' can only be used on routes that contain a unique "id"') : invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(DataRouterStateHook.UseRouteId);
}
function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}
function useMatches() {
  let {
    matches: matches2,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return React2.useMemo(() => matches2.map((m) => convertRouteMatchToUiMatch(m, loaderData)), [matches2, loaderData]);
}
function useRouteError() {
  var _state$errors;
  let error2 = React2.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
  if (error2 !== void 0) {
    return error2;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
var blockerId = 0;
function useBlocker(shouldBlock) {
  let {
    router,
    basename
  } = useDataRouterContext(DataRouterHook.UseBlocker);
  let state = useDataRouterState(DataRouterStateHook.UseBlocker);
  let [blockerKey, setBlockerKey] = React2.useState("");
  let blockerFunction = React2.useCallback((arg) => {
    if (typeof shouldBlock !== "function") {
      return !!shouldBlock;
    }
    if (basename === "/") {
      return shouldBlock(arg);
    }
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = arg;
    return shouldBlock({
      currentLocation: _extends4({}, currentLocation, {
        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
      }),
      nextLocation: _extends4({}, nextLocation, {
        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
      }),
      historyAction
    });
  }, [basename, shouldBlock]);
  React2.useEffect(() => {
    let key = String(++blockerId);
    setBlockerKey(key);
    return () => router.deleteBlocker(key);
  }, [router]);
  React2.useEffect(() => {
    if (blockerKey !== "") {
      router.getBlocker(blockerKey, blockerFunction);
    }
  }, [router, blockerKey, blockerFunction]);
  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);
  let activeRef = React2.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React2.useCallback(function(to, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    true ? warning2(activeRef.current, navigateEffectWarning) : void 0;
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends4({
        fromRouteId: id2
      }, options2));
    }
  }, [router, id2]);
  return navigate;
}
var alreadyWarned$1 = {};
function warningOnce(key, cond, message2) {
  if (!cond && !alreadyWarned$1[key]) {
    alreadyWarned$1[key] = true;
    true ? warning2(false, message2) : void 0;
  }
}
var alreadyWarned = {};
function warnOnce(key, message2) {
  if (!alreadyWarned[message2]) {
    alreadyWarned[message2] = true;
    console.warn(message2);
  }
}
var logDeprecation = (flag, msg, link) => warnOnce(flag, "⚠️ React Router Future Flag Warning: " + msg + ". " + ("You can use the `" + flag + "` future flag to opt-in early. ") + ("For more information, see " + link + "."));
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) {
    logDeprecation("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition");
  }
  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && (!routerFuture || !routerFuture.v7_relativeSplatPath)) {
    logDeprecation("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
  }
  if (routerFuture) {
    if (routerFuture.v7_fetcherPersist === void 0) {
      logDeprecation("v7_fetcherPersist", "The persistence behavior of fetchers is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist");
    }
    if (routerFuture.v7_normalizeFormMethod === void 0) {
      logDeprecation("v7_normalizeFormMethod", "Casing of `formMethod` fields is being normalized to uppercase in v7", "https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod");
    }
    if (routerFuture.v7_partialHydration === void 0) {
      logDeprecation("v7_partialHydration", "`RouterProvider` hydration behavior is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_partialhydration");
    }
    if (routerFuture.v7_skipActionErrorRevalidation === void 0) {
      logDeprecation("v7_skipActionErrorRevalidation", "The revalidation behavior after 4xx/5xx `action` responses is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation");
    }
  }
}
var START_TRANSITION = "startTransition";
var startTransitionImpl = React2[START_TRANSITION];
function Route(_props) {
  true ? invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = React2.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends4({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search: search2 = "",
    hash: hash4 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = React2.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search: search2,
        hash: hash4,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search2, hash4, state, key, navigationType]);
  true ? warning2(locationContext != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search2 + hash4 + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (locationContext == null) {
    return null;
  }
  return React2.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, React2.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
var AwaitRenderStatus = function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
  return AwaitRenderStatus2;
}(AwaitRenderStatus || {});
var neverSettledPromise = new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  React2.Children.forEach(children, (element, index2) => {
    if (!React2.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === React2.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? true ? invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? true ? invariant(false, "An index route cannot have child routes.") : invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    if (true) {
      if (route.element) {
        true ? warning2(false, "You should not include both `Component` and `element` on your route - `Component` will be used.") : void 0;
      }
    }
    Object.assign(updates, {
      element: React2.createElement(route.Component),
      Component: void 0
    });
  }
  if (route.HydrateFallback) {
    if (true) {
      if (route.hydrateFallbackElement) {
        true ? warning2(false, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.") : void 0;
      }
    }
    Object.assign(updates, {
      hydrateFallbackElement: React2.createElement(route.HydrateFallback),
      HydrateFallback: void 0
    });
  }
  if (route.ErrorBoundary) {
    if (true) {
      if (route.errorElement) {
        true ? warning2(false, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.") : void 0;
      }
    }
    Object.assign(updates, {
      errorElement: React2.createElement(route.ErrorBoundary),
      ErrorBoundary: void 0
    });
  }
  return updates;
}

// ../../../node_modules/react-router-dom/dist/index.js
function _extends5() {
  _extends5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object2) {
  return object2 != null && typeof object2.tagName === "string";
}
function isButtonElement(object2) {
  return isHtmlElement(object2) && object2.tagName.toLowerCase() === "button";
}
function isFormElement(object2) {
  return isHtmlElement(object2) && object2.tagName.toLowerCase() === "form";
}
function isInputElement(object2) {
  return isHtmlElement(object2) && object2.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e2) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    true ? warning2(false, '"' + encType + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + defaultEncType + '"')) : void 0;
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let {
        name,
        type,
        value
      } = target;
      if (type === "image") {
        let prefix3 = name ? name + "." : "";
        formData.append(prefix3 + "x", "0");
        formData.append(prefix3 + "y", "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return {
    action,
    method: method.toLowerCase(),
    encType,
    formData,
    body
  };
}
var _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"];
var _excluded3 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"];
var REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e2) {
}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: _extends5({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createBrowserHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes,
    mapRouteProperties,
    dataStrategy: opts == null ? void 0 : opts.dataStrategy,
    patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,
    window: opts == null ? void 0 : opts.window
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = _extends5({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error2 = new ErrorConstructor(val.message);
            error2.stack = "";
            serialized[key] = error2;
          } catch (e2) {
          }
        }
      }
      if (serialized[key] == null) {
        let error2 = new Error(val.message);
        error2.stack = "";
        serialized[key] = error2;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
var ViewTransitionContext = React3.createContext({
  isTransitioning: false
});
if (true) {
  ViewTransitionContext.displayName = "ViewTransition";
}
var FetchersContext = React3.createContext(/* @__PURE__ */ new Map());
if (true) {
  FetchersContext.displayName = "Fetchers";
}
var START_TRANSITION2 = "startTransition";
var startTransitionImpl2 = React3[START_TRANSITION2];
var FLUSH_SYNC = "flushSync";
var flushSyncImpl = ReactDOM[FLUSH_SYNC];
var USE_ID = "useId";
var useIdImpl = React3[USE_ID];
function startTransitionSafe(cb) {
  if (startTransitionImpl2) {
    startTransitionImpl2(cb);
  } else {
    cb();
  }
}
function flushSyncSafe(cb) {
  if (flushSyncImpl) {
    flushSyncImpl(cb);
  } else {
    cb();
  }
}
var Deferred = class {
  constructor() {
    this.status = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (value) => {
        if (this.status === "pending") {
          this.status = "resolved";
          resolve(value);
        }
      };
      this.reject = (reason) => {
        if (this.status === "pending") {
          this.status = "rejected";
          reject(reason);
        }
      };
    });
  }
};
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router,
    future
  } = _ref;
  let [state, setStateImpl] = React3.useState(router.state);
  let [pendingState, setPendingState] = React3.useState();
  let [vtContext, setVtContext] = React3.useState({
    isTransitioning: false
  });
  let [renderDfd, setRenderDfd] = React3.useState();
  let [transition, setTransition] = React3.useState();
  let [interruption, setInterruption] = React3.useState();
  let fetcherData = React3.useRef(/* @__PURE__ */ new Map());
  let {
    v7_startTransition
  } = future || {};
  let optInStartTransition = React3.useCallback((cb) => {
    if (v7_startTransition) {
      startTransitionSafe(cb);
    } else {
      cb();
    }
  }, [v7_startTransition]);
  let setState = React3.useCallback((newState, _ref2) => {
    let {
      deletedFetchers,
      flushSync: flushSync3,
      viewTransitionOpts
    } = _ref2;
    newState.fetchers.forEach((fetcher, key) => {
      if (fetcher.data !== void 0) {
        fetcherData.current.set(key, fetcher.data);
      }
    });
    deletedFetchers.forEach((key) => fetcherData.current.delete(key));
    let isViewTransitionUnavailable = router.window == null || router.window.document == null || typeof router.window.document.startViewTransition !== "function";
    if (!viewTransitionOpts || isViewTransitionUnavailable) {
      if (flushSync3) {
        flushSyncSafe(() => setStateImpl(newState));
      } else {
        optInStartTransition(() => setStateImpl(newState));
      }
      return;
    }
    if (flushSync3) {
      flushSyncSafe(() => {
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
        }
        setVtContext({
          isTransitioning: true,
          flushSync: true,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      });
      let t2 = router.window.document.startViewTransition(() => {
        flushSyncSafe(() => setStateImpl(newState));
      });
      t2.finished.finally(() => {
        flushSyncSafe(() => {
          setRenderDfd(void 0);
          setTransition(void 0);
          setPendingState(void 0);
          setVtContext({
            isTransitioning: false
          });
        });
      });
      flushSyncSafe(() => setTransition(t2));
      return;
    }
    if (transition) {
      renderDfd && renderDfd.resolve();
      transition.skipTransition();
      setInterruption({
        state: newState,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    } else {
      setPendingState(newState);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    }
  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);
  React3.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  React3.useEffect(() => {
    if (vtContext.isTransitioning && !vtContext.flushSync) {
      setRenderDfd(new Deferred());
    }
  }, [vtContext]);
  React3.useEffect(() => {
    if (renderDfd && pendingState && router.window) {
      let newState = pendingState;
      let renderPromise = renderDfd.promise;
      let transition2 = router.window.document.startViewTransition(async () => {
        optInStartTransition(() => setStateImpl(newState));
        await renderPromise;
      });
      transition2.finished.finally(() => {
        setRenderDfd(void 0);
        setTransition(void 0);
        setPendingState(void 0);
        setVtContext({
          isTransitioning: false
        });
      });
      setTransition(transition2);
    }
  }, [optInStartTransition, pendingState, renderDfd, router.window]);
  React3.useEffect(() => {
    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
      renderDfd.resolve();
    }
  }, [renderDfd, transition, state.location, pendingState]);
  React3.useEffect(() => {
    if (!vtContext.isTransitioning && interruption) {
      setPendingState(interruption.state);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: interruption.currentLocation,
        nextLocation: interruption.nextLocation
      });
      setInterruption(void 0);
    }
  }, [vtContext.isTransitioning, interruption]);
  React3.useEffect(() => {
    true ? warning2(fallbackElement == null || !router.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead") : void 0;
  }, []);
  let navigator2 = React3.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: (n2) => router.navigate(n2),
      push: (to, state2, opts) => router.navigate(to, {
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state2, opts) => router.navigate(to, {
        replace: true,
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = React3.useMemo(() => ({
    router,
    navigator: navigator2,
    static: false,
    basename
  }), [router, navigator2, basename]);
  let routerFuture = React3.useMemo(() => ({
    v7_relativeSplatPath: router.future.v7_relativeSplatPath
  }), [router.future.v7_relativeSplatPath]);
  React3.useEffect(() => logV6DeprecationWarnings(future, router.future), [future, router.future]);
  return React3.createElement(React3.Fragment, null, React3.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, React3.createElement(DataRouterStateContext.Provider, {
    value: state
  }, React3.createElement(FetchersContext.Provider, {
    value: fetcherData.current
  }, React3.createElement(ViewTransitionContext.Provider, {
    value: vtContext
  }, React3.createElement(Router, {
    basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator2,
    future: routerFuture
  }, state.initialized || router.future.v7_partialHydration ? React3.createElement(MemoizedDataRoutes, {
    routes: router.routes,
    future: router.future,
    state
  }) : fallbackElement))))), null);
}
var MemoizedDataRoutes = React3.memo(DataRoutes);
function DataRoutes(_ref3) {
  let {
    routes,
    future,
    state
  } = _ref3;
  return useRoutesImpl(routes, void 0, state, future);
}
function HistoryRouter(_ref6) {
  let {
    basename,
    children,
    future,
    history: history2
  } = _ref6;
  let [state, setStateImpl] = React3.useState({
    action: history2.action,
    location: history2.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React3.useCallback((newState) => {
    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React3.useLayoutEffect(() => history2.listen(setState), [history2, setState]);
  React3.useEffect(() => logV6DeprecationWarnings(future), [future]);
  return React3.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history2,
    future
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = React3.forwardRef(function LinkWithRef(_ref7, ref2) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace3,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose2(_ref7, _excluded);
  let {
    basename
  } = React3.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to)) {
    absoluteHref = to;
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
        true ? warning2(false, '<Link to="' + to + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.') : void 0;
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace3,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick2(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    React3.createElement("a", _extends5({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick2,
      ref: ref2,
      target
    }))
  );
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = React3.forwardRef(function NavLinkWithRef(_ref8, ref2) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end: end3 = false,
    style: styleProp,
    to,
    viewTransition,
    children
  } = _ref8, rest = _objectWithoutPropertiesLoose2(_ref8, _excluded2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = React3.useContext(DataRouterStateContext);
  let {
    navigator: navigator2,
    basename
  } = React3.useContext(NavigationContext);
  let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(path) && viewTransition === true;
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename) {
    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
  }
  const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
  let isActive3 = locationPathname === toPathname || !end3 && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end3 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let renderProps2 = {
    isActive: isActive3,
    isPending,
    isTransitioning
  };
  let ariaCurrent = isActive3 ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps2);
  } else {
    className = [classNameProp, isActive3 ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
  }
  let style3 = typeof styleProp === "function" ? styleProp(renderProps2) : styleProp;
  return React3.createElement(Link, _extends5({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref: ref2,
    style: style3,
    to,
    viewTransition
  }), typeof children === "function" ? children(renderProps2) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
var Form = React3.forwardRef((_ref9, forwardedRef) => {
  let {
    fetcherKey,
    navigate,
    reloadDocument,
    replace: replace3,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    relative,
    preventScrollReset,
    viewTransition
  } = _ref9, props = _objectWithoutPropertiesLoose2(_ref9, _excluded3);
  let submit = useSubmit();
  let formAction = useFormAction(action, {
    relative
  });
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let submitHandler = (event) => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      fetcherKey,
      method: submitMethod,
      navigate,
      replace: replace3,
      state,
      relative,
      preventScrollReset,
      viewTransition
    });
  };
  return React3.createElement("form", _extends5({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});
if (true) {
  Form.displayName = "Form";
}
function ScrollRestoration(_ref10) {
  let {
    getKey,
    storageKey
  } = _ref10;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (true) {
  ScrollRestoration.displayName = "ScrollRestoration";
}
var DataRouterHook2;
(function(DataRouterHook3) {
  DataRouterHook3["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook3["UseSubmit"] = "useSubmit";
  DataRouterHook3["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook3["UseFetcher"] = "useFetcher";
  DataRouterHook3["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook2 || (DataRouterHook2 = {}));
var DataRouterStateHook2;
(function(DataRouterStateHook3) {
  DataRouterStateHook3["UseFetcher"] = "useFetcher";
  DataRouterStateHook3["UseFetchers"] = "useFetchers";
  DataRouterStateHook3["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook2 || (DataRouterStateHook2 = {}));
function getDataRouterConsoleError2(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/v6/routers/picking-a-router.";
}
function useDataRouterContext2(hookName) {
  let ctx = React3.useContext(DataRouterContext);
  !ctx ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;
  return ctx;
}
function useDataRouterState2(hookName) {
  let state = React3.useContext(DataRouterStateContext);
  !state ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;
  return state;
}
function useLinkClickHandler(to, _temp12) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp12 === void 0 ? {} : _temp12;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return React3.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace3 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace: replace3,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
}
function validateClientSideSubmission() {
  if (typeof document === "undefined") {
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
  }
}
var fetcherId = 0;
var getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";
function useSubmit() {
  let {
    router
  } = useDataRouterContext2(DataRouterHook2.UseSubmit);
  let {
    basename
  } = React3.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return React3.useCallback(function(target, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    validateClientSideSubmission();
    let {
      action,
      method,
      encType,
      formData,
      body
    } = getFormSubmissionInfo(target, basename);
    if (options2.navigate === false) {
      let key = options2.fetcherKey || getUniqueFetcherId();
      router.fetch(key, currentRouteId, options2.action || action, {
        preventScrollReset: options2.preventScrollReset,
        formData,
        body,
        formMethod: options2.method || method,
        formEncType: options2.encType || encType,
        flushSync: options2.flushSync
      });
    } else {
      router.navigate(options2.action || action, {
        preventScrollReset: options2.preventScrollReset,
        formData,
        body,
        formMethod: options2.method || method,
        formEncType: options2.encType || encType,
        replace: options2.replace,
        state: options2.state,
        fromRouteId: currentRouteId,
        flushSync: options2.flushSync,
        viewTransition: options2.viewTransition
      });
    }
  }, [router, basename, currentRouteId]);
}
function useFormAction(action, _temp23) {
  let {
    relative
  } = _temp23 === void 0 ? {} : _temp23;
  let {
    basename
  } = React3.useContext(NavigationContext);
  let routeContext = React3.useContext(RouteContext);
  !routeContext ? true ? invariant(false, "useFormAction must be used inside a RouteContext") : invariant(false) : void 0;
  let [match85] = routeContext.matches.slice(-1);
  let path = _extends5({}, useResolvedPath(action ? action : ".", {
    relative
  }));
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v) => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? "?" + qs : "";
    }
  }
  if ((!action || action === ".") && match85.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function useScrollRestoration(_temp43) {
  let {
    getKey,
    storageKey
  } = _temp43 === void 0 ? {} : _temp43;
  let {
    router
  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);
  let {
    basename
  } = React3.useContext(NavigationContext);
  let location = useLocation();
  let matches2 = useMatches();
  let navigation = useNavigation();
  React3.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  usePageHide(React3.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches2) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    try {
      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    } catch (error2) {
      true ? warning2(false, "Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (" + error2 + ").") : void 0;
    }
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches2]));
  if (typeof document !== "undefined") {
    React3.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e2) {
      }
    }, [storageKey]);
    React3.useLayoutEffect(() => {
      let getKeyWithoutBasename = getKey && basename !== "/" ? (location2, matches3) => getKey(
        // Strip the basename to match useLocation()
        _extends5({}, location2, {
          pathname: stripBasename(location2.pathname, basename) || location2.pathname
        }),
        matches3
      ) : getKey;
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, basename, getKey]);
    React3.useLayoutEffect(() => {
      if (restoreScrollPosition === false) {
        return;
      }
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el2 = document.getElementById(decodeURIComponent(location.hash.slice(1)));
        if (el2) {
          el2.scrollIntoView();
          return;
        }
      }
      if (preventScrollReset === true) {
        return;
      }
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
function usePageHide(callback, options2) {
  let {
    capture
  } = options2 || {};
  React3.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
function useViewTransitionState(to, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let vtContext = React3.useContext(ViewTransitionContext);
  !(vtContext != null) ? true ? invariant(false, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : invariant(false) : void 0;
  let {
    basename
  } = useDataRouterContext2(DataRouterHook2.useViewTransitionState);
  let path = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}

// ../../../node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject2(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject2(value) && value !== null;
}
function isDefined3(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max3) => `Pattern length exceeds max of ${max3}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys2) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys2.forEach((key) => {
      let obj = createKey2(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey2(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index2) => {
    if (!isDefined3(obj2)) {
      return;
    }
    if (!path2[index2]) {
      list.push(obj2);
    } else {
      let key = path2[index2];
      const value = obj2[key];
      if (!isDefined3(value)) {
        return;
      }
      if (index2 === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i2 = 0, len = value.length; i2 < len; i2 += 1) {
          deepGet(value[i2], path2, index2 + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index2 + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When `true`, the algorithm will ignore diacritics (accents) in comparisons
  ignoreDiacritics: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a2, b2) => a2.score === b2.score ? a2.idx < b2.idx ? -1 : 1 : a2.score < b2.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n2 = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n2);
      return n2;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys2 = []) {
    this.keys = keys2;
    this._keysMap = {};
    keys2.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc3, docIndex) => {
        this._addString(doc3, docIndex);
      });
    } else {
      this.docs.forEach((doc3, docIndex) => {
        this._addObject(doc3, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc3) {
    const idx = this.size();
    if (isString(doc3)) {
      this._addString(doc3, idx);
    } else {
      this._addObject(doc3, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
      this.records[i2].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc3, docIndex) {
    if (!isDefined3(doc3) || isBlank(doc3)) {
      return;
    }
    let record = {
      v: doc3,
      i: docIndex,
      n: this.norm.get(doc3)
    };
    this.records.push(record);
  }
  _addObject(doc3, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc3) : this.getFn(doc3, key.path);
      if (!isDefined3(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined3(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k2) => {
              stack.push({
                nestedArrIndex: k2,
                value: item
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys2, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2.map(createKey2));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys: keys2, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance: distance2 = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance2) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance2;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start3 = -1;
  let end3 = -1;
  let i2 = 0;
  for (let len = matchmask.length; i2 < len; i2 += 1) {
    let match85 = matchmask[i2];
    if (match85 && start3 === -1) {
      start3 = i2;
    } else if (!match85 && start3 !== -1) {
      end3 = i2 - 1;
      if (end3 - start3 + 1 >= minMatchCharLength) {
        indices.push([start3, end3]);
      }
      start3 = -1;
    }
  }
  if (matchmask[i2 - 1] && i2 - start3 >= minMatchCharLength) {
    indices.push([start3, i2 - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance: distance2 = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index2;
  while ((index2 = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index2,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index2 + patternLen;
    if (computeMatches) {
      let i2 = 0;
      while (i2 < patternLen) {
        matchMask[index2 + i2] = 1;
        i2 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i2 = 0; i2 < patternLen; i2 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i2,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance: distance2,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start3 = Math.max(1, expectedLocation - binMid + 1);
    let finish2 = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish2 + 2);
    bitArr[finish2 + 1] = (1 << i2) - 1;
    for (let j2 = finish2; j2 >= start3; j2 -= 1) {
      let currentLocation = j2 - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j2] = (bitArr[j2 + 1] << 1 | 1) & charMatch;
      if (i2) {
        bitArr[j2] |= (lastBitArr[j2 + 1] | lastBitArr[j2]) << 1 | 1 | lastBitArr[j2 + 1];
      }
      if (bitArr[j2] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i2,
          currentLocation,
          expectedLocation,
          distance: distance2,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start3 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i2 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance: distance2,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
    const char = pattern.charAt(i2);
    mask[char] = (mask[char] || 0) | 1 << len - i2 - 1;
  }
  return mask;
}
var stripDiacritics = String.prototype.normalize ? (str) => str.normalize("NFD").replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, "") : (str) => str;
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreDiacritics = Config.ignoreDiacritics,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreDiacritics,
      ignoreLocation
    };
    pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
    this.pattern = pattern;
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i2 = 0;
      const remainder = len % MAX_BITS;
      const end3 = len - remainder;
      while (i2 < end3) {
        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
        i2 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, ignoreDiacritics, includeMatches } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    text = ignoreDiacritics ? stripDiacritics(text) : text;
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance: distance2,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance: distance2,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches2 = pattern.match(exp);
  return matches2 ? matches2[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index2 = text.indexOf(this.pattern);
    const isMatch = index2 === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreDiacritics = Config.ignoreDiacritics,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance: distance2,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreDiacritics,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index2;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index2 = text.indexOf(this.pattern, location)) > -1) {
      location = index2 + patternLen;
      indices.push([index2, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options2 = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
      const queryItem = query[i2];
      let found2 = false;
      let idx = -1;
      while (!found2 && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options2));
          found2 = true;
        }
      }
      if (found2) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options2));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    ignoreDiacritics = Config.ignoreDiacritics,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance: distance2 = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      ignoreDiacritics,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance: distance2
    };
    pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
    this.pattern = pattern;
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options2) {
    return options2.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive, ignoreDiacritics } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    text = ignoreDiacritics ? stripDiacritics(text) : text;
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
      const searchers2 = query[i2];
      allIndices.length = 0;
      numMatches = 0;
      for (let j2 = 0, pLen = searchers2.length; j2 < pLen; j2 += 1) {
        const searcher = searchers2[j2];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options2) {
  for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
    let searcherClass = registeredSearchers[i2];
    if (searcherClass.condition(pattern, options2)) {
      return new searcherClass(pattern, options2);
    }
  }
  return new BitapSearch(pattern, options2);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject2(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options2, { auto: auto2 = true } = {}) {
  const next = (query2) => {
    let keys2 = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto2) {
        obj.searcher = createSearcher(pattern, options2);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys2[0]
    };
    keys2.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore2(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches2 = result.matches;
  data.matches = [];
  if (!isDefined3(matches2)) {
    return;
  }
  matches2.forEach((match85) => {
    if (!isDefined3(match85.indices) || !match85.indices.length) {
      return;
    }
    const { indices, value } = match85;
    let obj = {
      indices,
      value
    };
    if (match85.key) {
      obj.key = match85.key.src;
    }
    if (match85.idx > -1) {
      obj.refIndex = match85.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options2 = {}, index2) {
    this.options = { ...Config, ...options2 };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index2);
  }
  setCollection(docs, index2) {
    this._docs = docs;
    if (index2 && !(index2 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc3) {
    if (!isDefined3(doc3)) {
      return;
    }
    this._docs.push(doc3);
    this._myIndex.add(doc3);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
      const doc3 = this._docs[i2];
      if (predicate(doc3, i2)) {
        this.removeAt(i2);
        i2 -= 1;
        len -= 1;
        results.push(doc3);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore2(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined3(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches2 = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches2 && matches2.length) {
          return [
            {
              idx,
              item,
              matches: matches2
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i2 = 0, len = node.children.length; i2 < len; i2 += 1) {
        const child = node.children[i2];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined3(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches: matches2 }) => {
            resultMap[idx].matches.push(...matches2);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys: keys2, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined3(item)) {
        return;
      }
      let matches2 = [];
      keys2.forEach((key, keyIndex) => {
        matches2.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches2.length) {
        results.push({
          idx,
          item,
          matches: matches2
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined3(value)) {
      return [];
    }
    let matches2 = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined3(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches2.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches2.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches2;
  }
};
Fuse.version = "7.1.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// ../../../node_modules/@firecms/core/dist/index.es.js
var import_react_fast_compare2 = __toESM(require_react_fast_compare());

// ../../../node_modules/date-fns/toDate.mjs
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}

// ../../../node_modules/date-fns/constructFrom.mjs
function constructFrom(date2, value) {
  if (date2 instanceof Date) {
    return new date2.constructor(value);
  } else {
    return new Date(value);
  }
}

// ../../../node_modules/date-fns/addDays.mjs
function addDays(date2, amount) {
  const _date = toDate(date2);
  if (isNaN(amount)) return constructFrom(date2, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// ../../../node_modules/date-fns/constants.mjs
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInDay = 864e5;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// ../../../node_modules/date-fns/_lib/defaultOptions.mjs
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// ../../../node_modules/date-fns/startOfWeek.mjs
function startOfWeek(date2, options2) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options2 == null ? void 0 : options2.weekStartsOn) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date2);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// ../../../node_modules/date-fns/startOfISOWeek.mjs
function startOfISOWeek(date2) {
  return startOfWeek(date2, { weekStartsOn: 1 });
}

// ../../../node_modules/date-fns/getISOWeekYear.mjs
function getISOWeekYear(date2) {
  const _date = toDate(date2);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date2, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date2, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// ../../../node_modules/date-fns/startOfDay.mjs
function startOfDay(date2) {
  const _date = toDate(date2);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// ../../../node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs
function getTimezoneOffsetInMilliseconds(date2) {
  const _date = toDate(date2);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date2 - +utcDate;
}

// ../../../node_modules/date-fns/differenceInCalendarDays.mjs
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = startOfDay(dateLeft);
  const startOfDayRight = startOfDay(dateRight);
  const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
}

// ../../../node_modules/date-fns/startOfISOWeekYear.mjs
function startOfISOWeekYear(date2) {
  const year = getISOWeekYear(date2);
  const fourthOfJanuary = constructFrom(date2, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// ../../../node_modules/date-fns/isDate.mjs
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// ../../../node_modules/date-fns/isValid.mjs
function isValid(date2) {
  if (!isDate(date2) && typeof date2 !== "number") {
    return false;
  }
  const _date = toDate(date2);
  return !isNaN(Number(_date));
}

// ../../../node_modules/date-fns/startOfYear.mjs
function startOfYear(date2) {
  const cleanDate = toDate(date2);
  const _date = constructFrom(date2, 0);
  _date.setFullYear(cleanDate.getFullYear(), 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// ../../../node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs
function buildFormatLongFn(args) {
  return (options2 = {}) => {
    const width = options2.width ? String(options2.width) : args.defaultWidth;
    const format3 = args.formats[width] || args.formats[args.defaultWidth];
    return format3;
  };
}

// ../../../node_modules/date-fns/locale/en-US/_lib/formatLong.mjs
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

// ../../../node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs
function buildLocalizeFn(args) {
  return (value, options2) => {
    const context = (options2 == null ? void 0 : options2.context) ? String(options2.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options2 == null ? void 0 : options2.width) ? String(options2.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options2 == null ? void 0 : options2.width) ? String(options2.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}

// ../../../node_modules/date-fns/locale/en-US/_lib/localize.mjs
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "st";
      case 2:
        return number2 + "nd";
      case 3:
        return number2 + "rd";
    }
  }
  return number2 + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/_lib/buildMatchFn.mjs
function buildMatchFn(args) {
  return (string2, options2 = {}) => {
    const width = options2.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string2.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options2.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options2.valueCallback(value)
    ) : value;
    const rest = string2.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object2, predicate) {
  for (const key in object2) {
    if (Object.prototype.hasOwnProperty.call(object2, key) && predicate(object2[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array2, predicate) {
  for (let key = 0; key < array2.length; key++) {
    if (predicate(array2[key])) {
      return key;
    }
  }
  return void 0;
}

// ../../../node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs
function buildMatchPatternFn(args) {
  return (string2, options2 = {}) => {
    const matchResult = string2.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string2.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    const rest = string2.slice(matchedString.length);
    return { value, rest };
  };
}

// ../../../node_modules/date-fns/locale/en-US/_lib/match.mjs
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/en-US.mjs
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/getDayOfYear.mjs
function getDayOfYear(date2) {
  const _date = toDate(date2);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// ../../../node_modules/date-fns/getISOWeek.mjs
function getISOWeek(date2) {
  const _date = toDate(date2);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// ../../../node_modules/date-fns/getWeekYear.mjs
function getWeekYear(date2, options2) {
  var _a, _b, _c, _d;
  const _date = toDate(date2);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options2 == null ? void 0 : options2.firstWeekContainsDate) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom(date2, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options2);
  const firstWeekOfThisYear = constructFrom(date2, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options2);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// ../../../node_modules/date-fns/startOfWeekYear.mjs
function startOfWeekYear(date2, options2) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options2 == null ? void 0 : options2.firstWeekContainsDate) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date2, options2);
  const firstWeek = constructFrom(date2, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options2);
  return _date;
}

// ../../../node_modules/date-fns/getWeek.mjs
function getWeek(date2, options2) {
  const _date = toDate(date2);
  const diff = +startOfWeek(_date, options2) - +startOfWeekYear(_date, options2);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// ../../../node_modules/date-fns/_lib/addLeadingZeros.mjs
function addLeadingZeros(number2, targetLength) {
  const sign = number2 < 0 ? "-" : "";
  const output = Math.abs(number2).toString().padStart(targetLength, "0");
  return sign + output;
}

// ../../../node_modules/date-fns/_lib/format/lightFormatters.mjs
var lightFormatters = {
  // Year
  y(date2, token) {
    const signedYear = date2.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date2, token) {
    const month = date2.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date2, token) {
    return addLeadingZeros(date2.getDate(), token.length);
  },
  // AM or PM
  a(date2, token) {
    const dayPeriodEnumValue = date2.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date2, token) {
    return addLeadingZeros(date2.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date2, token) {
    return addLeadingZeros(date2.getHours(), token.length);
  },
  // Minute
  m(date2, token) {
    return addLeadingZeros(date2.getMinutes(), token.length);
  },
  // Second
  s(date2, token) {
    return addLeadingZeros(date2.getSeconds(), token.length);
  },
  // Fraction of second
  S(date2, token) {
    const numberOfDigits = token.length;
    const milliseconds = date2.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};

// ../../../node_modules/date-fns/_lib/format/formatters.mjs
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date2, token, localize86) {
    const era = date2.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize86.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize86.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize86.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date2, token, localize86) {
    if (token === "yo") {
      const signedYear = date2.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize86.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date2, token);
  },
  // Local week-numbering year
  Y: function(date2, token, localize86, options2) {
    const signedWeekYear = getWeekYear(date2, options2);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize86.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date2, token) {
    const isoWeekYear = getISOWeekYear(date2);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date2, token) {
    const year = date2.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date2, token, localize86) {
    const quarter = Math.ceil((date2.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize86.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize86.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize86.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize86.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date2, token, localize86) {
    const quarter = Math.ceil((date2.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize86.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize86.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize86.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize86.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date2, token, localize86) {
    const month = date2.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date2, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize86.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize86.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize86.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize86.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date2, token, localize86) {
    const month = date2.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize86.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize86.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize86.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize86.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date2, token, localize86, options2) {
    const week2 = getWeek(date2, options2);
    if (token === "wo") {
      return localize86.ordinalNumber(week2, { unit: "week" });
    }
    return addLeadingZeros(week2, token.length);
  },
  // ISO week of year
  I: function(date2, token, localize86) {
    const isoWeek = getISOWeek(date2);
    if (token === "Io") {
      return localize86.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date2, token, localize86) {
    if (token === "do") {
      return localize86.ordinalNumber(date2.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date2, token);
  },
  // Day of year
  D: function(date2, token, localize86) {
    const dayOfYear = getDayOfYear(date2);
    if (token === "Do") {
      return localize86.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date2, token, localize86) {
    const dayOfWeek = date2.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize86.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize86.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize86.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize86.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date2, token, localize86, options2) {
    const dayOfWeek = date2.getDay();
    const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize86.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize86.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize86.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize86.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize86.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date2, token, localize86, options2) {
    const dayOfWeek = date2.getDay();
    const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize86.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize86.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize86.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize86.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize86.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date2, token, localize86) {
    const dayOfWeek = date2.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize86.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize86.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize86.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize86.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize86.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date2, token, localize86) {
    const hours = date2.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date2, token, localize86) {
    const hours = date2.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date2, token, localize86) {
    const hours = date2.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize86.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date2, token, localize86) {
    if (token === "ho") {
      let hours = date2.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize86.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date2, token);
  },
  // Hour [0-23]
  H: function(date2, token, localize86) {
    if (token === "Ho") {
      return localize86.ordinalNumber(date2.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date2, token);
  },
  // Hour [0-11]
  K: function(date2, token, localize86) {
    const hours = date2.getHours() % 12;
    if (token === "Ko") {
      return localize86.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date2, token, localize86) {
    let hours = date2.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize86.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date2, token, localize86) {
    if (token === "mo") {
      return localize86.ordinalNumber(date2.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date2, token);
  },
  // Second
  s: function(date2, token, localize86) {
    if (token === "so") {
      return localize86.ordinalNumber(date2.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date2, token);
  },
  // Fraction of second
  S: function(date2, token) {
    return lightFormatters.S(date2, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date2, token, _localize) {
    const timezoneOffset = date2.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date2, token, _localize) {
    const timestamp = Math.trunc(date2.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date2, token, _localize) {
    const timestamp = date2.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset4, delimiter = "") {
  const sign = offset4 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset4);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset4, delimiter) {
  if (offset4 % 60 === 0) {
    const sign = offset4 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset4) / 60, 2);
  }
  return formatTimezone(offset4, delimiter);
}
function formatTimezone(offset4, delimiter = "") {
  const sign = offset4 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset4);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

// ../../../node_modules/date-fns/_lib/format/longFormatters.mjs
var dateLongFormatter = (pattern, formatLong94) => {
  switch (pattern) {
    case "P":
      return formatLong94.date({ width: "short" });
    case "PP":
      return formatLong94.date({ width: "medium" });
    case "PPP":
      return formatLong94.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong94.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong94) => {
  switch (pattern) {
    case "p":
      return formatLong94.time({ width: "short" });
    case "pp":
      return formatLong94.time({ width: "medium" });
    case "ppp":
      return formatLong94.time({ width: "long" });
    case "pppp":
    default:
      return formatLong94.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong94) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong94);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong94.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong94.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong94.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong94.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong94)).replace("{{time}}", timeLongFormatter(timePattern, formatLong94));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// ../../../node_modules/date-fns/_lib/protectedTokens.mjs
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format3, input) {
  const _message = message(token, format3, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format3, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format3}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// ../../../node_modules/date-fns/format.mjs
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format2(date2, formatStr, options2) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions2 = getDefaultOptions();
  const locale = (options2 == null ? void 0 : options2.locale) ?? defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = (options2 == null ? void 0 : options2.firstWeekContainsDate) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const weekStartsOn = (options2 == null ? void 0 : options2.weekStartsOn) ?? ((_f = (_e = options2 == null ? void 0 : options2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
  const originalDate = toDate(date2);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!(options2 == null ? void 0 : options2.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options2 == null ? void 0 : options2.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date2));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// ../../../node_modules/date-fns/getISODay.mjs
function getISODay(date2) {
  const _date = toDate(date2);
  let day = _date.getDay();
  if (day === 0) {
    day = 7;
  }
  return day;
}

// ../../../node_modules/date-fns/parse/_lib/Setter.mjs
var Setter = class {
  constructor() {
    __publicField(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
};
var ValueSetter = class extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date2, options2) {
    return this.validateValue(date2, this.value, options2);
  }
  set(date2, flags, options2) {
    return this.setValue(date2, flags, this.value, options2);
  }
};

// ../../../node_modules/date-fns/parse/_lib/Parser.mjs
var Parser = class {
  run(dateString, token, match85, options2) {
    const result = this.parse(dateString, token, match85, options2);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/EraParser.mjs
var EraParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 140);
    __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return match85.era(dateString, { width: "abbreviated" }) || match85.era(dateString, { width: "narrow" });
      // A, B
      case "GGGGG":
        return match85.era(dateString, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return match85.era(dateString, { width: "wide" }) || match85.era(dateString, { width: "abbreviated" }) || match85.era(dateString, { width: "narrow" });
    }
  }
  set(date2, flags, value) {
    flags.era = value;
    date2.setFullYear(value, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/constants.mjs
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// ../../../node_modules/date-fns/parse/_lib/utils.mjs
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
  }
}
function parseNDigitsSigned(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// ../../../node_modules/date-fns/parse/_lib/parsers/YearParser.mjs
var YearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match85) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match85.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date2, flags, value) {
    const currentYear = date2.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date2.setFullYear(normalizedTwoDigitYear, 0, 1);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date2.setFullYear(year, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.mjs
var LocalWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match85.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date2, flags, value, options2) {
    const currentYear = getWeekYear(date2, options2);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date2.setFullYear(
        normalizedTwoDigitYear,
        0,
        options2.firstWeekContainsDate
      );
      date2.setHours(0, 0, 0, 0);
      return startOfWeek(date2, options2);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date2.setFullYear(year, 0, options2.firstWeekContainsDate);
    date2.setHours(0, 0, 0, 0);
    return startOfWeek(date2, options2);
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.mjs
var ISOWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date2, _flags, value) {
    const firstWeekOfYear = constructFrom(date2, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.mjs
var ExtendedYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date2, _flags, value) {
    date2.setFullYear(value, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/QuarterParser.mjs
var QuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return match85.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return match85.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return match85.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return match85.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match85.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date2, _flags, value) {
    date2.setMonth((value - 1) * 3, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.mjs
var StandAloneQuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match85.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return match85.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match85.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match85.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return match85.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match85.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match85.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date2, _flags, value) {
    date2.setMonth((value - 1) * 3, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/MonthParser.mjs
var MonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    __publicField(this, "priority", 110);
  }
  parse(dateString, token, match85) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      // 1, 2, ..., 12
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      // 01, 02, ..., 12
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return mapValue(
          match85.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return match85.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.month(dateString, { width: "narrow", context: "formatting" });
      // J, F, ..., D
      case "MMMMM":
        return match85.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return match85.month(dateString, { width: "wide", context: "formatting" }) || match85.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    date2.setMonth(value, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.mjs
var StandAloneMonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 110);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      // 01, 02, ..., 12
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return mapValue(
          match85.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return match85.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match85.month(dateString, { width: "narrow", context: "standalone" });
      // J, F, ..., D
      case "LLLLL":
        return match85.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return match85.month(dateString, { width: "wide", context: "standalone" }) || match85.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match85.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    date2.setMonth(value, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/setWeek.mjs
function setWeek(date2, week2, options2) {
  const _date = toDate(date2);
  const diff = getWeek(_date, options2) - week2;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// ../../../node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.mjs
var LocalWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match85.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date2, _flags, value, options2) {
    return startOfWeek(setWeek(date2, value, options2), options2);
  }
};

// ../../../node_modules/date-fns/setISOWeek.mjs
function setISOWeek(date2, week2) {
  const _date = toDate(date2);
  const diff = getISOWeek(_date) - week2;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// ../../../node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.mjs
var ISOWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match85.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date2, _flags, value) {
    return startOfISOWeek(setISOWeek(date2, value));
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/DateParser.mjs
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
var DateParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subPriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match85.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date2, value) {
    const year = date2.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    const month = date2.getMonth();
    if (isLeapYear2) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date2, _flags, value) {
    date2.setDate(value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.mjs
var DayOfYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subpriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match85.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date2, value) {
    const year = date2.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    if (isLeapYear2) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date2, _flags, value) {
    date2.setMonth(0, value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/setDay.mjs
function setDay(date2, day, options2) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options2 == null ? void 0 : options2.weekStartsOn) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date2);
  const currentDay = _date.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(_date, diff);
}

// ../../../node_modules/date-fns/parse/_lib/parsers/DayParser.mjs
var DayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return match85.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.day(dateString, { width: "short", context: "formatting" }) || match85.day(dateString, { width: "narrow", context: "formatting" });
      // T
      case "EEEEE":
        return match85.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return match85.day(dateString, { width: "short", context: "formatting" }) || match85.day(dateString, { width: "narrow", context: "formatting" });
      // Tuesday
      case "EEEE":
      default:
        return match85.day(dateString, { width: "wide", context: "formatting" }) || match85.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.day(dateString, { width: "short", context: "formatting" }) || match85.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options2) {
    date2 = setDay(date2, value, options2);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/LocalDayParser.mjs
var LocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85, options2) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      // 3
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "eo":
        return mapValue(
          match85.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      // Tue
      case "eee":
        return match85.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.day(dateString, { width: "short", context: "formatting" }) || match85.day(dateString, { width: "narrow", context: "formatting" });
      // T
      case "eeeee":
        return match85.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return match85.day(dateString, { width: "short", context: "formatting" }) || match85.day(dateString, { width: "narrow", context: "formatting" });
      // Tuesday
      case "eeee":
      default:
        return match85.day(dateString, { width: "wide", context: "formatting" }) || match85.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.day(dateString, { width: "short", context: "formatting" }) || match85.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options2) {
    date2 = setDay(date2, value, options2);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.mjs
var StandAloneLocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85, options2) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      // 3
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "co":
        return mapValue(
          match85.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      // Tue
      case "ccc":
        return match85.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match85.day(dateString, { width: "short", context: "standalone" }) || match85.day(dateString, { width: "narrow", context: "standalone" });
      // T
      case "ccccc":
        return match85.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return match85.day(dateString, { width: "short", context: "standalone" }) || match85.day(dateString, { width: "narrow", context: "standalone" });
      // Tuesday
      case "cccc":
      default:
        return match85.day(dateString, { width: "wide", context: "standalone" }) || match85.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match85.day(dateString, { width: "short", context: "standalone" }) || match85.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date2, _flags, value, options2) {
    date2 = setDay(date2, value, options2);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/setISODay.mjs
function setISODay(date2, day) {
  const _date = toDate(date2);
  const currentDay = getISODay(_date);
  const diff = day - currentDay;
  return addDays(_date, diff);
}

// ../../../node_modules/date-fns/parse/_lib/parsers/ISODayParser.mjs
var ISODayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match85) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      // 2
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      // 2nd
      case "io":
        return match85.ordinalNumber(dateString, { unit: "day" });
      // Tue
      case "iii":
        return mapValue(
          match85.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match85.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match85.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // T
      case "iiiii":
        return mapValue(
          match85.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // Tu
      case "iiiiii":
        return mapValue(
          match85.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match85.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // Tuesday
      case "iiii":
      default:
        return mapValue(
          match85.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match85.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match85.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match85.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date2, _flags, value) {
    date2 = setISODay(date2, value);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/AMPMParser.mjs
var AMPMParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match85.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match85.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.mjs
var AMPMMidnightParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match85.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match85.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.mjs
var DayPeriodParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match85.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match85.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match85.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date2, _flags, value) {
    date2.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.mjs
var Hour1to12Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match85.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date2, _flags, value) {
    const isPM = date2.getHours() >= 12;
    if (isPM && value < 12) {
      date2.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date2.setHours(0, 0, 0, 0);
    } else {
      date2.setHours(value, 0, 0, 0);
    }
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.mjs
var Hour0to23Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match85.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date2, _flags, value) {
    date2.setHours(value, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.mjs
var Hour0To11Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match85.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date2, _flags, value) {
    const isPM = date2.getHours() >= 12;
    if (isPM && value < 12) {
      date2.setHours(value + 12, 0, 0, 0);
    } else {
      date2.setHours(value, 0, 0, 0);
    }
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.mjs
var Hour1To24Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match85.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date2, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date2.setHours(hours, 0, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/MinuteParser.mjs
var MinuteParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 60);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match85.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date2, _flags, value) {
    date2.setMinutes(value, 0, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/SecondParser.mjs
var SecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 50);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match85) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match85.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date2, _flags, value) {
    date2.setSeconds(value, 0);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.mjs
var FractionOfSecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 30);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date2, _flags, value) {
    date2.setMilliseconds(value);
    return date2;
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.mjs
var ISOTimezoneWithZParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date2, flags, value) {
    if (flags.timestampIsSet) return date2;
    return constructFrom(
      date2,
      date2.getTime() - getTimezoneOffsetInMilliseconds(date2) - value
    );
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.mjs
var ISOTimezoneParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date2, flags, value) {
    if (flags.timestampIsSet) return date2;
    return constructFrom(
      date2,
      date2.getTime() - getTimezoneOffsetInMilliseconds(date2) - value
    );
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.mjs
var TimestampSecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 40);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date2, _flags, value) {
    return [constructFrom(date2, value * 1e3), { timestampIsSet: true }];
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.mjs
var TimestampMillisecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 20);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date2, _flags, value) {
    return [constructFrom(date2, value), { timestampIsSet: true }];
  }
};

// ../../../node_modules/date-fns/parse/_lib/parsers.mjs
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// ../../../node_modules/date-fns/isSameWeek.mjs
function isSameWeek(dateLeft, dateRight, options2) {
  const dateLeftStartOfWeek = startOfWeek(dateLeft, options2);
  const dateRightStartOfWeek = startOfWeek(dateRight, options2);
  return +dateLeftStartOfWeek === +dateRightStartOfWeek;
}

// ../../../node_modules/date-fns/locale.mjs
var locale_exports = {};
__export(locale_exports, {
  af: () => af,
  ar: () => ar,
  arDZ: () => arDZ,
  arEG: () => arEG,
  arMA: () => arMA,
  arSA: () => arSA,
  arTN: () => arTN,
  az: () => az,
  be: () => be,
  beTarask: () => beTarask,
  bg: () => bg,
  bn: () => bn,
  bs: () => bs,
  ca: () => ca,
  ckb: () => ckb,
  cs: () => cs,
  cy: () => cy,
  da: () => da,
  de: () => de,
  deAT: () => deAT,
  el: () => el,
  enAU: () => enAU,
  enCA: () => enCA,
  enGB: () => enGB,
  enIE: () => enIE,
  enIN: () => enIN,
  enNZ: () => enNZ,
  enUS: () => enUS,
  enZA: () => enZA,
  eo: () => eo,
  es: () => es,
  et: () => et,
  eu: () => eu,
  faIR: () => faIR,
  fi: () => fi,
  fr: () => fr,
  frCA: () => frCA,
  frCH: () => frCH,
  fy: () => fy,
  gd: () => gd,
  gl: () => gl,
  gu: () => gu,
  he: () => he,
  hi: () => hi,
  hr: () => hr,
  ht: () => ht,
  hu: () => hu,
  hy: () => hy,
  id: () => id,
  is: () => is,
  it: () => it,
  itCH: () => itCH,
  ja: () => ja,
  jaHira: () => jaHira,
  ka: () => ka,
  kk: () => kk,
  km: () => km,
  kn: () => kn,
  ko: () => ko,
  lb: () => lb,
  lt: () => lt,
  lv: () => lv,
  mk: () => mk,
  mn: () => mn,
  ms: () => ms,
  mt: () => mt,
  nb: () => nb,
  nl: () => nl,
  nlBE: () => nlBE,
  nn: () => nn,
  oc: () => oc,
  pl: () => pl,
  pt: () => pt,
  ptBR: () => ptBR,
  ro: () => ro,
  ru: () => ru,
  se: () => se,
  sk: () => sk,
  sl: () => sl,
  sq: () => sq,
  sr: () => sr,
  srLatn: () => srLatn,
  sv: () => sv,
  ta: () => ta,
  te: () => te,
  th: () => th,
  tr: () => tr,
  ug: () => ug,
  uk: () => uk,
  uz: () => uz,
  uzCyrl: () => uzCyrl,
  vi: () => vi,
  zhCN: () => zhCN,
  zhHK: () => zhHK,
  zhTW: () => zhTW
});

// ../../../node_modules/date-fns/locale/af/_lib/formatDistance.mjs
var formatDistanceLocale2 = {
  lessThanXSeconds: {
    one: "minder as 'n sekonde",
    other: "minder as {{count}} sekondes"
  },
  xSeconds: {
    one: "1 sekonde",
    other: "{{count}} sekondes"
  },
  halfAMinute: "'n halwe minuut",
  lessThanXMinutes: {
    one: "minder as 'n minuut",
    other: "minder as {{count}} minute"
  },
  xMinutes: {
    one: "'n minuut",
    other: "{{count}} minute"
  },
  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} ure"
  },
  xHours: {
    one: "1 uur",
    other: "{{count}} ure"
  },
  xDays: {
    one: "1 dag",
    other: "{{count}} dae"
  },
  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weke"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weke"
  },
  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maande"
  },
  xMonths: {
    one: "1 maand",
    other: "{{count}} maande"
  },
  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar"
  },
  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar"
  },
  overXYears: {
    one: "meer as 1 jaar",
    other: "meer as {{count}} jaar"
  },
  almostXYears: {
    one: "byna 1 jaar",
    other: "byna {{count}} jaar"
  }
};
var formatDistance3 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale2[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "oor " + result;
    } else {
      return result + " gelede";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/af/_lib/formatLong.mjs
var dateFormats2 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "yyyy/MM/dd"
};
var timeFormats2 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats2 = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong2 = {
  date: buildFormatLongFn({
    formats: dateFormats2,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats2,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats2,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/af/_lib/formatRelative.mjs
var formatRelativeLocale2 = {
  lastWeek: "'verlede' eeee 'om' p",
  yesterday: "'gister om' p",
  today: "'vandag om' p",
  tomorrow: "'môre om' p",
  nextWeek: "eeee 'om' p",
  other: "P"
};
var formatRelative2 = (token, _date, _baseDate, _options) => formatRelativeLocale2[token];

// ../../../node_modules/date-fns/locale/af/_lib/localize.mjs
var eraValues2 = {
  narrow: ["vC", "nC"],
  abbreviated: ["vC", "nC"],
  wide: ["voor Christus", "na Christus"]
};
var quarterValues2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1ste kwartaal", "2de kwartaal", "3de kwartaal", "4de kwartaal"]
};
var monthValues2 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mrt",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Des"
  ],
  wide: [
    "Januarie",
    "Februarie",
    "Maart",
    "April",
    "Mei",
    "Junie",
    "Julie",
    "Augustus",
    "September",
    "Oktober",
    "November",
    "Desember"
  ]
};
var dayValues2 = {
  narrow: ["S", "M", "D", "W", "D", "V", "S"],
  short: ["So", "Ma", "Di", "Wo", "Do", "Vr", "Sa"],
  abbreviated: ["Son", "Maa", "Din", "Woe", "Don", "Vry", "Sat"],
  wide: [
    "Sondag",
    "Maandag",
    "Dinsdag",
    "Woensdag",
    "Donderdag",
    "Vrydag",
    "Saterdag"
  ]
};
var dayPeriodValues2 = {
  narrow: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand"
  },
  abbreviated: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand"
  },
  wide: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "middaguur",
    morning: "oggend",
    afternoon: "middag",
    evening: "laat middag",
    night: "aand"
  }
};
var formattingDayPeriodValues2 = {
  narrow: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand"
  },
  abbreviated: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand"
  },
  wide: {
    am: "vm",
    pm: "nm",
    midnight: "middernag",
    noon: "uur die middag",
    morning: "uur die oggend",
    afternoon: "uur die middag",
    evening: "uur die aand",
    night: "uur die aand"
  }
};
var ordinalNumber2 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 < 20) {
    switch (rem100) {
      case 1:
      case 8:
        return number2 + "ste";
      default:
        return number2 + "de";
    }
  }
  return number2 + "ste";
};
var localize2 = {
  ordinalNumber: ordinalNumber2,
  era: buildLocalizeFn({
    values: eraValues2,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues2,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues2,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues2,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues2,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues2,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/af/_lib/match.mjs
var matchOrdinalNumberPattern2 = /^(\d+)(ste|de)?/i;
var parseOrdinalNumberPattern2 = /\d+/i;
var matchEraPatterns2 = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?C\.?)/,
  wide: /^((voor|na) Christus)/
};
var parseEraPatterns2 = {
  any: [/^v/, /^n/]
};
var matchQuarterPatterns2 = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234](st|d)e kwartaal/i
};
var parseQuarterPatterns2 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns2 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(Jan|Feb|Mrt|Apr|Mei|Jun|Jul|Aug|Sep|Okt|Nov|Dec)\.?/i,
  wide: /^(Januarie|Februarie|Maart|April|Mei|Junie|Julie|Augustus|September|Oktober|November|Desember)/i
};
var parseMonthPatterns2 = {
  narrow: [
    /^J/i,
    /^F/i,
    /^M/i,
    /^A/i,
    /^M/i,
    /^J/i,
    /^J/i,
    /^A/i,
    /^S/i,
    /^O/i,
    /^N/i,
    /^D/i
  ],
  any: [
    /^Jan/i,
    /^Feb/i,
    /^Mrt/i,
    /^Apr/i,
    /^Mei/i,
    /^Jun/i,
    /^Jul/i,
    /^Aug/i,
    /^Sep/i,
    /^Okt/i,
    /^Nov/i,
    /^Dec/i
  ]
};
var matchDayPatterns2 = {
  narrow: /^[smdwv]/i,
  short: /^(So|Ma|Di|Wo|Do|Vr|Sa)/i,
  abbreviated: /^(Son|Maa|Din|Woe|Don|Vry|Sat)/i,
  wide: /^(Sondag|Maandag|Dinsdag|Woensdag|Donderdag|Vrydag|Saterdag)/i
};
var parseDayPatterns2 = {
  narrow: [/^S/i, /^M/i, /^D/i, /^W/i, /^D/i, /^V/i, /^S/i],
  any: [/^So/i, /^Ma/i, /^Di/i, /^Wo/i, /^Do/i, /^Vr/i, /^Sa/i]
};
var matchDayPeriodPatterns2 = {
  any: /^(vm|nm|middernag|(?:uur )?die (oggend|middag|aand))/i
};
var parseDayPeriodPatterns2 = {
  any: {
    am: /^vm/i,
    pm: /^nm/i,
    midnight: /^middernag/i,
    noon: /^middaguur/i,
    morning: /oggend/i,
    afternoon: /middag/i,
    evening: /laat middag/i,
    night: /aand/i
  }
};
var match2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern2,
    parsePattern: parseOrdinalNumberPattern2,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns2,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns2,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns2,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns2,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns2,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns2,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/af.mjs
var af = {
  code: "af",
  formatDistance: formatDistance3,
  formatLong: formatLong2,
  formatRelative: formatRelative2,
  localize: localize2,
  match: match2,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ar/_lib/formatDistance.mjs
var formatDistanceLocale3 = {
  lessThanXSeconds: {
    one: "أقل من ثانية",
    two: "أقل من ثانيتين",
    threeToTen: "أقل من {{count}} ثواني",
    other: "أقل من {{count}} ثانية"
  },
  xSeconds: {
    one: "ثانية واحدة",
    two: "ثانيتان",
    threeToTen: "{{count}} ثواني",
    other: "{{count}} ثانية"
  },
  halfAMinute: "نصف دقيقة",
  lessThanXMinutes: {
    one: "أقل من دقيقة",
    two: "أقل من دقيقتين",
    threeToTen: "أقل من {{count}} دقائق",
    other: "أقل من {{count}} دقيقة"
  },
  xMinutes: {
    one: "دقيقة واحدة",
    two: "دقيقتان",
    threeToTen: "{{count}} دقائق",
    other: "{{count}} دقيقة"
  },
  aboutXHours: {
    one: "ساعة واحدة تقريباً",
    two: "ساعتين تقريبا",
    threeToTen: "{{count}} ساعات تقريباً",
    other: "{{count}} ساعة تقريباً"
  },
  xHours: {
    one: "ساعة واحدة",
    two: "ساعتان",
    threeToTen: "{{count}} ساعات",
    other: "{{count}} ساعة"
  },
  xDays: {
    one: "يوم واحد",
    two: "يومان",
    threeToTen: "{{count}} أيام",
    other: "{{count}} يوم"
  },
  aboutXWeeks: {
    one: "أسبوع واحد تقريبا",
    two: "أسبوعين تقريبا",
    threeToTen: "{{count}} أسابيع تقريبا",
    other: "{{count}} أسبوعا تقريبا"
  },
  xWeeks: {
    one: "أسبوع واحد",
    two: "أسبوعان",
    threeToTen: "{{count}} أسابيع",
    other: "{{count}} أسبوعا"
  },
  aboutXMonths: {
    one: "شهر واحد تقريباً",
    two: "شهرين تقريبا",
    threeToTen: "{{count}} أشهر تقريبا",
    other: "{{count}} شهرا تقريباً"
  },
  xMonths: {
    one: "شهر واحد",
    two: "شهران",
    threeToTen: "{{count}} أشهر",
    other: "{{count}} شهرا"
  },
  aboutXYears: {
    one: "سنة واحدة تقريباً",
    two: "سنتين تقريبا",
    threeToTen: "{{count}} سنوات تقريباً",
    other: "{{count}} سنة تقريباً"
  },
  xYears: {
    one: "سنة واحد",
    two: "سنتان",
    threeToTen: "{{count}} سنوات",
    other: "{{count}} سنة"
  },
  overXYears: {
    one: "أكثر من سنة",
    two: "أكثر من سنتين",
    threeToTen: "أكثر من {{count}} سنوات",
    other: "أكثر من {{count}} سنة"
  },
  almostXYears: {
    one: "ما يقارب سنة واحدة",
    two: "ما يقارب سنتين",
    threeToTen: "ما يقارب {{count}} سنوات",
    other: "ما يقارب {{count}} سنة"
  }
};
var formatDistance4 = (token, count, options2) => {
  const usageGroup = formatDistanceLocale3[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "خلال " + result;
    } else {
      return "منذ " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ar/_lib/formatLong.mjs
var dateFormats3 = {
  full: "EEEE، do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
var timeFormats3 = {
  full: "HH:mm:ss",
  long: "HH:mm:ss",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats3 = {
  full: "{{date}} 'عند الساعة' {{time}}",
  long: "{{date}} 'عند الساعة' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong3 = {
  date: buildFormatLongFn({
    formats: dateFormats3,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats3,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats3,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ar/_lib/formatRelative.mjs
var formatRelativeLocale3 = {
  lastWeek: "eeee 'الماضي عند الساعة' p",
  yesterday: "'الأمس عند الساعة' p",
  today: "'اليوم عند الساعة' p",
  tomorrow: "'غدا عند الساعة' p",
  nextWeek: "eeee 'القادم عند الساعة' p",
  other: "P"
};
var formatRelative3 = (token) => formatRelativeLocale3[token];

// ../../../node_modules/date-fns/locale/ar/_lib/localize.mjs
var eraValues3 = {
  narrow: ["ق", "ب"],
  abbreviated: ["ق.م.", "ب.م."],
  wide: ["قبل الميلاد", "بعد الميلاد"]
};
var quarterValues3 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ر1", "ر2", "ر3", "ر4"],
  wide: ["الربع الأول", "الربع الثاني", "الربع الثالث", "الربع الرابع"]
};
var monthValues3 = {
  narrow: ["ي", "ف", "م", "أ", "م", "ي", "ي", "أ", "س", "أ", "ن", "د"],
  abbreviated: [
    "يناير",
    "فبراير",
    "مارس",
    "أبريل",
    "مايو",
    "يونيو",
    "يوليو",
    "أغسطس",
    "سبتمبر",
    "أكتوبر",
    "نوفمبر",
    "ديسمبر"
  ],
  wide: [
    "يناير",
    "فبراير",
    "مارس",
    "أبريل",
    "مايو",
    "يونيو",
    "يوليو",
    "أغسطس",
    "سبتمبر",
    "أكتوبر",
    "نوفمبر",
    "ديسمبر"
  ]
};
var dayValues3 = {
  narrow: ["ح", "ن", "ث", "ر", "خ", "ج", "س"],
  short: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  abbreviated: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  wide: [
    "الأحد",
    "الاثنين",
    "الثلاثاء",
    "الأربعاء",
    "الخميس",
    "الجمعة",
    "السبت"
  ]
};
var dayPeriodValues3 = {
  narrow: {
    am: "ص",
    pm: "م",
    morning: "الصباح",
    noon: "الظهر",
    afternoon: "بعد الظهر",
    evening: "المساء",
    night: "الليل",
    midnight: "منتصف الليل"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    morning: "الصباح",
    noon: "الظهر",
    afternoon: "بعد الظهر",
    evening: "المساء",
    night: "الليل",
    midnight: "منتصف الليل"
  },
  wide: {
    am: "ص",
    pm: "م",
    morning: "الصباح",
    noon: "الظهر",
    afternoon: "بعد الظهر",
    evening: "المساء",
    night: "الليل",
    midnight: "منتصف الليل"
  }
};
var formattingDayPeriodValues3 = {
  narrow: {
    am: "ص",
    pm: "م",
    morning: "في الصباح",
    noon: "الظهر",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل",
    midnight: "منتصف الليل"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    morning: "في الصباح",
    noon: "الظهر",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل",
    midnight: "منتصف الليل"
  },
  wide: {
    am: "ص",
    pm: "م",
    morning: "في الصباح",
    noon: "الظهر",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل",
    midnight: "منتصف الليل"
  }
};
var ordinalNumber3 = (num) => String(num);
var localize3 = {
  ordinalNumber: ordinalNumber3,
  era: buildLocalizeFn({
    values: eraValues3,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues3,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues3,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues3,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues3,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues3,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ar/_lib/match.mjs
var matchOrdinalNumberPattern3 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern3 = /\d+/i;
var matchEraPatterns3 = {
  narrow: /[قب]/,
  abbreviated: /[قب]\.م\./,
  wide: /(قبل|بعد) الميلاد/
};
var parseEraPatterns3 = {
  any: [/قبل/, /بعد/]
};
var matchQuarterPatterns3 = {
  narrow: /^[1234]/i,
  abbreviated: /ر[1234]/,
  wide: /الربع (الأول|الثاني|الثالث|الرابع)/
};
var parseQuarterPatterns3 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns3 = {
  narrow: /^[أيفمسند]/,
  abbreviated: /^(يناير|فبراير|مارس|أبريل|مايو|يونيو|يوليو|أغسطس|سبتمبر|أكتوبر|نوفمبر|ديسمبر)/,
  wide: /^(يناير|فبراير|مارس|أبريل|مايو|يونيو|يوليو|أغسطس|سبتمبر|أكتوبر|نوفمبر|ديسمبر)/
};
var parseMonthPatterns3 = {
  narrow: [
    /^ي/i,
    /^ف/i,
    /^م/i,
    /^أ/i,
    /^م/i,
    /^ي/i,
    /^ي/i,
    /^أ/i,
    /^س/i,
    /^أ/i,
    /^ن/i,
    /^د/i
  ],
  any: [
    /^يناير/i,
    /^فبراير/i,
    /^مارس/i,
    /^أبريل/i,
    /^مايو/i,
    /^يونيو/i,
    /^يوليو/i,
    /^أغسطس/i,
    /^سبتمبر/i,
    /^أكتوبر/i,
    /^نوفمبر/i,
    /^ديسمبر/i
  ]
};
var matchDayPatterns3 = {
  narrow: /^[حنثرخجس]/i,
  short: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,
  abbreviated: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,
  wide: /^(الأحد|الاثنين|الثلاثاء|الأربعاء|الخميس|الجمعة|السبت)/i
};
var parseDayPatterns3 = {
  narrow: [/^ح/i, /^ن/i, /^ث/i, /^ر/i, /^خ/i, /^ج/i, /^س/i],
  wide: [
    /^الأحد/i,
    /^الاثنين/i,
    /^الثلاثاء/i,
    /^الأربعاء/i,
    /^الخميس/i,
    /^الجمعة/i,
    /^السبت/i
  ],
  any: [/^أح/i, /^اث/i, /^ث/i, /^أر/i, /^خ/i, /^ج/i, /^س/i]
};
var matchDayPeriodPatterns3 = {
  narrow: /^(ص|م|منتصف الليل|الظهر|بعد الظهر|في الصباح|في المساء|في الليل)/,
  any: /^(ص|م|منتصف الليل|الظهر|بعد الظهر|في الصباح|في المساء|في الليل)/
};
var parseDayPeriodPatterns3 = {
  any: {
    am: /^ص/,
    pm: /^م/,
    midnight: /منتصف الليل/,
    noon: /الظهر/,
    afternoon: /بعد الظهر/,
    morning: /في الصباح/,
    evening: /في المساء/,
    night: /في الليل/
  }
};
var match3 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern3,
    parsePattern: parseOrdinalNumberPattern3,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns3,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns3,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns3,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns3,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns3,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns3,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ar.mjs
var ar = {
  code: "ar",
  formatDistance: formatDistance4,
  formatLong: formatLong3,
  formatRelative: formatRelative3,
  localize: localize3,
  match: match3,
  options: {
    weekStartsOn: 6,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ar-DZ/_lib/formatDistance.mjs
var formatDistanceLocale4 = {
  lessThanXSeconds: {
    one: "أقل من ثانية واحدة",
    two: "أقل من ثانتين",
    threeToTen: "أقل من {{count}} ثواني",
    other: "أقل من {{count}} ثانية"
  },
  xSeconds: {
    one: "ثانية واحدة",
    two: "ثانتين",
    threeToTen: "{{count}} ثواني",
    other: "{{count}} ثانية"
  },
  halfAMinute: "نصف دقيقة",
  lessThanXMinutes: {
    one: "أقل من دقيقة",
    two: "أقل من دقيقتين",
    threeToTen: "أقل من {{count}} دقائق",
    other: "أقل من {{count}} دقيقة"
  },
  xMinutes: {
    one: "دقيقة واحدة",
    two: "دقيقتين",
    threeToTen: "{{count}} دقائق",
    other: "{{count}} دقيقة"
  },
  aboutXHours: {
    one: "ساعة واحدة تقريباً",
    two: "ساعتين تقريباً",
    threeToTen: "{{count}} ساعات تقريباً",
    other: "{{count}} ساعة تقريباً"
  },
  xHours: {
    one: "ساعة واحدة",
    two: "ساعتين",
    threeToTen: "{{count}} ساعات",
    other: "{{count}} ساعة"
  },
  xDays: {
    one: "يوم واحد",
    two: "يومين",
    threeToTen: "{{count}} أيام",
    other: "{{count}} يوم"
  },
  aboutXWeeks: {
    one: "أسبوع واحد تقريباً",
    two: "أسبوعين تقريباً",
    threeToTen: "{{count}} أسابيع تقريباً",
    other: "{{count}} أسبوع تقريباً"
  },
  xWeeks: {
    one: "أسبوع واحد",
    two: "أسبوعين",
    threeToTen: "{{count}} أسابيع",
    other: "{{count}} أسبوع"
  },
  aboutXMonths: {
    one: "شهر واحد تقريباً",
    two: "شهرين تقريباً",
    threeToTen: "{{count}} أشهر تقريباً",
    other: "{{count}} شهر تقريباً"
  },
  xMonths: {
    one: "شهر واحد",
    two: "شهرين",
    threeToTen: "{{count}} أشهر",
    other: "{{count}} شهر"
  },
  aboutXYears: {
    one: "عام واحد تقريباً",
    two: "عامين تقريباً",
    threeToTen: "{{count}} أعوام تقريباً",
    other: "{{count}} عام تقريباً"
  },
  xYears: {
    one: "عام واحد",
    two: "عامين",
    threeToTen: "{{count}} أعوام",
    other: "{{count}} عام"
  },
  overXYears: {
    one: "أكثر من عام",
    two: "أكثر من عامين",
    threeToTen: "أكثر من {{count}} أعوام",
    other: "أكثر من {{count}} عام"
  },
  almostXYears: {
    one: "عام واحد تقريباً",
    two: "عامين تقريباً",
    threeToTen: "{{count}} أعوام تقريباً",
    other: "{{count}} عام تقريباً"
  }
};
var formatDistance5 = (token, count, options2) => {
  options2 = options2 || {};
  const usageGroup = formatDistanceLocale4[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "في خلال " + result;
    } else {
      return "منذ " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ar-DZ/_lib/formatLong.mjs
var dateFormats4 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats4 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats4 = {
  full: "{{date}} 'عند' {{time}}",
  long: "{{date}} 'عند' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong4 = {
  date: buildFormatLongFn({
    formats: dateFormats4,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats4,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats4,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ar-DZ/_lib/formatRelative.mjs
var formatRelativeLocale4 = {
  lastWeek: "'أخر' eeee 'عند' p",
  yesterday: "'أمس عند' p",
  today: "'اليوم عند' p",
  tomorrow: "'غداً عند' p",
  nextWeek: "eeee 'عند' p",
  other: "P"
};
var formatRelative4 = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale4[token];
};

// ../../../node_modules/date-fns/locale/ar-DZ/_lib/localize.mjs
var eraValues4 = {
  narrow: ["ق", "ب"],
  abbreviated: ["ق.م.", "ب.م."],
  wide: ["قبل الميلاد", "بعد الميلاد"]
};
var quarterValues4 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ر1", "ر2", "ر3", "ر4"],
  wide: ["الربع الأول", "الربع الثاني", "الربع الثالث", "الربع الرابع"]
};
var monthValues4 = {
  narrow: ["ج", "ف", "م", "أ", "م", "ج", "ج", "أ", "س", "أ", "ن", "د"],
  abbreviated: [
    "جانـ",
    "فيفـ",
    "مارس",
    "أفريل",
    "مايـ",
    "جوانـ",
    "جويـ",
    "أوت",
    "سبتـ",
    "أكتـ",
    "نوفـ",
    "ديسـ"
  ],
  wide: [
    "جانفي",
    "فيفري",
    "مارس",
    "أفريل",
    "ماي",
    "جوان",
    "جويلية",
    "أوت",
    "سبتمبر",
    "أكتوبر",
    "نوفمبر",
    "ديسمبر"
  ]
};
var dayValues4 = {
  narrow: ["ح", "ن", "ث", "ر", "خ", "ج", "س"],
  short: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  abbreviated: ["أحد", "اثنـ", "ثلا", "أربـ", "خميـ", "جمعة", "سبت"],
  wide: [
    "الأحد",
    "الاثنين",
    "الثلاثاء",
    "الأربعاء",
    "الخميس",
    "الجمعة",
    "السبت"
  ]
};
var dayPeriodValues4 = {
  narrow: {
    am: "ص",
    pm: "م",
    midnight: "ن",
    noon: "ظ",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  },
  wide: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  }
};
var formattingDayPeriodValues4 = {
  narrow: {
    am: "ص",
    pm: "م",
    midnight: "ن",
    noon: "ظ",
    morning: "في الصباح",
    afternoon: "بعد الظـهر",
    evening: "في المساء",
    night: "في الليل"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "في الصباح",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل"
  },
  wide: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظـهر",
    evening: "في المساء",
    night: "في الليل"
  }
};
var ordinalNumber4 = (dirtyNumber) => {
  return String(dirtyNumber);
};
var localize4 = {
  ordinalNumber: ordinalNumber4,
  era: buildLocalizeFn({
    values: eraValues4,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues4,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues4,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues4,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues4,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues4,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ar-DZ/_lib/match.mjs
var matchOrdinalNumberPattern4 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern4 = /\d+/i;
var matchEraPatterns4 = {
  narrow: /^(ق|ب)/i,
  abbreviated: /^(ق\.?\s?م\.?|ق\.?\s?م\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^(قبل الميلاد|قبل الميلاد|بعد الميلاد|بعد الميلاد)/i
};
var parseEraPatterns4 = {
  any: [/^قبل/i, /^بعد/i]
};
var matchQuarterPatterns4 = {
  narrow: /^[1234]/i,
  abbreviated: /^ر[1234]/i,
  wide: /^الربع [1234]/i
};
var parseQuarterPatterns4 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns4 = {
  narrow: /^[جفمأسند]/i,
  abbreviated: /^(جان|فيف|مار|أفر|ماي|جوا|جوي|أوت|سبت|أكت|نوف|ديس)/i,
  wide: /^(جانفي|فيفري|مارس|أفريل|ماي|جوان|جويلية|أوت|سبتمبر|أكتوبر|نوفمبر|ديسمبر)/i
};
var parseMonthPatterns4 = {
  narrow: [
    /^ج/i,
    /^ف/i,
    /^م/i,
    /^أ/i,
    /^م/i,
    /^ج/i,
    /^ج/i,
    /^أ/i,
    /^س/i,
    /^أ/i,
    /^ن/i,
    /^د/i
  ],
  any: [
    /^جان/i,
    /^فيف/i,
    /^مار/i,
    /^أفر/i,
    /^ماي/i,
    /^جوا/i,
    /^جوي/i,
    /^أوت/i,
    /^سبت/i,
    /^أكت/i,
    /^نوف/i,
    /^ديس/i
  ]
};
var matchDayPatterns4 = {
  narrow: /^[حنثرخجس]/i,
  short: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,
  abbreviated: /^(أحد|اثن|ثلا|أرب|خمي|جمعة|سبت)/i,
  wide: /^(الأحد|الاثنين|الثلاثاء|الأربعاء|الخميس|الجمعة|السبت)/i
};
var parseDayPatterns4 = {
  narrow: [/^ح/i, /^ن/i, /^ث/i, /^ر/i, /^خ/i, /^ج/i, /^س/i],
  wide: [
    /^الأحد/i,
    /^الاثنين/i,
    /^الثلاثاء/i,
    /^الأربعاء/i,
    /^الخميس/i,
    /^الجمعة/i,
    /^السبت/i
  ],
  any: [/^أح/i, /^اث/i, /^ث/i, /^أر/i, /^خ/i, /^ج/i, /^س/i]
};
var matchDayPeriodPatterns4 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns4 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match4 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern4,
    parsePattern: parseOrdinalNumberPattern4,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns4,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns4,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns4,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns4,
    defaultParseWidth: "any",
    valueCallback: (index2) => Number(index2) + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns4,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns4,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns4,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns4,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns4,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns4,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ar-DZ.mjs
var arDZ = {
  code: "ar-DZ",
  formatDistance: formatDistance5,
  formatLong: formatLong4,
  formatRelative: formatRelative4,
  localize: localize4,
  match: match4,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ar-EG/_lib/formatDistance.mjs
var formatDistanceLocale5 = {
  lessThanXSeconds: {
    one: "أقل من ثانية",
    two: "أقل من ثانيتين",
    threeToTen: "أقل من {{count}} ثواني",
    other: "أقل من {{count}} ثانية"
  },
  xSeconds: {
    one: "ثانية",
    two: "ثانيتين",
    threeToTen: "{{count}} ثواني",
    other: "{{count}} ثانية"
  },
  halfAMinute: "نص دقيقة",
  lessThanXMinutes: {
    one: "أقل من دقيقة",
    two: "أقل من دقيقتين",
    threeToTen: "أقل من {{count}} دقايق",
    other: "أقل من {{count}} دقيقة"
  },
  xMinutes: {
    one: "دقيقة",
    two: "دقيقتين",
    threeToTen: "{{count}} دقايق",
    other: "{{count}} دقيقة"
  },
  aboutXHours: {
    one: "حوالي ساعة",
    two: "حوالي ساعتين",
    threeToTen: "حوالي {{count}} ساعات",
    other: "حوالي {{count}} ساعة"
  },
  xHours: {
    one: "ساعة",
    two: "ساعتين",
    threeToTen: "{{count}} ساعات",
    other: "{{count}} ساعة"
  },
  xDays: {
    one: "يوم",
    two: "يومين",
    threeToTen: "{{count}} أيام",
    other: "{{count}} يوم"
  },
  aboutXWeeks: {
    one: "حوالي أسبوع",
    two: "حوالي أسبوعين",
    threeToTen: "حوالي {{count}} أسابيع",
    other: "حوالي {{count}} أسبوع"
  },
  xWeeks: {
    one: "أسبوع",
    two: "أسبوعين",
    threeToTen: "{{count}} أسابيع",
    other: "{{count}} أسبوع"
  },
  aboutXMonths: {
    one: "حوالي شهر",
    two: "حوالي شهرين",
    threeToTen: "حوالي {{count}} أشهر",
    other: "حوالي {{count}} شهر"
  },
  xMonths: {
    one: "شهر",
    two: "شهرين",
    threeToTen: "{{count}} أشهر",
    other: "{{count}} شهر"
  },
  aboutXYears: {
    one: "حوالي سنة",
    two: "حوالي سنتين",
    threeToTen: "حوالي {{count}} سنين",
    other: "حوالي {{count}} سنة"
  },
  xYears: {
    one: "عام",
    two: "عامين",
    threeToTen: "{{count}} أعوام",
    other: "{{count}} عام"
  },
  overXYears: {
    one: "أكثر من سنة",
    two: "أكثر من سنتين",
    threeToTen: "أكثر من {{count}} سنين",
    other: "أكثر من {{count}} سنة"
  },
  almostXYears: {
    one: "عام تقريبًا",
    two: "عامين تقريبًا",
    threeToTen: "{{count}} أعوام تقريبًا",
    other: "{{count}} عام تقريبًا"
  }
};
var formatDistance6 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale5[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else if (count <= 10) {
    result = tokenValue.threeToTen.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return `في خلال ${result}`;
    } else {
      return `منذ ${result}`;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ar-EG/_lib/formatLong.mjs
var dateFormats5 = {
  full: "EEEE، do MMMM y",
  long: "do MMMM y",
  medium: "dd/MMM/y",
  short: "d/MM/y"
};
var timeFormats5 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats5 = {
  full: "{{date}} 'الساعة' {{time}}",
  long: "{{date}} 'الساعة' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong5 = {
  date: buildFormatLongFn({
    formats: dateFormats5,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats5,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats5,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ar-EG/_lib/formatRelative.mjs
var formatRelativeLocale5 = {
  lastWeek: "eeee 'اللي جاي الساعة' p",
  yesterday: "'إمبارح الساعة' p",
  today: "'النهاردة الساعة' p",
  tomorrow: "'بكرة الساعة' p",
  nextWeek: "eeee 'الساعة' p",
  other: "P"
};
var formatRelative5 = (token, _date, _baseDate, _options) => formatRelativeLocale5[token];

// ../../../node_modules/date-fns/locale/ar-EG/_lib/localize.mjs
var eraValues5 = {
  narrow: ["ق", "ب"],
  abbreviated: ["ق.م", "ب.م"],
  wide: ["قبل الميلاد", "بعد الميلاد"]
};
var quarterValues5 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ر1", "ر2", "ر3", "ر4"],
  wide: ["الربع الأول", "الربع الثاني", "الربع الثالث", "الربع الرابع"]
};
var monthValues5 = {
  narrow: ["ي", "ف", "م", "أ", "م", "ي", "ي", "أ", "س", "أ", "ن", "د"],
  abbreviated: [
    "ينا",
    "فبر",
    "مارس",
    "أبريل",
    "مايو",
    "يونـ",
    "يولـ",
    "أغسـ",
    "سبتـ",
    "أكتـ",
    "نوفـ",
    "ديسـ"
  ],
  wide: [
    "يناير",
    "فبراير",
    "مارس",
    "أبريل",
    "مايو",
    "يونيو",
    "يوليو",
    "أغسطس",
    "سبتمبر",
    "أكتوبر",
    "نوفمبر",
    "ديسمبر"
  ]
};
var dayValues5 = {
  narrow: ["ح", "ن", "ث", "ر", "خ", "ج", "س"],
  short: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  abbreviated: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  wide: [
    "الأحد",
    "الاثنين",
    "الثلاثاء",
    "الأربعاء",
    "الخميس",
    "الجمعة",
    "السبت"
  ]
};
var dayPeriodValues5 = {
  narrow: {
    am: "ص",
    pm: "م",
    midnight: "ن",
    noon: "ظ",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءً",
    night: "ليلاً"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهراً",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءً",
    night: "ليلاً"
  },
  wide: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهراً",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءً",
    night: "ليلاً"
  }
};
var formattingDayPeriodValues5 = {
  narrow: {
    am: "ص",
    pm: "م",
    midnight: "ن",
    noon: "ظ",
    morning: "في الصباح",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهراً",
    morning: "في الصباح",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل"
  },
  wide: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    morning: "في الصباح",
    noon: "ظهراً",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل"
  }
};
var ordinalNumber5 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize5 = {
  ordinalNumber: ordinalNumber5,
  era: buildLocalizeFn({
    values: eraValues5,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues5,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues5,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues5,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues5,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues5,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ar-EG/_lib/match.mjs
var matchOrdinalNumberPattern5 = /^(\d+)/;
var parseOrdinalNumberPattern5 = /\d+/i;
var matchEraPatterns5 = {
  narrow: /^(ق|ب)/g,
  abbreviated: /^(ق.م|ب.م)/g,
  wide: /^(قبل الميلاد|بعد الميلاد)/g
};
var parseEraPatterns5 = {
  any: [/^ق/g, /^ب/g]
};
var matchQuarterPatterns5 = {
  narrow: /^[1234]/,
  abbreviated: /^ر[1234]/,
  wide: /^الربع (الأول|الثاني|الثالث|الرابع)/
};
var parseQuarterPatterns5 = {
  wide: [/الربع الأول/, /الربع الثاني/, /الربع الثالث/, /الربع الرابع/],
  any: [/1/, /2/, /3/, /4/]
};
var matchMonthPatterns5 = {
  narrow: /^(ي|ف|م|أ|س|ن|د)/,
  abbreviated: /^(ينا|فبر|مارس|أبريل|مايو|يونـ|يولـ|أغسـ|سبتـ|أكتـ|نوفـ|ديسـ)/,
  wide: /^(يناير|فبراير|مارس|أبريل|مايو|يونيو|يوليو|أغسطس|سبتمبر|أكتوبر|نوفمبر|ديسمبر)/
};
var parseMonthPatterns5 = {
  narrow: [
    /^ي/,
    /^ف/,
    /^م/,
    /^أ/,
    /^م/,
    /^ي/,
    /^ي/,
    /^أ/,
    /^س/,
    /^أ/,
    /^ن/,
    /^د/
  ],
  any: [
    /^ينا/,
    /^فبر/,
    /^مارس/,
    /^أبريل/,
    /^مايو/,
    /^يون/,
    /^يول/,
    /^أغس/,
    /^سبت/,
    /^أكت/,
    /^نوف/,
    /^ديس/
  ]
};
var matchDayPatterns5 = {
  narrow: /^(ح|ن|ث|ر|خ|ج|س)/,
  short: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/,
  abbreviated: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/,
  wide: /^(الأحد|الاثنين|الثلاثاء|الأربعاء|الخميس|الجمعة|السبت)/
};
var parseDayPatterns5 = {
  narrow: [/^ح/, /^ن/, /^ث/, /^ر/, /^خ/, /^ج/, /^س/],
  any: [/أحد/, /اثنين/, /ثلاثاء/, /أربعاء/, /خميس/, /جمعة/, /سبت/]
};
var matchDayPeriodPatterns5 = {
  narrow: /^(ص|م|ن|ظ|في الصباح|بعد الظهر|في المساء|في الليل)/,
  abbreviated: /^(ص|م|نصف الليل|ظهراً|في الصباح|بعد الظهر|في المساء|في الليل)/,
  wide: /^(ص|م|نصف الليل|في الصباح|ظهراً|بعد الظهر|في المساء|في الليل)/,
  any: /^(ص|م|صباح|ظهر|مساء|ليل)/
};
var parseDayPeriodPatterns5 = {
  any: {
    am: /^ص/,
    pm: /^م/,
    midnight: /^ن/,
    noon: /^ظ/,
    morning: /^ص/,
    afternoon: /^بعد/,
    evening: /^م/,
    night: /^ل/
  }
};
var match5 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern5,
    parsePattern: parseOrdinalNumberPattern5,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns5,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns5,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns5,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns5,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns5,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns5,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns5,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns5,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns5,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns5,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ar-EG.mjs
var arEG = {
  code: "ar-EG",
  formatDistance: formatDistance6,
  formatLong: formatLong5,
  formatRelative: formatRelative5,
  localize: localize5,
  match: match5,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ar-MA/_lib/formatDistance.mjs
var formatDistanceLocale6 = {
  lessThanXSeconds: {
    one: "أقل من ثانية واحدة",
    two: "أقل من ثانتين",
    threeToTen: "أقل من {{count}} ثواني",
    other: "أقل من {{count}} ثانية"
  },
  xSeconds: {
    one: "ثانية واحدة",
    two: "ثانتين",
    threeToTen: "{{count}} ثواني",
    other: "{{count}} ثانية"
  },
  halfAMinute: "نصف دقيقة",
  lessThanXMinutes: {
    one: "أقل من دقيقة",
    two: "أقل من دقيقتين",
    threeToTen: "أقل من {{count}} دقائق",
    other: "أقل من {{count}} دقيقة"
  },
  xMinutes: {
    one: "دقيقة واحدة",
    two: "دقيقتين",
    threeToTen: "{{count}} دقائق",
    other: "{{count}} دقيقة"
  },
  aboutXHours: {
    one: "ساعة واحدة تقريباً",
    two: "ساعتين تقريباً",
    threeToTen: "{{count}} ساعات تقريباً",
    other: "{{count}} ساعة تقريباً"
  },
  xHours: {
    one: "ساعة واحدة",
    two: "ساعتين",
    threeToTen: "{{count}} ساعات",
    other: "{{count}} ساعة"
  },
  xDays: {
    one: "يوم واحد",
    two: "يومين",
    threeToTen: "{{count}} أيام",
    other: "{{count}} يوم"
  },
  aboutXWeeks: {
    one: "أسبوع واحد تقريباً",
    two: "أسبوعين تقريباً",
    threeToTen: "{{count}} أسابيع تقريباً",
    other: "{{count}} أسبوع تقريباً"
  },
  xWeeks: {
    one: "أسبوع واحد",
    two: "أسبوعين",
    threeToTen: "{{count}} أسابيع",
    other: "{{count}} أسبوع"
  },
  aboutXMonths: {
    one: "شهر واحد تقريباً",
    two: "شهرين تقريباً",
    threeToTen: "{{count}} أشهر تقريباً",
    other: "{{count}} شهر تقريباً"
  },
  xMonths: {
    one: "شهر واحد",
    two: "شهرين",
    threeToTen: "{{count}} أشهر",
    other: "{{count}} شهر"
  },
  aboutXYears: {
    one: "عام واحد تقريباً",
    two: "عامين تقريباً",
    threeToTen: "{{count}} أعوام تقريباً",
    other: "{{count}} عام تقريباً"
  },
  xYears: {
    one: "عام واحد",
    two: "عامين",
    threeToTen: "{{count}} أعوام",
    other: "{{count}} عام"
  },
  overXYears: {
    one: "أكثر من عام",
    two: "أكثر من عامين",
    threeToTen: "أكثر من {{count}} أعوام",
    other: "أكثر من {{count}} عام"
  },
  almostXYears: {
    one: "عام واحد تقريباً",
    two: "عامين تقريباً",
    threeToTen: "{{count}} أعوام تقريباً",
    other: "{{count}} عام تقريباً"
  }
};
var formatDistance7 = (token, count, options2) => {
  options2 = options2 || {};
  const usageGroup = formatDistanceLocale6[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "في خلال " + result;
    } else {
      return "منذ " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ar-MA/_lib/formatLong.mjs
var dateFormats6 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats6 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats6 = {
  full: "{{date}} 'عند' {{time}}",
  long: "{{date}} 'عند' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong6 = {
  date: buildFormatLongFn({
    formats: dateFormats6,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats6,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats6,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ar-MA/_lib/formatRelative.mjs
var formatRelativeLocale6 = {
  lastWeek: "'أخر' eeee 'عند' p",
  yesterday: "'أمس عند' p",
  today: "'اليوم عند' p",
  tomorrow: "'غداً عند' p",
  nextWeek: "eeee 'عند' p",
  other: "P"
};
var formatRelative6 = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale6[token];
};

// ../../../node_modules/date-fns/locale/ar-MA/_lib/localize.mjs
var eraValues6 = {
  narrow: ["ق", "ب"],
  abbreviated: ["ق.م.", "ب.م."],
  wide: ["قبل الميلاد", "بعد الميلاد"]
};
var quarterValues6 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ر1", "ر2", "ر3", "ر4"],
  wide: ["الربع الأول", "الربع الثاني", "الربع الثالث", "الربع الرابع"]
};
var monthValues6 = {
  narrow: ["ي", "ف", "م", "أ", "م", "ي", "ي", "غ", "ش", "أ", "ن", "د"],
  abbreviated: [
    "ينا",
    "فبر",
    "مارس",
    "أبريل",
    "ماي",
    "يونـ",
    "يولـ",
    "غشت",
    "شتنـ",
    "أكتـ",
    "نونـ",
    "دجنـ"
  ],
  wide: [
    "يناير",
    "فبراير",
    "مارس",
    "أبريل",
    "ماي",
    "يونيو",
    "يوليوز",
    "غشت",
    "شتنبر",
    "أكتوبر",
    "نونبر",
    "دجنبر"
  ]
};
var dayValues6 = {
  narrow: ["ح", "ن", "ث", "ر", "خ", "ج", "س"],
  short: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  abbreviated: ["أحد", "اثنـ", "ثلا", "أربـ", "خميـ", "جمعة", "سبت"],
  wide: [
    "الأحد",
    "الإثنين",
    "الثلاثاء",
    "الأربعاء",
    "الخميس",
    "الجمعة",
    "السبت"
  ]
};
var dayPeriodValues6 = {
  narrow: {
    am: "ص",
    pm: "م",
    midnight: "ن",
    noon: "ظ",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  },
  wide: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  }
};
var formattingDayPeriodValues6 = {
  narrow: {
    am: "ص",
    pm: "م",
    midnight: "ن",
    noon: "ظ",
    morning: "في الصباح",
    afternoon: "بعد الظـهر",
    evening: "في المساء",
    night: "في الليل"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "في الصباح",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل"
  },
  wide: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظـهر",
    evening: "في المساء",
    night: "في الليل"
  }
};
var ordinalNumber6 = (dirtyNumber) => {
  return String(dirtyNumber);
};
var localize6 = {
  ordinalNumber: ordinalNumber6,
  era: buildLocalizeFn({
    values: eraValues6,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues6,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues6,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues6,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues6,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues6,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ar-MA/_lib/match.mjs
var matchOrdinalNumberPattern6 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern6 = /\d+/i;
var matchEraPatterns6 = {
  narrow: /^(ق|ب)/i,
  abbreviated: /^(ق\.?\s?م\.?|ق\.?\s?م\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^(قبل الميلاد|قبل الميلاد|بعد الميلاد|بعد الميلاد)/i
};
var parseEraPatterns6 = {
  any: [/^قبل/i, /^بعد/i]
};
var matchQuarterPatterns6 = {
  narrow: /^[1234]/i,
  abbreviated: /^ر[1234]/i,
  wide: /^الربع [1234]/i
};
var parseQuarterPatterns6 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns6 = {
  narrow: /^[يفمأمسند]/i,
  abbreviated: /^(ين|ف|مار|أب|ماي|يون|يول|غش|شت|أك|ن|د)/i,
  wide: /^(ين|ف|مار|أب|ماي|يون|يول|غش|شت|أك|ن|د)/i
};
var parseMonthPatterns6 = {
  narrow: [
    /^ي/i,
    /^ف/i,
    /^م/i,
    /^أ/i,
    /^م/i,
    /^ي/i,
    /^ي/i,
    /^غ/i,
    /^ش/i,
    /^أ/i,
    /^ن/i,
    /^د/i
  ],
  any: [
    /^ين/i,
    /^فب/i,
    /^مار/i,
    /^أب/i,
    /^ماي/i,
    /^يون/i,
    /^يول/i,
    /^غشت/i,
    /^ش/i,
    /^أك/i,
    /^ن/i,
    /^د/i
  ]
};
var matchDayPatterns6 = {
  narrow: /^[حنثرخجس]/i,
  short: /^(أحد|إثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,
  abbreviated: /^(أحد|إثن|ثلا|أرب|خمي|جمعة|سبت)/i,
  wide: /^(الأحد|الإثنين|الثلاثاء|الأربعاء|الخميس|الجمعة|السبت)/i
};
var parseDayPatterns6 = {
  narrow: [/^ح/i, /^ن/i, /^ث/i, /^ر/i, /^خ/i, /^ج/i, /^س/i],
  wide: [
    /^الأحد/i,
    /^الإثنين/i,
    /^الثلاثاء/i,
    /^الأربعاء/i,
    /^الخميس/i,
    /^الجمعة/i,
    /^السبت/i
  ],
  any: [/^أح/i, /^إث/i, /^ث/i, /^أر/i, /^خ/i, /^ج/i, /^س/i]
};
var matchDayPeriodPatterns6 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns6 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match6 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern6,
    parsePattern: parseOrdinalNumberPattern6,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns6,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns6,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns6,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns6,
    defaultParseWidth: "any",
    valueCallback: (index2) => Number(index2) + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns6,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns6,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns6,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns6,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns6,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns6,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ar-MA.mjs
var arMA = {
  code: "ar-MA",
  formatDistance: formatDistance7,
  formatLong: formatLong6,
  formatRelative: formatRelative6,
  localize: localize6,
  match: match6,
  options: {
    // Monday is 1
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ar-SA/_lib/formatDistance.mjs
var formatDistanceLocale7 = {
  lessThanXSeconds: {
    one: "أقل من ثانية واحدة",
    two: "أقل من ثانتين",
    threeToTen: "أقل من {{count}} ثواني",
    other: "أقل من {{count}} ثانية"
  },
  xSeconds: {
    one: "ثانية واحدة",
    two: "ثانتين",
    threeToTen: "{{count}} ثواني",
    other: "{{count}} ثانية"
  },
  halfAMinute: "نصف دقيقة",
  lessThanXMinutes: {
    one: "أقل من دقيقة",
    two: "أقل من دقيقتين",
    threeToTen: "أقل من {{count}} دقائق",
    other: "أقل من {{count}} دقيقة"
  },
  xMinutes: {
    one: "دقيقة واحدة",
    two: "دقيقتين",
    threeToTen: "{{count}} دقائق",
    other: "{{count}} دقيقة"
  },
  aboutXHours: {
    one: "ساعة واحدة تقريباً",
    two: "ساعتين تقريباً",
    threeToTen: "{{count}} ساعات تقريباً",
    other: "{{count}} ساعة تقريباً"
  },
  xHours: {
    one: "ساعة واحدة",
    two: "ساعتين",
    threeToTen: "{{count}} ساعات",
    other: "{{count}} ساعة"
  },
  xDays: {
    one: "يوم واحد",
    two: "يومين",
    threeToTen: "{{count}} أيام",
    other: "{{count}} يوم"
  },
  aboutXWeeks: {
    one: "أسبوع واحد تقريباً",
    two: "أسبوعين تقريباً",
    threeToTen: "{{count}} أسابيع تقريباً",
    other: "{{count}} أسبوع تقريباً"
  },
  xWeeks: {
    one: "أسبوع واحد",
    two: "أسبوعين",
    threeToTen: "{{count}} أسابيع",
    other: "{{count}} أسبوع"
  },
  aboutXMonths: {
    one: "شهر واحد تقريباً",
    two: "شهرين تقريباً",
    threeToTen: "{{count}} أشهر تقريباً",
    other: "{{count}} شهر تقريباً"
  },
  xMonths: {
    one: "شهر واحد",
    two: "شهرين",
    threeToTen: "{{count}} أشهر",
    other: "{{count}} شهر"
  },
  aboutXYears: {
    one: "عام واحد تقريباً",
    two: "عامين تقريباً",
    threeToTen: "{{count}} أعوام تقريباً",
    other: "{{count}} عام تقريباً"
  },
  xYears: {
    one: "عام واحد",
    two: "عامين",
    threeToTen: "{{count}} أعوام",
    other: "{{count}} عام"
  },
  overXYears: {
    one: "أكثر من عام",
    two: "أكثر من عامين",
    threeToTen: "أكثر من {{count}} أعوام",
    other: "أكثر من {{count}} عام"
  },
  almostXYears: {
    one: "عام واحد تقريباً",
    two: "عامين تقريباً",
    threeToTen: "{{count}} أعوام تقريباً",
    other: "{{count}} عام تقريباً"
  }
};
var formatDistance8 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale7[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else if (count <= 10) {
    result = tokenValue.threeToTen.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "في خلال " + result;
    } else {
      return "منذ " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ar-SA/_lib/formatLong.mjs
var dateFormats7 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats7 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats7 = {
  full: "{{date}} 'عند' {{time}}",
  long: "{{date}} 'عند' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong7 = {
  date: buildFormatLongFn({
    formats: dateFormats7,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats7,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats7,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ar-SA/_lib/formatRelative.mjs
var formatRelativeLocale7 = {
  lastWeek: "'أخر' eeee 'عند' p",
  yesterday: "'أمس عند' p",
  today: "'اليوم عند' p",
  tomorrow: "'غداً عند' p",
  nextWeek: "eeee 'عند' p",
  other: "P"
};
var formatRelative7 = (token, _date, _baseDate, _options) => formatRelativeLocale7[token];

// ../../../node_modules/date-fns/locale/ar-SA/_lib/localize.mjs
var eraValues7 = {
  narrow: ["ق", "ب"],
  abbreviated: ["ق.م.", "ب.م."],
  wide: ["قبل الميلاد", "بعد الميلاد"]
};
var quarterValues7 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ر1", "ر2", "ر3", "ر4"],
  wide: ["الربع الأول", "الربع الثاني", "الربع الثالث", "الربع الرابع"]
};
var monthValues7 = {
  narrow: ["ي", "ف", "م", "أ", "م", "ي", "ي", "أ", "س", "أ", "ن", "د"],
  abbreviated: [
    "ينا",
    "فبر",
    "مارس",
    "أبريل",
    "مايو",
    "يونـ",
    "يولـ",
    "أغسـ",
    "سبتـ",
    "أكتـ",
    "نوفـ",
    "ديسـ"
  ],
  wide: [
    "يناير",
    "فبراير",
    "مارس",
    "أبريل",
    "مايو",
    "يونيو",
    "يوليو",
    "أغسطس",
    "سبتمبر",
    "أكتوبر",
    "نوفمبر",
    "ديسمبر"
  ]
};
var dayValues7 = {
  narrow: ["ح", "ن", "ث", "ر", "خ", "ج", "س"],
  short: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  abbreviated: ["أحد", "اثنـ", "ثلا", "أربـ", "خميـ", "جمعة", "سبت"],
  wide: [
    "الأحد",
    "الاثنين",
    "الثلاثاء",
    "الأربعاء",
    "الخميس",
    "الجمعة",
    "السبت"
  ]
};
var dayPeriodValues7 = {
  narrow: {
    am: "ص",
    pm: "م",
    midnight: "ن",
    noon: "ظ",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  },
  wide: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظهر",
    evening: "مساءاً",
    night: "ليلاً"
  }
};
var formattingDayPeriodValues7 = {
  narrow: {
    am: "ص",
    pm: "م",
    midnight: "ن",
    noon: "ظ",
    morning: "في الصباح",
    afternoon: "بعد الظـهر",
    evening: "في المساء",
    night: "في الليل"
  },
  abbreviated: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "في الصباح",
    afternoon: "بعد الظهر",
    evening: "في المساء",
    night: "في الليل"
  },
  wide: {
    am: "ص",
    pm: "م",
    midnight: "نصف الليل",
    noon: "ظهر",
    morning: "صباحاً",
    afternoon: "بعد الظـهر",
    evening: "في المساء",
    night: "في الليل"
  }
};
var ordinalNumber7 = (dirtyNumber) => {
  return String(dirtyNumber);
};
var localize7 = {
  ordinalNumber: ordinalNumber7,
  era: buildLocalizeFn({
    values: eraValues7,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues7,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues7,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues7,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues7,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues7,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ar-SA/_lib/match.mjs
var matchOrdinalNumberPattern7 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern7 = /\d+/i;
var matchEraPatterns7 = {
  narrow: /^(ق|ب)/i,
  abbreviated: /^(ق\.?\s?م\.?|ق\.?\s?م\.?\s?|a\.?\s?d\.?|c\.?\s?)/i,
  wide: /^(قبل الميلاد|قبل الميلاد|بعد الميلاد|بعد الميلاد)/i
};
var parseEraPatterns7 = {
  any: [/^قبل/i, /^بعد/i]
};
var matchQuarterPatterns7 = {
  narrow: /^[1234]/i,
  abbreviated: /^ر[1234]/i,
  wide: /^الربع [1234]/i
};
var parseQuarterPatterns7 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns7 = {
  narrow: /^[يفمأمسند]/i,
  abbreviated: /^(ين|ف|مار|أب|ماي|يون|يول|أغ|س|أك|ن|د)/i,
  wide: /^(ين|ف|مار|أب|ماي|يون|يول|أغ|س|أك|ن|د)/i
};
var parseMonthPatterns7 = {
  narrow: [
    /^ي/i,
    /^ف/i,
    /^م/i,
    /^أ/i,
    /^م/i,
    /^ي/i,
    /^ي/i,
    /^أ/i,
    /^س/i,
    /^أ/i,
    /^ن/i,
    /^د/i
  ],
  any: [
    /^ين/i,
    /^ف/i,
    /^مار/i,
    /^أب/i,
    /^ماي/i,
    /^يون/i,
    /^يول/i,
    /^أغ/i,
    /^س/i,
    /^أك/i,
    /^ن/i,
    /^د/i
  ]
};
var matchDayPatterns7 = {
  narrow: /^[حنثرخجس]/i,
  short: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,
  abbreviated: /^(أحد|اثن|ثلا|أرب|خمي|جمعة|سبت)/i,
  wide: /^(الأحد|الاثنين|الثلاثاء|الأربعاء|الخميس|الجمعة|السبت)/i
};
var parseDayPatterns7 = {
  narrow: [/^ح/i, /^ن/i, /^ث/i, /^ر/i, /^خ/i, /^ج/i, /^س/i],
  wide: [
    /^الأحد/i,
    /^الاثنين/i,
    /^الثلاثاء/i,
    /^الأربعاء/i,
    /^الخميس/i,
    /^الجمعة/i,
    /^السبت/i
  ],
  any: [/^أح/i, /^اث/i, /^ث/i, /^أر/i, /^خ/i, /^ج/i, /^س/i]
};
var matchDayPeriodPatterns7 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns7 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match7 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern7,
    parsePattern: parseOrdinalNumberPattern7,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns7,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns7,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns7,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns7,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns7,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns7,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns7,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns7,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns7,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns7,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ar-SA.mjs
var arSA = {
  code: "ar-SA",
  formatDistance: formatDistance8,
  formatLong: formatLong7,
  formatRelative: formatRelative7,
  localize: localize7,
  match: match7,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ar-TN/_lib/formatDistance.mjs
var formatDistanceLocale8 = {
  lessThanXSeconds: {
    one: "أقل من ثانية",
    two: "أقل من زوز ثواني",
    threeToTen: "أقل من {{count}} ثواني",
    other: "أقل من {{count}} ثانية"
  },
  xSeconds: {
    one: "ثانية",
    two: "زوز ثواني",
    threeToTen: "{{count}} ثواني",
    other: "{{count}} ثانية"
  },
  halfAMinute: "نص دقيقة",
  lessThanXMinutes: {
    one: "أقل من دقيقة",
    two: "أقل من دقيقتين",
    threeToTen: "أقل من {{count}} دقايق",
    other: "أقل من {{count}} دقيقة"
  },
  xMinutes: {
    one: "دقيقة",
    two: "دقيقتين",
    threeToTen: "{{count}} دقايق",
    other: "{{count}} دقيقة"
  },
  aboutXHours: {
    one: "ساعة تقريب",
    two: "ساعتين تقريب",
    threeToTen: "{{count}} سوايع تقريب",
    other: "{{count}} ساعة تقريب"
  },
  xHours: {
    one: "ساعة",
    two: "ساعتين",
    threeToTen: "{{count}} سوايع",
    other: "{{count}} ساعة"
  },
  xDays: {
    one: "نهار",
    two: "نهارين",
    threeToTen: "{{count}} أيام",
    other: "{{count}} يوم"
  },
  aboutXWeeks: {
    one: "جمعة تقريب",
    two: "جمعتين تقريب",
    threeToTen: "{{count}} جماع تقريب",
    other: "{{count}} جمعة تقريب"
  },
  xWeeks: {
    one: "جمعة",
    two: "جمعتين",
    threeToTen: "{{count}} جماع",
    other: "{{count}} جمعة"
  },
  aboutXMonths: {
    one: "شهر تقريب",
    two: "شهرين تقريب",
    threeToTen: "{{count}} أشهرة تقريب",
    other: "{{count}} شهر تقريب"
  },
  xMonths: {
    one: "شهر",
    two: "شهرين",
    threeToTen: "{{count}} أشهرة",
    other: "{{count}} شهر"
  },
  aboutXYears: {
    one: "عام تقريب",
    two: "عامين تقريب",
    threeToTen: "{{count}} أعوام تقريب",
    other: "{{count}} عام تقريب"
  },
  xYears: {
    one: "عام",
    two: "عامين",
    threeToTen: "{{count}} أعوام",
    other: "{{count}} عام"
  },
  overXYears: {
    one: "أكثر من عام",
    two: "أكثر من عامين",
    threeToTen: "أكثر من {{count}} أعوام",
    other: "أكثر من {{count}} عام"
  },
  almostXYears: {
    one: "عام تقريب",
    two: "عامين تقريب",
    threeToTen: "{{count}} أعوام تقريب",
    other: "{{count}} عام تقريب"
  }
};
var formatDistance9 = (token, count, options2) => {
  const usageGroup = formatDistanceLocale8[token];
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else if (count === 2) {
    result = usageGroup.two;
  } else if (count <= 10) {
    result = usageGroup.threeToTen.replace("{{count}}", String(count));
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "في " + result;
    } else {
      return "عندو " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ar-TN/_lib/formatLong.mjs
var dateFormats8 = {
  full: "EEEE، do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
var timeFormats8 = {
  full: "HH:mm:ss",
  long: "HH:mm:ss",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats8 = {
  full: "{{date}} 'مع' {{time}}",
  long: "{{date}} 'مع' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong8 = {
  date: buildFormatLongFn({
    formats: dateFormats8,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats8,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats8,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ar-TN/_lib/formatRelative.mjs
var formatRelativeLocale8 = {
  lastWeek: "eeee 'إلي فات مع' p",
  yesterday: "'البارح مع' p",
  today: "'اليوم مع' p",
  tomorrow: "'غدوة مع' p",
  nextWeek: "eeee 'الجمعة الجاية مع' p 'نهار'",
  other: "P"
};
var formatRelative8 = (token) => formatRelativeLocale8[token];

// ../../../node_modules/date-fns/locale/ar-TN/_lib/localize.mjs
var eraValues8 = {
  narrow: ["ق", "ب"],
  abbreviated: ["ق.م.", "ب.م."],
  wide: ["قبل الميلاد", "بعد الميلاد"]
};
var quarterValues8 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ر1", "ر2", "ر3", "ر4"],
  wide: ["الربع الأول", "الربع الثاني", "الربع الثالث", "الربع الرابع"]
};
var monthValues8 = {
  narrow: ["د", "ن", "أ", "س", "أ", "ج", "ج", "م", "أ", "م", "ف", "ج"],
  abbreviated: [
    "جانفي",
    "فيفري",
    "مارس",
    "أفريل",
    "ماي",
    "جوان",
    "جويلية",
    "أوت",
    "سبتمبر",
    "أكتوبر",
    "نوفمبر",
    "ديسمبر"
  ],
  wide: [
    "جانفي",
    "فيفري",
    "مارس",
    "أفريل",
    "ماي",
    "جوان",
    "جويلية",
    "أوت",
    "سبتمبر",
    "أكتوبر",
    "نوفمبر",
    "ديسمبر"
  ]
};
var dayValues8 = {
  narrow: ["ح", "ن", "ث", "ر", "خ", "ج", "س"],
  short: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  abbreviated: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  wide: [
    "الأحد",
    "الاثنين",
    "الثلاثاء",
    "الأربعاء",
    "الخميس",
    "الجمعة",
    "السبت"
  ]
};
var dayPeriodValues8 = {
  narrow: {
    am: "ص",
    pm: "ع",
    morning: "الصباح",
    noon: "القايلة",
    afternoon: "بعد القايلة",
    evening: "العشية",
    night: "الليل",
    midnight: "نص الليل"
  },
  abbreviated: {
    am: "ص",
    pm: "ع",
    morning: "الصباح",
    noon: "القايلة",
    afternoon: "بعد القايلة",
    evening: "العشية",
    night: "الليل",
    midnight: "نص الليل"
  },
  wide: {
    am: "ص",
    pm: "ع",
    morning: "الصباح",
    noon: "القايلة",
    afternoon: "بعد القايلة",
    evening: "العشية",
    night: "الليل",
    midnight: "نص الليل"
  }
};
var formattingDayPeriodValues8 = {
  narrow: {
    am: "ص",
    pm: "ع",
    morning: "في الصباح",
    noon: "في القايلة",
    afternoon: "بعد القايلة",
    evening: "في العشية",
    night: "في الليل",
    midnight: "نص الليل"
  },
  abbreviated: {
    am: "ص",
    pm: "ع",
    morning: "في الصباح",
    noon: "في القايلة",
    afternoon: "بعد القايلة",
    evening: "في العشية",
    night: "في الليل",
    midnight: "نص الليل"
  },
  wide: {
    am: "ص",
    pm: "ع",
    morning: "في الصباح",
    noon: "في القايلة",
    afternoon: "بعد القايلة",
    evening: "في العشية",
    night: "في الليل",
    midnight: "نص الليل"
  }
};
var ordinalNumber8 = (num) => String(num);
var localize8 = {
  ordinalNumber: ordinalNumber8,
  era: buildLocalizeFn({
    values: eraValues8,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues8,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues8,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues8,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues8,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues8,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ar-TN/_lib/match.mjs
var matchOrdinalNumberPattern8 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern8 = /\d+/i;
var matchEraPatterns8 = {
  narrow: /[قب]/,
  abbreviated: /[قب]\.م\./,
  wide: /(قبل|بعد) الميلاد/
};
var parseEraPatterns8 = {
  any: [/قبل/, /بعد/]
};
var matchQuarterPatterns8 = {
  narrow: /^[1234]/i,
  abbreviated: /ر[1234]/,
  wide: /الربع (الأول|الثاني|الثالث|الرابع)/
};
var parseQuarterPatterns8 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns8 = {
  narrow: /^[جفمأسند]/,
  abbreviated: /^(جانفي|فيفري|مارس|أفريل|ماي|جوان|جويلية|أوت|سبتمبر|أكتوبر|نوفمبر|ديسمبر)/,
  wide: /^(جانفي|فيفري|مارس|أفريل|ماي|جوان|جويلية|أوت|سبتمبر|أكتوبر|نوفمبر|ديسمبر)/
};
var parseMonthPatterns8 = {
  narrow: [
    /^ج/i,
    /^ف/i,
    /^م/i,
    /^أ/i,
    /^م/i,
    /^ج/i,
    /^ج/i,
    /^أ/i,
    /^س/i,
    /^أ/i,
    /^ن/i,
    /^د/i
  ],
  any: [
    /^جانفي/i,
    /^فيفري/i,
    /^مارس/i,
    /^أفريل/i,
    /^ماي/i,
    /^جوان/i,
    /^جويلية/i,
    /^أوت/i,
    /^سبتمبر/i,
    /^أكتوبر/i,
    /^نوفمبر/i,
    /^ديسمبر/i
  ]
};
var matchDayPatterns8 = {
  narrow: /^[حنثرخجس]/i,
  short: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,
  abbreviated: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,
  wide: /^(الأحد|الاثنين|الثلاثاء|الأربعاء|الخميس|الجمعة|السبت)/i
};
var parseDayPatterns8 = {
  narrow: [/^ح/i, /^ن/i, /^ث/i, /^ر/i, /^خ/i, /^ج/i, /^س/i],
  wide: [
    /^الأحد/i,
    /^الاثنين/i,
    /^الثلاثاء/i,
    /^الأربعاء/i,
    /^الخميس/i,
    /^الجمعة/i,
    /^السبت/i
  ],
  any: [/^أح/i, /^اث/i, /^ث/i, /^أر/i, /^خ/i, /^ج/i, /^س/i]
};
var matchDayPeriodPatterns8 = {
  narrow: /^(ص|ع|ن ل|ل|(في|مع) (صباح|قايلة|عشية|ليل))/,
  any: /^([صع]|نص الليل|قايلة|(في|مع) (صباح|قايلة|عشية|ليل))/
};
var parseDayPeriodPatterns8 = {
  any: {
    am: /^ص/,
    pm: /^ع/,
    midnight: /نص الليل/,
    noon: /قايلة/,
    afternoon: /بعد القايلة/,
    morning: /صباح/,
    evening: /عشية/,
    night: /ليل/
  }
};
var match8 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern8,
    parsePattern: parseOrdinalNumberPattern8,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns8,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns8,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns8,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns8,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns8,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns8,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns8,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns8,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns8,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns8,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ar-TN.mjs
var arTN = {
  code: "ar-TN",
  formatDistance: formatDistance9,
  formatLong: formatLong8,
  formatRelative: formatRelative8,
  localize: localize8,
  match: match8,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/az/_lib/formatDistance.mjs
var formatDistanceLocale9 = {
  lessThanXSeconds: {
    one: "bir saniyədən az",
    other: "{{count}} bir saniyədən az"
  },
  xSeconds: {
    one: "1 saniyə",
    other: "{{count}} saniyə"
  },
  halfAMinute: "yarım dəqiqə",
  lessThanXMinutes: {
    one: "bir dəqiqədən az",
    other: "{{count}} bir dəqiqədən az"
  },
  xMinutes: {
    one: "bir dəqiqə",
    other: "{{count}} dəqiqə"
  },
  aboutXHours: {
    one: "təxminən 1 saat",
    other: "təxminən {{count}} saat"
  },
  xHours: {
    one: "1 saat",
    other: "{{count}} saat"
  },
  xDays: {
    one: "1 gün",
    other: "{{count}} gün"
  },
  aboutXWeeks: {
    one: "təxminən 1 həftə",
    other: "təxminən {{count}} həftə"
  },
  xWeeks: {
    one: "1 həftə",
    other: "{{count}} həftə"
  },
  aboutXMonths: {
    one: "təxminən 1 ay",
    other: "təxminən {{count}} ay"
  },
  xMonths: {
    one: "1 ay",
    other: "{{count}} ay"
  },
  aboutXYears: {
    one: "təxminən 1 il",
    other: "təxminən {{count}} il"
  },
  xYears: {
    one: "1 il",
    other: "{{count}} il"
  },
  overXYears: {
    one: "1 ildən çox",
    other: "{{count}} ildən çox"
  },
  almostXYears: {
    one: "demək olar ki 1 il",
    other: "demək olar ki {{count}} il"
  }
};
var formatDistance10 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale9[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + " sonra";
    } else {
      return result + " əvvəl";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/az/_lib/formatLong.mjs
var dateFormats9 = {
  full: "EEEE, do MMMM y 'il'",
  long: "do MMMM y 'il'",
  medium: "d MMM y 'il'",
  short: "dd.MM.yyyy"
};
var timeFormats9 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats9 = {
  full: "{{date}} {{time}} - 'də'",
  long: "{{date}} {{time}} - 'də'",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong9 = {
  date: buildFormatLongFn({
    formats: dateFormats9,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats9,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats9,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/az/_lib/formatRelative.mjs
var formatRelativeLocale9 = {
  lastWeek: "'sonuncu' eeee p -'də'",
  yesterday: "'dünən' p -'də'",
  today: "'bugün' p -'də'",
  tomorrow: "'sabah' p -'də'",
  nextWeek: "eeee p -'də'",
  other: "P"
};
var formatRelative9 = (token, _date, _baseDate, _options) => formatRelativeLocale9[token];

// ../../../node_modules/date-fns/locale/az/_lib/localize.mjs
var eraValues9 = {
  narrow: ["e.ə", "b.e"],
  abbreviated: ["e.ə", "b.e"],
  wide: ["eramızdan əvvəl", "bizim era"]
};
var quarterValues9 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1ci kvartal", "2ci kvartal", "3cü kvartal", "4cü kvartal"]
};
var monthValues9 = {
  narrow: ["Y", "F", "M", "A", "M", "İ", "İ", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Yan",
    "Fev",
    "Mar",
    "Apr",
    "May",
    "İyun",
    "İyul",
    "Avq",
    "Sen",
    "Okt",
    "Noy",
    "Dek"
  ],
  wide: [
    "Yanvar",
    "Fevral",
    "Mart",
    "Aprel",
    "May",
    "İyun",
    "İyul",
    "Avqust",
    "Sentyabr",
    "Oktyabr",
    "Noyabr",
    "Dekabr"
  ]
};
var dayValues9 = {
  narrow: ["B.", "B.e", "Ç.a", "Ç.", "C.a", "C.", "Ş."],
  short: ["B.", "B.e", "Ç.a", "Ç.", "C.a", "C.", "Ş."],
  abbreviated: ["Baz", "Baz.e", "Çər.a", "Çər", "Cüm.a", "Cüm", "Şə"],
  wide: [
    "Bazar",
    "Bazar ertəsi",
    "Çərşənbə axşamı",
    "Çərşənbə",
    "Cümə axşamı",
    "Cümə",
    "Şənbə"
  ]
};
var dayPeriodValues9 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "gecəyarı",
    noon: "gün",
    morning: "səhər",
    afternoon: "gündüz",
    evening: "axşam",
    night: "gecə"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gecəyarı",
    noon: "gün",
    morning: "səhər",
    afternoon: "gündüz",
    evening: "axşam",
    night: "gecə"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gecəyarı",
    noon: "gün",
    morning: "səhər",
    afternoon: "gündüz",
    evening: "axşam",
    night: "gecə"
  }
};
var formattingDayPeriodValues9 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "gecəyarı",
    noon: "gün",
    morning: "səhər",
    afternoon: "gündüz",
    evening: "axşam",
    night: "gecə"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gecəyarı",
    noon: "gün",
    morning: "səhər",
    afternoon: "gündüz",
    evening: "axşam",
    night: "gecə"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gecəyarı",
    noon: "gün",
    morning: "səhər",
    afternoon: "gündüz",
    evening: "axşam",
    night: "gecə"
  }
};
var suffixes = {
  1: "-inci",
  5: "-inci",
  8: "-inci",
  70: "-inci",
  80: "-inci",
  2: "-nci",
  7: "-nci",
  20: "-nci",
  50: "-nci",
  3: "-üncü",
  4: "-üncü",
  100: "-üncü",
  6: "-ncı",
  9: "-uncu",
  10: "-uncu",
  30: "-uncu",
  60: "-ıncı",
  90: "-ıncı"
};
var getSuffix = (number2) => {
  if (number2 === 0) {
    return number2 + "-ıncı";
  }
  const a2 = number2 % 10;
  const b2 = number2 % 100 - a2;
  const c5 = number2 >= 100 ? 100 : null;
  if (suffixes[a2]) {
    return suffixes[a2];
  } else if (suffixes[b2]) {
    return suffixes[b2];
  } else if (c5 !== null) {
    return suffixes[c5];
  }
  return "";
};
var ordinalNumber9 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const suffix2 = getSuffix(number2);
  return number2 + suffix2;
};
var localize9 = {
  ordinalNumber: ordinalNumber9,
  era: buildLocalizeFn({
    values: eraValues9,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues9,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues9,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues9,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues9,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues9,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/az/_lib/match.mjs
var matchOrdinalNumberPattern9 = /^(\d+)(-?(ci|inci|nci|uncu|üncü|ncı))?/i;
var parseOrdinalNumberPattern9 = /\d+/i;
var matchEraPatterns9 = {
  narrow: /^(b|a)$/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)$/i,
  wide: /^(bizim eradan əvvəl|bizim era)$/i
};
var parseEraPatterns9 = {
  any: [/^b$/i, /^(a|c)$/i]
};
var matchQuarterPatterns9 = {
  narrow: /^[1234]$/i,
  abbreviated: /^K[1234]$/i,
  wide: /^[1234](ci)? kvartal$/i
};
var parseQuarterPatterns9 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns9 = {
  narrow: /^[(?-i)yfmaisond]$/i,
  abbreviated: /^(Yan|Fev|Mar|Apr|May|İyun|İyul|Avq|Sen|Okt|Noy|Dek)$/i,
  wide: /^(Yanvar|Fevral|Mart|Aprel|May|İyun|İyul|Avgust|Sentyabr|Oktyabr|Noyabr|Dekabr)$/i
};
var parseMonthPatterns9 = {
  narrow: [
    /^[(?-i)y]$/i,
    /^[(?-i)f]$/i,
    /^[(?-i)m]$/i,
    /^[(?-i)a]$/i,
    /^[(?-i)m]$/i,
    /^[(?-i)i]$/i,
    /^[(?-i)i]$/i,
    /^[(?-i)a]$/i,
    /^[(?-i)s]$/i,
    /^[(?-i)o]$/i,
    /^[(?-i)n]$/i,
    /^[(?-i)d]$/i
  ],
  abbreviated: [
    /^Yan$/i,
    /^Fev$/i,
    /^Mar$/i,
    /^Apr$/i,
    /^May$/i,
    /^İyun$/i,
    /^İyul$/i,
    /^Avg$/i,
    /^Sen$/i,
    /^Okt$/i,
    /^Noy$/i,
    /^Dek$/i
  ],
  wide: [
    /^Yanvar$/i,
    /^Fevral$/i,
    /^Mart$/i,
    /^Aprel$/i,
    /^May$/i,
    /^İyun$/i,
    /^İyul$/i,
    /^Avgust$/i,
    /^Sentyabr$/i,
    /^Oktyabr$/i,
    /^Noyabr$/i,
    /^Dekabr$/i
  ]
};
var matchDayPatterns9 = {
  narrow: /^(B\.|B\.e|Ç\.a|Ç\.|C\.a|C\.|Ş\.)$/i,
  short: /^(B\.|B\.e|Ç\.a|Ç\.|C\.a|C\.|Ş\.)$/i,
  abbreviated: /^(Baz\.e|Çər|Çər\.a|Cüm|Cüm\.a|Şə)$/i,
  wide: /^(Bazar|Bazar ertəsi|Çərşənbə axşamı|Çərşənbə|Cümə axşamı|Cümə|Şənbə)$/i
};
var parseDayPatterns9 = {
  narrow: [
    /^B\.$/i,
    /^B\.e$/i,
    /^Ç\.a$/i,
    /^Ç\.$/i,
    /^C\.a$/i,
    /^C\.$/i,
    /^Ş\.$/i
  ],
  abbreviated: [
    /^Baz$/i,
    /^Baz\.e$/i,
    /^Çər\.a$/i,
    /^Çər$/i,
    /^Cüm\.a$/i,
    /^Cüm$/i,
    /^Şə$/i
  ],
  wide: [
    /^Bazar$/i,
    /^Bazar ertəsi$/i,
    /^Çərşənbə axşamı$/i,
    /^Çərşənbə$/i,
    /^Cümə axşamı$/i,
    /^Cümə$/i,
    /^Şənbə$/i
  ],
  any: [
    /^B\.$/i,
    /^B\.e$/i,
    /^Ç\.a$/i,
    /^Ç\.$/i,
    /^C\.a$/i,
    /^C\.$/i,
    /^Ş\.$/i
  ]
};
var matchDayPeriodPatterns9 = {
  narrow: /^(a|p|gecəyarı|gün|səhər|gündüz|axşam|gecə)$/i,
  any: /^(am|pm|a\.m\.|p\.m\.|AM|PM|gecəyarı|gün|səhər|gündüz|axşam|gecə)$/i
};
var parseDayPeriodPatterns9 = {
  any: {
    am: /^a$/i,
    pm: /^p$/i,
    midnight: /^gecəyarı$/i,
    noon: /^gün$/i,
    morning: /səhər$/i,
    afternoon: /gündüz$/i,
    evening: /axşam$/i,
    night: /gecə$/i
  }
};
var match9 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern9,
    parsePattern: parseOrdinalNumberPattern9,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns9,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns9,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns9,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns9,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns9,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns9,
    defaultParseWidth: "narrow"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns9,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns9,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns9,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns9,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/az.mjs
var az = {
  code: "az",
  formatDistance: formatDistance10,
  formatLong: formatLong9,
  formatRelative: formatRelative9,
  localize: localize9,
  match: match9,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/be/_lib/formatDistance.mjs
function declension(scheme2, count) {
  if (scheme2.one !== void 0 && count === 1) {
    return scheme2.one;
  }
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
function buildLocalizeTokenFn(scheme2) {
  return (count, options2) => {
    if (options2 && options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        if (scheme2.future) {
          return declension(scheme2.future, count);
        } else {
          return "праз " + declension(scheme2.regular, count);
        }
      } else {
        if (scheme2.past) {
          return declension(scheme2.past, count);
        } else {
          return declension(scheme2.regular, count) + " таму";
        }
      }
    } else {
      return declension(scheme2.regular, count);
    }
  };
}
var halfAMinute = (_, options2) => {
  if (options2 && options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "праз паўхвіліны";
    } else {
      return "паўхвіліны таму";
    }
  }
  return "паўхвіліны";
};
var formatDistanceLocale10 = {
  lessThanXSeconds: buildLocalizeTokenFn({
    regular: {
      one: "менш за секунду",
      singularNominative: "менш за {{count}} секунду",
      singularGenitive: "менш за {{count}} секунды",
      pluralGenitive: "менш за {{count}} секунд"
    },
    future: {
      one: "менш, чым праз секунду",
      singularNominative: "менш, чым праз {{count}} секунду",
      singularGenitive: "менш, чым праз {{count}} секунды",
      pluralGenitive: "менш, чым праз {{count}} секунд"
    }
  }),
  xSeconds: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} секунда",
      singularGenitive: "{{count}} секунды",
      pluralGenitive: "{{count}} секунд"
    },
    past: {
      singularNominative: "{{count}} секунду таму",
      singularGenitive: "{{count}} секунды таму",
      pluralGenitive: "{{count}} секунд таму"
    },
    future: {
      singularNominative: "праз {{count}} секунду",
      singularGenitive: "праз {{count}} секунды",
      pluralGenitive: "праз {{count}} секунд"
    }
  }),
  halfAMinute,
  lessThanXMinutes: buildLocalizeTokenFn({
    regular: {
      one: "менш за хвіліну",
      singularNominative: "менш за {{count}} хвіліну",
      singularGenitive: "менш за {{count}} хвіліны",
      pluralGenitive: "менш за {{count}} хвілін"
    },
    future: {
      one: "менш, чым праз хвіліну",
      singularNominative: "менш, чым праз {{count}} хвіліну",
      singularGenitive: "менш, чым праз {{count}} хвіліны",
      pluralGenitive: "менш, чым праз {{count}} хвілін"
    }
  }),
  xMinutes: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} хвіліна",
      singularGenitive: "{{count}} хвіліны",
      pluralGenitive: "{{count}} хвілін"
    },
    past: {
      singularNominative: "{{count}} хвіліну таму",
      singularGenitive: "{{count}} хвіліны таму",
      pluralGenitive: "{{count}} хвілін таму"
    },
    future: {
      singularNominative: "праз {{count}} хвіліну",
      singularGenitive: "праз {{count}} хвіліны",
      pluralGenitive: "праз {{count}} хвілін"
    }
  }),
  aboutXHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "каля {{count}} гадзіны",
      singularGenitive: "каля {{count}} гадзін",
      pluralGenitive: "каля {{count}} гадзін"
    },
    future: {
      singularNominative: "прыблізна праз {{count}} гадзіну",
      singularGenitive: "прыблізна праз {{count}} гадзіны",
      pluralGenitive: "прыблізна праз {{count}} гадзін"
    }
  }),
  xHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} гадзіна",
      singularGenitive: "{{count}} гадзіны",
      pluralGenitive: "{{count}} гадзін"
    },
    past: {
      singularNominative: "{{count}} гадзіну таму",
      singularGenitive: "{{count}} гадзіны таму",
      pluralGenitive: "{{count}} гадзін таму"
    },
    future: {
      singularNominative: "праз {{count}} гадзіну",
      singularGenitive: "праз {{count}} гадзіны",
      pluralGenitive: "праз {{count}} гадзін"
    }
  }),
  xDays: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} дзень",
      singularGenitive: "{{count}} дні",
      pluralGenitive: "{{count}} дзён"
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "каля {{count}} тыдні",
      singularGenitive: "каля {{count}} тыдняў",
      pluralGenitive: "каля {{count}} тыдняў"
    },
    future: {
      singularNominative: "прыблізна праз {{count}} тыдзень",
      singularGenitive: "прыблізна праз {{count}} тыдні",
      pluralGenitive: "прыблізна праз {{count}} тыдняў"
    }
  }),
  xWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} тыдзень",
      singularGenitive: "{{count}} тыдні",
      pluralGenitive: "{{count}} тыдняў"
    }
  }),
  aboutXMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "каля {{count}} месяца",
      singularGenitive: "каля {{count}} месяцаў",
      pluralGenitive: "каля {{count}} месяцаў"
    },
    future: {
      singularNominative: "прыблізна праз {{count}} месяц",
      singularGenitive: "прыблізна праз {{count}} месяцы",
      pluralGenitive: "прыблізна праз {{count}} месяцаў"
    }
  }),
  xMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} месяц",
      singularGenitive: "{{count}} месяцы",
      pluralGenitive: "{{count}} месяцаў"
    }
  }),
  aboutXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "каля {{count}} года",
      singularGenitive: "каля {{count}} гадоў",
      pluralGenitive: "каля {{count}} гадоў"
    },
    future: {
      singularNominative: "прыблізна праз {{count}} год",
      singularGenitive: "прыблізна праз {{count}} гады",
      pluralGenitive: "прыблізна праз {{count}} гадоў"
    }
  }),
  xYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} год",
      singularGenitive: "{{count}} гады",
      pluralGenitive: "{{count}} гадоў"
    }
  }),
  overXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "больш за {{count}} год",
      singularGenitive: "больш за {{count}} гады",
      pluralGenitive: "больш за {{count}} гадоў"
    },
    future: {
      singularNominative: "больш, чым праз {{count}} год",
      singularGenitive: "больш, чым праз {{count}} гады",
      pluralGenitive: "больш, чым праз {{count}} гадоў"
    }
  }),
  almostXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "амаль {{count}} год",
      singularGenitive: "амаль {{count}} гады",
      pluralGenitive: "амаль {{count}} гадоў"
    },
    future: {
      singularNominative: "амаль праз {{count}} год",
      singularGenitive: "амаль праз {{count}} гады",
      pluralGenitive: "амаль праз {{count}} гадоў"
    }
  })
};
var formatDistance11 = (token, count, options2) => {
  options2 = options2 || {};
  return formatDistanceLocale10[token](count, options2);
};

// ../../../node_modules/date-fns/locale/be/_lib/formatLong.mjs
var dateFormats10 = {
  full: "EEEE, d MMMM y 'г.'",
  long: "d MMMM y 'г.'",
  medium: "d MMM y 'г.'",
  short: "dd.MM.y"
};
var timeFormats10 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats10 = {
  any: "{{date}}, {{time}}"
};
var formatLong10 = {
  date: buildFormatLongFn({
    formats: dateFormats10,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats10,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats10,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/be/_lib/formatRelative.mjs
var accusativeWeekdays = [
  "нядзелю",
  "панядзелак",
  "аўторак",
  "сераду",
  "чацвер",
  "пятніцу",
  "суботу"
];
function lastWeek(day) {
  const weekday = accusativeWeekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'у мінулую " + weekday + " а' p";
    case 1:
    case 2:
    case 4:
      return "'у мінулы " + weekday + " а' p";
  }
}
function thisWeek(day) {
  const weekday = accusativeWeekdays[day];
  return "'у " + weekday + " а' p";
}
function nextWeek(day) {
  const weekday = accusativeWeekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'у наступную " + weekday + " а' p";
    case 1:
    case 2:
    case 4:
      return "'у наступны " + weekday + " а' p";
  }
}
var lastWeekFormat = (dirtyDate, baseDate, options2) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options2)) {
    return thisWeek(day);
  } else {
    return lastWeek(day);
  }
};
var nextWeekFormat = (dirtyDate, baseDate, options2) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options2)) {
    return thisWeek(day);
  } else {
    return nextWeek(day);
  }
};
var formatRelativeLocale10 = {
  lastWeek: lastWeekFormat,
  yesterday: "'учора а' p",
  today: "'сёння а' p",
  tomorrow: "'заўтра а' p",
  nextWeek: nextWeekFormat,
  other: "P"
};
var formatRelative10 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale10[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/be/_lib/localize.mjs
var eraValues10 = {
  narrow: ["да н.э.", "н.э."],
  abbreviated: ["да н. э.", "н. э."],
  wide: ["да нашай эры", "нашай эры"]
};
var quarterValues10 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-ы кв.", "2-і кв.", "3-і кв.", "4-ы кв."],
  wide: ["1-ы квартал", "2-і квартал", "3-і квартал", "4-ы квартал"]
};
var monthValues10 = {
  narrow: ["С", "Л", "С", "К", "М", "Ч", "Л", "Ж", "В", "К", "Л", "С"],
  abbreviated: [
    "студз.",
    "лют.",
    "сак.",
    "крас.",
    "май",
    "чэрв.",
    "ліп.",
    "жн.",
    "вер.",
    "кастр.",
    "ліст.",
    "снеж."
  ],
  wide: [
    "студзень",
    "люты",
    "сакавік",
    "красавік",
    "май",
    "чэрвень",
    "ліпень",
    "жнівень",
    "верасень",
    "кастрычнік",
    "лістапад",
    "снежань"
  ]
};
var formattingMonthValues = {
  narrow: ["С", "Л", "С", "К", "М", "Ч", "Л", "Ж", "В", "К", "Л", "С"],
  abbreviated: [
    "студз.",
    "лют.",
    "сак.",
    "крас.",
    "мая",
    "чэрв.",
    "ліп.",
    "жн.",
    "вер.",
    "кастр.",
    "ліст.",
    "снеж."
  ],
  wide: [
    "студзеня",
    "лютага",
    "сакавіка",
    "красавіка",
    "мая",
    "чэрвеня",
    "ліпеня",
    "жніўня",
    "верасня",
    "кастрычніка",
    "лістапада",
    "снежня"
  ]
};
var dayValues10 = {
  narrow: ["Н", "П", "А", "С", "Ч", "П", "С"],
  short: ["нд", "пн", "аў", "ср", "чц", "пт", "сб"],
  abbreviated: ["нядз", "пан", "аўт", "сер", "чац", "пят", "суб"],
  wide: [
    "нядзеля",
    "панядзелак",
    "аўторак",
    "серада",
    "чацвер",
    "пятніца",
    "субота"
  ]
};
var dayPeriodValues10 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўн.",
    noon: "поўд.",
    morning: "ран.",
    afternoon: "дзень",
    evening: "веч.",
    night: "ноч"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўн.",
    noon: "поўд.",
    morning: "ран.",
    afternoon: "дзень",
    evening: "веч.",
    night: "ноч"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўнач",
    noon: "поўдзень",
    morning: "раніца",
    afternoon: "дзень",
    evening: "вечар",
    night: "ноч"
  }
};
var formattingDayPeriodValues10 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўн.",
    noon: "поўд.",
    morning: "ран.",
    afternoon: "дня",
    evening: "веч.",
    night: "ночы"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўн.",
    noon: "поўд.",
    morning: "ран.",
    afternoon: "дня",
    evening: "веч.",
    night: "ночы"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўнач",
    noon: "поўдзень",
    morning: "раніцы",
    afternoon: "дня",
    evening: "вечара",
    night: "ночы"
  }
};
var ordinalNumber10 = (dirtyNumber, options2) => {
  const unit = String(options2 == null ? void 0 : options2.unit);
  const number2 = Number(dirtyNumber);
  let suffix2;
  if (unit === "date") {
    suffix2 = "-га";
  } else if (unit === "hour" || unit === "minute" || unit === "second") {
    suffix2 = "-я";
  } else {
    suffix2 = (number2 % 10 === 2 || number2 % 10 === 3) && number2 % 100 !== 12 && number2 % 100 !== 13 ? "-і" : "-ы";
  }
  return number2 + suffix2;
};
var localize10 = {
  ordinalNumber: ordinalNumber10,
  era: buildLocalizeFn({
    values: eraValues10,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues10,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues10,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues10,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues10,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues10,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/be/_lib/match.mjs
var matchOrdinalNumberPattern10 = /^(\d+)(-?(е|я|га|і|ы|ае|ая|яя|шы|гі|ці|ты|мы))?/i;
var parseOrdinalNumberPattern10 = /\d+/i;
var matchEraPatterns10 = {
  narrow: /^((да )?н\.?\s?э\.?)/i,
  abbreviated: /^((да )?н\.?\s?э\.?)/i,
  wide: /^(да нашай эры|нашай эры|наша эра)/i
};
var parseEraPatterns10 = {
  any: [/^д/i, /^н/i]
};
var matchQuarterPatterns10 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[ыі]?)? кв.?/i,
  wide: /^[1234](-?[ыі]?)? квартал/i
};
var parseQuarterPatterns10 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns10 = {
  narrow: /^[слкмчжв]/i,
  abbreviated: /^(студз|лют|сак|крас|ма[йя]|чэрв|ліп|жн|вер|кастр|ліст|снеж)\.?/i,
  wide: /^(студзен[ья]|лют(ы|ага)|сакавіка?|красавіка?|ма[йя]|чэрвен[ья]|ліпен[ья]|жні(вень|ўня)|верас(ень|ня)|кастрычніка?|лістапада?|снеж(ань|ня))/i
};
var parseMonthPatterns10 = {
  narrow: [
    /^с/i,
    /^л/i,
    /^с/i,
    /^к/i,
    /^м/i,
    /^ч/i,
    /^л/i,
    /^ж/i,
    /^в/i,
    /^к/i,
    /^л/i,
    /^с/i
  ],
  any: [
    /^ст/i,
    /^лю/i,
    /^са/i,
    /^кр/i,
    /^ма/i,
    /^ч/i,
    /^ліп/i,
    /^ж/i,
    /^в/i,
    /^ка/i,
    /^ліс/i,
    /^сн/i
  ]
};
var matchDayPatterns10 = {
  narrow: /^[нпасч]/i,
  short: /^(нд|ня|пн|па|аў|ат|ср|се|чц|ча|пт|пя|сб|су)\.?/i,
  abbreviated: /^(нядз?|ндз|пнд|пан|аўт|срд|сер|чцв|чац|птн|пят|суб).?/i,
  wide: /^(нядзел[яі]|панядзел(ак|ка)|аўтор(ак|ка)|серад[аы]|чацв(ер|ярга)|пятніц[аы]|субот[аы])/i
};
var parseDayPatterns10 = {
  narrow: [/^н/i, /^п/i, /^а/i, /^с/i, /^ч/i, /^п/i, /^с/i],
  any: [/^н/i, /^п[ан]/i, /^а/i, /^с[ер]/i, /^ч/i, /^п[ят]/i, /^с[уб]/i]
};
var matchDayPeriodPatterns10 = {
  narrow: /^([дп]п|поўн\.?|поўд\.?|ран\.?|дзень|дня|веч\.?|ночы?)/i,
  abbreviated: /^([дп]п|поўн\.?|поўд\.?|ран\.?|дзень|дня|веч\.?|ночы?)/i,
  wide: /^([дп]п|поўнач|поўдзень|раніц[аы]|дзень|дня|вечара?|ночы?)/i
};
var parseDayPeriodPatterns10 = {
  any: {
    am: /^дп/i,
    pm: /^пп/i,
    midnight: /^поўн/i,
    noon: /^поўд/i,
    morning: /^р/i,
    afternoon: /^д[зн]/i,
    evening: /^в/i,
    night: /^н/i
  }
};
var match10 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern10,
    parsePattern: parseOrdinalNumberPattern10,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns10,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns10,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns10,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns10,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns10,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns10,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns10,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns10,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns10,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns10,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/be.mjs
var be = {
  code: "be",
  formatDistance: formatDistance11,
  formatLong: formatLong10,
  formatRelative: formatRelative10,
  localize: localize10,
  match: match10,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/be-tarask/_lib/formatDistance.mjs
function declension2(scheme2, count) {
  if (scheme2.one !== void 0 && count === 1) {
    return scheme2.one;
  }
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
function buildLocalizeTokenFn2(scheme2) {
  return (count, options2) => {
    if (options2 && options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        if (scheme2.future) {
          return declension2(scheme2.future, count);
        } else {
          return "праз " + declension2(scheme2.regular, count);
        }
      } else {
        if (scheme2.past) {
          return declension2(scheme2.past, count);
        } else {
          return declension2(scheme2.regular, count) + " таму";
        }
      }
    } else {
      return declension2(scheme2.regular, count);
    }
  };
}
var halfAMinute2 = (_, options2) => {
  if (options2 && options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "праз паўхвіліны";
    } else {
      return "паўхвіліны таму";
    }
  }
  return "паўхвіліны";
};
var formatDistanceLocale11 = {
  lessThanXSeconds: buildLocalizeTokenFn2({
    regular: {
      one: "менш за секунду",
      singularNominative: "менш за {{count}} секунду",
      singularGenitive: "менш за {{count}} секунды",
      pluralGenitive: "менш за {{count}} секунд"
    },
    future: {
      one: "менш, чым праз секунду",
      singularNominative: "менш, чым праз {{count}} секунду",
      singularGenitive: "менш, чым праз {{count}} секунды",
      pluralGenitive: "менш, чым праз {{count}} секунд"
    }
  }),
  xSeconds: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "{{count}} секунда",
      singularGenitive: "{{count}} секунды",
      pluralGenitive: "{{count}} секунд"
    },
    past: {
      singularNominative: "{{count}} секунду таму",
      singularGenitive: "{{count}} секунды таму",
      pluralGenitive: "{{count}} секунд таму"
    },
    future: {
      singularNominative: "праз {{count}} секунду",
      singularGenitive: "праз {{count}} секунды",
      pluralGenitive: "праз {{count}} секунд"
    }
  }),
  halfAMinute: halfAMinute2,
  lessThanXMinutes: buildLocalizeTokenFn2({
    regular: {
      one: "менш за хвіліну",
      singularNominative: "менш за {{count}} хвіліну",
      singularGenitive: "менш за {{count}} хвіліны",
      pluralGenitive: "менш за {{count}} хвілін"
    },
    future: {
      one: "менш, чым праз хвіліну",
      singularNominative: "менш, чым праз {{count}} хвіліну",
      singularGenitive: "менш, чым праз {{count}} хвіліны",
      pluralGenitive: "менш, чым праз {{count}} хвілін"
    }
  }),
  xMinutes: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "{{count}} хвіліна",
      singularGenitive: "{{count}} хвіліны",
      pluralGenitive: "{{count}} хвілін"
    },
    past: {
      singularNominative: "{{count}} хвіліну таму",
      singularGenitive: "{{count}} хвіліны таму",
      pluralGenitive: "{{count}} хвілін таму"
    },
    future: {
      singularNominative: "праз {{count}} хвіліну",
      singularGenitive: "праз {{count}} хвіліны",
      pluralGenitive: "праз {{count}} хвілін"
    }
  }),
  aboutXHours: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "каля {{count}} гадзіны",
      singularGenitive: "каля {{count}} гадзін",
      pluralGenitive: "каля {{count}} гадзін"
    },
    future: {
      singularNominative: "прыблізна праз {{count}} гадзіну",
      singularGenitive: "прыблізна праз {{count}} гадзіны",
      pluralGenitive: "прыблізна праз {{count}} гадзін"
    }
  }),
  xHours: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "{{count}} гадзіна",
      singularGenitive: "{{count}} гадзіны",
      pluralGenitive: "{{count}} гадзін"
    },
    past: {
      singularNominative: "{{count}} гадзіну таму",
      singularGenitive: "{{count}} гадзіны таму",
      pluralGenitive: "{{count}} гадзін таму"
    },
    future: {
      singularNominative: "праз {{count}} гадзіну",
      singularGenitive: "праз {{count}} гадзіны",
      pluralGenitive: "праз {{count}} гадзін"
    }
  }),
  xDays: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "{{count}} дзень",
      singularGenitive: "{{count}} дні",
      pluralGenitive: "{{count}} дзён"
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "каля {{count}} тыдні",
      singularGenitive: "каля {{count}} тыдняў",
      pluralGenitive: "каля {{count}} тыдняў"
    },
    future: {
      singularNominative: "прыблізна праз {{count}} тыдзень",
      singularGenitive: "прыблізна праз {{count}} тыдні",
      pluralGenitive: "прыблізна праз {{count}} тыдняў"
    }
  }),
  xWeeks: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "{{count}} тыдзень",
      singularGenitive: "{{count}} тыдні",
      pluralGenitive: "{{count}} тыдняў"
    }
  }),
  aboutXMonths: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "каля {{count}} месяца",
      singularGenitive: "каля {{count}} месяцаў",
      pluralGenitive: "каля {{count}} месяцаў"
    },
    future: {
      singularNominative: "прыблізна праз {{count}} месяц",
      singularGenitive: "прыблізна праз {{count}} месяцы",
      pluralGenitive: "прыблізна праз {{count}} месяцаў"
    }
  }),
  xMonths: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "{{count}} месяц",
      singularGenitive: "{{count}} месяцы",
      pluralGenitive: "{{count}} месяцаў"
    }
  }),
  aboutXYears: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "каля {{count}} года",
      singularGenitive: "каля {{count}} гадоў",
      pluralGenitive: "каля {{count}} гадоў"
    },
    future: {
      singularNominative: "прыблізна праз {{count}} год",
      singularGenitive: "прыблізна праз {{count}} гады",
      pluralGenitive: "прыблізна праз {{count}} гадоў"
    }
  }),
  xYears: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "{{count}} год",
      singularGenitive: "{{count}} гады",
      pluralGenitive: "{{count}} гадоў"
    }
  }),
  overXYears: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "больш за {{count}} год",
      singularGenitive: "больш за {{count}} гады",
      pluralGenitive: "больш за {{count}} гадоў"
    },
    future: {
      singularNominative: "больш, чым праз {{count}} год",
      singularGenitive: "больш, чым праз {{count}} гады",
      pluralGenitive: "больш, чым праз {{count}} гадоў"
    }
  }),
  almostXYears: buildLocalizeTokenFn2({
    regular: {
      singularNominative: "амаль {{count}} год",
      singularGenitive: "амаль {{count}} гады",
      pluralGenitive: "амаль {{count}} гадоў"
    },
    future: {
      singularNominative: "амаль праз {{count}} год",
      singularGenitive: "амаль праз {{count}} гады",
      pluralGenitive: "амаль праз {{count}} гадоў"
    }
  })
};
var formatDistance12 = (token, count, options2) => {
  options2 = options2 || {};
  return formatDistanceLocale11[token](count, options2);
};

// ../../../node_modules/date-fns/locale/be-tarask/_lib/formatLong.mjs
var dateFormats11 = {
  full: "EEEE, d MMMM y 'г.'",
  long: "d MMMM y 'г.'",
  medium: "d MMM y 'г.'",
  short: "dd.MM.y"
};
var timeFormats11 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats11 = {
  any: "{{date}}, {{time}}"
};
var formatLong11 = {
  date: buildFormatLongFn({
    formats: dateFormats11,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats11,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats11,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/be-tarask/_lib/formatRelative.mjs
var accusativeWeekdays2 = [
  "нядзелю",
  "панядзелак",
  "аўторак",
  "сераду",
  "чацьвер",
  "пятніцу",
  "суботу"
];
function lastWeek2(day) {
  const weekday = accusativeWeekdays2[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'у мінулую " + weekday + " а' p";
    case 1:
    case 2:
    case 4:
      return "'у мінулы " + weekday + " а' p";
  }
}
function thisWeek2(day) {
  const weekday = accusativeWeekdays2[day];
  return "'у " + weekday + " а' p";
}
function nextWeek2(day) {
  const weekday = accusativeWeekdays2[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'у наступную " + weekday + " а' p";
    case 1:
    case 2:
    case 4:
      return "'у наступны " + weekday + " а' p";
  }
}
var lastWeekFormat2 = (dirtyDate, baseDate, options2) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options2)) {
    return thisWeek2(day);
  } else {
    return lastWeek2(day);
  }
};
var nextWeekFormat2 = (dirtyDate, baseDate, options2) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options2)) {
    return thisWeek2(day);
  } else {
    return nextWeek2(day);
  }
};
var formatRelativeLocale11 = {
  lastWeek: lastWeekFormat2,
  yesterday: "'учора а' p",
  today: "'сёньня а' p",
  tomorrow: "'заўтра а' p",
  nextWeek: nextWeekFormat2,
  other: "P"
};
var formatRelative11 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale11[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/be-tarask/_lib/localize.mjs
var eraValues11 = {
  narrow: ["да н.э.", "н.э."],
  abbreviated: ["да н. э.", "н. э."],
  wide: ["да нашай эры", "нашай эры"]
};
var quarterValues11 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-ы кв.", "2-і кв.", "3-і кв.", "4-ы кв."],
  wide: ["1-ы квартал", "2-і квартал", "3-і квартал", "4-ы квартал"]
};
var monthValues11 = {
  narrow: ["С", "Л", "С", "К", "Т", "Ч", "Л", "Ж", "В", "К", "Л", "С"],
  abbreviated: [
    "студз.",
    "лют.",
    "сак.",
    "крас.",
    "трав.",
    "чэрв.",
    "ліп.",
    "жн.",
    "вер.",
    "кастр.",
    "ліст.",
    "сьнеж."
  ],
  wide: [
    "студзень",
    "люты",
    "сакавік",
    "красавік",
    "травень",
    "чэрвень",
    "ліпень",
    "жнівень",
    "верасень",
    "кастрычнік",
    "лістапад",
    "сьнежань"
  ]
};
var formattingMonthValues2 = {
  narrow: ["С", "Л", "С", "К", "Т", "Ч", "Л", "Ж", "В", "К", "Л", "С"],
  abbreviated: [
    "студз.",
    "лют.",
    "сак.",
    "крас.",
    "трав.",
    "чэрв.",
    "ліп.",
    "жн.",
    "вер.",
    "кастр.",
    "ліст.",
    "сьнеж."
  ],
  wide: [
    "студзеня",
    "лютага",
    "сакавіка",
    "красавіка",
    "траўня",
    "чэрвеня",
    "ліпеня",
    "жніўня",
    "верасня",
    "кастрычніка",
    "лістапада",
    "сьнежня"
  ]
};
var dayValues11 = {
  narrow: ["Н", "П", "А", "С", "Ч", "П", "С"],
  short: ["нд", "пн", "аў", "ср", "чц", "пт", "сб"],
  abbreviated: ["нядз", "пан", "аўт", "сер", "чаць", "пят", "суб"],
  wide: [
    "нядзеля",
    "панядзелак",
    "аўторак",
    "серада",
    "чацьвер",
    "пятніца",
    "субота"
  ]
};
var dayPeriodValues11 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўн.",
    noon: "поўд.",
    morning: "ран.",
    afternoon: "дзень",
    evening: "веч.",
    night: "ноч"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўн.",
    noon: "поўд.",
    morning: "ран.",
    afternoon: "дзень",
    evening: "веч.",
    night: "ноч"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўнач",
    noon: "поўдзень",
    morning: "раніца",
    afternoon: "дзень",
    evening: "вечар",
    night: "ноч"
  }
};
var formattingDayPeriodValues11 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўн.",
    noon: "поўд.",
    morning: "ран.",
    afternoon: "дня",
    evening: "веч.",
    night: "ночы"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўн.",
    noon: "поўд.",
    morning: "ран.",
    afternoon: "дня",
    evening: "веч.",
    night: "ночы"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "поўнач",
    noon: "поўдзень",
    morning: "раніцы",
    afternoon: "дня",
    evening: "вечара",
    night: "ночы"
  }
};
var ordinalNumber11 = (dirtyNumber, options2) => {
  const unit = String(options2 == null ? void 0 : options2.unit);
  const number2 = Number(dirtyNumber);
  let suffix2;
  if (unit === "date") {
    suffix2 = "-га";
  } else if (unit === "hour" || unit === "minute" || unit === "second") {
    suffix2 = "-я";
  } else {
    suffix2 = (number2 % 10 === 2 || number2 % 10 === 3) && number2 % 100 !== 12 && number2 % 100 !== 13 ? "-і" : "-ы";
  }
  return number2 + suffix2;
};
var localize11 = {
  ordinalNumber: ordinalNumber11,
  era: buildLocalizeFn({
    values: eraValues11,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues11,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues11,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues2,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues11,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues11,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues11,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/be-tarask/_lib/match.mjs
var matchOrdinalNumberPattern11 = /^(\d+)(-?(е|я|га|і|ы|ае|ая|яя|шы|гі|ці|ты|мы))?/i;
var parseOrdinalNumberPattern11 = /\d+/i;
var matchEraPatterns11 = {
  narrow: /^((да )?н\.?\s?э\.?)/i,
  abbreviated: /^((да )?н\.?\s?э\.?)/i,
  wide: /^(да нашай эры|нашай эры|наша эра)/i
};
var parseEraPatterns11 = {
  any: [/^д/i, /^н/i]
};
var matchQuarterPatterns11 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[ыі]?)? кв.?/i,
  wide: /^[1234](-?[ыі]?)? квартал/i
};
var parseQuarterPatterns11 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns11 = {
  narrow: /^[слкмчжв]/i,
  abbreviated: /^(студз|лют|сак|крас|тр(ав)?|чэрв|ліп|жн|вер|кастр|ліст|сьнеж)\.?/i,
  wide: /^(студзен[ья]|лют(ы|ага)|сакавіка?|красавіка?|тра(вень|ўня)|чэрвен[ья]|ліпен[ья]|жні(вень|ўня)|верас(ень|ня)|кастрычніка?|лістапада?|сьнеж(ань|ня))/i
};
var parseMonthPatterns11 = {
  narrow: [
    /^с/i,
    /^л/i,
    /^с/i,
    /^к/i,
    /^т/i,
    /^ч/i,
    /^л/i,
    /^ж/i,
    /^в/i,
    /^к/i,
    /^л/i,
    /^с/i
  ],
  any: [
    /^ст/i,
    /^лю/i,
    /^са/i,
    /^кр/i,
    /^тр/i,
    /^ч/i,
    /^ліп/i,
    /^ж/i,
    /^в/i,
    /^ка/i,
    /^ліс/i,
    /^сн/i
  ]
};
var matchDayPatterns11 = {
  narrow: /^[нпасч]/i,
  short: /^(нд|ня|пн|па|аў|ат|ср|се|чц|ча|пт|пя|сб|су)\.?/i,
  abbreviated: /^(нядз?|ндз|пнд|пан|аўт|срд|сер|чцьв|чаць|птн|пят|суб).?/i,
  wide: /^(нядзел[яі]|панядзел(ак|ка)|аўтор(ак|ка)|серад[аы]|чацьв(ер|ярга)|пятніц[аы]|субот[аы])/i
};
var parseDayPatterns11 = {
  narrow: [/^н/i, /^п/i, /^а/i, /^с/i, /^ч/i, /^п/i, /^с/i],
  any: [/^н/i, /^п[ан]/i, /^а/i, /^с[ер]/i, /^ч/i, /^п[ят]/i, /^с[уб]/i]
};
var matchDayPeriodPatterns11 = {
  narrow: /^([дп]п|поўн\.?|поўд\.?|ран\.?|дзень|дня|веч\.?|ночы?)/i,
  abbreviated: /^([дп]п|поўн\.?|поўд\.?|ран\.?|дзень|дня|веч\.?|ночы?)/i,
  wide: /^([дп]п|поўнач|поўдзень|раніц[аы]|дзень|дня|вечара?|ночы?)/i
};
var parseDayPeriodPatterns11 = {
  any: {
    am: /^дп/i,
    pm: /^пп/i,
    midnight: /^поўн/i,
    noon: /^поўд/i,
    morning: /^р/i,
    afternoon: /^д[зн]/i,
    evening: /^в/i,
    night: /^н/i
  }
};
var match11 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern11,
    parsePattern: parseOrdinalNumberPattern11,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns11,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns11,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns11,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns11,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns11,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns11,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns11,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns11,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns11,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns11,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/be-tarask.mjs
var beTarask = {
  code: "be-tarask",
  formatDistance: formatDistance12,
  formatLong: formatLong11,
  formatRelative: formatRelative11,
  localize: localize11,
  match: match11,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/bg/_lib/formatDistance.mjs
var formatDistanceLocale12 = {
  lessThanXSeconds: {
    one: "по-малко от секунда",
    other: "по-малко от {{count}} секунди"
  },
  xSeconds: {
    one: "1 секунда",
    other: "{{count}} секунди"
  },
  halfAMinute: "половин минута",
  lessThanXMinutes: {
    one: "по-малко от минута",
    other: "по-малко от {{count}} минути"
  },
  xMinutes: {
    one: "1 минута",
    other: "{{count}} минути"
  },
  aboutXHours: {
    one: "около час",
    other: "около {{count}} часа"
  },
  xHours: {
    one: "1 час",
    other: "{{count}} часа"
  },
  xDays: {
    one: "1 ден",
    other: "{{count}} дни"
  },
  aboutXWeeks: {
    one: "около седмица",
    other: "около {{count}} седмици"
  },
  xWeeks: {
    one: "1 седмица",
    other: "{{count}} седмици"
  },
  aboutXMonths: {
    one: "около месец",
    other: "около {{count}} месеца"
  },
  xMonths: {
    one: "1 месец",
    other: "{{count}} месеца"
  },
  aboutXYears: {
    one: "около година",
    other: "около {{count}} години"
  },
  xYears: {
    one: "1 година",
    other: "{{count}} години"
  },
  overXYears: {
    one: "над година",
    other: "над {{count}} години"
  },
  almostXYears: {
    one: "почти година",
    other: "почти {{count}} години"
  }
};
var formatDistance13 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale12[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "след " + result;
    } else {
      return "преди " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/bg/_lib/formatLong.mjs
var dateFormats12 = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats12 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "H:mm"
};
var dateTimeFormats12 = {
  any: "{{date}} {{time}}"
};
var formatLong12 = {
  date: buildFormatLongFn({
    formats: dateFormats12,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats12,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats12,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/bg/_lib/formatRelative.mjs
var weekdays = [
  "неделя",
  "понеделник",
  "вторник",
  "сряда",
  "четвъртък",
  "петък",
  "събота"
];
function lastWeek3(day) {
  const weekday = weekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'миналата " + weekday + " в' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'миналия " + weekday + " в' p";
  }
}
function thisWeek3(day) {
  const weekday = weekdays[day];
  if (day === 2) {
    return "'във " + weekday + " в' p";
  } else {
    return "'в " + weekday + " в' p";
  }
}
function nextWeek3(day) {
  const weekday = weekdays[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'следващата " + weekday + " в' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'следващия " + weekday + " в' p";
  }
}
var lastWeekFormatToken = (dirtyDate, baseDate, options2) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options2)) {
    return thisWeek3(day);
  } else {
    return lastWeek3(day);
  }
};
var nextWeekFormatToken = (dirtyDate, baseDate, options2) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options2)) {
    return thisWeek3(day);
  } else {
    return nextWeek3(day);
  }
};
var formatRelativeLocale12 = {
  lastWeek: lastWeekFormatToken,
  yesterday: "'вчера в' p",
  today: "'днес в' p",
  tomorrow: "'утре в' p",
  nextWeek: nextWeekFormatToken,
  other: "P"
};
var formatRelative12 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale12[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/bg/_lib/localize.mjs
var eraValues12 = {
  narrow: ["пр.н.е.", "н.е."],
  abbreviated: ["преди н. е.", "н. е."],
  wide: ["преди новата ера", "новата ера"]
};
var quarterValues12 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-во тримес.", "2-ро тримес.", "3-то тримес.", "4-то тримес."],
  wide: [
    "1-во тримесечие",
    "2-ро тримесечие",
    "3-то тримесечие",
    "4-то тримесечие"
  ]
};
var monthValues12 = {
  abbreviated: [
    "яну",
    "фев",
    "мар",
    "апр",
    "май",
    "юни",
    "юли",
    "авг",
    "сеп",
    "окт",
    "ное",
    "дек"
  ],
  wide: [
    "януари",
    "февруари",
    "март",
    "април",
    "май",
    "юни",
    "юли",
    "август",
    "септември",
    "октомври",
    "ноември",
    "декември"
  ]
};
var dayValues12 = {
  narrow: ["Н", "П", "В", "С", "Ч", "П", "С"],
  short: ["нд", "пн", "вт", "ср", "чт", "пт", "сб"],
  abbreviated: ["нед", "пон", "вто", "сря", "чет", "пет", "съб"],
  wide: [
    "неделя",
    "понеделник",
    "вторник",
    "сряда",
    "четвъртък",
    "петък",
    "събота"
  ]
};
var dayPeriodValues12 = {
  wide: {
    am: "преди обяд",
    pm: "след обяд",
    midnight: "в полунощ",
    noon: "на обяд",
    morning: "сутринта",
    afternoon: "следобед",
    evening: "вечерта",
    night: "през нощта"
  }
};
function isFeminine(unit) {
  return unit === "year" || unit === "week" || unit === "minute" || unit === "second";
}
function isNeuter(unit) {
  return unit === "quarter";
}
function numberWithSuffix(number2, unit, masculine, feminine, neuter) {
  const suffix2 = isNeuter(unit) ? neuter : isFeminine(unit) ? feminine : masculine;
  return number2 + "-" + suffix2;
}
var ordinalNumber12 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = options2 == null ? void 0 : options2.unit;
  if (number2 === 0) {
    return numberWithSuffix(0, unit, "ев", "ева", "ево");
  } else if (number2 % 1e3 === 0) {
    return numberWithSuffix(number2, unit, "ен", "на", "но");
  } else if (number2 % 100 === 0) {
    return numberWithSuffix(number2, unit, "тен", "тна", "тно");
  }
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return numberWithSuffix(number2, unit, "ви", "ва", "во");
      case 2:
        return numberWithSuffix(number2, unit, "ри", "ра", "ро");
      case 7:
      case 8:
        return numberWithSuffix(number2, unit, "ми", "ма", "мо");
    }
  }
  return numberWithSuffix(number2, unit, "ти", "та", "то");
};
var localize12 = {
  ordinalNumber: ordinalNumber12,
  era: buildLocalizeFn({
    values: eraValues12,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues12,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues12,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues12,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues12,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/bg/_lib/match.mjs
var matchOrdinalNumberPattern12 = /^(\d+)(-?[врмт][аи]|-?т?(ен|на)|-?(ев|ева))?/i;
var parseOrdinalNumberPattern12 = /\d+/i;
var matchEraPatterns12 = {
  narrow: /^((пр)?н\.?\s?е\.?)/i,
  abbreviated: /^((пр)?н\.?\s?е\.?)/i,
  wide: /^(преди новата ера|новата ера|нова ера)/i
};
var parseEraPatterns12 = {
  any: [/^п/i, /^н/i]
};
var matchQuarterPatterns12 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[врт]?o?)? тримес.?/i,
  wide: /^[1234](-?[врт]?о?)? тримесечие/i
};
var parseQuarterPatterns12 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchDayPatterns12 = {
  narrow: /^[нпвсч]/i,
  short: /^(нд|пн|вт|ср|чт|пт|сб)/i,
  abbreviated: /^(нед|пон|вто|сря|чет|пет|съб)/i,
  wide: /^(неделя|понеделник|вторник|сряда|четвъртък|петък|събота)/i
};
var parseDayPatterns12 = {
  narrow: [/^н/i, /^п/i, /^в/i, /^с/i, /^ч/i, /^п/i, /^с/i],
  any: [/^н[ед]/i, /^п[он]/i, /^вт/i, /^ср/i, /^ч[ет]/i, /^п[ет]/i, /^с[ъб]/i]
};
var matchMonthPatterns12 = {
  abbreviated: /^(яну|фев|мар|апр|май|юни|юли|авг|сеп|окт|ное|дек)/i,
  wide: /^(януари|февруари|март|април|май|юни|юли|август|септември|октомври|ноември|декември)/i
};
var parseMonthPatterns12 = {
  any: [
    /^я/i,
    /^ф/i,
    /^мар/i,
    /^ап/i,
    /^май/i,
    /^юн/i,
    /^юл/i,
    /^ав/i,
    /^се/i,
    /^окт/i,
    /^но/i,
    /^де/i
  ]
};
var matchDayPeriodPatterns12 = {
  any: /^(преди о|след о|в по|на о|през|веч|сут|следо)/i
};
var parseDayPeriodPatterns12 = {
  any: {
    am: /^преди о/i,
    pm: /^след о/i,
    midnight: /^в пол/i,
    noon: /^на об/i,
    morning: /^сут/i,
    afternoon: /^следо/i,
    evening: /^веч/i,
    night: /^през н/i
  }
};
var match12 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern12,
    parsePattern: parseOrdinalNumberPattern12,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns12,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns12,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns12,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns12,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns12,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns12,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns12,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns12,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns12,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns12,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/bg.mjs
var bg = {
  code: "bg",
  formatDistance: formatDistance13,
  formatLong: formatLong12,
  formatRelative: formatRelative12,
  localize: localize12,
  match: match12,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/bn/_lib/localize.mjs
var numberValues = {
  locale: {
    1: "১",
    2: "২",
    3: "৩",
    4: "৪",
    5: "৫",
    6: "৬",
    7: "৭",
    8: "৮",
    9: "৯",
    0: "০"
  },
  number: {
    "১": "1",
    "২": "2",
    "৩": "3",
    "৪": "4",
    "৫": "5",
    "৬": "6",
    "৭": "7",
    "৮": "8",
    "৯": "9",
    "০": "0"
  }
};
var eraValues13 = {
  narrow: ["খ্রিঃপূঃ", "খ্রিঃ"],
  abbreviated: ["খ্রিঃপূর্ব", "খ্রিঃ"],
  wide: ["খ্রিস্টপূর্ব", "খ্রিস্টাব্দ"]
};
var quarterValues13 = {
  narrow: ["১", "২", "৩", "৪"],
  abbreviated: ["১ত্রৈ", "২ত্রৈ", "৩ত্রৈ", "৪ত্রৈ"],
  wide: ["১ম ত্রৈমাসিক", "২য় ত্রৈমাসিক", "৩য় ত্রৈমাসিক", "৪র্থ ত্রৈমাসিক"]
};
var monthValues13 = {
  narrow: [
    "জানু",
    "ফেব্রু",
    "মার্চ",
    "এপ্রিল",
    "মে",
    "জুন",
    "জুলাই",
    "আগস্ট",
    "সেপ্ট",
    "অক্টো",
    "নভে",
    "ডিসে"
  ],
  abbreviated: [
    "জানু",
    "ফেব্রু",
    "মার্চ",
    "এপ্রিল",
    "মে",
    "জুন",
    "জুলাই",
    "আগস্ট",
    "সেপ্ট",
    "অক্টো",
    "নভে",
    "ডিসে"
  ],
  wide: [
    "জানুয়ারি",
    "ফেব্রুয়ারি",
    "মার্চ",
    "এপ্রিল",
    "মে",
    "জুন",
    "জুলাই",
    "আগস্ট",
    "সেপ্টেম্বর",
    "অক্টোবর",
    "নভেম্বর",
    "ডিসেম্বর"
  ]
};
var dayValues13 = {
  narrow: ["র", "সো", "ম", "বু", "বৃ", "শু", "শ"],
  short: ["রবি", "সোম", "মঙ্গল", "বুধ", "বৃহ", "শুক্র", "শনি"],
  abbreviated: ["রবি", "সোম", "মঙ্গল", "বুধ", "বৃহ", "শুক্র", "শনি"],
  wide: [
    "রবিবার",
    "সোমবার",
    "মঙ্গলবার",
    "বুধবার",
    "বৃহস্পতিবার ",
    "শুক্রবার",
    "শনিবার"
  ]
};
var dayPeriodValues13 = {
  narrow: {
    am: "পূ",
    pm: "অপ",
    midnight: "মধ্যরাত",
    noon: "মধ্যাহ্ন",
    morning: "সকাল",
    afternoon: "বিকাল",
    evening: "সন্ধ্যা",
    night: "রাত"
  },
  abbreviated: {
    am: "পূর্বাহ্ন",
    pm: "অপরাহ্ন",
    midnight: "মধ্যরাত",
    noon: "মধ্যাহ্ন",
    morning: "সকাল",
    afternoon: "বিকাল",
    evening: "সন্ধ্যা",
    night: "রাত"
  },
  wide: {
    am: "পূর্বাহ্ন",
    pm: "অপরাহ্ন",
    midnight: "মধ্যরাত",
    noon: "মধ্যাহ্ন",
    morning: "সকাল",
    afternoon: "বিকাল",
    evening: "সন্ধ্যা",
    night: "রাত"
  }
};
var formattingDayPeriodValues12 = {
  narrow: {
    am: "পূ",
    pm: "অপ",
    midnight: "মধ্যরাত",
    noon: "মধ্যাহ্ন",
    morning: "সকাল",
    afternoon: "বিকাল",
    evening: "সন্ধ্যা",
    night: "রাত"
  },
  abbreviated: {
    am: "পূর্বাহ্ন",
    pm: "অপরাহ্ন",
    midnight: "মধ্যরাত",
    noon: "মধ্যাহ্ন",
    morning: "সকাল",
    afternoon: "বিকাল",
    evening: "সন্ধ্যা",
    night: "রাত"
  },
  wide: {
    am: "পূর্বাহ্ন",
    pm: "অপরাহ্ন",
    midnight: "মধ্যরাত",
    noon: "মধ্যাহ্ন",
    morning: "সকাল",
    afternoon: "বিকাল",
    evening: "সন্ধ্যা",
    night: "রাত"
  }
};
function dateOrdinalNumber(number2, localeNumber) {
  if (number2 > 18 && number2 <= 31) {
    return localeNumber + "শে";
  } else {
    switch (number2) {
      case 1:
        return localeNumber + "লা";
      case 2:
      case 3:
        return localeNumber + "রা";
      case 4:
        return localeNumber + "ঠা";
      default:
        return localeNumber + "ই";
    }
  }
}
var ordinalNumber13 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const localeNumber = numberToLocale(number2);
  const unit = options2 == null ? void 0 : options2.unit;
  if (unit === "date") {
    return dateOrdinalNumber(number2, localeNumber);
  }
  if (number2 > 10 || number2 === 0) return localeNumber + "তম";
  const rem10 = number2 % 10;
  switch (rem10) {
    case 2:
    case 3:
      return localeNumber + "য়";
    case 4:
      return localeNumber + "র্থ";
    case 6:
      return localeNumber + "ষ্ঠ";
    default:
      return localeNumber + "ম";
  }
};
function numberToLocale(enNumber) {
  return enNumber.toString().replace(/\d/g, function(match85) {
    return numberValues.locale[match85];
  });
}
var localize13 = {
  ordinalNumber: ordinalNumber13,
  era: buildLocalizeFn({
    values: eraValues13,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues13,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues13,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues13,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues13,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues12,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/bn/_lib/formatDistance.mjs
var formatDistanceLocale13 = {
  lessThanXSeconds: {
    one: "প্রায় ১ সেকেন্ড",
    other: "প্রায় {{count}} সেকেন্ড"
  },
  xSeconds: {
    one: "১ সেকেন্ড",
    other: "{{count}} সেকেন্ড"
  },
  halfAMinute: "আধ মিনিট",
  lessThanXMinutes: {
    one: "প্রায় ১ মিনিট",
    other: "প্রায় {{count}} মিনিট"
  },
  xMinutes: {
    one: "১ মিনিট",
    other: "{{count}} মিনিট"
  },
  aboutXHours: {
    one: "প্রায় ১ ঘন্টা",
    other: "প্রায় {{count}} ঘন্টা"
  },
  xHours: {
    one: "১ ঘন্টা",
    other: "{{count}} ঘন্টা"
  },
  xDays: {
    one: "১ দিন",
    other: "{{count}} দিন"
  },
  aboutXWeeks: {
    one: "প্রায় ১ সপ্তাহ",
    other: "প্রায় {{count}} সপ্তাহ"
  },
  xWeeks: {
    one: "১ সপ্তাহ",
    other: "{{count}} সপ্তাহ"
  },
  aboutXMonths: {
    one: "প্রায় ১ মাস",
    other: "প্রায় {{count}} মাস"
  },
  xMonths: {
    one: "১ মাস",
    other: "{{count}} মাস"
  },
  aboutXYears: {
    one: "প্রায় ১ বছর",
    other: "প্রায় {{count}} বছর"
  },
  xYears: {
    one: "১ বছর",
    other: "{{count}} বছর"
  },
  overXYears: {
    one: "১ বছরের বেশি",
    other: "{{count}} বছরের বেশি"
  },
  almostXYears: {
    one: "প্রায় ১ বছর",
    other: "প্রায় {{count}} বছর"
  }
};
var formatDistance14 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale13[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", numberToLocale(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + " এর মধ্যে";
    } else {
      return result + " আগে";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/bn/_lib/formatLong.mjs
var dateFormats13 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats13 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats13 = {
  full: "{{date}} {{time}} 'সময়'",
  long: "{{date}} {{time}} 'সময়'",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong13 = {
  date: buildFormatLongFn({
    formats: dateFormats13,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats13,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats13,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/bn/_lib/formatRelative.mjs
var formatRelativeLocale13 = {
  lastWeek: "'গত' eeee 'সময়' p",
  yesterday: "'গতকাল' 'সময়' p",
  today: "'আজ' 'সময়' p",
  tomorrow: "'আগামীকাল' 'সময়' p",
  nextWeek: "eeee 'সময়' p",
  other: "P"
};
var formatRelative13 = (token, _date, _baseDate, _options) => formatRelativeLocale13[token];

// ../../../node_modules/date-fns/locale/bn/_lib/match.mjs
var matchOrdinalNumberPattern13 = /^(\d+)(ম|য়|র্থ|ষ্ঠ|শে|ই|তম)?/i;
var parseOrdinalNumberPattern13 = /\d+/i;
var matchEraPatterns13 = {
  narrow: /^(খ্রিঃপূঃ|খ্রিঃ)/i,
  abbreviated: /^(খ্রিঃপূর্ব|খ্রিঃ)/i,
  wide: /^(খ্রিস্টপূর্ব|খ্রিস্টাব্দ)/i
};
var parseEraPatterns13 = {
  narrow: [/^খ্রিঃপূঃ/i, /^খ্রিঃ/i],
  abbreviated: [/^খ্রিঃপূর্ব/i, /^খ্রিঃ/i],
  wide: [/^খ্রিস্টপূর্ব/i, /^খ্রিস্টাব্দ/i]
};
var matchQuarterPatterns13 = {
  narrow: /^[১২৩৪]/i,
  abbreviated: /^[১২৩৪]ত্রৈ/i,
  wide: /^[১২৩৪](ম|য়|র্থ)? ত্রৈমাসিক/i
};
var parseQuarterPatterns13 = {
  any: [/১/i, /২/i, /৩/i, /৪/i]
};
var matchMonthPatterns13 = {
  narrow: /^(জানু|ফেব্রু|মার্চ|এপ্রিল|মে|জুন|জুলাই|আগস্ট|সেপ্ট|অক্টো|নভে|ডিসে)/i,
  abbreviated: /^(জানু|ফেব্রু|মার্চ|এপ্রিল|মে|জুন|জুলাই|আগস্ট|সেপ্ট|অক্টো|নভে|ডিসে)/i,
  wide: /^(জানুয়ারি|ফেব্রুয়ারি|মার্চ|এপ্রিল|মে|জুন|জুলাই|আগস্ট|সেপ্টেম্বর|অক্টোবর|নভেম্বর|ডিসেম্বর)/i
};
var parseMonthPatterns13 = {
  any: [
    /^জানু/i,
    /^ফেব্রু/i,
    /^মার্চ/i,
    /^এপ্রিল/i,
    /^মে/i,
    /^জুন/i,
    /^জুলাই/i,
    /^আগস্ট/i,
    /^সেপ্ট/i,
    /^অক্টো/i,
    /^নভে/i,
    /^ডিসে/i
  ]
};
var matchDayPatterns13 = {
  narrow: /^(র|সো|ম|বু|বৃ|শু|শ)+/i,
  short: /^(রবি|সোম|মঙ্গল|বুধ|বৃহ|শুক্র|শনি)+/i,
  abbreviated: /^(রবি|সোম|মঙ্গল|বুধ|বৃহ|শুক্র|শনি)+/i,
  wide: /^(রবিবার|সোমবার|মঙ্গলবার|বুধবার|বৃহস্পতিবার |শুক্রবার|শনিবার)+/i
};
var parseDayPatterns13 = {
  narrow: [/^র/i, /^সো/i, /^ম/i, /^বু/i, /^বৃ/i, /^শু/i, /^শ/i],
  short: [/^রবি/i, /^সোম/i, /^মঙ্গল/i, /^বুধ/i, /^বৃহ/i, /^শুক্র/i, /^শনি/i],
  abbreviated: [
    /^রবি/i,
    /^সোম/i,
    /^মঙ্গল/i,
    /^বুধ/i,
    /^বৃহ/i,
    /^শুক্র/i,
    /^শনি/i
  ],
  wide: [
    /^রবিবার/i,
    /^সোমবার/i,
    /^মঙ্গলবার/i,
    /^বুধবার/i,
    /^বৃহস্পতিবার /i,
    /^শুক্রবার/i,
    /^শনিবার/i
  ]
};
var matchDayPeriodPatterns13 = {
  narrow: /^(পূ|অপ|মধ্যরাত|মধ্যাহ্ন|সকাল|বিকাল|সন্ধ্যা|রাত)/i,
  abbreviated: /^(পূর্বাহ্ন|অপরাহ্ন|মধ্যরাত|মধ্যাহ্ন|সকাল|বিকাল|সন্ধ্যা|রাত)/i,
  wide: /^(পূর্বাহ্ন|অপরাহ্ন|মধ্যরাত|মধ্যাহ্ন|সকাল|বিকাল|সন্ধ্যা|রাত)/i
};
var parseDayPeriodPatterns13 = {
  any: {
    am: /^পূ/i,
    pm: /^অপ/i,
    midnight: /^মধ্যরাত/i,
    noon: /^মধ্যাহ্ন/i,
    morning: /সকাল/i,
    afternoon: /বিকাল/i,
    evening: /সন্ধ্যা/i,
    night: /রাত/i
  }
};
var match13 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern13,
    parsePattern: parseOrdinalNumberPattern13,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns13,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns13,
    defaultParseWidth: "wide"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns13,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns13,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns13,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns13,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns13,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns13,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns13,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns13,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/bn.mjs
var bn = {
  code: "bn",
  formatDistance: formatDistance14,
  formatLong: formatLong13,
  formatRelative: formatRelative13,
  localize: localize13,
  match: match13,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/bs/_lib/formatDistance.mjs
var formatDistanceLocale14 = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu"
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi"
  },
  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu"
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi"
  },
  halfAMinute: "pola minute",
  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu"
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta"
  },
  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu"
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta"
  },
  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat"
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati"
  },
  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat"
    },
    dual: "{{count}} sata",
    other: "{{count}} sati"
  },
  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan"
    },
    dual: "{{count}} dana",
    other: "{{count}} dana"
  },
  aboutXWeeks: {
    one: {
      standalone: "oko 1 sedmicu",
      withPrepositionAgo: "oko 1 sedmicu",
      withPrepositionIn: "oko 1 sedmicu"
    },
    dual: "oko {{count}} sedmice",
    other: "oko {{count}} sedmice"
  },
  xWeeks: {
    one: {
      standalone: "1 sedmicu",
      withPrepositionAgo: "1 sedmicu",
      withPrepositionIn: "1 sedmicu"
    },
    dual: "{{count}} sedmice",
    other: "{{count}} sedmice"
  },
  aboutXMonths: {
    one: {
      standalone: "oko 1 mjesec",
      withPrepositionAgo: "oko 1 mjesec",
      withPrepositionIn: "oko 1 mjesec"
    },
    dual: "oko {{count}} mjeseca",
    other: "oko {{count}} mjeseci"
  },
  xMonths: {
    one: {
      standalone: "1 mjesec",
      withPrepositionAgo: "1 mjesec",
      withPrepositionIn: "1 mjesec"
    },
    dual: "{{count}} mjeseca",
    other: "{{count}} mjeseci"
  },
  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu"
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina"
  },
  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu"
    },
    dual: "{{count}} godine",
    other: "{{count}} godina"
  },
  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu"
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina"
  },
  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu"
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina"
  }
};
var formatDistance15 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale14[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options2 == null ? void 0 : options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
  String(count).substr(-2, 1) !== "1") {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "za " + result;
    } else {
      return "prije " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/bs/_lib/formatLong.mjs
var dateFormats14 = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy."
};
var timeFormats14 = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats14 = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong14 = {
  date: buildFormatLongFn({
    formats: dateFormats14,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats14,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats14,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/bs/_lib/formatRelative.mjs
var formatRelativeLocale14 = {
  lastWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'prošle nedjelje u' p";
      case 3:
        return "'prošle srijede u' p";
      case 6:
        return "'prošle subote u' p";
      default:
        return "'prošli' EEEE 'u' p";
    }
  },
  yesterday: "'juče u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'sljedeće nedjelje u' p";
      case 3:
        return "'sljedeću srijedu u' p";
      case 6:
        return "'sljedeću subotu u' p";
      default:
        return "'sljedeći' EEEE 'u' p";
    }
  },
  other: "P"
};
var formatRelative14 = (token, date2, _baseDate, _options) => {
  const format3 = formatRelativeLocale14[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/bs/_lib/localize.mjs
var eraValues14 = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Hr.", "po. Hr."],
  wide: ["Prije Hrista", "Poslije Hrista"]
};
var quarterValues14 = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
var monthValues14 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "juni",
    "juli",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar"
  ]
};
var formattingMonthValues3 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "juni",
    "juli",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar"
  ]
};
var dayValues14 = {
  narrow: ["N", "P", "U", "S", "Č", "P", "S"],
  short: ["ned", "pon", "uto", "sre", "čet", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sre", "čet", "pet", "sub"],
  wide: [
    "nedjelja",
    "ponedjeljak",
    "utorak",
    "srijeda",
    "četvrtak",
    "petak",
    "subota"
  ]
};
var dayPeriodValues14 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveče",
    night: "noću"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveče",
    night: "noću"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "poslije podne",
    evening: "uveče",
    night: "noću"
  }
};
var formattingDayPeriodValues13 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveče",
    night: "noću"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveče",
    night: "noću"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "poslije podne",
    evening: "uveče",
    night: "noću"
  }
};
var ordinalNumber14 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return String(number2) + ".";
};
var localize14 = {
  ordinalNumber: ordinalNumber14,
  era: buildLocalizeFn({
    values: eraValues14,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues14,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues14,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues3,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues14,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues14,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues13,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/bs/_lib/match.mjs
var matchOrdinalNumberPattern14 = /^(\d+)\./i;
var parseOrdinalNumberPattern14 = /\d+/i;
var matchEraPatterns14 = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Hr\.|po\.\s?Hr\.)/i,
  wide: /^(Prije Hrista|prije nove ere|Poslije Hrista|nova era)/i
};
var parseEraPatterns14 = {
  any: [/^pr/i, /^(po|nova)/i]
};
var matchQuarterPatterns14 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i
};
var parseQuarterPatterns14 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns14 = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,
  wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(juni|juna)|(juli|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i
};
var parseMonthPatterns14 = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^avg/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns14 = {
  narrow: /^[npusčc]/i,
  short: /^(ned|pon|uto|sre|(čet|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sre|(čet|cet)|pet|sub)/i,
  wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(četvrtak|cetvrtak)|petak|subota)/i
};
var parseDayPatterns14 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns14 = {
  any: /^(am|pm|ponoc|ponoć|(po)?podne|uvece|uveče|noću|poslije podne|ujutru)/i
};
var parseDayPeriodPatterns14 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(poslije\s|po)+podne/i,
    evening: /(uvece|uveče)/i,
    night: /(nocu|noću)/i
  }
};
var match14 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern14,
    parsePattern: parseOrdinalNumberPattern14,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns14,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns14,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns14,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns14,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns14,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns14,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns14,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns14,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns14,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns14,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/bs.mjs
var bs = {
  code: "bs",
  formatDistance: formatDistance15,
  formatLong: formatLong14,
  formatRelative: formatRelative14,
  localize: localize14,
  match: match14,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/ca/_lib/formatDistance.mjs
var formatDistanceLocale15 = {
  lessThanXSeconds: {
    one: "menys d'un segon",
    eleven: "menys d'onze segons",
    other: "menys de {{count}} segons"
  },
  xSeconds: {
    one: "1 segon",
    other: "{{count}} segons"
  },
  halfAMinute: "mig minut",
  lessThanXMinutes: {
    one: "menys d'un minut",
    eleven: "menys d'onze minuts",
    other: "menys de {{count}} minuts"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minuts"
  },
  aboutXHours: {
    one: "aproximadament una hora",
    other: "aproximadament {{count}} hores"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} hores"
  },
  xDays: {
    one: "1 dia",
    other: "{{count}} dies"
  },
  aboutXWeeks: {
    one: "aproximadament una setmana",
    other: "aproximadament {{count}} setmanes"
  },
  xWeeks: {
    one: "1 setmana",
    other: "{{count}} setmanes"
  },
  aboutXMonths: {
    one: "aproximadament un mes",
    other: "aproximadament {{count}} mesos"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} mesos"
  },
  aboutXYears: {
    one: "aproximadament un any",
    other: "aproximadament {{count}} anys"
  },
  xYears: {
    one: "1 any",
    other: "{{count}} anys"
  },
  overXYears: {
    one: "més d'un any",
    eleven: "més d'onze anys",
    other: "més de {{count}} anys"
  },
  almostXYears: {
    one: "gairebé un any",
    other: "gairebé {{count}} anys"
  }
};
var formatDistance16 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale15[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 11 && tokenValue.eleven) {
    result = tokenValue.eleven;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "en " + result;
    } else {
      return "fa " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ca/_lib/formatLong.mjs
var dateFormats15 = {
  full: "EEEE, d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats15 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats15 = {
  full: "{{date}} 'a les' {{time}}",
  long: "{{date}} 'a les' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong15 = {
  date: buildFormatLongFn({
    formats: dateFormats15,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats15,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats15,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ca/_lib/formatRelative.mjs
var formatRelativeLocale15 = {
  lastWeek: "'el' eeee 'passat a la' LT",
  yesterday: "'ahir a la' p",
  today: "'avui a la' p",
  tomorrow: "'demà a la' p",
  nextWeek: "eeee 'a la' p",
  other: "P"
};
var formatRelativeLocalePlural = {
  lastWeek: "'el' eeee 'passat a les' p",
  yesterday: "'ahir a les' p",
  today: "'avui a les' p",
  tomorrow: "'demà a les' p",
  nextWeek: "eeee 'a les' p",
  other: "P"
};
var formatRelative15 = (token, date2, _baseDate, _options) => {
  if (date2.getHours() !== 1) {
    return formatRelativeLocalePlural[token];
  }
  return formatRelativeLocale15[token];
};

// ../../../node_modules/date-fns/locale/ca/_lib/localize.mjs
var eraValues15 = {
  narrow: ["aC", "dC"],
  abbreviated: ["a. de C.", "d. de C."],
  wide: ["abans de Crist", "després de Crist"]
};
var quarterValues15 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1r trimestre", "2n trimestre", "3r trimestre", "4t trimestre"]
};
var monthValues15 = {
  narrow: [
    "GN",
    "FB",
    "MÇ",
    "AB",
    "MG",
    "JN",
    "JL",
    "AG",
    "ST",
    "OC",
    "NV",
    "DS"
  ],
  /**
   * Les abreviatures dels mesos de l'any es formen seguint una de les normes generals de formació d'abreviatures.
   * S'escriu la primera síl·laba i les consonants de la síl·laba següent anteriors a la primera vocal.
   * Els mesos de març, maig i juny no s'abreugen perquè són paraules d'una sola síl·laba.
   */
  abbreviated: [
    "gen.",
    "febr.",
    "març",
    "abr.",
    "maig",
    "juny",
    "jul.",
    "ag.",
    "set.",
    "oct.",
    "nov.",
    "des."
  ],
  wide: [
    "gener",
    "febrer",
    "març",
    "abril",
    "maig",
    "juny",
    "juliol",
    "agost",
    "setembre",
    "octubre",
    "novembre",
    "desembre"
  ]
};
var dayValues15 = {
  narrow: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  short: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  abbreviated: ["dg.", "dl.", "dt.", "dm.", "dj.", "dv.", "ds."],
  wide: [
    "diumenge",
    "dilluns",
    "dimarts",
    "dimecres",
    "dijous",
    "divendres",
    "dissabte"
  ]
};
var dayPeriodValues15 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "matí",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "matí",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit"
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "mitjanit",
    noon: "migdia",
    morning: "matí",
    afternoon: "tarda",
    evening: "vespre",
    night: "nit"
  }
};
var formattingDayPeriodValues14 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del matí",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del matí",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit"
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "de la mitjanit",
    noon: "del migdia",
    morning: "del matí",
    afternoon: "de la tarda",
    evening: "del vespre",
    night: "de la nit"
  }
};
var ordinalNumber15 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "r";
      case 2:
        return number2 + "n";
      case 3:
        return number2 + "r";
      case 4:
        return number2 + "t";
    }
  }
  return number2 + "è";
};
var localize15 = {
  ordinalNumber: ordinalNumber15,
  era: buildLocalizeFn({
    values: eraValues15,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues15,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues15,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues15,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues15,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues14,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ca/_lib/match.mjs
var matchOrdinalNumberPattern15 = /^(\d+)(è|r|n|r|t)?/i;
var parseOrdinalNumberPattern15 = /\d+/i;
var matchEraPatterns15 = {
  narrow: /^(aC|dC)/i,
  abbreviated: /^(a. de C.|d. de C.)/i,
  wide: /^(abans de Crist|despr[eé]s de Crist)/i
};
var parseEraPatterns15 = {
  narrow: [/^aC/i, /^dC/i],
  abbreviated: [/^(a. de C.)/i, /^(d. de C.)/i],
  wide: [/^(abans de Crist)/i, /^(despr[eé]s de Crist)/i]
};
var matchQuarterPatterns15 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](è|r|n|r|t)? trimestre/i
};
var parseQuarterPatterns15 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns15 = {
  narrow: /^(GN|FB|MÇ|AB|MG|JN|JL|AG|ST|OC|NV|DS)/i,
  abbreviated: /^(gen.|febr.|març|abr.|maig|juny|jul.|ag.|set.|oct.|nov.|des.)/i,
  wide: /^(gener|febrer|març|abril|maig|juny|juliol|agost|setembre|octubre|novembre|desembre)/i
};
var parseMonthPatterns15 = {
  narrow: [
    /^GN/i,
    /^FB/i,
    /^MÇ/i,
    /^AB/i,
    /^MG/i,
    /^JN/i,
    /^JL/i,
    /^AG/i,
    /^ST/i,
    /^OC/i,
    /^NV/i,
    /^DS/i
  ],
  abbreviated: [
    /^gen./i,
    /^febr./i,
    /^març/i,
    /^abr./i,
    /^maig/i,
    /^juny/i,
    /^jul./i,
    /^ag./i,
    /^set./i,
    /^oct./i,
    /^nov./i,
    /^des./i
  ],
  wide: [
    /^gener/i,
    /^febrer/i,
    /^març/i,
    /^abril/i,
    /^maig/i,
    /^juny/i,
    /^juliol/i,
    /^agost/i,
    /^setembre/i,
    /^octubre/i,
    /^novembre/i,
    /^desembre/i
  ]
};
var matchDayPatterns15 = {
  narrow: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  short: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  abbreviated: /^(dg\.|dl\.|dt\.|dm\.|dj\.|dv\.|ds\.)/i,
  wide: /^(diumenge|dilluns|dimarts|dimecres|dijous|divendres|dissabte)/i
};
var parseDayPatterns15 = {
  narrow: [/^dg./i, /^dl./i, /^dt./i, /^dm./i, /^dj./i, /^dv./i, /^ds./i],
  abbreviated: [/^dg./i, /^dl./i, /^dt./i, /^dm./i, /^dj./i, /^dv./i, /^ds./i],
  wide: [
    /^diumenge/i,
    /^dilluns/i,
    /^dimarts/i,
    /^dimecres/i,
    /^dijous/i,
    /^divendres/i,
    /^disssabte/i
  ]
};
var matchDayPeriodPatterns15 = {
  narrow: /^(a|p|mn|md|(del|de la) (matí|tarda|vespre|nit))/i,
  abbreviated: /^([ap]\.?\s?m\.?|mitjanit|migdia|(del|de la) (matí|tarda|vespre|nit))/i,
  wide: /^(ante meridiem|post meridiem|mitjanit|migdia|(del|de la) (matí|tarda|vespre|nit))/i
};
var parseDayPeriodPatterns15 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mitjanit/i,
    noon: /^migdia/i,
    morning: /matí/i,
    afternoon: /tarda/i,
    evening: /vespre/i,
    night: /nit/i
  }
};
var match15 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern15,
    parsePattern: parseOrdinalNumberPattern15,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns15,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns15,
    defaultParseWidth: "wide"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns15,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns15,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns15,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns15,
    defaultParseWidth: "wide"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns15,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns15,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns15,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns15,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ca.mjs
var ca = {
  code: "ca",
  formatDistance: formatDistance16,
  formatLong: formatLong15,
  formatRelative: formatRelative15,
  localize: localize15,
  match: match15,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/ckb/_lib/formatDistance.mjs
var formatDistanceLocale16 = {
  lessThanXSeconds: {
    one: "کەمتر لە یەک چرکە",
    other: "کەمتر لە {{count}} چرکە"
  },
  xSeconds: {
    one: "1 چرکە",
    other: "{{count}} چرکە"
  },
  halfAMinute: "نیو کاتژمێر",
  lessThanXMinutes: {
    one: "کەمتر لە یەک خولەک",
    other: "کەمتر لە {{count}} خولەک"
  },
  xMinutes: {
    one: "1 خولەک",
    other: "{{count}} خولەک"
  },
  aboutXHours: {
    one: "دەوروبەری 1 کاتژمێر",
    other: "دەوروبەری {{count}} کاتژمێر"
  },
  xHours: {
    one: "1 کاتژمێر",
    other: "{{count}} کاتژمێر"
  },
  xDays: {
    one: "1 ڕۆژ",
    other: "{{count}} ژۆژ"
  },
  aboutXWeeks: {
    one: "دەوروبەری 1 هەفتە",
    other: "دوروبەری {{count}} هەفتە"
  },
  xWeeks: {
    one: "1 هەفتە",
    other: "{{count}} هەفتە"
  },
  aboutXMonths: {
    one: "داوروبەری 1 مانگ",
    other: "دەوروبەری {{count}} مانگ"
  },
  xMonths: {
    one: "1 مانگ",
    other: "{{count}} مانگ"
  },
  aboutXYears: {
    one: "دەوروبەری  1 ساڵ",
    other: "دەوروبەری {{count}} ساڵ"
  },
  xYears: {
    one: "1 ساڵ",
    other: "{{count}} ساڵ"
  },
  overXYears: {
    one: "زیاتر لە ساڵێک",
    other: "زیاتر لە {{count}} ساڵ"
  },
  almostXYears: {
    one: "بەنزیکەیی ساڵێک  ",
    other: "بەنزیکەیی {{count}} ساڵ"
  }
};
var formatDistance17 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale16[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "لە ماوەی " + result + "دا";
    } else {
      return result + "پێش ئێستا";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ckb/_lib/formatLong.mjs
var dateFormats16 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats16 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats16 = {
  full: "{{date}} 'کاتژمێر' {{time}}",
  long: "{{date}} 'کاتژمێر' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong16 = {
  date: buildFormatLongFn({
    formats: dateFormats16,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats16,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats16,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ckb/_lib/formatRelative.mjs
var formatRelativeLocale16 = {
  lastWeek: "'هەفتەی ڕابردوو' eeee 'کاتژمێر' p",
  yesterday: "'دوێنێ کاتژمێر' p",
  today: "'ئەمڕۆ کاتژمێر' p",
  tomorrow: "'بەیانی کاتژمێر' p",
  nextWeek: "eeee 'کاتژمێر' p",
  other: "P"
};
var formatRelative16 = (token, _date, _baseDate, _options) => formatRelativeLocale16[token];

// ../../../node_modules/date-fns/locale/ckb/_lib/localize.mjs
var eraValues16 = {
  narrow: ["پ", "د"],
  abbreviated: ["پ-ز", "د-ز"],
  wide: ["پێش زاین", "دوای زاین"]
};
var quarterValues16 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["چ1م", "چ2م", "چ3م", "چ4م"],
  wide: ["چارەگی یەکەم", "چارەگی دووەم", "چارەگی سێیەم", "چارەگی چوارەم"]
};
var monthValues16 = {
  narrow: [
    "ک-د",
    "ش",
    "ئا",
    "ن",
    "م",
    "ح",
    "ت",
    "ئا",
    "ئە",
    "تش-ی",
    "تش-د",
    "ک-ی"
  ],
  abbreviated: [
    "کان-دوو",
    "شوب",
    "ئاد",
    "نیس",
    "مایس",
    "حوز",
    "تەم",
    "ئاب",
    "ئەل",
    "تش-یەک",
    "تش-دوو",
    "کان-یەک"
  ],
  wide: [
    "کانوونی دووەم",
    "شوبات",
    "ئادار",
    "نیسان",
    "مایس",
    "حوزەیران",
    "تەمموز",
    "ئاب",
    "ئەیلول",
    "تشرینی یەکەم",
    "تشرینی دووەم",
    "کانوونی یەکەم"
  ]
};
var dayValues16 = {
  narrow: ["ی-ش", "د-ش", "س-ش", "چ-ش", "پ-ش", "هە", "ش"],
  short: ["یە-شە", "دوو-شە", "سێ-شە", "چو-شە", "پێ-شە", "هەی", "شە"],
  abbreviated: [
    "یەک-شەم",
    "دوو-شەم",
    "سێ-شەم",
    "چوار-شەم",
    "پێنج-شەم",
    "هەینی",
    "شەمە"
  ],
  wide: [
    "یەک شەمە",
    "دوو شەمە",
    "سێ شەمە",
    "چوار شەمە",
    "پێنج شەمە",
    "هەینی",
    "شەمە"
  ]
};
var dayPeriodValues16 = {
  narrow: {
    am: "پ",
    pm: "د",
    midnight: "ن-ش",
    noon: "ن",
    morning: "بەیانی",
    afternoon: "دوای نیوەڕۆ",
    evening: "ئێوارە",
    night: "شەو"
  },
  abbreviated: {
    am: "پ-ن",
    pm: "د-ن",
    midnight: "نیوە شەو",
    noon: "نیوەڕۆ",
    morning: "بەیانی",
    afternoon: "دوای نیوەڕۆ",
    evening: "ئێوارە",
    night: "شەو"
  },
  wide: {
    am: "پێش نیوەڕۆ",
    pm: "دوای نیوەڕۆ",
    midnight: "نیوە شەو",
    noon: "نیوەڕۆ",
    morning: "بەیانی",
    afternoon: "دوای نیوەڕۆ",
    evening: "ئێوارە",
    night: "شەو"
  }
};
var formattingDayPeriodValues15 = {
  narrow: {
    am: "پ",
    pm: "د",
    midnight: "ن-ش",
    noon: "ن",
    morning: "لە بەیانیدا",
    afternoon: "لە دوای نیوەڕۆدا",
    evening: "لە ئێوارەدا",
    night: "لە شەودا"
  },
  abbreviated: {
    am: "پ-ن",
    pm: "د-ن",
    midnight: "نیوە شەو",
    noon: "نیوەڕۆ",
    morning: "لە بەیانیدا",
    afternoon: "لە دوای نیوەڕۆدا",
    evening: "لە ئێوارەدا",
    night: "لە شەودا"
  },
  wide: {
    am: "پێش نیوەڕۆ",
    pm: "دوای نیوەڕۆ",
    midnight: "نیوە شەو",
    noon: "نیوەڕۆ",
    morning: "لە بەیانیدا",
    afternoon: "لە دوای نیوەڕۆدا",
    evening: "لە ئێوارەدا",
    night: "لە شەودا"
  }
};
var ordinalNumber16 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize16 = {
  ordinalNumber: ordinalNumber16,
  era: buildLocalizeFn({
    values: eraValues16,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues16,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues16,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues16,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues16,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues15,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ckb/_lib/match.mjs
var matchOrdinalNumberPattern16 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern16 = /\d+/i;
var matchEraPatterns16 = {
  narrow: /^(پ|د)/i,
  abbreviated: /^(پ-ز|د.ز)/i,
  wide: /^(پێش زاین| دوای زاین)/i
};
var parseEraPatterns16 = {
  any: [/^د/g, /^پ/g]
};
var matchQuarterPatterns16 = {
  narrow: /^[1234]/i,
  abbreviated: /^م[1234]چ/i,
  wide: /^(یەکەم|دووەم|سێیەم| چوارەم) (چارەگی)? quarter/i
};
var parseQuarterPatterns16 = {
  wide: [/چارەگی یەکەم/, /چارەگی دووەم/, /چارەگی سيیەم/, /چارەگی چوارەم/],
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns16 = {
  narrow: /^(ک-د|ش|ئا|ن|م|ح|ت|ئە|تش-ی|تش-د|ک-ی)/i,
  abbreviated: /^(کان-دوو|شوب|ئاد|نیس|مایس|حوز|تەم|ئاب|ئەل|تش-یەک|تش-دوو|کان-یەک)/i,
  wide: /^(کانوونی دووەم|شوبات|ئادار|نیسان|مایس|حوزەیران|تەمموز|ئاب|ئەیلول|تشرینی یەکەم|تشرینی دووەم|کانوونی یەکەم)/i
};
var parseMonthPatterns16 = {
  narrow: [
    /^ک-د/i,
    /^ش/i,
    /^ئا/i,
    /^ن/i,
    /^م/i,
    /^ح/i,
    /^ت/i,
    /^ئا/i,
    /^ئە/i,
    /^تش-ی/i,
    /^تش-د/i,
    /^ک-ی/i
  ],
  any: [
    /^کان-دوو/i,
    /^شوب/i,
    /^ئاد/i,
    /^نیس/i,
    /^مایس/i,
    /^حوز/i,
    /^تەم/i,
    /^ئاب/i,
    /^ئەل/i,
    /^تش-یەک/i,
    /^تش-دوو/i,
    /^|کان-یەک/i
  ]
};
var matchDayPatterns16 = {
  narrow: /^(ش|ی|د|س|چ|پ|هە)/i,
  short: /^(یە-شە|دوو-شە|سێ-شە|چو-شە|پێ-شە|هە|شە)/i,
  abbreviated: /^(یەک-شەم|دوو-شەم|سێ-شەم|چوار-شەم|پێنخ-شەم|هەینی|شەمە)/i,
  wide: /^(یەک شەمە|دوو شەمە|سێ شەمە|چوار شەمە|پێنج شەمە|هەینی|شەمە)/i
};
var parseDayPatterns16 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns16 = {
  narrow: /^(پ|د|ن-ش|ن| (بەیانی|دوای نیوەڕۆ|ئێوارە|شەو))/i,
  abbreviated: /^(پ-ن|د-ن|نیوە شەو|نیوەڕۆ|بەیانی|دوای نیوەڕۆ|ئێوارە|شەو)/,
  wide: /^(پێش نیوەڕۆ|دوای نیوەڕۆ|نیوەڕۆ|نیوە شەو|لەبەیانیدا|لەدواینیوەڕۆدا|لە ئێوارەدا|لە شەودا)/,
  any: /^(پ|د|بەیانی|نیوەڕۆ|ئێوارە|شەو)/
};
var parseDayPeriodPatterns16 = {
  any: {
    am: /^د/i,
    pm: /^پ/i,
    midnight: /^ن-ش/i,
    noon: /^ن/i,
    morning: /بەیانی/i,
    afternoon: /دواینیوەڕۆ/i,
    evening: /ئێوارە/i,
    night: /شەو/i
  }
};
var match16 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern16,
    parsePattern: parseOrdinalNumberPattern16,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns16,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns16,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns16,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns16,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns16,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns16,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns16,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns16,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns16,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns16,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ckb.mjs
var ckb = {
  code: "ckb",
  formatDistance: formatDistance17,
  formatLong: formatLong16,
  formatRelative: formatRelative16,
  localize: localize16,
  match: match16,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/cs/_lib/formatDistance.mjs
var formatDistanceLocale17 = {
  lessThanXSeconds: {
    one: {
      regular: "méně než 1 sekunda",
      past: "před méně než 1 sekundou",
      future: "za méně než 1 sekundu"
    },
    few: {
      regular: "méně než {{count}} sekundy",
      past: "před méně než {{count}} sekundami",
      future: "za méně než {{count}} sekundy"
    },
    many: {
      regular: "méně než {{count}} sekund",
      past: "před méně než {{count}} sekundami",
      future: "za méně než {{count}} sekund"
    }
  },
  xSeconds: {
    one: {
      regular: "1 sekunda",
      past: "před 1 sekundou",
      future: "za 1 sekundu"
    },
    few: {
      regular: "{{count}} sekundy",
      past: "před {{count}} sekundami",
      future: "za {{count}} sekundy"
    },
    many: {
      regular: "{{count}} sekund",
      past: "před {{count}} sekundami",
      future: "za {{count}} sekund"
    }
  },
  halfAMinute: {
    type: "other",
    other: {
      regular: "půl minuty",
      past: "před půl minutou",
      future: "za půl minuty"
    }
  },
  lessThanXMinutes: {
    one: {
      regular: "méně než 1 minuta",
      past: "před méně než 1 minutou",
      future: "za méně než 1 minutu"
    },
    few: {
      regular: "méně než {{count}} minuty",
      past: "před méně než {{count}} minutami",
      future: "za méně než {{count}} minuty"
    },
    many: {
      regular: "méně než {{count}} minut",
      past: "před méně než {{count}} minutami",
      future: "za méně než {{count}} minut"
    }
  },
  xMinutes: {
    one: {
      regular: "1 minuta",
      past: "před 1 minutou",
      future: "za 1 minutu"
    },
    few: {
      regular: "{{count}} minuty",
      past: "před {{count}} minutami",
      future: "za {{count}} minuty"
    },
    many: {
      regular: "{{count}} minut",
      past: "před {{count}} minutami",
      future: "za {{count}} minut"
    }
  },
  aboutXHours: {
    one: {
      regular: "přibližně 1 hodina",
      past: "přibližně před 1 hodinou",
      future: "přibližně za 1 hodinu"
    },
    few: {
      regular: "přibližně {{count}} hodiny",
      past: "přibližně před {{count}} hodinami",
      future: "přibližně za {{count}} hodiny"
    },
    many: {
      regular: "přibližně {{count}} hodin",
      past: "přibližně před {{count}} hodinami",
      future: "přibližně za {{count}} hodin"
    }
  },
  xHours: {
    one: {
      regular: "1 hodina",
      past: "před 1 hodinou",
      future: "za 1 hodinu"
    },
    few: {
      regular: "{{count}} hodiny",
      past: "před {{count}} hodinami",
      future: "za {{count}} hodiny"
    },
    many: {
      regular: "{{count}} hodin",
      past: "před {{count}} hodinami",
      future: "za {{count}} hodin"
    }
  },
  xDays: {
    one: {
      regular: "1 den",
      past: "před 1 dnem",
      future: "za 1 den"
    },
    few: {
      regular: "{{count}} dny",
      past: "před {{count}} dny",
      future: "za {{count}} dny"
    },
    many: {
      regular: "{{count}} dní",
      past: "před {{count}} dny",
      future: "za {{count}} dní"
    }
  },
  aboutXWeeks: {
    one: {
      regular: "přibližně 1 týden",
      past: "přibližně před 1 týdnem",
      future: "přibližně za 1 týden"
    },
    few: {
      regular: "přibližně {{count}} týdny",
      past: "přibližně před {{count}} týdny",
      future: "přibližně za {{count}} týdny"
    },
    many: {
      regular: "přibližně {{count}} týdnů",
      past: "přibližně před {{count}} týdny",
      future: "přibližně za {{count}} týdnů"
    }
  },
  xWeeks: {
    one: {
      regular: "1 týden",
      past: "před 1 týdnem",
      future: "za 1 týden"
    },
    few: {
      regular: "{{count}} týdny",
      past: "před {{count}} týdny",
      future: "za {{count}} týdny"
    },
    many: {
      regular: "{{count}} týdnů",
      past: "před {{count}} týdny",
      future: "za {{count}} týdnů"
    }
  },
  aboutXMonths: {
    one: {
      regular: "přibližně 1 měsíc",
      past: "přibližně před 1 měsícem",
      future: "přibližně za 1 měsíc"
    },
    few: {
      regular: "přibližně {{count}} měsíce",
      past: "přibližně před {{count}} měsíci",
      future: "přibližně za {{count}} měsíce"
    },
    many: {
      regular: "přibližně {{count}} měsíců",
      past: "přibližně před {{count}} měsíci",
      future: "přibližně za {{count}} měsíců"
    }
  },
  xMonths: {
    one: {
      regular: "1 měsíc",
      past: "před 1 měsícem",
      future: "za 1 měsíc"
    },
    few: {
      regular: "{{count}} měsíce",
      past: "před {{count}} měsíci",
      future: "za {{count}} měsíce"
    },
    many: {
      regular: "{{count}} měsíců",
      past: "před {{count}} měsíci",
      future: "za {{count}} měsíců"
    }
  },
  aboutXYears: {
    one: {
      regular: "přibližně 1 rok",
      past: "přibližně před 1 rokem",
      future: "přibližně za 1 rok"
    },
    few: {
      regular: "přibližně {{count}} roky",
      past: "přibližně před {{count}} roky",
      future: "přibližně za {{count}} roky"
    },
    many: {
      regular: "přibližně {{count}} roků",
      past: "přibližně před {{count}} roky",
      future: "přibližně za {{count}} roků"
    }
  },
  xYears: {
    one: {
      regular: "1 rok",
      past: "před 1 rokem",
      future: "za 1 rok"
    },
    few: {
      regular: "{{count}} roky",
      past: "před {{count}} roky",
      future: "za {{count}} roky"
    },
    many: {
      regular: "{{count}} roků",
      past: "před {{count}} roky",
      future: "za {{count}} roků"
    }
  },
  overXYears: {
    one: {
      regular: "více než 1 rok",
      past: "před více než 1 rokem",
      future: "za více než 1 rok"
    },
    few: {
      regular: "více než {{count}} roky",
      past: "před více než {{count}} roky",
      future: "za více než {{count}} roky"
    },
    many: {
      regular: "více než {{count}} roků",
      past: "před více než {{count}} roky",
      future: "za více než {{count}} roků"
    }
  },
  almostXYears: {
    one: {
      regular: "skoro 1 rok",
      past: "skoro před 1 rokem",
      future: "skoro za 1 rok"
    },
    few: {
      regular: "skoro {{count}} roky",
      past: "skoro před {{count}} roky",
      future: "skoro za {{count}} roky"
    },
    many: {
      regular: "skoro {{count}} roků",
      past: "skoro před {{count}} roky",
      future: "skoro za {{count}} roků"
    }
  }
};
var formatDistance18 = (token, count, options2) => {
  let pluralResult;
  const tokenValue = formatDistanceLocale17[token];
  if (tokenValue.type === "other") {
    pluralResult = tokenValue.other;
  } else if (count === 1) {
    pluralResult = tokenValue.one;
  } else if (count > 1 && count < 5) {
    pluralResult = tokenValue.few;
  } else {
    pluralResult = tokenValue.many;
  }
  const suffixExist = (options2 == null ? void 0 : options2.addSuffix) === true;
  const comparison = options2 == null ? void 0 : options2.comparison;
  let timeResult;
  if (suffixExist && comparison === -1) {
    timeResult = pluralResult.past;
  } else if (suffixExist && comparison === 1) {
    timeResult = pluralResult.future;
  } else {
    timeResult = pluralResult.regular;
  }
  return timeResult.replace("{{count}}", String(count));
};

// ../../../node_modules/date-fns/locale/cs/_lib/formatLong.mjs
var dateFormats17 = {
  full: "EEEE, d. MMMM yyyy",
  long: "d. MMMM yyyy",
  medium: "d. M. yyyy",
  short: "dd.MM.yyyy"
};
var timeFormats17 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats17 = {
  full: "{{date}} 'v' {{time}}",
  long: "{{date}} 'v' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong17 = {
  date: buildFormatLongFn({
    formats: dateFormats17,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats17,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats17,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/cs/_lib/formatRelative.mjs
var accusativeWeekdays3 = [
  "neděli",
  "pondělí",
  "úterý",
  "středu",
  "čtvrtek",
  "pátek",
  "sobotu"
];
var formatRelativeLocale17 = {
  lastWeek: "'poslední' eeee 've' p",
  yesterday: "'včera v' p",
  today: "'dnes v' p",
  tomorrow: "'zítra v' p",
  nextWeek: (date2) => {
    const day = date2.getDay();
    return "'v " + accusativeWeekdays3[day] + " o' p";
  },
  other: "P"
};
var formatRelative17 = (token, date2) => {
  const format3 = formatRelativeLocale17[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/cs/_lib/localize.mjs
var eraValues17 = {
  narrow: ["př. n. l.", "n. l."],
  abbreviated: ["př. n. l.", "n. l."],
  wide: ["před naším letopočtem", "našeho letopočtu"]
};
var quarterValues17 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. čtvrtletí", "2. čtvrtletí", "3. čtvrtletí", "4. čtvrtletí"],
  wide: ["1. čtvrtletí", "2. čtvrtletí", "3. čtvrtletí", "4. čtvrtletí"]
};
var monthValues17 = {
  narrow: ["L", "Ú", "B", "D", "K", "Č", "Č", "S", "Z", "Ř", "L", "P"],
  abbreviated: [
    "led",
    "úno",
    "bře",
    "dub",
    "kvě",
    "čvn",
    "čvc",
    "srp",
    "zář",
    "říj",
    "lis",
    "pro"
  ],
  wide: [
    "leden",
    "únor",
    "březen",
    "duben",
    "květen",
    "červen",
    "červenec",
    "srpen",
    "září",
    "říjen",
    "listopad",
    "prosinec"
  ]
};
var formattingMonthValues4 = {
  narrow: ["L", "Ú", "B", "D", "K", "Č", "Č", "S", "Z", "Ř", "L", "P"],
  abbreviated: [
    "led",
    "úno",
    "bře",
    "dub",
    "kvě",
    "čvn",
    "čvc",
    "srp",
    "zář",
    "říj",
    "lis",
    "pro"
  ],
  wide: [
    "ledna",
    "února",
    "března",
    "dubna",
    "května",
    "června",
    "července",
    "srpna",
    "září",
    "října",
    "listopadu",
    "prosince"
  ]
};
var dayValues17 = {
  narrow: ["ne", "po", "út", "st", "čt", "pá", "so"],
  short: ["ne", "po", "út", "st", "čt", "pá", "so"],
  abbreviated: ["ned", "pon", "úte", "stř", "čtv", "pát", "sob"],
  wide: ["neděle", "pondělí", "úterý", "středa", "čtvrtek", "pátek", "sobota"]
};
var dayPeriodValues17 = {
  narrow: {
    am: "dop.",
    pm: "odp.",
    midnight: "půlnoc",
    noon: "poledne",
    morning: "ráno",
    afternoon: "odpoledne",
    evening: "večer",
    night: "noc"
  },
  abbreviated: {
    am: "dop.",
    pm: "odp.",
    midnight: "půlnoc",
    noon: "poledne",
    morning: "ráno",
    afternoon: "odpoledne",
    evening: "večer",
    night: "noc"
  },
  wide: {
    am: "dopoledne",
    pm: "odpoledne",
    midnight: "půlnoc",
    noon: "poledne",
    morning: "ráno",
    afternoon: "odpoledne",
    evening: "večer",
    night: "noc"
  }
};
var formattingDayPeriodValues16 = {
  narrow: {
    am: "dop.",
    pm: "odp.",
    midnight: "půlnoc",
    noon: "poledne",
    morning: "ráno",
    afternoon: "odpoledne",
    evening: "večer",
    night: "noc"
  },
  abbreviated: {
    am: "dop.",
    pm: "odp.",
    midnight: "půlnoc",
    noon: "poledne",
    morning: "ráno",
    afternoon: "odpoledne",
    evening: "večer",
    night: "noc"
  },
  wide: {
    am: "dopoledne",
    pm: "odpoledne",
    midnight: "půlnoc",
    noon: "poledne",
    morning: "ráno",
    afternoon: "odpoledne",
    evening: "večer",
    night: "noc"
  }
};
var ordinalNumber17 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize17 = {
  ordinalNumber: ordinalNumber17,
  era: buildLocalizeFn({
    values: eraValues17,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues17,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues17,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues4,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues17,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues17,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues16,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/cs/_lib/match.mjs
var matchOrdinalNumberPattern17 = /^(\d+)\.?/i;
var parseOrdinalNumberPattern17 = /\d+/i;
var matchEraPatterns17 = {
  narrow: /^(p[řr](\.|ed) Kr\.|p[řr](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
  abbreviated: /^(p[řr](\.|ed) Kr\.|p[řr](\.|ed) n\. l\.|po Kr\.|n\. l\.)/i,
  wide: /^(p[řr](\.|ed) Kristem|p[řr](\.|ed) na[šs][íi]m letopo[čc]tem|po Kristu|na[šs]eho letopo[čc]tu)/i
};
var parseEraPatterns17 = {
  any: [/^p[řr]/i, /^(po|n)/i]
};
var matchQuarterPatterns17 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\. [čc]tvrtlet[íi]/i,
  wide: /^[1234]\. [čc]tvrtlet[íi]/i
};
var parseQuarterPatterns17 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns17 = {
  narrow: /^[lúubdkčcszřrlp]/i,
  abbreviated: /^(led|[úu]no|b[řr]e|dub|kv[ěe]|[čc]vn|[čc]vc|srp|z[áa][řr]|[řr][íi]j|lis|pro)/i,
  wide: /^(leden|ledna|[úu]nora?|b[řr]ezen|b[řr]ezna|duben|dubna|kv[ěe]ten|kv[ěe]tna|[čc]erven(ec|ce)?|[čc]ervna|srpen|srpna|z[áa][řr][íi]|[řr][íi]jen|[řr][íi]jna|listopad(a|u)?|prosinec|prosince)/i
};
var parseMonthPatterns17 = {
  narrow: [
    /^l/i,
    /^[úu]/i,
    /^b/i,
    /^d/i,
    /^k/i,
    /^[čc]/i,
    /^[čc]/i,
    /^s/i,
    /^z/i,
    /^[řr]/i,
    /^l/i,
    /^p/i
  ],
  any: [
    /^led/i,
    /^[úu]n/i,
    /^b[řr]e/i,
    /^dub/i,
    /^kv[ěe]/i,
    /^[čc]vn|[čc]erven(?!\w)|[čc]ervna/i,
    /^[čc]vc|[čc]erven(ec|ce)/i,
    /^srp/i,
    /^z[áa][řr]/i,
    /^[řr][íi]j/i,
    /^lis/i,
    /^pro/i
  ]
};
var matchDayPatterns17 = {
  narrow: /^[npuúsčps]/i,
  short: /^(ne|po|[úu]t|st|[čc]t|p[áa]|so)/i,
  abbreviated: /^(ned|pon|[úu]te|st[rř]|[čc]tv|p[áa]t|sob)/i,
  wide: /^(ned[ěe]le|pond[ěe]l[íi]|[úu]ter[ýy]|st[řr]eda|[čc]tvrtek|p[áa]tek|sobota)/i
};
var parseDayPatterns17 = {
  narrow: [/^n/i, /^p/i, /^[úu]/i, /^s/i, /^[čc]/i, /^p/i, /^s/i],
  any: [/^ne/i, /^po/i, /^[úu]t/i, /^st/i, /^[čc]t/i, /^p[áa]/i, /^so/i]
};
var matchDayPeriodPatterns17 = {
  any: /^dopoledne|dop\.?|odpoledne|odp\.?|p[ůu]lnoc|poledne|r[áa]no|odpoledne|ve[čc]er|(v )?noci?/i
};
var parseDayPeriodPatterns17 = {
  any: {
    am: /^dop/i,
    pm: /^odp/i,
    midnight: /^p[ůu]lnoc/i,
    noon: /^poledne/i,
    morning: /r[áa]no/i,
    afternoon: /odpoledne/i,
    evening: /ve[čc]er/i,
    night: /noc/i
  }
};
var match17 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern17,
    parsePattern: parseOrdinalNumberPattern17,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns17,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns17,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns17,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns17,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns17,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns17,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns17,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns17,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns17,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns17,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/cs.mjs
var cs = {
  code: "cs",
  formatDistance: formatDistance18,
  formatLong: formatLong17,
  formatRelative: formatRelative17,
  localize: localize17,
  match: match17,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/cy/_lib/formatDistance.mjs
var formatDistanceLocale18 = {
  lessThanXSeconds: {
    one: "llai na eiliad",
    other: "llai na {{count}} eiliad"
  },
  xSeconds: {
    one: "1 eiliad",
    other: "{{count}} eiliad"
  },
  halfAMinute: "hanner munud",
  lessThanXMinutes: {
    one: "llai na munud",
    two: "llai na 2 funud",
    other: "llai na {{count}} munud"
  },
  xMinutes: {
    one: "1 munud",
    two: "2 funud",
    other: "{{count}} munud"
  },
  aboutXHours: {
    one: "tua 1 awr",
    other: "tua {{count}} awr"
  },
  xHours: {
    one: "1 awr",
    other: "{{count}} awr"
  },
  xDays: {
    one: "1 diwrnod",
    two: "2 ddiwrnod",
    other: "{{count}} diwrnod"
  },
  aboutXWeeks: {
    one: "tua 1 wythnos",
    two: "tua pythefnos",
    other: "tua {{count}} wythnos"
  },
  xWeeks: {
    one: "1 wythnos",
    two: "pythefnos",
    other: "{{count}} wythnos"
  },
  aboutXMonths: {
    one: "tua 1 mis",
    two: "tua 2 fis",
    other: "tua {{count}} mis"
  },
  xMonths: {
    one: "1 mis",
    two: "2 fis",
    other: "{{count}} mis"
  },
  aboutXYears: {
    one: "tua 1 flwyddyn",
    two: "tua 2 flynedd",
    other: "tua {{count}} mlynedd"
  },
  xYears: {
    one: "1 flwyddyn",
    two: "2 flynedd",
    other: "{{count}} mlynedd"
  },
  overXYears: {
    one: "dros 1 flwyddyn",
    two: "dros 2 flynedd",
    other: "dros {{count}} mlynedd"
  },
  almostXYears: {
    one: "bron 1 flwyddyn",
    two: "bron 2 flynedd",
    other: "bron {{count}} mlynedd"
  }
};
var formatDistance19 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale18[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && !!tokenValue.two) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "mewn " + result;
    } else {
      return result + " yn ôl";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/cy/_lib/formatLong.mjs
var dateFormats18 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats18 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats18 = {
  full: "{{date}} 'am' {{time}}",
  long: "{{date}} 'am' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong18 = {
  date: buildFormatLongFn({
    formats: dateFormats18,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats18,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats18,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/cy/_lib/formatRelative.mjs
var formatRelativeLocale18 = {
  lastWeek: "eeee 'diwethaf am' p",
  yesterday: "'ddoe am' p",
  today: "'heddiw am' p",
  tomorrow: "'yfory am' p",
  nextWeek: "eeee 'am' p",
  other: "P"
};
var formatRelative18 = (token, _date, _baseDate, _options) => formatRelativeLocale18[token];

// ../../../node_modules/date-fns/locale/cy/_lib/localize.mjs
var eraValues18 = {
  narrow: ["C", "O"],
  abbreviated: ["CC", "OC"],
  wide: ["Cyn Crist", "Ar ôl Crist"]
};
var quarterValues18 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ch1", "Ch2", "Ch3", "Ch4"],
  wide: ["Chwarter 1af", "2ail chwarter", "3ydd chwarter", "4ydd chwarter"]
};
var monthValues18 = {
  narrow: ["I", "Ch", "Ma", "E", "Mi", "Me", "G", "A", "Md", "H", "T", "Rh"],
  abbreviated: [
    "Ion",
    "Chwe",
    "Maw",
    "Ebr",
    "Mai",
    "Meh",
    "Gor",
    "Aws",
    "Med",
    "Hyd",
    "Tach",
    "Rhag"
  ],
  wide: [
    "Ionawr",
    "Chwefror",
    "Mawrth",
    "Ebrill",
    "Mai",
    "Mehefin",
    "Gorffennaf",
    "Awst",
    "Medi",
    "Hydref",
    "Tachwedd",
    "Rhagfyr"
  ]
};
var dayValues18 = {
  narrow: ["S", "Ll", "M", "M", "I", "G", "S"],
  short: ["Su", "Ll", "Ma", "Me", "Ia", "Gw", "Sa"],
  abbreviated: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
  wide: [
    "dydd Sul",
    "dydd Llun",
    "dydd Mawrth",
    "dydd Mercher",
    "dydd Iau",
    "dydd Gwener",
    "dydd Sadwrn"
  ]
};
var dayPeriodValues18 = {
  narrow: {
    am: "b",
    pm: "h",
    midnight: "hn",
    noon: "hd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos"
  },
  abbreviated: {
    am: "yb",
    pm: "yh",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos"
  },
  wide: {
    am: "y.b.",
    pm: "y.h.",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "bore",
    afternoon: "prynhawn",
    evening: "gyda'r nos",
    night: "nos"
  }
};
var formattingDayPeriodValues17 = {
  narrow: {
    am: "b",
    pm: "h",
    midnight: "hn",
    noon: "hd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos"
  },
  abbreviated: {
    am: "yb",
    pm: "yh",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos"
  },
  wide: {
    am: "y.b.",
    pm: "y.h.",
    midnight: "hanner nos",
    noon: "hanner dydd",
    morning: "yn y bore",
    afternoon: "yn y prynhawn",
    evening: "gyda'r nos",
    night: "yn y nos"
  }
};
var ordinalNumber18 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  if (number2 < 20) {
    switch (number2) {
      case 0:
        return number2 + "fed";
      case 1:
        return number2 + "af";
      case 2:
        return number2 + "ail";
      case 3:
      case 4:
        return number2 + "ydd";
      case 5:
      case 6:
        return number2 + "ed";
      case 7:
      case 8:
      case 9:
      case 10:
      case 12:
      case 15:
      case 18:
        return number2 + "fed";
      case 11:
      case 13:
      case 14:
      case 16:
      case 17:
      case 19:
        return number2 + "eg";
    }
  } else if (number2 >= 50 && number2 <= 60 || number2 === 80 || number2 >= 100) {
    return number2 + "fed";
  }
  return number2 + "ain";
};
var localize18 = {
  ordinalNumber: ordinalNumber18,
  era: buildLocalizeFn({
    values: eraValues18,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues18,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues18,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues18,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues18,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues17,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/cy/_lib/match.mjs
var matchOrdinalNumberPattern18 = /^(\d+)(af|ail|ydd|ed|fed|eg|ain)?/i;
var parseOrdinalNumberPattern18 = /\d+/i;
var matchEraPatterns18 = {
  narrow: /^(c|o)/i,
  abbreviated: /^(c\.?\s?c\.?|o\.?\s?c\.?)/i,
  wide: /^(cyn christ|ar ôl crist|ar ol crist)/i
};
var parseEraPatterns18 = {
  wide: [/^c/i, /^(ar ôl crist|ar ol crist)/i],
  any: [/^c/i, /^o/i]
};
var matchQuarterPatterns18 = {
  narrow: /^[1234]/i,
  abbreviated: /^ch[1234]/i,
  wide: /^(chwarter 1af)|([234](ail|ydd)? chwarter)/i
};
var parseQuarterPatterns18 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns18 = {
  narrow: /^(i|ch|m|e|g|a|h|t|rh)/i,
  abbreviated: /^(ion|chwe|maw|ebr|mai|meh|gor|aws|med|hyd|tach|rhag)/i,
  wide: /^(ionawr|chwefror|mawrth|ebrill|mai|mehefin|gorffennaf|awst|medi|hydref|tachwedd|rhagfyr)/i
};
var parseMonthPatterns18 = {
  narrow: [
    /^i/i,
    /^ch/i,
    /^m/i,
    /^e/i,
    /^m/i,
    /^m/i,
    /^g/i,
    /^a/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^rh/i
  ],
  any: [
    /^io/i,
    /^ch/i,
    /^maw/i,
    /^e/i,
    /^mai/i,
    /^meh/i,
    /^g/i,
    /^a/i,
    /^med/i,
    /^h/i,
    /^t/i,
    /^rh/i
  ]
};
var matchDayPatterns18 = {
  narrow: /^(s|ll|m|i|g)/i,
  short: /^(su|ll|ma|me|ia|gw|sa)/i,
  abbreviated: /^(sul|llun|maw|mer|iau|gwe|sad)/i,
  wide: /^dydd (sul|llun|mawrth|mercher|iau|gwener|sadwrn)/i
};
var parseDayPatterns18 = {
  narrow: [/^s/i, /^ll/i, /^m/i, /^m/i, /^i/i, /^g/i, /^s/i],
  wide: [
    /^dydd su/i,
    /^dydd ll/i,
    /^dydd ma/i,
    /^dydd me/i,
    /^dydd i/i,
    /^dydd g/i,
    /^dydd sa/i
  ],
  any: [/^su/i, /^ll/i, /^ma/i, /^me/i, /^i/i, /^g/i, /^sa/i]
};
var matchDayPeriodPatterns18 = {
  narrow: /^(b|h|hn|hd|(yn y|y|yr|gyda'r) (bore|prynhawn|nos|hwyr))/i,
  any: /^(y\.?\s?[bh]\.?|hanner nos|hanner dydd|(yn y|y|yr|gyda'r) (bore|prynhawn|nos|hwyr))/i
};
var parseDayPeriodPatterns18 = {
  any: {
    am: /^b|(y\.?\s?b\.?)/i,
    pm: /^h|(y\.?\s?h\.?)|(yr hwyr)/i,
    midnight: /^hn|hanner nos/i,
    noon: /^hd|hanner dydd/i,
    morning: /bore/i,
    afternoon: /prynhawn/i,
    evening: /^gyda'r nos$/i,
    night: /blah/i
  }
};
var match18 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern18,
    parsePattern: parseOrdinalNumberPattern18,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns18,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns18,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns18,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns18,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns18,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns18,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns18,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns18,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns18,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns18,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/cy.mjs
var cy = {
  code: "cy",
  formatDistance: formatDistance19,
  formatLong: formatLong18,
  formatRelative: formatRelative18,
  localize: localize18,
  match: match18,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/da/_lib/formatDistance.mjs
var formatDistanceLocale19 = {
  lessThanXSeconds: {
    one: "mindre end ét sekund",
    other: "mindre end {{count}} sekunder"
  },
  xSeconds: {
    one: "1 sekund",
    other: "{{count}} sekunder"
  },
  halfAMinute: "ét halvt minut",
  lessThanXMinutes: {
    one: "mindre end ét minut",
    other: "mindre end {{count}} minutter"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minutter"
  },
  aboutXHours: {
    one: "cirka 1 time",
    other: "cirka {{count}} timer"
  },
  xHours: {
    one: "1 time",
    other: "{{count}} timer"
  },
  xDays: {
    one: "1 dag",
    other: "{{count}} dage"
  },
  aboutXWeeks: {
    one: "cirka 1 uge",
    other: "cirka {{count}} uger"
  },
  xWeeks: {
    one: "1 uge",
    other: "{{count}} uger"
  },
  aboutXMonths: {
    one: "cirka 1 måned",
    other: "cirka {{count}} måneder"
  },
  xMonths: {
    one: "1 måned",
    other: "{{count}} måneder"
  },
  aboutXYears: {
    one: "cirka 1 år",
    other: "cirka {{count}} år"
  },
  xYears: {
    one: "1 år",
    other: "{{count}} år"
  },
  overXYears: {
    one: "over 1 år",
    other: "over {{count}} år"
  },
  almostXYears: {
    one: "næsten 1 år",
    other: "næsten {{count}} år"
  }
};
var formatDistance20 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale19[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "om " + result;
    } else {
      return result + " siden";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/da/_lib/formatLong.mjs
var dateFormats19 = {
  full: "EEEE 'den' d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd/MM/y"
};
var timeFormats19 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats19 = {
  full: "{{date}} 'kl'. {{time}}",
  long: "{{date}} 'kl'. {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong19 = {
  date: buildFormatLongFn({
    formats: dateFormats19,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats19,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats19,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/da/_lib/formatRelative.mjs
var formatRelativeLocale19 = {
  lastWeek: "'sidste' eeee 'kl.' p",
  yesterday: "'i går kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgen kl.' p",
  nextWeek: "'på' eeee 'kl.' p",
  other: "P"
};
var formatRelative19 = (token, _date, _baseDate, _options) => formatRelativeLocale19[token];

// ../../../node_modules/date-fns/locale/da/_lib/localize.mjs
var eraValues19 = {
  narrow: ["fvt", "vt"],
  abbreviated: ["f.v.t.", "v.t."],
  wide: ["før vesterlandsk tidsregning", "vesterlandsk tidsregning"]
};
var quarterValues19 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. kvt.", "2. kvt.", "3. kvt.", "4. kvt."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
var monthValues19 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mar.",
    "apr.",
    "maj",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januar",
    "februar",
    "marts",
    "april",
    "maj",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
var dayValues19 = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["sø", "ma", "ti", "on", "to", "fr", "lø"],
  abbreviated: ["søn.", "man.", "tir.", "ons.", "tor.", "fre.", "lør."],
  wide: [
    "søndag",
    "mandag",
    "tirsdag",
    "onsdag",
    "torsdag",
    "fredag",
    "lørdag"
  ]
};
var dayPeriodValues19 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnat",
    noon: "middag",
    morning: "morgen",
    afternoon: "eftermiddag",
    evening: "aften",
    night: "nat"
  }
};
var formattingDayPeriodValues18 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnat",
    noon: "middag",
    morning: "om morgenen",
    afternoon: "om eftermiddagen",
    evening: "om aftenen",
    night: "om natten"
  }
};
var ordinalNumber19 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize19 = {
  ordinalNumber: ordinalNumber19,
  era: buildLocalizeFn({
    values: eraValues19,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues19,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues19,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues19,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues19,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues18,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/da/_lib/match.mjs
var matchOrdinalNumberPattern19 = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern19 = /\d+/i;
var matchEraPatterns19 = {
  narrow: /^(fKr|fvt|eKr|vt)/i,
  abbreviated: /^(f\.Kr\.?|f\.v\.t\.?|e\.Kr\.?|v\.t\.)/i,
  wide: /^(f.Kr.|før vesterlandsk tidsregning|e.Kr.|vesterlandsk tidsregning)/i
};
var parseEraPatterns19 = {
  any: [/^f/i, /^(v|e)/i]
};
var matchQuarterPatterns19 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]. kvt\./i,
  wide: /^[1234]\.? kvartal/i
};
var parseQuarterPatterns19 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns19 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mar.|apr.|maj|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januar|februar|marts|april|maj|juni|juli|august|september|oktober|november|december)/i
};
var parseMonthPatterns19 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns19 = {
  narrow: /^[smtofl]/i,
  short: /^(søn.|man.|tir.|ons.|tor.|fre.|lør.)/i,
  abbreviated: /^(søn|man|tir|ons|tor|fre|lør)/i,
  wide: /^(søndag|mandag|tirsdag|onsdag|torsdag|fredag|lørdag)/i
};
var parseDayPatterns19 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^o/i, /^t/i, /^f/i, /^l/i],
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
var matchDayPeriodPatterns19 = {
  narrow: /^(a|p|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i,
  any: /^([ap]\.?\s?m\.?|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i
};
var parseDayPeriodPatterns19 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /midnat/i,
    noon: /middag/i,
    morning: /morgen/i,
    afternoon: /eftermiddag/i,
    evening: /aften/i,
    night: /nat/i
  }
};
var match19 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern19,
    parsePattern: parseOrdinalNumberPattern19,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns19,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns19,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns19,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns19,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns19,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns19,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns19,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns19,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns19,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns19,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/da.mjs
var da = {
  code: "da",
  formatDistance: formatDistance20,
  formatLong: formatLong19,
  formatRelative: formatRelative19,
  localize: localize19,
  match: match19,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/de/_lib/formatDistance.mjs
var formatDistanceLocale20 = {
  lessThanXSeconds: {
    standalone: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden"
    },
    withPreposition: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden"
    }
  },
  xSeconds: {
    standalone: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden"
    },
    withPreposition: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden"
    }
  },
  halfAMinute: {
    standalone: "eine halbe Minute",
    withPreposition: "einer halben Minute"
  },
  lessThanXMinutes: {
    standalone: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten"
    },
    withPreposition: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten"
    }
  },
  xMinutes: {
    standalone: {
      one: "1 Minute",
      other: "{{count}} Minuten"
    },
    withPreposition: {
      one: "1 Minute",
      other: "{{count}} Minuten"
    }
  },
  aboutXHours: {
    standalone: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden"
    },
    withPreposition: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden"
    }
  },
  xHours: {
    standalone: {
      one: "1 Stunde",
      other: "{{count}} Stunden"
    },
    withPreposition: {
      one: "1 Stunde",
      other: "{{count}} Stunden"
    }
  },
  xDays: {
    standalone: {
      one: "1 Tag",
      other: "{{count}} Tage"
    },
    withPreposition: {
      one: "1 Tag",
      other: "{{count}} Tagen"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen"
    },
    withPreposition: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen"
    }
  },
  xWeeks: {
    standalone: {
      one: "1 Woche",
      other: "{{count}} Wochen"
    },
    withPreposition: {
      one: "1 Woche",
      other: "{{count}} Wochen"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monate"
    },
    withPreposition: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monaten"
    }
  },
  xMonths: {
    standalone: {
      one: "1 Monat",
      other: "{{count}} Monate"
    },
    withPreposition: {
      one: "1 Monat",
      other: "{{count}} Monaten"
    }
  },
  aboutXYears: {
    standalone: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahre"
    },
    withPreposition: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahren"
    }
  },
  xYears: {
    standalone: {
      one: "1 Jahr",
      other: "{{count}} Jahre"
    },
    withPreposition: {
      one: "1 Jahr",
      other: "{{count}} Jahren"
    }
  },
  overXYears: {
    standalone: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahre"
    },
    withPreposition: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahren"
    }
  },
  almostXYears: {
    standalone: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahre"
    },
    withPreposition: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahren"
    }
  }
};
var formatDistance21 = (token, count, options2) => {
  let result;
  const tokenValue = (options2 == null ? void 0 : options2.addSuffix) ? formatDistanceLocale20[token].withPreposition : formatDistanceLocale20[token].standalone;
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "in " + result;
    } else {
      return "vor " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/de/_lib/formatLong.mjs
var dateFormats20 = {
  full: "EEEE, do MMMM y",
  // Montag, 7. Januar 2018
  long: "do MMMM y",
  // 7. Januar 2018
  medium: "do MMM y",
  // 7. Jan. 2018
  short: "dd.MM.y"
  // 07.01.2018
};
var timeFormats20 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats20 = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong20 = {
  date: buildFormatLongFn({
    formats: dateFormats20,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats20,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats20,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/de/_lib/formatRelative.mjs
var formatRelativeLocale20 = {
  lastWeek: "'letzten' eeee 'um' p",
  yesterday: "'gestern um' p",
  today: "'heute um' p",
  tomorrow: "'morgen um' p",
  nextWeek: "eeee 'um' p",
  other: "P"
};
var formatRelative20 = (token, _date, _baseDate, _options) => formatRelativeLocale20[token];

// ../../../node_modules/date-fns/locale/de/_lib/localize.mjs
var eraValues20 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"]
};
var quarterValues20 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
var monthValues20 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mär",
    "Apr",
    "Mai",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez"
  ],
  wide: [
    "Januar",
    "Februar",
    "März",
    "April",
    "Mai",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember"
  ]
};
var formattingMonthValues5 = {
  narrow: monthValues20.narrow,
  abbreviated: [
    "Jan.",
    "Feb.",
    "März",
    "Apr.",
    "Mai",
    "Juni",
    "Juli",
    "Aug.",
    "Sep.",
    "Okt.",
    "Nov.",
    "Dez."
  ],
  wide: monthValues20.wide
};
var dayValues20 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonntag",
    "Montag",
    "Dienstag",
    "Mittwoch",
    "Donnerstag",
    "Freitag",
    "Samstag"
  ]
};
var dayPeriodValues20 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  }
};
var formattingDayPeriodValues19 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  }
};
var ordinalNumber20 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize20 = {
  ordinalNumber: ordinalNumber20,
  era: buildLocalizeFn({
    values: eraValues20,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues20,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues20,
    formattingValues: formattingMonthValues5,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues20,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues20,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues19,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/de/_lib/match.mjs
var matchOrdinalNumberPattern20 = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern20 = /\d+/i;
var matchEraPatterns20 = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
};
var parseEraPatterns20 = {
  any: [/^v/i, /^n/i]
};
var matchQuarterPatterns20 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
var parseQuarterPatterns20 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns20 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(j[aä]n|feb|mär[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
  wide: /^(januar|februar|märz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
};
var parseMonthPatterns20 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^j[aä]/i,
    /^f/i,
    /^mär/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns20 = {
  narrow: /^[smdmf]/i,
  short: /^(so|mo|di|mi|do|fr|sa)/i,
  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
};
var parseDayPatterns20 = {
  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns20 = {
  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
};
var parseDayPeriodPatterns20 = {
  any: {
    am: /^v/i,
    pm: /^n/i,
    midnight: /^Mitte/i,
    noon: /^Mitta/i,
    morning: /morgens/i,
    afternoon: /nachmittags/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /abends/i,
    night: /nachts/i
    // will never be matched. Night is matched by `pm`
  }
};
var match20 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern20,
    parsePattern: parseOrdinalNumberPattern20,
    valueCallback: (value) => parseInt(value)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns20,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns20,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns20,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns20,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns20,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns20,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns20,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns20,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns20,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns20,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/de.mjs
var de = {
  code: "de",
  formatDistance: formatDistance21,
  formatLong: formatLong20,
  formatRelative: formatRelative20,
  localize: localize20,
  match: match20,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/de-AT/_lib/localize.mjs
var eraValues21 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"]
};
var quarterValues21 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
var monthValues21 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jän",
    "Feb",
    "Mär",
    "Apr",
    "Mai",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez"
  ],
  wide: [
    "Jänner",
    "Februar",
    "März",
    "April",
    "Mai",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember"
  ]
};
var formattingMonthValues6 = {
  narrow: monthValues21.narrow,
  abbreviated: [
    "Jän.",
    "Feb.",
    "März",
    "Apr.",
    "Mai",
    "Juni",
    "Juli",
    "Aug.",
    "Sep.",
    "Okt.",
    "Nov.",
    "Dez."
  ],
  wide: monthValues21.wide
};
var dayValues21 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonntag",
    "Montag",
    "Dienstag",
    "Mittwoch",
    "Donnerstag",
    "Freitag",
    "Samstag"
  ]
};
var dayPeriodValues21 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  }
};
var formattingDayPeriodValues20 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  }
};
var ordinalNumber21 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize21 = {
  ordinalNumber: ordinalNumber21,
  era: buildLocalizeFn({
    values: eraValues21,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues21,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues21,
    formattingValues: formattingMonthValues6,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues21,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues21,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues20,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/de-AT.mjs
var deAT = {
  code: "de-AT",
  formatDistance: formatDistance21,
  formatLong: formatLong20,
  formatRelative: formatRelative20,
  localize: localize21,
  match: match20,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/el/_lib/formatDistance.mjs
var formatDistanceLocale21 = {
  lessThanXSeconds: {
    one: "λιγότερο από ένα δευτερόλεπτο",
    other: "λιγότερο από {{count}} δευτερόλεπτα"
  },
  xSeconds: {
    one: "1 δευτερόλεπτο",
    other: "{{count}} δευτερόλεπτα"
  },
  halfAMinute: "μισό λεπτό",
  lessThanXMinutes: {
    one: "λιγότερο από ένα λεπτό",
    other: "λιγότερο από {{count}} λεπτά"
  },
  xMinutes: {
    one: "1 λεπτό",
    other: "{{count}} λεπτά"
  },
  aboutXHours: {
    one: "περίπου 1 ώρα",
    other: "περίπου {{count}} ώρες"
  },
  xHours: {
    one: "1 ώρα",
    other: "{{count}} ώρες"
  },
  xDays: {
    one: "1 ημέρα",
    other: "{{count}} ημέρες"
  },
  aboutXWeeks: {
    one: "περίπου 1 εβδομάδα",
    other: "περίπου {{count}} εβδομάδες"
  },
  xWeeks: {
    one: "1 εβδομάδα",
    other: "{{count}} εβδομάδες"
  },
  aboutXMonths: {
    one: "περίπου 1 μήνας",
    other: "περίπου {{count}} μήνες"
  },
  xMonths: {
    one: "1 μήνας",
    other: "{{count}} μήνες"
  },
  aboutXYears: {
    one: "περίπου 1 χρόνο",
    other: "περίπου {{count}} χρόνια"
  },
  xYears: {
    one: "1 χρόνο",
    other: "{{count}} χρόνια"
  },
  overXYears: {
    one: "πάνω από 1 χρόνο",
    other: "πάνω από {{count}} χρόνια"
  },
  almostXYears: {
    one: "περίπου 1 χρόνο",
    other: "περίπου {{count}} χρόνια"
  }
};
var formatDistance22 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale21[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "σε " + result;
    } else {
      return result + " πριν";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/el/_lib/formatLong.mjs
var dateFormats21 = {
  full: "EEEE, d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "d/M/yy"
};
var timeFormats21 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats21 = {
  full: "{{date}} - {{time}}",
  long: "{{date}} - {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong21 = {
  date: buildFormatLongFn({
    formats: dateFormats21,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats21,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats21,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/el/_lib/formatRelative.mjs
var formatRelativeLocale21 = {
  lastWeek: (date2) => {
    switch (date2.getDay()) {
      case 6:
        return "'το προηγούμενο' eeee 'στις' p";
      default:
        return "'την προηγούμενη' eeee 'στις' p";
    }
  },
  yesterday: "'χθες στις' p",
  today: "'σήμερα στις' p",
  tomorrow: "'αύριο στις' p",
  nextWeek: "eeee 'στις' p",
  other: "P"
};
var formatRelative21 = (token, date2) => {
  const format3 = formatRelativeLocale21[token];
  if (typeof format3 === "function") return format3(date2);
  return format3;
};

// ../../../node_modules/date-fns/locale/el/_lib/localize.mjs
var eraValues22 = {
  narrow: ["πΧ", "μΧ"],
  abbreviated: ["π.Χ.", "μ.Χ."],
  wide: ["προ Χριστού", "μετά Χριστόν"]
};
var quarterValues22 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Τ1", "Τ2", "Τ3", "Τ4"],
  wide: ["1ο τρίμηνο", "2ο τρίμηνο", "3ο τρίμηνο", "4ο τρίμηνο"]
};
var monthValues22 = {
  narrow: ["Ι", "Φ", "Μ", "Α", "Μ", "Ι", "Ι", "Α", "Σ", "Ο", "Ν", "Δ"],
  abbreviated: [
    "Ιαν",
    "Φεβ",
    "Μάρ",
    "Απρ",
    "Μάι",
    "Ιούν",
    "Ιούλ",
    "Αύγ",
    "Σεπ",
    "Οκτ",
    "Νοέ",
    "Δεκ"
  ],
  wide: [
    "Ιανουάριος",
    "Φεβρουάριος",
    "Μάρτιος",
    "Απρίλιος",
    "Μάιος",
    "Ιούνιος",
    "Ιούλιος",
    "Αύγουστος",
    "Σεπτέμβριος",
    "Οκτώβριος",
    "Νοέμβριος",
    "Δεκέμβριος"
  ]
};
var formattingMonthValues7 = {
  narrow: ["Ι", "Φ", "Μ", "Α", "Μ", "Ι", "Ι", "Α", "Σ", "Ο", "Ν", "Δ"],
  abbreviated: [
    "Ιαν",
    "Φεβ",
    "Μαρ",
    "Απρ",
    "Μαΐ",
    "Ιουν",
    "Ιουλ",
    "Αυγ",
    "Σεπ",
    "Οκτ",
    "Νοε",
    "Δεκ"
  ],
  wide: [
    "Ιανουαρίου",
    "Φεβρουαρίου",
    "Μαρτίου",
    "Απριλίου",
    "Μαΐου",
    "Ιουνίου",
    "Ιουλίου",
    "Αυγούστου",
    "Σεπτεμβρίου",
    "Οκτωβρίου",
    "Νοεμβρίου",
    "Δεκεμβρίου"
  ]
};
var dayValues22 = {
  narrow: ["Κ", "Δ", "T", "Τ", "Π", "Π", "Σ"],
  short: ["Κυ", "Δε", "Τρ", "Τε", "Πέ", "Πα", "Σά"],
  abbreviated: ["Κυρ", "Δευ", "Τρί", "Τετ", "Πέμ", "Παρ", "Σάβ"],
  wide: [
    "Κυριακή",
    "Δευτέρα",
    "Τρίτη",
    "Τετάρτη",
    "Πέμπτη",
    "Παρασκευή",
    "Σάββατο"
  ]
};
var dayPeriodValues22 = {
  narrow: {
    am: "πμ",
    pm: "μμ",
    midnight: "μεσάνυχτα",
    noon: "μεσημέρι",
    morning: "πρωί",
    afternoon: "απόγευμα",
    evening: "βράδυ",
    night: "νύχτα"
  },
  abbreviated: {
    am: "π.μ.",
    pm: "μ.μ.",
    midnight: "μεσάνυχτα",
    noon: "μεσημέρι",
    morning: "πρωί",
    afternoon: "απόγευμα",
    evening: "βράδυ",
    night: "νύχτα"
  },
  wide: {
    am: "π.μ.",
    pm: "μ.μ.",
    midnight: "μεσάνυχτα",
    noon: "μεσημέρι",
    morning: "πρωί",
    afternoon: "απόγευμα",
    evening: "βράδυ",
    night: "νύχτα"
  }
};
var ordinalNumber22 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = options2 == null ? void 0 : options2.unit;
  let suffix2;
  if (unit === "year" || unit === "month") {
    suffix2 = "ος";
  } else if (unit === "week" || unit === "dayOfYear" || unit === "day" || unit === "hour" || unit === "date") {
    suffix2 = "η";
  } else {
    suffix2 = "ο";
  }
  return number2 + suffix2;
};
var localize22 = {
  ordinalNumber: ordinalNumber22,
  era: buildLocalizeFn({
    values: eraValues22,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues22,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues22,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues7,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues22,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues22,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/el/_lib/match.mjs
var matchOrdinalNumberPattern21 = /^(\d+)(ος|η|ο)?/i;
var parseOrdinalNumberPattern21 = /\d+/i;
var matchEraPatterns21 = {
  narrow: /^(πΧ|μΧ)/i,
  abbreviated: /^(π\.?\s?χ\.?|π\.?\s?κ\.?\s?χ\.?|μ\.?\s?χ\.?|κ\.?\s?χ\.?)/i,
  wide: /^(προ Χριστο(ύ|υ)|πριν απ(ό|ο) την Κοιν(ή|η) Χρονολογ(ί|ι)α|μετ(ά|α) Χριστ(ό|ο)ν|Κοιν(ή|η) Χρονολογ(ί|ι)α)/i
};
var parseEraPatterns21 = {
  any: [/^π/i, /^(μ|κ)/i]
};
var matchQuarterPatterns21 = {
  narrow: /^[1234]/i,
  abbreviated: /^τ[1234]/i,
  wide: /^[1234]ο? τρ(ί|ι)μηνο/i
};
var parseQuarterPatterns21 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns21 = {
  narrow: /^[ιφμαμιιασονδ]/i,
  abbreviated: /^(ιαν|φεβ|μ[άα]ρ|απρ|μ[άα][ιΐ]|ιο[ύυ]ν|ιο[ύυ]λ|α[ύυ]γ|σεπ|οκτ|νο[έε]|δεκ)/i,
  wide: /^(μ[άα][ιΐ]|α[ύυ]γο[υύ]στ)(ος|ου)|(ιανου[άα]ρ|φεβρου[άα]ρ|μ[άα]ρτ|απρ[ίι]λ|ιο[ύυ]ν|ιο[ύυ]λ|σεπτ[έε]μβρ|οκτ[ώω]βρ|νο[έε]μβρ|δεκ[έε]μβρ)(ιος|ίου)/i
};
var parseMonthPatterns21 = {
  narrow: [
    /^ι/i,
    /^φ/i,
    /^μ/i,
    /^α/i,
    /^μ/i,
    /^ι/i,
    /^ι/i,
    /^α/i,
    /^σ/i,
    /^ο/i,
    /^ν/i,
    /^δ/i
  ],
  any: [
    /^ια/i,
    /^φ/i,
    /^μ[άα]ρ/i,
    /^απ/i,
    /^μ[άα][ιΐ]/i,
    /^ιο[ύυ]ν/i,
    /^ιο[ύυ]λ/i,
    /^α[ύυ]/i,
    /^σ/i,
    /^ο/i,
    /^ν/i,
    /^δ/i
  ]
};
var matchDayPatterns21 = {
  narrow: /^[κδτπσ]/i,
  short: /^(κυ|δε|τρ|τε|π[εέ]|π[αά]|σ[αά])/i,
  abbreviated: /^(κυρ|δευ|τρι|τετ|πεμ|παρ|σαβ)/i,
  wide: /^(κυριακ(ή|η)|δευτ(έ|ε)ρα|τρ(ί|ι)τη|τετ(ά|α)ρτη|π(έ|ε)μπτη|παρασκευ(ή|η)|σ(ά|α)ββατο)/i
};
var parseDayPatterns21 = {
  narrow: [/^κ/i, /^δ/i, /^τ/i, /^τ/i, /^π/i, /^π/i, /^σ/i],
  any: [/^κ/i, /^δ/i, /^τρ/i, /^τε/i, /^π[εέ]/i, /^π[αά]/i, /^σ/i]
};
var matchDayPeriodPatterns21 = {
  narrow: /^(πμ|μμ|μεσ(ά|α)νυχτα|μεσημ(έ|ε)ρι|πρω(ί|ι)|απ(ό|ο)γευμα|βρ(ά|α)δυ|ν(ύ|υ)χτα)/i,
  any: /^([πμ]\.?\s?μ\.?|μεσ(ά|α)νυχτα|μεσημ(έ|ε)ρι|πρω(ί|ι)|απ(ό|ο)γευμα|βρ(ά|α)δυ|ν(ύ|υ)χτα)/i
};
var parseDayPeriodPatterns21 = {
  any: {
    am: /^πμ|π\.\s?μ\./i,
    pm: /^μμ|μ\.\s?μ\./i,
    midnight: /^μεσάν/i,
    noon: /^μεσημ(έ|ε)/i,
    morning: /πρω(ί|ι)/i,
    afternoon: /απ(ό|ο)γευμα/i,
    evening: /βρ(ά|α)δυ/i,
    night: /ν(ύ|υ)χτα/i
  }
};
var match21 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern21,
    parsePattern: parseOrdinalNumberPattern21,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns21,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns21,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns21,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns21,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns21,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns21,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns21,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns21,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns21,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns21,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/el.mjs
var el = {
  code: "el",
  formatDistance: formatDistance22,
  formatLong: formatLong21,
  formatRelative: formatRelative21,
  localize: localize22,
  match: match21,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/en-AU/_lib/formatLong.mjs
var dateFormats22 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats22 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats22 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong22 = {
  date: buildFormatLongFn({
    formats: dateFormats22,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats22,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats22,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/en-AU.mjs
var enAU = {
  code: "en-AU",
  formatDistance,
  formatLong: formatLong22,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/en-CA/_lib/formatDistance.mjs
var formatDistanceLocale22 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "a second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "a minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about an hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "an hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "a day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about a week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "a week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about a month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "a month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about a year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "a year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over a year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost a year",
    other: "almost {{count}} years"
  }
};
var formatDistance23 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale22[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/en-CA/_lib/formatLong.mjs
var dateFormats23 = {
  full: "EEEE, MMMM do, yyyy",
  long: "MMMM do, yyyy",
  medium: "MMM d, yyyy",
  short: "yyyy-MM-dd"
};
var timeFormats23 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats23 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong23 = {
  date: buildFormatLongFn({
    formats: dateFormats23,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats23,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats23,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/en-CA.mjs
var enCA = {
  code: "en-CA",
  formatDistance: formatDistance23,
  formatLong: formatLong23,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/en-GB/_lib/formatLong.mjs
var dateFormats24 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats24 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats24 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong24 = {
  date: buildFormatLongFn({
    formats: dateFormats24,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats24,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats24,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/en-GB.mjs
var enGB = {
  code: "en-GB",
  formatDistance,
  formatLong: formatLong24,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/en-IE.mjs
var enIE = {
  code: "en-IE",
  formatDistance,
  formatLong: formatLong24,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/en-IN/_lib/formatLong.mjs
var dateFormats25 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM, yyyy",
  medium: "d MMM, yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats25 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats25 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong25 = {
  date: buildFormatLongFn({
    formats: dateFormats25,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats25,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats25,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/en-IN.mjs
var enIN = {
  code: "en-IN",
  formatDistance,
  formatLong: formatLong25,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 1,
    // Monday is the first day of the week.
    firstWeekContainsDate: 4
    // The week that contains Jan 4th is the first week of the year.
  }
};

// ../../../node_modules/date-fns/locale/en-NZ/_lib/formatLong.mjs
var dateFormats26 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats26 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats26 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong26 = {
  date: buildFormatLongFn({
    formats: dateFormats26,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats26,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats26,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/en-NZ.mjs
var enNZ = {
  code: "en-NZ",
  formatDistance,
  formatLong: formatLong26,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/en-ZA/_lib/formatLong.mjs
var dateFormats27 = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "yyyy/MM/dd"
};
var timeFormats27 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats27 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong27 = {
  date: buildFormatLongFn({
    formats: dateFormats27,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats27,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats27,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/en-ZA.mjs
var enZA = {
  code: "en-ZA",
  formatDistance,
  formatLong: formatLong27,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    // Sunday is the first day of the week.
    firstWeekContainsDate: 1
    // The week that contains Jan 1st is the first week of the year.
  }
};

// ../../../node_modules/date-fns/locale/eo/_lib/formatDistance.mjs
var formatDistanceLocale23 = {
  lessThanXSeconds: {
    one: "malpli ol sekundo",
    other: "malpli ol {{count}} sekundoj"
  },
  xSeconds: {
    one: "1 sekundo",
    other: "{{count}} sekundoj"
  },
  halfAMinute: "duonminuto",
  lessThanXMinutes: {
    one: "malpli ol minuto",
    other: "malpli ol {{count}} minutoj"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutoj"
  },
  aboutXHours: {
    one: "proksimume 1 horo",
    other: "proksimume {{count}} horoj"
  },
  xHours: {
    one: "1 horo",
    other: "{{count}} horoj"
  },
  xDays: {
    one: "1 tago",
    other: "{{count}} tagoj"
  },
  aboutXMonths: {
    one: "proksimume 1 monato",
    other: "proksimume {{count}} monatoj"
  },
  xWeeks: {
    one: "1 semajno",
    other: "{{count}} semajnoj"
  },
  aboutXWeeks: {
    one: "proksimume 1 semajno",
    other: "proksimume {{count}} semajnoj"
  },
  xMonths: {
    one: "1 monato",
    other: "{{count}} monatoj"
  },
  aboutXYears: {
    one: "proksimume 1 jaro",
    other: "proksimume {{count}} jaroj"
  },
  xYears: {
    one: "1 jaro",
    other: "{{count}} jaroj"
  },
  overXYears: {
    one: "pli ol 1 jaro",
    other: "pli ol {{count}} jaroj"
  },
  almostXYears: {
    one: "preskaŭ 1 jaro",
    other: "preskaŭ {{count}} jaroj"
  }
};
var formatDistance24 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale23[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if ((options2 == null ? void 0 : options2.comparison) && options2.comparison > 0) {
      return "post " + result;
    } else {
      return "antaŭ " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/eo/_lib/formatLong.mjs
var dateFormats28 = {
  full: "EEEE, do 'de' MMMM y",
  long: "y-MMMM-dd",
  medium: "y-MMM-dd",
  short: "yyyy-MM-dd"
};
var timeFormats28 = {
  full: "Ho 'horo kaj' m:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats28 = {
  any: "{{date}} {{time}}"
};
var formatLong28 = {
  date: buildFormatLongFn({
    formats: dateFormats28,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats28,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats28,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/eo/_lib/formatRelative.mjs
var formatRelativeLocale22 = {
  lastWeek: "'pasinta' eeee 'je' p",
  yesterday: "'hieraŭ je' p",
  today: "'hodiaŭ je' p",
  tomorrow: "'morgaŭ je' p",
  nextWeek: "eeee 'je' p",
  other: "P"
};
var formatRelative22 = (token, _date, _baseDate, _options) => formatRelativeLocale22[token];

// ../../../node_modules/date-fns/locale/eo/_lib/localize.mjs
var eraValues23 = {
  narrow: ["aK", "pK"],
  abbreviated: ["a.K.E.", "p.K.E."],
  wide: ["antaŭ Komuna Erao", "Komuna Erao"]
};
var quarterValues23 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: [
    "1-a kvaronjaro",
    "2-a kvaronjaro",
    "3-a kvaronjaro",
    "4-a kvaronjaro"
  ]
};
var monthValues23 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "aŭg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januaro",
    "februaro",
    "marto",
    "aprilo",
    "majo",
    "junio",
    "julio",
    "aŭgusto",
    "septembro",
    "oktobro",
    "novembro",
    "decembro"
  ]
};
var dayValues23 = {
  narrow: ["D", "L", "M", "M", "Ĵ", "V", "S"],
  short: ["di", "lu", "ma", "me", "ĵa", "ve", "sa"],
  abbreviated: ["dim", "lun", "mar", "mer", "ĵaŭ", "ven", "sab"],
  wide: [
    "dimanĉo",
    "lundo",
    "mardo",
    "merkredo",
    "ĵaŭdo",
    "vendredo",
    "sabato"
  ]
};
var dayPeriodValues23 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte"
  },
  abbreviated: {
    am: "a.t.m.",
    pm: "p.t.m.",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte"
  },
  wide: {
    am: "antaŭtagmeze",
    pm: "posttagmeze",
    midnight: "noktomezo",
    noon: "tagmezo",
    morning: "matene",
    afternoon: "posttagmeze",
    evening: "vespere",
    night: "nokte"
  }
};
var ordinalNumber23 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  return number2 + "-a";
};
var localize23 = {
  ordinalNumber: ordinalNumber23,
  era: buildLocalizeFn({
    values: eraValues23,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues23,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues23,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues23,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues23,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/eo/_lib/match.mjs
var matchOrdinalNumberPattern22 = /^(\d+)(-?a)?/i;
var parseOrdinalNumberPattern22 = /\d+/i;
var matchEraPatterns22 = {
  narrow: /^([ap]k)/i,
  abbreviated: /^([ap]\.?\s?k\.?\s?e\.?)/i,
  wide: /^((antaǔ |post )?komuna erao)/i
};
var parseEraPatterns22 = {
  any: [/^a/i, /^[kp]/i]
};
var matchQuarterPatterns22 = {
  narrow: /^[1234]/i,
  abbreviated: /^k[1234]/i,
  wide: /^[1234](-?a)? kvaronjaro/i
};
var parseQuarterPatterns22 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns22 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|a(ŭ|ux|uh|u)g|sep|okt|nov|dec)/i,
  wide: /^(januaro|februaro|marto|aprilo|majo|junio|julio|a(ŭ|ux|uh|u)gusto|septembro|oktobro|novembro|decembro)/i
};
var parseMonthPatterns22 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^a(u|ŭ)/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns22 = {
  narrow: /^[dlmĵjvs]/i,
  short: /^(di|lu|ma|me|(ĵ|jx|jh|j)a|ve|sa)/i,
  abbreviated: /^(dim|lun|mar|mer|(ĵ|jx|jh|j)a(ŭ|ux|uh|u)|ven|sab)/i,
  wide: /^(diman(ĉ|cx|ch|c)o|lundo|mardo|merkredo|(ĵ|jx|jh|j)a(ŭ|ux|uh|u)do|vendredo|sabato)/i
};
var parseDayPatterns22 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^(j|ĵ)/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^(j|ĵ)/i, /^v/i, /^s/i]
};
var matchDayPeriodPatterns22 = {
  narrow: /^([ap]|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
  abbreviated: /^([ap][.\s]?t[.\s]?m[.\s]?|(posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo])/i,
  wide: /^(anta(ŭ|ux)tagmez|posttagmez|noktomez|tagmez|maten|vesper|nokt)[eo]/i
};
var parseDayPeriodPatterns22 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^noktom/i,
    noon: /^t/i,
    morning: /^m/i,
    afternoon: /^posttagmeze/i,
    evening: /^v/i,
    night: /^n/i
  }
};
var match22 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern22,
    parsePattern: parseOrdinalNumberPattern22,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns22,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns22,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns22,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns22,
    defaultParseWidth: "any",
    valueCallback: function(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns22,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns22,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns22,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns22,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns22,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns22,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/eo.mjs
var eo = {
  code: "eo",
  formatDistance: formatDistance24,
  formatLong: formatLong28,
  formatRelative: formatRelative22,
  localize: localize23,
  match: match22,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/es/_lib/formatDistance.mjs
var formatDistanceLocale24 = {
  lessThanXSeconds: {
    one: "menos de un segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "medio minuto",
  lessThanXMinutes: {
    one: "menos de un minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "alrededor de 1 hora",
    other: "alrededor de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 día",
    other: "{{count}} días"
  },
  aboutXWeeks: {
    one: "alrededor de 1 semana",
    other: "alrededor de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "alrededor de 1 mes",
    other: "alrededor de {{count}} meses"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "alrededor de 1 año",
    other: "alrededor de {{count}} años"
  },
  xYears: {
    one: "1 año",
    other: "{{count}} años"
  },
  overXYears: {
    one: "más de 1 año",
    other: "más de {{count}} años"
  },
  almostXYears: {
    one: "casi 1 año",
    other: "casi {{count}} años"
  }
};
var formatDistance25 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale24[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "en " + result;
    } else {
      return "hace " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/es/_lib/formatLong.mjs
var dateFormats29 = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats29 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats29 = {
  full: "{{date}} 'a las' {{time}}",
  long: "{{date}} 'a las' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong29 = {
  date: buildFormatLongFn({
    formats: dateFormats29,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats29,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats29,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/es/_lib/formatRelative.mjs
var formatRelativeLocale23 = {
  lastWeek: "'el' eeee 'pasado a la' p",
  yesterday: "'ayer a la' p",
  today: "'hoy a la' p",
  tomorrow: "'mañana a la' p",
  nextWeek: "eeee 'a la' p",
  other: "P"
};
var formatRelativeLocalePlural2 = {
  lastWeek: "'el' eeee 'pasado a las' p",
  yesterday: "'ayer a las' p",
  today: "'hoy a las' p",
  tomorrow: "'mañana a las' p",
  nextWeek: "eeee 'a las' p",
  other: "P"
};
var formatRelative23 = (token, date2, _baseDate, _options) => {
  if (date2.getHours() !== 1) {
    return formatRelativeLocalePlural2[token];
  } else {
    return formatRelativeLocale23[token];
  }
};

// ../../../node_modules/date-fns/locale/es/_lib/localize.mjs
var eraValues24 = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "después de cristo"]
};
var quarterValues24 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
};
var monthValues24 = {
  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "ene",
    "feb",
    "mar",
    "abr",
    "may",
    "jun",
    "jul",
    "ago",
    "sep",
    "oct",
    "nov",
    "dic"
  ],
  wide: [
    "enero",
    "febrero",
    "marzo",
    "abril",
    "mayo",
    "junio",
    "julio",
    "agosto",
    "septiembre",
    "octubre",
    "noviembre",
    "diciembre"
  ]
};
var dayValues24 = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["do", "lu", "ma", "mi", "ju", "vi", "sá"],
  abbreviated: ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
  wide: [
    "domingo",
    "lunes",
    "martes",
    "miércoles",
    "jueves",
    "viernes",
    "sábado"
  ]
};
var dayPeriodValues24 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "mañana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "mañana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "mañana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  }
};
var formattingDayPeriodValues21 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "de la mañana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la mañana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la mañana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  }
};
var ordinalNumber24 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "º";
};
var localize24 = {
  ordinalNumber: ordinalNumber24,
  era: buildLocalizeFn({
    values: eraValues24,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues24,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues24,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues24,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues24,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues21,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/es/_lib/match.mjs
var matchOrdinalNumberPattern23 = /^(\d+)(º)?/i;
var parseOrdinalNumberPattern23 = /\d+/i;
var matchEraPatterns23 = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes de la era com[uú]n|despu[eé]s de cristo|era com[uú]n)/i
};
var parseEraPatterns23 = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes de la era com[uú]n)/i,
    /^(despu[eé]s de cristo|era com[uú]n)/i
  ]
};
var matchQuarterPatterns23 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](º)? trimestre/i
};
var parseQuarterPatterns23 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns23 = {
  narrow: /^[efmajsond]/i,
  abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
  wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
};
var parseMonthPatterns23 = {
  narrow: [
    /^e/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^en/i,
    /^feb/i,
    /^mar/i,
    /^abr/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^ago/i,
    /^sep/i,
    /^oct/i,
    /^nov/i,
    /^dic/i
  ]
};
var matchDayPatterns23 = {
  narrow: /^[dlmjvs]/i,
  short: /^(do|lu|ma|mi|ju|vi|s[áa])/i,
  abbreviated: /^(dom|lun|mar|mi[ée]|jue|vie|s[áa]b)/i,
  wide: /^(domingo|lunes|martes|mi[ée]rcoles|jueves|viernes|s[áa]bado)/i
};
var parseDayPatterns23 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
};
var matchDayPeriodPatterns23 = {
  narrow: /^(a|p|mn|md|(de la|a las) (mañana|tarde|noche))/i,
  any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (mañana|tarde|noche))/i
};
var parseDayPeriodPatterns23 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /^md/i,
    morning: /mañana/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noche/i
  }
};
var match23 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern23,
    parsePattern: parseOrdinalNumberPattern23,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns23,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns23,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns23,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns23,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns23,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns23,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns23,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns23,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns23,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns23,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/es.mjs
var es = {
  code: "es",
  formatDistance: formatDistance25,
  formatLong: formatLong29,
  formatRelative: formatRelative23,
  localize: localize24,
  match: match23,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/et/_lib/formatDistance.mjs
var formatDistanceLocale25 = {
  lessThanXSeconds: {
    standalone: {
      one: "vähem kui üks sekund",
      other: "vähem kui {{count}} sekundit"
    },
    withPreposition: {
      one: "vähem kui ühe sekundi",
      other: "vähem kui {{count}} sekundi"
    }
  },
  xSeconds: {
    standalone: {
      one: "üks sekund",
      other: "{{count}} sekundit"
    },
    withPreposition: {
      one: "ühe sekundi",
      other: "{{count}} sekundi"
    }
  },
  halfAMinute: {
    standalone: "pool minutit",
    withPreposition: "poole minuti"
  },
  lessThanXMinutes: {
    standalone: {
      one: "vähem kui üks minut",
      other: "vähem kui {{count}} minutit"
    },
    withPreposition: {
      one: "vähem kui ühe minuti",
      other: "vähem kui {{count}} minuti"
    }
  },
  xMinutes: {
    standalone: {
      one: "üks minut",
      other: "{{count}} minutit"
    },
    withPreposition: {
      one: "ühe minuti",
      other: "{{count}} minuti"
    }
  },
  aboutXHours: {
    standalone: {
      one: "umbes üks tund",
      other: "umbes {{count}} tundi"
    },
    withPreposition: {
      one: "umbes ühe tunni",
      other: "umbes {{count}} tunni"
    }
  },
  xHours: {
    standalone: {
      one: "üks tund",
      other: "{{count}} tundi"
    },
    withPreposition: {
      one: "ühe tunni",
      other: "{{count}} tunni"
    }
  },
  xDays: {
    standalone: {
      one: "üks päev",
      other: "{{count}} päeva"
    },
    withPreposition: {
      one: "ühe päeva",
      other: "{{count}} päeva"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "umbes üks nädal",
      other: "umbes {{count}} nädalat"
    },
    withPreposition: {
      one: "umbes ühe nädala",
      other: "umbes {{count}} nädala"
    }
  },
  xWeeks: {
    standalone: {
      one: "üks nädal",
      other: "{{count}} nädalat"
    },
    withPreposition: {
      one: "ühe nädala",
      other: "{{count}} nädala"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "umbes üks kuu",
      other: "umbes {{count}} kuud"
    },
    withPreposition: {
      one: "umbes ühe kuu",
      other: "umbes {{count}} kuu"
    }
  },
  xMonths: {
    standalone: {
      one: "üks kuu",
      other: "{{count}} kuud"
    },
    withPreposition: {
      one: "ühe kuu",
      other: "{{count}} kuu"
    }
  },
  aboutXYears: {
    standalone: {
      one: "umbes üks aasta",
      other: "umbes {{count}} aastat"
    },
    withPreposition: {
      one: "umbes ühe aasta",
      other: "umbes {{count}} aasta"
    }
  },
  xYears: {
    standalone: {
      one: "üks aasta",
      other: "{{count}} aastat"
    },
    withPreposition: {
      one: "ühe aasta",
      other: "{{count}} aasta"
    }
  },
  overXYears: {
    standalone: {
      one: "rohkem kui üks aasta",
      other: "rohkem kui {{count}} aastat"
    },
    withPreposition: {
      one: "rohkem kui ühe aasta",
      other: "rohkem kui {{count}} aasta"
    }
  },
  almostXYears: {
    standalone: {
      one: "peaaegu üks aasta",
      other: "peaaegu {{count}} aastat"
    },
    withPreposition: {
      one: "peaaegu ühe aasta",
      other: "peaaegu {{count}} aasta"
    }
  }
};
var formatDistance26 = (token, count, options2) => {
  const usageGroup = (options2 == null ? void 0 : options2.addSuffix) ? formatDistanceLocale25[token].withPreposition : formatDistanceLocale25[token].standalone;
  let result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + " pärast";
    } else {
      return result + " eest";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/et/_lib/formatLong.mjs
var dateFormats30 = {
  full: "EEEE, d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y"
};
var timeFormats30 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats30 = {
  full: "{{date}} 'kell' {{time}}",
  long: "{{date}} 'kell' {{time}}",
  medium: "{{date}}. {{time}}",
  short: "{{date}}. {{time}}"
};
var formatLong30 = {
  date: buildFormatLongFn({
    formats: dateFormats30,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats30,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats30,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/et/_lib/formatRelative.mjs
var formatRelativeLocale24 = {
  lastWeek: "'eelmine' eeee 'kell' p",
  yesterday: "'eile kell' p",
  today: "'täna kell' p",
  tomorrow: "'homme kell' p",
  nextWeek: "'järgmine' eeee 'kell' p",
  other: "P"
};
var formatRelative24 = (token, _date, _baseDate, _options) => formatRelativeLocale24[token];

// ../../../node_modules/date-fns/locale/et/_lib/localize.mjs
var eraValues25 = {
  narrow: ["e.m.a", "m.a.j"],
  abbreviated: ["e.m.a", "m.a.j"],
  wide: ["enne meie ajaarvamist", "meie ajaarvamise järgi"]
};
var quarterValues25 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
var monthValues25 = {
  narrow: ["J", "V", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jaan",
    "veebr",
    "märts",
    "apr",
    "mai",
    "juuni",
    "juuli",
    "aug",
    "sept",
    "okt",
    "nov",
    "dets"
  ],
  wide: [
    "jaanuar",
    "veebruar",
    "märts",
    "aprill",
    "mai",
    "juuni",
    "juuli",
    "august",
    "september",
    "oktoober",
    "november",
    "detsember"
  ]
};
var dayValues25 = {
  narrow: ["P", "E", "T", "K", "N", "R", "L"],
  short: ["P", "E", "T", "K", "N", "R", "L"],
  abbreviated: [
    "pühap.",
    "esmasp.",
    "teisip.",
    "kolmap.",
    "neljap.",
    "reede.",
    "laup."
  ],
  wide: [
    "pühapäev",
    "esmaspäev",
    "teisipäev",
    "kolmapäev",
    "neljapäev",
    "reede",
    "laupäev"
  ]
};
var dayPeriodValues25 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "kesköö",
    noon: "keskpäev",
    morning: "hommik",
    afternoon: "pärastlõuna",
    evening: "õhtu",
    night: "öö"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "kesköö",
    noon: "keskpäev",
    morning: "hommik",
    afternoon: "pärastlõuna",
    evening: "õhtu",
    night: "öö"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "kesköö",
    noon: "keskpäev",
    morning: "hommik",
    afternoon: "pärastlõuna",
    evening: "õhtu",
    night: "öö"
  }
};
var formattingDayPeriodValues22 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "keskööl",
    noon: "keskpäeval",
    morning: "hommikul",
    afternoon: "pärastlõunal",
    evening: "õhtul",
    night: "öösel"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "keskööl",
    noon: "keskpäeval",
    morning: "hommikul",
    afternoon: "pärastlõunal",
    evening: "õhtul",
    night: "öösel"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "keskööl",
    noon: "keskpäeval",
    morning: "hommikul",
    afternoon: "pärastlõunal",
    evening: "õhtul",
    night: "öösel"
  }
};
var ordinalNumber25 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize25 = {
  ordinalNumber: ordinalNumber25,
  era: buildLocalizeFn({
    values: eraValues25,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues25,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues25,
    defaultWidth: "wide",
    formattingValues: monthValues25,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues25,
    defaultWidth: "wide",
    formattingValues: dayValues25,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues25,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues22,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/et/_lib/match.mjs
var matchOrdinalNumberPattern24 = /^\d+\./i;
var parseOrdinalNumberPattern24 = /\d+/i;
var matchEraPatterns24 = {
  narrow: /^(e\.m\.a|m\.a\.j|eKr|pKr)/i,
  abbreviated: /^(e\.m\.a|m\.a\.j|eKr|pKr)/i,
  wide: /^(enne meie ajaarvamist|meie ajaarvamise järgi|enne Kristust|pärast Kristust)/i
};
var parseEraPatterns24 = {
  any: [/^e/i, /^(m|p)/i]
};
var matchQuarterPatterns24 = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234](\.)? kvartal/i
};
var parseQuarterPatterns24 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns24 = {
  narrow: /^[jvmasond]/i,
  abbreviated: /^(jaan|veebr|märts|apr|mai|juuni|juuli|aug|sept|okt|nov|dets)/i,
  wide: /^(jaanuar|veebruar|märts|aprill|mai|juuni|juuli|august|september|oktoober|november|detsember)/i
};
var parseMonthPatterns24 = {
  narrow: [
    /^j/i,
    /^v/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^v/i,
    /^mär/i,
    /^ap/i,
    /^mai/i,
    /^juun/i,
    /^juul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns24 = {
  narrow: /^[petknrl]/i,
  short: /^[petknrl]/i,
  abbreviated: /^(püh?|esm?|tei?|kolm?|nel?|ree?|laup?)\.?/i,
  wide: /^(pühapäev|esmaspäev|teisipäev|kolmapäev|neljapäev|reede|laupäev)/i
};
var parseDayPatterns24 = {
  any: [/^p/i, /^e/i, /^t/i, /^k/i, /^n/i, /^r/i, /^l/i]
};
var matchDayPeriodPatterns24 = {
  any: /^(am|pm|keskööl?|keskpäev(al)?|hommik(ul)?|pärastlõunal?|õhtul?|öö(sel)?)/i
};
var parseDayPeriodPatterns24 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^keskö/i,
    noon: /^keskp/i,
    morning: /hommik/i,
    afternoon: /pärastlõuna/i,
    evening: /õhtu/i,
    night: /öö/i
  }
};
var match24 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern24,
    parsePattern: parseOrdinalNumberPattern24,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns24,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns24,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns24,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns24,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns24,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns24,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns24,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns24,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns24,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns24,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/et.mjs
var et = {
  code: "et",
  formatDistance: formatDistance26,
  formatLong: formatLong30,
  formatRelative: formatRelative24,
  localize: localize25,
  match: match24,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/eu/_lib/formatDistance.mjs
var formatDistanceLocale26 = {
  lessThanXSeconds: {
    one: "segundo bat baino gutxiago",
    other: "{{count}} segundo baino gutxiago"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundo"
  },
  halfAMinute: "minutu erdi",
  lessThanXMinutes: {
    one: "minutu bat baino gutxiago",
    other: "{{count}} minutu baino gutxiago"
  },
  xMinutes: {
    one: "1 minutu",
    other: "{{count}} minutu"
  },
  aboutXHours: {
    one: "1 ordu gutxi gorabehera",
    other: "{{count}} ordu gutxi gorabehera"
  },
  xHours: {
    one: "1 ordu",
    other: "{{count}} ordu"
  },
  xDays: {
    one: "1 egun",
    other: "{{count}} egun"
  },
  aboutXWeeks: {
    one: "aste 1 inguru",
    other: "{{count}} aste inguru"
  },
  xWeeks: {
    one: "1 aste",
    other: "{{count}} astean"
  },
  aboutXMonths: {
    one: "1 hilabete gutxi gorabehera",
    other: "{{count}} hilabete gutxi gorabehera"
  },
  xMonths: {
    one: "1 hilabete",
    other: "{{count}} hilabete"
  },
  aboutXYears: {
    one: "1 urte gutxi gorabehera",
    other: "{{count}} urte gutxi gorabehera"
  },
  xYears: {
    one: "1 urte",
    other: "{{count}} urte"
  },
  overXYears: {
    one: "1 urte baino gehiago",
    other: "{{count}} urte baino gehiago"
  },
  almostXYears: {
    one: "ia 1 urte",
    other: "ia {{count}} urte"
  }
};
var formatDistance27 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale26[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "en " + result;
    } else {
      return "duela " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/eu/_lib/formatLong.mjs
var dateFormats31 = {
  full: "EEEE, y'ko' MMMM'ren' d'a' y'ren'",
  long: "y'ko' MMMM'ren' d'a'",
  medium: "y MMM d",
  short: "yy/MM/dd"
};
var timeFormats31 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats31 = {
  full: "{{date}} 'tan' {{time}}",
  long: "{{date}} 'tan' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong31 = {
  date: buildFormatLongFn({
    formats: dateFormats31,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats31,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats31,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/eu/_lib/formatRelative.mjs
var formatRelativeLocale25 = {
  lastWeek: "'joan den' eeee, LT",
  yesterday: "'atzo,' p",
  today: "'gaur,' p",
  tomorrow: "'bihar,' p",
  nextWeek: "eeee, p",
  other: "P"
};
var formatRelativeLocalePlural3 = {
  lastWeek: "'joan den' eeee, p",
  yesterday: "'atzo,' p",
  today: "'gaur,' p",
  tomorrow: "'bihar,' p",
  nextWeek: "eeee, p",
  other: "P"
};
var formatRelative25 = (token, date2) => {
  if (date2.getHours() !== 1) {
    return formatRelativeLocalePlural3[token];
  }
  return formatRelativeLocale25[token];
};

// ../../../node_modules/date-fns/locale/eu/_lib/localize.mjs
var eraValues26 = {
  narrow: ["k.a.", "k.o."],
  abbreviated: ["k.a.", "k.o."],
  wide: ["kristo aurretik", "kristo ondoren"]
};
var quarterValues26 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1H", "2H", "3H", "4H"],
  wide: [
    "1. hiruhilekoa",
    "2. hiruhilekoa",
    "3. hiruhilekoa",
    "4. hiruhilekoa"
  ]
};
var monthValues26 = {
  narrow: ["u", "o", "m", "a", "m", "e", "u", "a", "i", "u", "a", "a"],
  abbreviated: [
    "urt",
    "ots",
    "mar",
    "api",
    "mai",
    "eka",
    "uzt",
    "abu",
    "ira",
    "urr",
    "aza",
    "abe"
  ],
  wide: [
    "urtarrila",
    "otsaila",
    "martxoa",
    "apirila",
    "maiatza",
    "ekaina",
    "uztaila",
    "abuztua",
    "iraila",
    "urria",
    "azaroa",
    "abendua"
  ]
};
var dayValues26 = {
  narrow: ["i", "a", "a", "a", "o", "o", "l"],
  short: ["ig", "al", "as", "az", "og", "or", "lr"],
  abbreviated: ["iga", "ast", "ast", "ast", "ost", "ost", "lar"],
  wide: [
    "igandea",
    "astelehena",
    "asteartea",
    "asteazkena",
    "osteguna",
    "ostirala",
    "larunbata"
  ]
};
var dayPeriodValues26 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "ge",
    noon: "eg",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goiza",
    afternoon: "arratsaldea",
    evening: "arratsaldea",
    night: "gaua"
  }
};
var formattingDayPeriodValues23 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "ge",
    noon: "eg",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gauerdia",
    noon: "eguerdia",
    morning: "goizean",
    afternoon: "arratsaldean",
    evening: "arratsaldean",
    night: "gauean"
  }
};
var ordinalNumber26 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize26 = {
  ordinalNumber: ordinalNumber26,
  era: buildLocalizeFn({
    values: eraValues26,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues26,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues26,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues26,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues26,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues23,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/eu/_lib/match.mjs
var matchOrdinalNumberPattern25 = /^(\d+)(.)?/i;
var parseOrdinalNumberPattern25 = /\d+/i;
var matchEraPatterns25 = {
  narrow: /^(k.a.|k.o.)/i,
  abbreviated: /^(k.a.|k.o.)/i,
  wide: /^(kristo aurretik|kristo ondoren)/i
};
var parseEraPatterns25 = {
  narrow: [/^k.a./i, /^k.o./i],
  abbreviated: [/^(k.a.)/i, /^(k.o.)/i],
  wide: [/^(kristo aurretik)/i, /^(kristo ondoren)/i]
};
var matchQuarterPatterns25 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]H/i,
  wide: /^[1234](.)? hiruhilekoa/i
};
var parseQuarterPatterns25 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns25 = {
  narrow: /^[uomaei]/i,
  abbreviated: /^(urt|ots|mar|api|mai|eka|uzt|abu|ira|urr|aza|abe)/i,
  wide: /^(urtarrila|otsaila|martxoa|apirila|maiatza|ekaina|uztaila|abuztua|iraila|urria|azaroa|abendua)/i
};
var parseMonthPatterns25 = {
  narrow: [
    /^u/i,
    /^o/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^e/i,
    /^u/i,
    /^a/i,
    /^i/i,
    /^u/i,
    /^a/i,
    /^a/i
  ],
  any: [
    /^urt/i,
    /^ots/i,
    /^mar/i,
    /^api/i,
    /^mai/i,
    /^eka/i,
    /^uzt/i,
    /^abu/i,
    /^ira/i,
    /^urr/i,
    /^aza/i,
    /^abe/i
  ]
};
var matchDayPatterns25 = {
  narrow: /^[iaol]/i,
  short: /^(ig|al|as|az|og|or|lr)/i,
  abbreviated: /^(iga|ast|ast|ast|ost|ost|lar)/i,
  wide: /^(igandea|astelehena|asteartea|asteazkena|osteguna|ostirala|larunbata)/i
};
var parseDayPatterns25 = {
  narrow: [/^i/i, /^a/i, /^a/i, /^a/i, /^o/i, /^o/i, /^l/i],
  short: [/^ig/i, /^al/i, /^as/i, /^az/i, /^og/i, /^or/i, /^lr/i],
  abbreviated: [/^iga/i, /^ast/i, /^ast/i, /^ast/i, /^ost/i, /^ost/i, /^lar/i],
  wide: [
    /^igandea/i,
    /^astelehena/i,
    /^asteartea/i,
    /^asteazkena/i,
    /^osteguna/i,
    /^ostirala/i,
    /^larunbata/i
  ]
};
var matchDayPeriodPatterns25 = {
  narrow: /^(a|p|ge|eg|((goiza|goizean)|arratsaldea|(gaua|gauean)))/i,
  any: /^([ap]\.?\s?m\.?|gauerdia|eguerdia|((goiza|goizean)|arratsaldea|(gaua|gauean)))/i
};
var parseDayPeriodPatterns25 = {
  narrow: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^ge/i,
    noon: /^eg/i,
    morning: /goiz/i,
    afternoon: /arratsaldea/i,
    evening: /arratsaldea/i,
    night: /gau/i
  },
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^gauerdia/i,
    noon: /^eguerdia/i,
    morning: /goiz/i,
    afternoon: /arratsaldea/i,
    evening: /arratsaldea/i,
    night: /gau/i
  }
};
var match25 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern25,
    parsePattern: parseOrdinalNumberPattern25,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns25,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns25,
    defaultParseWidth: "wide"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns25,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns25,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns25,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns25,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns25,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns25,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns25,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns25,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/eu.mjs
var eu = {
  code: "eu",
  formatDistance: formatDistance27,
  formatLong: formatLong31,
  formatRelative: formatRelative25,
  localize: localize26,
  match: match25,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/fa-IR/_lib/formatDistance.mjs
var formatDistanceLocale27 = {
  lessThanXSeconds: {
    one: "کمتر از یک ثانیه",
    other: "کمتر از {{count}} ثانیه"
  },
  xSeconds: {
    one: "1 ثانیه",
    other: "{{count}} ثانیه"
  },
  halfAMinute: "نیم دقیقه",
  lessThanXMinutes: {
    one: "کمتر از یک دقیقه",
    other: "کمتر از {{count}} دقیقه"
  },
  xMinutes: {
    one: "1 دقیقه",
    other: "{{count}} دقیقه"
  },
  aboutXHours: {
    one: "حدود 1 ساعت",
    other: "حدود {{count}} ساعت"
  },
  xHours: {
    one: "1 ساعت",
    other: "{{count}} ساعت"
  },
  xDays: {
    one: "1 روز",
    other: "{{count}} روز"
  },
  aboutXWeeks: {
    one: "حدود 1 هفته",
    other: "حدود {{count}} هفته"
  },
  xWeeks: {
    one: "1 هفته",
    other: "{{count}} هفته"
  },
  aboutXMonths: {
    one: "حدود 1 ماه",
    other: "حدود {{count}} ماه"
  },
  xMonths: {
    one: "1 ماه",
    other: "{{count}} ماه"
  },
  aboutXYears: {
    one: "حدود 1 سال",
    other: "حدود {{count}} سال"
  },
  xYears: {
    one: "1 سال",
    other: "{{count}} سال"
  },
  overXYears: {
    one: "بیشتر از 1 سال",
    other: "بیشتر از {{count}} سال"
  },
  almostXYears: {
    one: "نزدیک 1 سال",
    other: "نزدیک {{count}} سال"
  }
};
var formatDistance28 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale27[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "در " + result;
    } else {
      return result + " قبل";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/fa-IR/_lib/formatLong.mjs
var dateFormats32 = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "yyyy/MM/dd"
};
var timeFormats32 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats32 = {
  full: "{{date}} 'در' {{time}}",
  long: "{{date}} 'در' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong32 = {
  date: buildFormatLongFn({
    formats: dateFormats32,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats32,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats32,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/fa-IR/_lib/formatRelative.mjs
var formatRelativeLocale26 = {
  lastWeek: "eeee 'گذشته در' p",
  yesterday: "'دیروز در' p",
  today: "'امروز در' p",
  tomorrow: "'فردا در' p",
  nextWeek: "eeee 'در' p",
  other: "P"
};
var formatRelative26 = (token, _date, _baseDate, _options) => formatRelativeLocale26[token];

// ../../../node_modules/date-fns/locale/fa-IR/_lib/localize.mjs
var eraValues27 = {
  narrow: ["ق", "ب"],
  abbreviated: ["ق.م.", "ب.م."],
  wide: ["قبل از میلاد", "بعد از میلاد"]
};
var quarterValues27 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["س‌م1", "س‌م2", "س‌م3", "س‌م4"],
  wide: ["سه‌ماهه 1", "سه‌ماهه 2", "سه‌ماهه 3", "سه‌ماهه 4"]
};
var monthValues27 = {
  narrow: ["ژ", "ف", "م", "آ", "م", "ج", "ج", "آ", "س", "ا", "ن", "د"],
  abbreviated: [
    "ژانـ",
    "فور",
    "مارس",
    "آپر",
    "می",
    "جون",
    "جولـ",
    "آگو",
    "سپتـ",
    "اکتـ",
    "نوامـ",
    "دسامـ"
  ],
  wide: [
    "ژانویه",
    "فوریه",
    "مارس",
    "آپریل",
    "می",
    "جون",
    "جولای",
    "آگوست",
    "سپتامبر",
    "اکتبر",
    "نوامبر",
    "دسامبر"
  ]
};
var dayValues27 = {
  narrow: ["ی", "د", "س", "چ", "پ", "ج", "ش"],
  short: ["1ش", "2ش", "3ش", "4ش", "5ش", "ج", "ش"],
  abbreviated: [
    "یکشنبه",
    "دوشنبه",
    "سه‌شنبه",
    "چهارشنبه",
    "پنجشنبه",
    "جمعه",
    "شنبه"
  ],
  wide: ["یکشنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه"]
};
var dayPeriodValues27 = {
  narrow: {
    am: "ق",
    pm: "ب",
    midnight: "ن",
    noon: "ظ",
    morning: "ص",
    afternoon: "ب.ظ.",
    evening: "ع",
    night: "ش"
  },
  abbreviated: {
    am: "ق.ظ.",
    pm: "ب.ظ.",
    midnight: "نیمه‌شب",
    noon: "ظهر",
    morning: "صبح",
    afternoon: "بعدازظهر",
    evening: "عصر",
    night: "شب"
  },
  wide: {
    am: "قبل‌ازظهر",
    pm: "بعدازظهر",
    midnight: "نیمه‌شب",
    noon: "ظهر",
    morning: "صبح",
    afternoon: "بعدازظهر",
    evening: "عصر",
    night: "شب"
  }
};
var formattingDayPeriodValues24 = {
  narrow: {
    am: "ق",
    pm: "ب",
    midnight: "ن",
    noon: "ظ",
    morning: "ص",
    afternoon: "ب.ظ.",
    evening: "ع",
    night: "ش"
  },
  abbreviated: {
    am: "ق.ظ.",
    pm: "ب.ظ.",
    midnight: "نیمه‌شب",
    noon: "ظهر",
    morning: "صبح",
    afternoon: "بعدازظهر",
    evening: "عصر",
    night: "شب"
  },
  wide: {
    am: "قبل‌ازظهر",
    pm: "بعدازظهر",
    midnight: "نیمه‌شب",
    noon: "ظهر",
    morning: "صبح",
    afternoon: "بعدازظهر",
    evening: "عصر",
    night: "شب"
  }
};
var ordinalNumber27 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize27 = {
  ordinalNumber: ordinalNumber27,
  era: buildLocalizeFn({
    values: eraValues27,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues27,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues27,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues27,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues27,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues24,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/fa-IR/_lib/match.mjs
var matchOrdinalNumberPattern26 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern26 = /\d+/i;
var matchEraPatterns26 = {
  narrow: /^(ق|ب)/i,
  abbreviated: /^(ق\.?\s?م\.?|ق\.?\s?د\.?\s?م\.?|م\.?\s?|د\.?\s?م\.?)/i,
  wide: /^(قبل از میلاد|قبل از دوران مشترک|میلادی|دوران مشترک|بعد از میلاد)/i
};
var parseEraPatterns26 = {
  any: [/^قبل/i, /^بعد/i]
};
var matchQuarterPatterns26 = {
  narrow: /^[1234]/i,
  abbreviated: /^س‌م[1234]/i,
  wide: /^سه‌ماهه [1234]/i
};
var parseQuarterPatterns26 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns26 = {
  narrow: /^[جژفمآاماسند]/i,
  abbreviated: /^(جنو|ژانـ|ژانویه|فوریه|فور|مارس|آوریل|آپر|مه|می|ژوئن|جون|جول|جولـ|ژوئیه|اوت|آگو|سپتمبر|سپتامبر|اکتبر|اکتوبر|نوامبر|نوامـ|دسامبر|دسامـ|دسم)/i,
  wide: /^(ژانویه|جنوری|فبروری|فوریه|مارچ|مارس|آپریل|اپریل|ایپریل|آوریل|مه|می|ژوئن|جون|جولای|ژوئیه|آگست|اگست|آگوست|اوت|سپتمبر|سپتامبر|اکتبر|اکتوبر|نوامبر|نومبر|دسامبر|دسمبر)/i
};
var parseMonthPatterns26 = {
  narrow: [
    /^(ژ|ج)/i,
    /^ف/i,
    /^م/i,
    /^(آ|ا)/i,
    /^م/i,
    /^(ژ|ج)/i,
    /^(ج|ژ)/i,
    /^(آ|ا)/i,
    /^س/i,
    /^ا/i,
    /^ن/i,
    /^د/i
  ],
  any: [
    /^ژا/i,
    /^ف/i,
    /^ما/i,
    /^آپ/i,
    /^(می|مه)/i,
    /^(ژوئن|جون)/i,
    /^(ژوئی|جول)/i,
    /^(اوت|آگ)/i,
    /^س/i,
    /^(اوک|اک)/i,
    /^ن/i,
    /^د/i
  ]
};
var matchDayPatterns26 = {
  narrow: /^[شیدسچپج]/i,
  short: /^(ش|ج|1ش|2ش|3ش|4ش|5ش)/i,
  abbreviated: /^(یکشنبه|دوشنبه|سه‌شنبه|چهارشنبه|پنج‌شنبه|جمعه|شنبه)/i,
  wide: /^(یکشنبه|دوشنبه|سه‌شنبه|چهارشنبه|پنج‌شنبه|جمعه|شنبه)/i
};
var parseDayPatterns26 = {
  narrow: [/^ی/i, /^دو/i, /^س/i, /^چ/i, /^پ/i, /^ج/i, /^ش/i],
  any: [
    /^(ی|1ش|یکشنبه)/i,
    /^(د|2ش|دوشنبه)/i,
    /^(س|3ش|سه‌شنبه)/i,
    /^(چ|4ش|چهارشنبه)/i,
    /^(پ|5ش|پنجشنبه)/i,
    /^(ج|جمعه)/i,
    /^(ش|شنبه)/i
  ]
};
var matchDayPeriodPatterns26 = {
  narrow: /^(ب|ق|ن|ظ|ص|ب.ظ.|ع|ش)/i,
  abbreviated: /^(ق.ظ.|ب.ظ.|نیمه‌شب|ظهر|صبح|بعدازظهر|عصر|شب)/i,
  wide: /^(قبل‌ازظهر|نیمه‌شب|ظهر|صبح|بعدازظهر|عصر|شب)/i
};
var parseDayPeriodPatterns26 = {
  any: {
    am: /^(ق|ق.ظ.|قبل‌ازظهر)/i,
    pm: /^(ب|ب.ظ.|بعدازظهر)/i,
    midnight: /^(‌نیمه‌شب|ن)/i,
    noon: /^(ظ|ظهر)/i,
    morning: /(ص|صبح)/i,
    afternoon: /(ب|ب.ظ.|بعدازظهر)/i,
    evening: /(ع|عصر)/i,
    night: /(ش|شب)/i
  }
};
var match26 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern26,
    parsePattern: parseOrdinalNumberPattern26,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns26,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns26,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns26,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns26,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns26,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns26,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns26,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns26,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns26,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns26,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/fa-IR.mjs
var faIR = {
  code: "fa-IR",
  formatDistance: formatDistance28,
  formatLong: formatLong32,
  formatRelative: formatRelative26,
  localize: localize27,
  match: match26,
  options: {
    weekStartsOn: 6,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/fi/_lib/formatDistance.mjs
function futureSeconds(text) {
  return text.replace(/sekuntia?/, "sekunnin");
}
function futureMinutes(text) {
  return text.replace(/minuuttia?/, "minuutin");
}
function futureHours(text) {
  return text.replace(/tuntia?/, "tunnin");
}
function futureDays(text) {
  return text.replace(/päivää?/, "päivän");
}
function futureWeeks(text) {
  return text.replace(/(viikko|viikkoa)/, "viikon");
}
function futureMonths(text) {
  return text.replace(/(kuukausi|kuukautta)/, "kuukauden");
}
function futureYears(text) {
  return text.replace(/(vuosi|vuotta)/, "vuoden");
}
var formatDistanceLocale28 = {
  lessThanXSeconds: {
    one: "alle sekunti",
    other: "alle {{count}} sekuntia",
    futureTense: futureSeconds
  },
  xSeconds: {
    one: "sekunti",
    other: "{{count}} sekuntia",
    futureTense: futureSeconds
  },
  halfAMinute: {
    one: "puoli minuuttia",
    other: "puoli minuuttia",
    futureTense: (_text) => "puolen minuutin"
  },
  lessThanXMinutes: {
    one: "alle minuutti",
    other: "alle {{count}} minuuttia",
    futureTense: futureMinutes
  },
  xMinutes: {
    one: "minuutti",
    other: "{{count}} minuuttia",
    futureTense: futureMinutes
  },
  aboutXHours: {
    one: "noin tunti",
    other: "noin {{count}} tuntia",
    futureTense: futureHours
  },
  xHours: {
    one: "tunti",
    other: "{{count}} tuntia",
    futureTense: futureHours
  },
  xDays: {
    one: "päivä",
    other: "{{count}} päivää",
    futureTense: futureDays
  },
  aboutXWeeks: {
    one: "noin viikko",
    other: "noin {{count}} viikkoa",
    futureTense: futureWeeks
  },
  xWeeks: {
    one: "viikko",
    other: "{{count}} viikkoa",
    futureTense: futureWeeks
  },
  aboutXMonths: {
    one: "noin kuukausi",
    other: "noin {{count}} kuukautta",
    futureTense: futureMonths
  },
  xMonths: {
    one: "kuukausi",
    other: "{{count}} kuukautta",
    futureTense: futureMonths
  },
  aboutXYears: {
    one: "noin vuosi",
    other: "noin {{count}} vuotta",
    futureTense: futureYears
  },
  xYears: {
    one: "vuosi",
    other: "{{count}} vuotta",
    futureTense: futureYears
  },
  overXYears: {
    one: "yli vuosi",
    other: "yli {{count}} vuotta",
    futureTense: futureYears
  },
  almostXYears: {
    one: "lähes vuosi",
    other: "lähes {{count}} vuotta",
    futureTense: futureYears
  }
};
var formatDistance29 = (token, count, options2) => {
  const tokenValue = formatDistanceLocale28[token];
  const result = count === 1 ? tokenValue.one : tokenValue.other.replace("{{count}}", String(count));
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return tokenValue.futureTense(result) + " kuluttua";
    } else {
      return result + " sitten";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/fi/_lib/formatLong.mjs
var dateFormats33 = {
  full: "eeee d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "d.M.y"
};
var timeFormats33 = {
  full: "HH.mm.ss zzzz",
  long: "HH.mm.ss z",
  medium: "HH.mm.ss",
  short: "HH.mm"
};
var dateTimeFormats33 = {
  full: "{{date}} 'klo' {{time}}",
  long: "{{date}} 'klo' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong33 = {
  date: buildFormatLongFn({
    formats: dateFormats33,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats33,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats33,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/fi/_lib/formatRelative.mjs
var formatRelativeLocale27 = {
  lastWeek: "'viime' eeee 'klo' p",
  yesterday: "'eilen klo' p",
  today: "'tänään klo' p",
  tomorrow: "'huomenna klo' p",
  nextWeek: "'ensi' eeee 'klo' p",
  other: "P"
};
var formatRelative27 = (token, _date, _baseDate, _options) => formatRelativeLocale27[token];

// ../../../node_modules/date-fns/locale/fi/_lib/localize.mjs
var eraValues28 = {
  narrow: ["eaa.", "jaa."],
  abbreviated: ["eaa.", "jaa."],
  wide: ["ennen ajanlaskun alkua", "jälkeen ajanlaskun alun"]
};
var quarterValues28 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartaali", "2. kvartaali", "3. kvartaali", "4. kvartaali"]
};
var monthValues28 = {
  narrow: ["T", "H", "M", "H", "T", "K", "H", "E", "S", "L", "M", "J"],
  abbreviated: [
    "tammi",
    "helmi",
    "maalis",
    "huhti",
    "touko",
    "kesä",
    "heinä",
    "elo",
    "syys",
    "loka",
    "marras",
    "joulu"
  ],
  wide: [
    "tammikuu",
    "helmikuu",
    "maaliskuu",
    "huhtikuu",
    "toukokuu",
    "kesäkuu",
    "heinäkuu",
    "elokuu",
    "syyskuu",
    "lokakuu",
    "marraskuu",
    "joulukuu"
  ]
};
var formattingMonthValues8 = {
  narrow: monthValues28.narrow,
  abbreviated: monthValues28.abbreviated,
  wide: [
    "tammikuuta",
    "helmikuuta",
    "maaliskuuta",
    "huhtikuuta",
    "toukokuuta",
    "kesäkuuta",
    "heinäkuuta",
    "elokuuta",
    "syyskuuta",
    "lokakuuta",
    "marraskuuta",
    "joulukuuta"
  ]
};
var dayValues28 = {
  narrow: ["S", "M", "T", "K", "T", "P", "L"],
  short: ["su", "ma", "ti", "ke", "to", "pe", "la"],
  abbreviated: ["sunn.", "maan.", "tiis.", "kesk.", "torst.", "perj.", "la"],
  wide: [
    "sunnuntai",
    "maanantai",
    "tiistai",
    "keskiviikko",
    "torstai",
    "perjantai",
    "lauantai"
  ]
};
var formattingDayValues = {
  narrow: dayValues28.narrow,
  short: dayValues28.short,
  abbreviated: dayValues28.abbreviated,
  wide: [
    "sunnuntaina",
    "maanantaina",
    "tiistaina",
    "keskiviikkona",
    "torstaina",
    "perjantaina",
    "lauantaina"
  ]
};
var dayPeriodValues28 = {
  narrow: {
    am: "ap",
    pm: "ip",
    midnight: "keskiyö",
    noon: "keskipäivä",
    morning: "ap",
    afternoon: "ip",
    evening: "illalla",
    night: "yöllä"
  },
  abbreviated: {
    am: "ap",
    pm: "ip",
    midnight: "keskiyö",
    noon: "keskipäivä",
    morning: "ap",
    afternoon: "ip",
    evening: "illalla",
    night: "yöllä"
  },
  wide: {
    am: "ap",
    pm: "ip",
    midnight: "keskiyöllä",
    noon: "keskipäivällä",
    morning: "aamupäivällä",
    afternoon: "iltapäivällä",
    evening: "illalla",
    night: "yöllä"
  }
};
var ordinalNumber28 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize28 = {
  ordinalNumber: ordinalNumber28,
  era: buildLocalizeFn({
    values: eraValues28,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues28,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues28,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues8,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues28,
    defaultWidth: "wide",
    formattingValues: formattingDayValues,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues28,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/fi/_lib/match.mjs
var matchOrdinalNumberPattern27 = /^(\d+)(\.)/i;
var parseOrdinalNumberPattern27 = /\d+/i;
var matchEraPatterns27 = {
  narrow: /^(e|j)/i,
  abbreviated: /^(eaa.|jaa.)/i,
  wide: /^(ennen ajanlaskun alkua|jälkeen ajanlaskun alun)/i
};
var parseEraPatterns27 = {
  any: [/^e/i, /^j/i]
};
var matchQuarterPatterns27 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]\.? kvartaali/i
};
var parseQuarterPatterns27 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns27 = {
  narrow: /^[thmkeslj]/i,
  abbreviated: /^(tammi|helmi|maalis|huhti|touko|kesä|heinä|elo|syys|loka|marras|joulu)/i,
  wide: /^(tammikuu|helmikuu|maaliskuu|huhtikuu|toukokuu|kesäkuu|heinäkuu|elokuu|syyskuu|lokakuu|marraskuu|joulukuu)(ta)?/i
};
var parseMonthPatterns27 = {
  narrow: [
    /^t/i,
    /^h/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^k/i,
    /^h/i,
    /^e/i,
    /^s/i,
    /^l/i,
    /^m/i,
    /^j/i
  ],
  any: [
    /^ta/i,
    /^hel/i,
    /^maa/i,
    /^hu/i,
    /^to/i,
    /^k/i,
    /^hei/i,
    /^e/i,
    /^s/i,
    /^l/i,
    /^mar/i,
    /^j/i
  ]
};
var matchDayPatterns27 = {
  narrow: /^[smtkpl]/i,
  short: /^(su|ma|ti|ke|to|pe|la)/i,
  abbreviated: /^(sunn.|maan.|tiis.|kesk.|torst.|perj.|la)/i,
  wide: /^(sunnuntai|maanantai|tiistai|keskiviikko|torstai|perjantai|lauantai)(na)?/i
};
var parseDayPatterns27 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^k/i, /^t/i, /^p/i, /^l/i],
  any: [/^s/i, /^m/i, /^ti/i, /^k/i, /^to/i, /^p/i, /^l/i]
};
var matchDayPeriodPatterns27 = {
  narrow: /^(ap|ip|keskiyö|keskipäivä|aamupäivällä|iltapäivällä|illalla|yöllä)/i,
  any: /^(ap|ip|keskiyöllä|keskipäivällä|aamupäivällä|iltapäivällä|illalla|yöllä)/i
};
var parseDayPeriodPatterns27 = {
  any: {
    am: /^ap/i,
    pm: /^ip/i,
    midnight: /^keskiyö/i,
    noon: /^keskipäivä/i,
    morning: /aamupäivällä/i,
    afternoon: /iltapäivällä/i,
    evening: /illalla/i,
    night: /yöllä/i
  }
};
var match27 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern27,
    parsePattern: parseOrdinalNumberPattern27,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns27,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns27,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns27,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns27,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns27,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns27,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns27,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns27,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns27,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns27,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/fi.mjs
var fi = {
  code: "fi",
  formatDistance: formatDistance29,
  formatLong: formatLong33,
  formatRelative: formatRelative27,
  localize: localize28,
  match: match27,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/fr/_lib/formatDistance.mjs
var formatDistanceLocale29 = {
  lessThanXSeconds: {
    one: "moins d’une seconde",
    other: "moins de {{count}} secondes"
  },
  xSeconds: {
    one: "1 seconde",
    other: "{{count}} secondes"
  },
  halfAMinute: "30 secondes",
  lessThanXMinutes: {
    one: "moins d’une minute",
    other: "moins de {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "environ 1 heure",
    other: "environ {{count}} heures"
  },
  xHours: {
    one: "1 heure",
    other: "{{count}} heures"
  },
  xDays: {
    one: "1 jour",
    other: "{{count}} jours"
  },
  aboutXWeeks: {
    one: "environ 1 semaine",
    other: "environ {{count}} semaines"
  },
  xWeeks: {
    one: "1 semaine",
    other: "{{count}} semaines"
  },
  aboutXMonths: {
    one: "environ 1 mois",
    other: "environ {{count}} mois"
  },
  xMonths: {
    one: "1 mois",
    other: "{{count}} mois"
  },
  aboutXYears: {
    one: "environ 1 an",
    other: "environ {{count}} ans"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} ans"
  },
  overXYears: {
    one: "plus d’un an",
    other: "plus de {{count}} ans"
  },
  almostXYears: {
    one: "presqu’un an",
    other: "presque {{count}} ans"
  }
};
var formatDistance30 = (token, count, options2) => {
  let result;
  const form = formatDistanceLocale29[token];
  if (typeof form === "string") {
    result = form;
  } else if (count === 1) {
    result = form.one;
  } else {
    result = form.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "dans " + result;
    } else {
      return "il y a " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/fr/_lib/formatLong.mjs
var dateFormats34 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats34 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats34 = {
  full: "{{date}} 'à' {{time}}",
  long: "{{date}} 'à' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong34 = {
  date: buildFormatLongFn({
    formats: dateFormats34,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats34,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats34,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/fr/_lib/formatRelative.mjs
var formatRelativeLocale28 = {
  lastWeek: "eeee 'dernier à' p",
  yesterday: "'hier à' p",
  today: "'aujourd’hui à' p",
  tomorrow: "'demain à' p'",
  nextWeek: "eeee 'prochain à' p",
  other: "P"
};
var formatRelative28 = (token, _date, _baseDate, _options) => formatRelativeLocale28[token];

// ../../../node_modules/date-fns/locale/fr/_lib/localize.mjs
var eraValues29 = {
  narrow: ["av. J.-C", "ap. J.-C"],
  abbreviated: ["av. J.-C", "ap. J.-C"],
  wide: ["avant Jésus-Christ", "après Jésus-Christ"]
};
var quarterValues29 = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1er trim.", "2ème trim.", "3ème trim.", "4ème trim."],
  wide: ["1er trimestre", "2ème trimestre", "3ème trimestre", "4ème trimestre"]
};
var monthValues29 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "févr.",
    "mars",
    "avr.",
    "mai",
    "juin",
    "juil.",
    "août",
    "sept.",
    "oct.",
    "nov.",
    "déc."
  ],
  wide: [
    "janvier",
    "février",
    "mars",
    "avril",
    "mai",
    "juin",
    "juillet",
    "août",
    "septembre",
    "octobre",
    "novembre",
    "décembre"
  ]
};
var dayValues29 = {
  narrow: ["D", "L", "M", "M", "J", "V", "S"],
  short: ["di", "lu", "ma", "me", "je", "ve", "sa"],
  abbreviated: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
  wide: [
    "dimanche",
    "lundi",
    "mardi",
    "mercredi",
    "jeudi",
    "vendredi",
    "samedi"
  ]
};
var dayPeriodValues29 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "mat.",
    afternoon: "ap.m.",
    evening: "soir",
    night: "mat."
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "matin",
    afternoon: "après-midi",
    evening: "soir",
    night: "matin"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "minuit",
    noon: "midi",
    morning: "du matin",
    afternoon: "de l’après-midi",
    evening: "du soir",
    night: "du matin"
  }
};
var ordinalNumber29 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = options2 == null ? void 0 : options2.unit;
  if (number2 === 0) return "0";
  const feminineUnits = ["year", "week", "hour", "minute", "second"];
  let suffix2;
  if (number2 === 1) {
    suffix2 = unit && feminineUnits.includes(unit) ? "ère" : "er";
  } else {
    suffix2 = "ème";
  }
  return number2 + suffix2;
};
var LONG_MONTHS_TOKENS = ["MMM", "MMMM"];
var localize29 = {
  preprocessor: (date2, parts) => {
    if (date2.getDate() === 1) return parts;
    const hasLongMonthToken = parts.some(
      (part) => part.isToken && LONG_MONTHS_TOKENS.includes(part.value)
    );
    if (!hasLongMonthToken) return parts;
    return parts.map(
      (part) => part.isToken && part.value === "do" ? { isToken: true, value: "d" } : part
    );
  },
  ordinalNumber: ordinalNumber29,
  era: buildLocalizeFn({
    values: eraValues29,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues29,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues29,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues29,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues29,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/fr/_lib/match.mjs
var matchOrdinalNumberPattern28 = /^(\d+)(ième|ère|ème|er|e)?/i;
var parseOrdinalNumberPattern28 = /\d+/i;
var matchEraPatterns28 = {
  narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
  abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
  wide: /^(avant Jésus-Christ|après Jésus-Christ)/i
};
var parseEraPatterns28 = {
  any: [/^av/i, /^ap/i]
};
var matchQuarterPatterns28 = {
  narrow: /^T?[1234]/i,
  abbreviated: /^[1234](er|ème|e)? trim\.?/i,
  wide: /^[1234](er|ème|e)? trimestre/i
};
var parseQuarterPatterns28 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns28 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(janv|févr|mars|avr|mai|juin|juill|juil|août|sept|oct|nov|déc)\.?/i,
  wide: /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i
};
var parseMonthPatterns28 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^av/i,
    /^ma/i,
    /^juin/i,
    /^juil/i,
    /^ao/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns28 = {
  narrow: /^[lmjvsd]/i,
  short: /^(di|lu|ma|me|je|ve|sa)/i,
  abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
  wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
};
var parseDayPatterns28 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
};
var matchDayPeriodPatterns28 = {
  narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
  any: /^([ap]\.?\s?m\.?|du matin|de l'après[-\s]midi|du soir|de la nuit)/i
};
var parseDayPeriodPatterns28 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^min/i,
    noon: /^mid/i,
    morning: /mat/i,
    afternoon: /ap/i,
    evening: /soir/i,
    night: /nuit/i
  }
};
var match28 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern28,
    parsePattern: parseOrdinalNumberPattern28,
    valueCallback: (value) => parseInt(value)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns28,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns28,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns28,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns28,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns28,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns28,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns28,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns28,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns28,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns28,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/fr.mjs
var fr = {
  code: "fr",
  formatDistance: formatDistance30,
  formatLong: formatLong34,
  formatRelative: formatRelative28,
  localize: localize29,
  match: match28,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/fr-CA/_lib/formatLong.mjs
var dateFormats35 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "yy-MM-dd"
};
var timeFormats35 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats35 = {
  full: "{{date}} 'à' {{time}}",
  long: "{{date}} 'à' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong35 = {
  date: buildFormatLongFn({
    formats: dateFormats35,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats35,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats35,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/fr-CA.mjs
var frCA = {
  code: "fr-CA",
  formatDistance: formatDistance30,
  formatLong: formatLong35,
  formatRelative: formatRelative28,
  localize: localize29,
  match: match28,
  // Unique for fr-CA
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/fr-CH/_lib/formatLong.mjs
var dateFormats36 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y"
};
var timeFormats36 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats36 = {
  full: "{{date}} 'à' {{time}}",
  long: "{{date}} 'à' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong36 = {
  date: buildFormatLongFn({
    formats: dateFormats36,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats36,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats36,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/fr-CH/_lib/formatRelative.mjs
var formatRelativeLocale29 = {
  lastWeek: "eeee 'la semaine dernière à' p",
  yesterday: "'hier à' p",
  today: "'aujourd’hui à' p",
  tomorrow: "'demain à' p'",
  nextWeek: "eeee 'la semaine prochaine à' p",
  other: "P"
};
var formatRelative29 = (token, _date, _baseDate, _options) => formatRelativeLocale29[token];

// ../../../node_modules/date-fns/locale/fr-CH.mjs
var frCH = {
  code: "fr-CH",
  formatDistance: formatDistance30,
  formatLong: formatLong36,
  formatRelative: formatRelative29,
  localize: localize29,
  match: match28,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/fy/_lib/formatDistance.mjs
var formatDistanceLocale30 = {
  lessThanXSeconds: {
    one: "minder as 1 sekonde",
    other: "minder as {{count}} sekonden"
  },
  xSeconds: {
    one: "1 sekonde",
    other: "{{count}} sekonden"
  },
  halfAMinute: "oardel minút",
  lessThanXMinutes: {
    one: "minder as 1 minút",
    other: "minder as {{count}} minuten"
  },
  xMinutes: {
    one: "1 minút",
    other: "{{count}} minuten"
  },
  aboutXHours: {
    one: "sawat 1 oere",
    other: "sawat {{count}} oere"
  },
  xHours: {
    one: "1 oere",
    other: "{{count}} oere"
  },
  xDays: {
    one: "1 dei",
    other: "{{count}} dagen"
  },
  aboutXWeeks: {
    one: "sawat 1 wike",
    other: "sawat {{count}} wiken"
  },
  xWeeks: {
    one: "1 wike",
    other: "{{count}} wiken"
  },
  aboutXMonths: {
    one: "sawat 1 moanne",
    other: "sawat {{count}} moannen"
  },
  xMonths: {
    one: "1 moanne",
    other: "{{count}} moannen"
  },
  aboutXYears: {
    one: "sawat 1 jier",
    other: "sawat {{count}} jier"
  },
  xYears: {
    one: "1 jier",
    other: "{{count}} jier"
  },
  overXYears: {
    one: "mear as 1 jier",
    other: "mear as {{count}}s jier"
  },
  almostXYears: {
    one: "hast 1 jier",
    other: "hast {{count}} jier"
  }
};
var formatDistance31 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale30[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "oer " + result;
    } else {
      return result + " lyn";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/fy/_lib/formatLong.mjs
var dateFormats37 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd-MM-y"
};
var timeFormats37 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats37 = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong37 = {
  date: buildFormatLongFn({
    formats: dateFormats37,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats37,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats37,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/fy/_lib/formatRelative.mjs
var formatRelativeLocale30 = {
  lastWeek: "'ôfrûne' eeee 'om' p",
  yesterday: "'juster om' p",
  today: "'hjoed om' p",
  tomorrow: "'moarn om' p",
  nextWeek: "eeee 'om' p",
  other: "P"
};
var formatRelative30 = (token, _date, _baseDate, _options) => formatRelativeLocale30[token];

// ../../../node_modules/date-fns/locale/fy/_lib/localize.mjs
var eraValues30 = {
  narrow: ["f.K.", "n.K."],
  abbreviated: ["f.Kr.", "n.Kr."],
  wide: ["foar Kristus", "nei Kristus"]
};
var quarterValues30 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e fearnsjier", "2e fearnsjier", "3e fearnsjier", "4e fearnsjier"]
};
var monthValues30 = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mai.",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des."
  ],
  wide: [
    "jannewaris",
    "febrewaris",
    "maart",
    "april",
    "maaie",
    "juny",
    "july",
    "augustus",
    "septimber",
    "oktober",
    "novimber",
    "desimber"
  ]
};
var dayValues30 = {
  narrow: ["s", "m", "t", "w", "t", "f", "s"],
  short: ["si", "mo", "ti", "wo", "to", "fr", "so"],
  abbreviated: ["snein", "moa", "tii", "woa", "ton", "fre", "sneon"],
  wide: [
    "snein",
    "moandei",
    "tiisdei",
    "woansdei",
    "tongersdei",
    "freed",
    "sneon"
  ]
};
var dayPeriodValues30 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jûns",
    night: "nachts"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jûns",
    night: "nachts"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "middei",
    morning: "moarns",
    afternoon: "middeis",
    evening: "jûns",
    night: "nachts"
  }
};
var ordinalNumber30 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "e";
};
var localize30 = {
  ordinalNumber: ordinalNumber30,
  era: buildLocalizeFn({
    values: eraValues30,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues30,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues30,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues30,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues30,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/fy/_lib/match.mjs
var matchOrdinalNumberPattern29 = /^(\d+)e?/i;
var parseOrdinalNumberPattern29 = /\d+/i;
var matchEraPatterns29 = {
  narrow: /^([fn]\.? ?K\.?)/,
  abbreviated: /^([fn]\. ?Kr\.?)/,
  wide: /^((foar|nei) Kristus)/
};
var parseEraPatterns29 = {
  any: [/^f/, /^n/]
};
var matchQuarterPatterns29 = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e fearnsjier/i
};
var parseQuarterPatterns29 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns29 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mrt.|apr.|mai.|jun.|jul.|aug.|sep.|okt.|nov.|des.)/i,
  wide: /^(jannewaris|febrewaris|maart|april|maaie|juny|july|augustus|septimber|oktober|novimber|desimber)/i
};
var parseMonthPatterns29 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^des/i
  ]
};
var matchDayPatterns29 = {
  narrow: /^[smtwf]/i,
  short: /^(si|mo|ti|wo|to|fr|so)/i,
  abbreviated: /^(snein|moa|tii|woa|ton|fre|sneon)/i,
  wide: /^(snein|moandei|tiisdei|woansdei|tongersdei|freed|sneon)/i
};
var parseDayPatterns29 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^sn/i, /^mo/i, /^ti/i, /^wo/i, /^to/i, /^fr/i, /^sn/i]
};
var matchDayPeriodPatterns29 = {
  any: /^(am|pm|middernacht|middeis|moarns|middei|jûns|nachts)/i
};
var parseDayPeriodPatterns29 = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^middei/i,
    morning: /moarns/i,
    afternoon: /^middeis/i,
    evening: /jûns/i,
    night: /nachts/i
  }
};
var match29 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern29,
    parsePattern: parseOrdinalNumberPattern29,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns29,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns29,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns29,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns29,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns29,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns29,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns29,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns29,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns29,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns29,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/fy.mjs
var fy = {
  code: "fy",
  formatDistance: formatDistance31,
  formatLong: formatLong37,
  formatRelative: formatRelative30,
  localize: localize30,
  match: match29,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/gd/_lib/formatDistance.mjs
var formatDistanceLocale31 = {
  lessThanXSeconds: {
    one: "nas lugha na diog",
    other: "nas lugha na {{count}} diogan"
  },
  xSeconds: {
    one: "1 diog",
    two: "2 dhiog",
    twenty: "20 diog",
    other: "{{count}} diogan"
  },
  halfAMinute: "leth mhionaid",
  lessThanXMinutes: {
    one: "nas lugha na mionaid",
    other: "nas lugha na {{count}} mionaidean"
  },
  xMinutes: {
    one: "1 mionaid",
    two: "2 mhionaid",
    twenty: "20 mionaid",
    other: "{{count}} mionaidean"
  },
  aboutXHours: {
    one: "mu uair de thìde",
    other: "mu {{count}} uairean de thìde"
  },
  xHours: {
    one: "1 uair de thìde",
    two: "2 uair de thìde",
    twenty: "20 uair de thìde",
    other: "{{count}} uairean de thìde"
  },
  xDays: {
    one: "1 là",
    other: "{{count}} là"
  },
  aboutXWeeks: {
    one: "mu 1 seachdain",
    other: "mu {{count}} seachdainean"
  },
  xWeeks: {
    one: "1 seachdain",
    other: "{{count}} seachdainean"
  },
  aboutXMonths: {
    one: "mu mhìos",
    other: "mu {{count}} mìosan"
  },
  xMonths: {
    one: "1 mìos",
    other: "{{count}} mìosan"
  },
  aboutXYears: {
    one: "mu bhliadhna",
    other: "mu {{count}} bliadhnaichean"
  },
  xYears: {
    one: "1 bhliadhna",
    other: "{{count}} bliadhna"
  },
  overXYears: {
    one: "còrr is bliadhna",
    other: "còrr is {{count}} bliadhnaichean"
  },
  almostXYears: {
    one: "cha mhòr bliadhna",
    other: "cha mhòr {{count}} bliadhnaichean"
  }
};
var formatDistance32 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale31[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && !!tokenValue.two) {
    result = tokenValue.two;
  } else if (count === 20 && !!tokenValue.twenty) {
    result = tokenValue.twenty;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "ann an " + result;
    } else {
      return "o chionn " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/gd/_lib/formatLong.mjs
var dateFormats38 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats38 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats38 = {
  full: "{{date}} 'aig' {{time}}",
  long: "{{date}} 'aig' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong38 = {
  date: buildFormatLongFn({
    formats: dateFormats38,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats38,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats38,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/gd/_lib/formatRelative.mjs
var formatRelativeLocale31 = {
  lastWeek: "'mu dheireadh' eeee 'aig' p",
  //FIX
  yesterday: "'an-dè aig' p",
  today: "'an-diugh aig' p",
  tomorrow: "'a-màireach aig' p",
  nextWeek: "eeee 'aig' p",
  other: "P"
};
var formatRelative31 = (token, _date, _baseDate, _options) => formatRelativeLocale31[token];

// ../../../node_modules/date-fns/locale/gd/_lib/localize.mjs
var eraValues31 = {
  narrow: ["R", "A"],
  abbreviated: ["RC", "AD"],
  wide: ["ro Chrìosta", "anno domini"]
};
var quarterValues31 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["C1", "C2", "C3", "C4"],
  wide: [
    "a' chiad chairteal",
    "an dàrna cairteal",
    "an treas cairteal",
    "an ceathramh cairteal"
  ]
};
var monthValues31 = {
  narrow: ["F", "G", "M", "G", "C", "Ò", "I", "L", "S", "D", "S", "D"],
  abbreviated: [
    "Faoi",
    "Gear",
    "Màrt",
    "Gibl",
    "Cèit",
    "Ògmh",
    "Iuch",
    "Lùn",
    "Sult",
    "Dàmh",
    "Samh",
    "Dùbh"
  ],
  wide: [
    "Am Faoilleach",
    "An Gearran",
    "Am Màrt",
    "An Giblean",
    "An Cèitean",
    "An t-Ògmhios",
    "An t-Iuchar",
    "An Lùnastal",
    "An t-Sultain",
    "An Dàmhair",
    "An t-Samhain",
    "An Dùbhlachd"
  ]
};
var dayValues31 = {
  narrow: ["D", "L", "M", "C", "A", "H", "S"],
  short: ["Dò", "Lu", "Mà", "Ci", "Ar", "Ha", "Sa"],
  abbreviated: ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"],
  wide: [
    "Didòmhnaich",
    "Diluain",
    "Dimàirt",
    "Diciadain",
    "Diardaoin",
    "Dihaoine",
    "Disathairne"
  ]
};
var dayPeriodValues31 = {
  narrow: {
    am: "m",
    pm: "f",
    midnight: "m.o.",
    noon: "m.l.",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche"
  },
  abbreviated: {
    am: "M.",
    pm: "F.",
    midnight: "meadhan oidhche",
    noon: "meadhan là",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche"
  },
  wide: {
    am: "m.",
    pm: "f.",
    midnight: "meadhan oidhche",
    noon: "meadhan là",
    morning: "madainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "oidhche"
  }
};
var formattingDayPeriodValues25 = {
  narrow: {
    am: "m",
    pm: "f",
    midnight: "m.o.",
    noon: "m.l.",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche"
  },
  abbreviated: {
    am: "M.",
    pm: "F.",
    midnight: "meadhan oidhche",
    noon: "meadhan là",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche"
  },
  wide: {
    am: "m.",
    pm: "f.",
    midnight: "meadhan oidhche",
    noon: "meadhan là",
    morning: "sa mhadainn",
    afternoon: "feasgar",
    evening: "feasgar",
    night: "air an oidhche"
  }
};
var ordinalNumber31 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "d";
      case 2:
        return number2 + "na";
    }
  }
  if (rem100 === 12) {
    return number2 + "na";
  }
  return number2 + "mh";
};
var localize31 = {
  ordinalNumber: ordinalNumber31,
  era: buildLocalizeFn({
    values: eraValues31,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues31,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues31,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues31,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues31,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues25,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/gd/_lib/match.mjs
var matchOrdinalNumberPattern30 = /^(\d+)(d|na|tr|mh)?/i;
var parseOrdinalNumberPattern30 = /\d+/i;
var matchEraPatterns30 = {
  narrow: /^(r|a)/i,
  abbreviated: /^(r\.?\s?c\.?|r\.?\s?a\.?\s?c\.?|a\.?\s?d\.?|a\.?\s?c\.?)/i,
  wide: /^(ro Chrìosta|ron aois choitchinn|anno domini|aois choitcheann)/i
};
var parseEraPatterns30 = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns30 = {
  narrow: /^[1234]/i,
  abbreviated: /^c[1234]/i,
  wide: /^[1234](cd|na|tr|mh)? cairteal/i
};
var parseQuarterPatterns30 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns30 = {
  narrow: /^[fgmcòilsd]/i,
  abbreviated: /^(faoi|gear|màrt|gibl|cèit|ògmh|iuch|lùn|sult|dàmh|samh|dùbh)/i,
  wide: /^(am faoilleach|an gearran|am màrt|an giblean|an cèitean|an t-Ògmhios|an t-Iuchar|an lùnastal|an t-Sultain|an dàmhair|an t-Samhain|an dùbhlachd)/i
};
var parseMonthPatterns30 = {
  narrow: [
    /^f/i,
    /^g/i,
    /^m/i,
    /^g/i,
    /^c/i,
    /^ò/i,
    /^i/i,
    /^l/i,
    /^s/i,
    /^d/i,
    /^s/i,
    /^d/i
  ],
  any: [
    /^fa/i,
    /^ge/i,
    /^mà/i,
    /^gi/i,
    /^c/i,
    /^ò/i,
    /^i/i,
    /^l/i,
    /^su/i,
    /^d/i,
    /^sa/i,
    /^d/i
  ]
};
var matchDayPatterns30 = {
  narrow: /^[dlmcahs]/i,
  short: /^(dò|lu|mà|ci|ar|ha|sa)/i,
  abbreviated: /^(did|dil|dim|dic|dia|dih|dis)/i,
  wide: /^(didòmhnaich|diluain|dimàirt|diciadain|diardaoin|dihaoine|disathairne)/i
};
var parseDayPatterns30 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^c/i, /^a/i, /^h/i, /^s/i],
  any: [/^d/i, /^l/i, /^m/i, /^c/i, /^a/i, /^h/i, /^s/i]
};
var matchDayPeriodPatterns30 = {
  narrow: /^(a|p|mi|n|(san|aig) (madainn|feasgar|feasgar|oidhche))/i,
  any: /^([ap]\.?\s?m\.?|meadhan oidhche|meadhan là|(san|aig) (madainn|feasgar|feasgar|oidhche))/i
};
var parseDayPeriodPatterns30 = {
  any: {
    am: /^m/i,
    pm: /^f/i,
    midnight: /^meadhan oidhche/i,
    noon: /^meadhan là/i,
    morning: /sa mhadainn/i,
    afternoon: /feasgar/i,
    evening: /feasgar/i,
    night: /air an oidhche/i
  }
};
var match30 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern30,
    parsePattern: parseOrdinalNumberPattern30,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns30,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns30,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns30,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns30,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns30,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns30,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns30,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns30,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns30,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns30,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/gd.mjs
var gd = {
  code: "gd",
  formatDistance: formatDistance32,
  formatLong: formatLong38,
  formatRelative: formatRelative31,
  localize: localize31,
  match: match30,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/gl/_lib/formatDistance.mjs
var formatDistanceLocale32 = {
  lessThanXSeconds: {
    one: "menos dun segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "medio minuto",
  lessThanXMinutes: {
    one: "menos dun minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "arredor dunha hora",
    other: "arredor de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 día",
    other: "{{count}} días"
  },
  aboutXWeeks: {
    one: "arredor dunha semana",
    other: "arredor de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "arredor de 1 mes",
    other: "arredor de {{count}} meses"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "arredor dun ano",
    other: "arredor de {{count}} anos"
  },
  xYears: {
    one: "1 ano",
    other: "{{count}} anos"
  },
  overXYears: {
    one: "máis dun ano",
    other: "máis de {{count}} anos"
  },
  almostXYears: {
    one: "case un ano",
    other: "case {{count}} anos"
  }
};
var formatDistance33 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale32[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "en " + result;
    } else {
      return "hai " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/gl/_lib/formatLong.mjs
var dateFormats39 = {
  full: "EEEE, d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats39 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats39 = {
  full: "{{date}} 'ás' {{time}}",
  long: "{{date}} 'ás' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong39 = {
  date: buildFormatLongFn({
    formats: dateFormats39,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats39,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats39,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/gl/_lib/formatRelative.mjs
var formatRelativeLocale32 = {
  lastWeek: "'o' eeee 'pasado á' LT",
  yesterday: "'onte á' p",
  today: "'hoxe á' p",
  tomorrow: "'mañá á' p",
  nextWeek: "eeee 'á' p",
  other: "P"
};
var formatRelativeLocalePlural4 = {
  lastWeek: "'o' eeee 'pasado ás' p",
  yesterday: "'onte ás' p",
  today: "'hoxe ás' p",
  tomorrow: "'mañá ás' p",
  nextWeek: "eeee 'ás' p",
  other: "P"
};
var formatRelative32 = (token, date2, _baseDate, _options) => {
  if (date2.getHours() !== 1) {
    return formatRelativeLocalePlural4[token];
  }
  return formatRelativeLocale32[token];
};

// ../../../node_modules/date-fns/locale/gl/_lib/localize.mjs
var eraValues32 = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "despois de cristo"]
};
var quarterValues32 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
};
var monthValues32 = {
  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "xan",
    "feb",
    "mar",
    "abr",
    "mai",
    "xun",
    "xul",
    "ago",
    "set",
    "out",
    "nov",
    "dec"
  ],
  wide: [
    "xaneiro",
    "febreiro",
    "marzo",
    "abril",
    "maio",
    "xuño",
    "xullo",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "decembro"
  ]
};
var dayValues32 = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["do", "lu", "ma", "me", "xo", "ve", "sa"],
  abbreviated: ["dom", "lun", "mar", "mer", "xov", "ven", "sab"],
  wide: ["domingo", "luns", "martes", "mércores", "xoves", "venres", "sábado"]
};
var dayPeriodValues32 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "mañá",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoite",
    noon: "mediodía",
    morning: "mañá",
    afternoon: "tarde",
    evening: "tardiña",
    night: "noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoite",
    noon: "mediodía",
    morning: "mañá",
    afternoon: "tarde",
    evening: "tardiña",
    night: "noite"
  }
};
var formattingDayPeriodValues26 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "da mañá",
    afternoon: "da tarde",
    evening: "da tardiña",
    night: "da noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoite",
    noon: "mediodía",
    morning: "da mañá",
    afternoon: "da tarde",
    evening: "da tardiña",
    night: "da noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoite",
    noon: "mediodía",
    morning: "da mañá",
    afternoon: "da tarde",
    evening: "da tardiña",
    night: "da noite"
  }
};
var ordinalNumber32 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "º";
};
var localize32 = {
  ordinalNumber: ordinalNumber32,
  era: buildLocalizeFn({
    values: eraValues32,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues32,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues32,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues32,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues32,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues26,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/gl/_lib/match.mjs
var matchOrdinalNumberPattern31 = /^(\d+)(º)?/i;
var parseOrdinalNumberPattern31 = /\d+/i;
var matchEraPatterns31 = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes da era com[uú]n|despois de cristo|era com[uú]n)/i
};
var parseEraPatterns31 = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes da era com[uú]n)/i,
    /^(despois de cristo|era com[uú]n)/i
  ]
};
var matchQuarterPatterns31 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](º)? trimestre/i
};
var parseQuarterPatterns31 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns31 = {
  narrow: /^[xfmasond]/i,
  abbreviated: /^(xan|feb|mar|abr|mai|xun|xul|ago|set|out|nov|dec)/i,
  wide: /^(xaneiro|febreiro|marzo|abril|maio|xuño|xullo|agosto|setembro|outubro|novembro|decembro)/i
};
var parseMonthPatterns31 = {
  narrow: [
    /^x/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^x/i,
    /^x/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^xan/i,
    /^feb/i,
    /^mar/i,
    /^abr/i,
    /^mai/i,
    /^xun/i,
    /^xul/i,
    /^ago/i,
    /^set/i,
    /^out/i,
    /^nov/i,
    /^dec/i
  ]
};
var matchDayPatterns31 = {
  narrow: /^[dlmxvs]/i,
  short: /^(do|lu|ma|me|xo|ve|sa)/i,
  abbreviated: /^(dom|lun|mar|mer|xov|ven|sab)/i,
  wide: /^(domingo|luns|martes|m[eé]rcores|xoves|venres|s[áa]bado)/i
};
var parseDayPatterns31 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^x/i, /^v/i, /^s/i],
  any: [/^do/i, /^lu/i, /^ma/i, /^me/i, /^xo/i, /^ve/i, /^sa/i]
};
var matchDayPeriodPatterns31 = {
  narrow: /^(a|p|mn|md|(da|[aá]s) (mañ[aá]|tarde|noite))/i,
  any: /^([ap]\.?\s?m\.?|medianoite|mediod[ií]a|(da|[aá]s) (mañ[aá]|tarde|noite))/i
};
var parseDayPeriodPatterns31 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /^md/i,
    morning: /mañ[aá]/i,
    afternoon: /tarde/i,
    evening: /tardiña/i,
    night: /noite/i
  }
};
var match31 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern31,
    parsePattern: parseOrdinalNumberPattern31,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns31,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns31,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns31,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns31,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns31,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns31,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns31,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns31,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns31,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns31,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/gl.mjs
var gl = {
  code: "gl",
  formatDistance: formatDistance33,
  formatLong: formatLong39,
  formatRelative: formatRelative32,
  localize: localize32,
  match: match31,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/gu/_lib/formatDistance.mjs
var formatDistanceLocale33 = {
  lessThanXSeconds: {
    one: "હમણાં",
    // CLDR #1461
    other: "​આશરે {{count}} સેકંડ"
  },
  xSeconds: {
    one: "1 સેકંડ",
    other: "{{count}} સેકંડ"
  },
  halfAMinute: "અડધી મિનિટ",
  lessThanXMinutes: {
    one: "આ મિનિટ",
    // CLDR #1448
    other: "​આશરે {{count}} મિનિટ"
  },
  xMinutes: {
    one: "1 મિનિટ",
    other: "{{count}} મિનિટ"
  },
  aboutXHours: {
    one: "​આશરે 1 કલાક",
    other: "​આશરે {{count}} કલાક"
  },
  xHours: {
    one: "1 કલાક",
    other: "{{count}} કલાક"
  },
  xDays: {
    one: "1 દિવસ",
    other: "{{count}} દિવસ"
  },
  aboutXWeeks: {
    one: "આશરે 1 અઠવાડિયું",
    other: "આશરે {{count}} અઠવાડિયા"
  },
  xWeeks: {
    one: "1 અઠવાડિયું",
    other: "{{count}} અઠવાડિયા"
  },
  aboutXMonths: {
    one: "આશરે 1 મહિનો",
    other: "આશરે {{count}} મહિના"
  },
  xMonths: {
    one: "1 મહિનો",
    other: "{{count}} મહિના"
  },
  aboutXYears: {
    one: "આશરે 1 વર્ષ",
    other: "આશરે {{count}} વર્ષ"
  },
  xYears: {
    one: "1 વર્ષ",
    other: "{{count}} વર્ષ"
  },
  overXYears: {
    one: "1 વર્ષથી વધુ",
    other: "{{count}} વર્ષથી વધુ"
  },
  almostXYears: {
    one: "લગભગ 1 વર્ષ",
    other: "લગભગ {{count}} વર્ષ"
  }
};
var formatDistance34 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale33[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "માં";
    } else {
      return result + " પહેલાં";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/gu/_lib/formatLong.mjs
var dateFormats40 = {
  full: "EEEE, d MMMM, y",
  // CLDR #1825
  long: "d MMMM, y",
  // CLDR #1826
  medium: "d MMM, y",
  // CLDR #1827
  short: "d/M/yy"
  // CLDR #1828
};
var timeFormats40 = {
  full: "hh:mm:ss a zzzz",
  // CLDR #1829
  long: "hh:mm:ss a z",
  // CLDR #1830
  medium: "hh:mm:ss a",
  // CLDR #1831
  short: "hh:mm a"
  // CLDR #1832
};
var dateTimeFormats40 = {
  full: "{{date}} {{time}}",
  // CLDR #1833
  long: "{{date}} {{time}}",
  // CLDR #1834
  medium: "{{date}} {{time}}",
  // CLDR #1835
  short: "{{date}} {{time}}"
  // CLDR #1836
};
var formatLong40 = {
  date: buildFormatLongFn({
    formats: dateFormats40,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats40,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats40,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/gu/_lib/formatRelative.mjs
var formatRelativeLocale33 = {
  lastWeek: "'પાછલા' eeee p",
  // CLDR #1384
  yesterday: "'ગઈકાલે' p",
  // CLDR #1409
  today: "'આજે' p",
  // CLDR #1410
  tomorrow: "'આવતીકાલે' p",
  // CLDR #1411
  nextWeek: "eeee p",
  // CLDR #1386
  other: "P"
};
var formatRelative33 = (token, _date, _baseDate, _options) => formatRelativeLocale33[token];

// ../../../node_modules/date-fns/locale/gu/_lib/localize.mjs
var eraValues33 = {
  narrow: ["ઈસપૂ", "ઈસ"],
  abbreviated: ["ઈ.સ.પૂર્વે", "ઈ.સ."],
  wide: ["ઈસવીસન પૂર્વે", "ઈસવીસન"]
};
var quarterValues33 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1લો ત્રિમાસ", "2જો ત્રિમાસ", "3જો ત્રિમાસ", "4થો ત્રિમાસ"]
};
var monthValues33 = {
  narrow: ["જા", "ફે", "મા", "એ", "મે", "જૂ", "જુ", "ઓ", "સ", "ઓ", "ન", "ડિ"],
  abbreviated: [
    "જાન્યુ",
    "ફેબ્રુ",
    "માર્ચ",
    "એપ્રિલ",
    "મે",
    "જૂન",
    "જુલાઈ",
    "ઑગસ્ટ",
    "સપ્ટે",
    "ઓક્ટો",
    "નવે",
    "ડિસે"
  ],
  wide: [
    "જાન્યુઆરી",
    "ફેબ્રુઆરી",
    "માર્ચ",
    "એપ્રિલ",
    "મે",
    "જૂન",
    "જુલાઇ",
    "ઓગસ્ટ",
    "સપ્ટેમ્બર",
    "ઓક્ટોબર",
    "નવેમ્બર",
    "ડિસેમ્બર"
  ]
};
var dayValues33 = {
  narrow: ["ર", "સો", "મં", "બુ", "ગુ", "શુ", "શ"],
  short: ["ર", "સો", "મં", "બુ", "ગુ", "શુ", "શ"],
  abbreviated: ["રવિ", "સોમ", "મંગળ", "બુધ", "ગુરુ", "શુક્ર", "શનિ"],
  wide: [
    "રવિવાર",
    "સોમવાર",
    "મંગળવાર",
    "બુધવાર",
    "ગુરુવાર",
    "શુક્રવાર",
    "શનિવાર"
  ]
};
var dayPeriodValues33 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "મ.રાત્રિ",
    noon: "બ.",
    morning: "સવારે",
    afternoon: "બપોરે",
    evening: "સાંજે",
    night: "રાત્રે"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "​મધ્યરાત્રિ",
    noon: "બપોરે",
    morning: "સવારે",
    afternoon: "બપોરે",
    evening: "સાંજે",
    night: "રાત્રે"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "​મધ્યરાત્રિ",
    noon: "બપોરે",
    morning: "સવારે",
    afternoon: "બપોરે",
    evening: "સાંજે",
    night: "રાત્રે"
  }
};
var formattingDayPeriodValues27 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "મ.રાત્રિ",
    noon: "બપોરે",
    morning: "સવારે",
    afternoon: "બપોરે",
    evening: "સાંજે",
    night: "રાત્રે"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "મધ્યરાત્રિ",
    noon: "બપોરે",
    morning: "સવારે",
    afternoon: "બપોરે",
    evening: "સાંજે",
    night: "રાત્રે"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "​મધ્યરાત્રિ",
    noon: "બપોરે",
    morning: "સવારે",
    afternoon: "બપોરે",
    evening: "સાંજે",
    night: "રાત્રે"
  }
};
var ordinalNumber33 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize33 = {
  ordinalNumber: ordinalNumber33,
  era: buildLocalizeFn({
    values: eraValues33,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues33,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues33,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues33,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues33,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues27,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/gu/_lib/match.mjs
var matchOrdinalNumberPattern32 = /^(\d+)(લ|જ|થ|ઠ્ઠ|મ)?/i;
var parseOrdinalNumberPattern32 = /\d+/i;
var matchEraPatterns32 = {
  narrow: /^(ઈસપૂ|ઈસ)/i,
  abbreviated: /^(ઈ\.સ\.પૂર્વે|ઈ\.સ\.)/i,
  wide: /^(ઈસવીસન\sપૂર્વે|ઈસવીસન)/i
};
var parseEraPatterns32 = {
  any: [/^ઈસપૂ/i, /^ઈસ/i]
};
var matchQuarterPatterns32 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](લો|જો|થો)? ત્રિમાસ/i
};
var parseQuarterPatterns32 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns32 = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[જાફેમાએમેજૂજુઓસઓનડિ]/i,
  abbreviated: /^(જાન્યુ|ફેબ્રુ|માર્ચ|એપ્રિલ|મે|જૂન|જુલાઈ|ઑગસ્ટ|સપ્ટે|ઓક્ટો|નવે|ડિસે)/i,
  wide: /^(જાન્યુઆરી|ફેબ્રુઆરી|માર્ચ|એપ્રિલ|મે|જૂન|જુલાઇ|ઓગસ્ટ|સપ્ટેમ્બર|ઓક્ટોબર|નવેમ્બર|ડિસેમ્બર)/i
};
var parseMonthPatterns32 = {
  narrow: [
    /^જા/i,
    /^ફે/i,
    /^મા/i,
    /^એ/i,
    /^મે/i,
    /^જૂ/i,
    /^જુ/i,
    /^ઑગ/i,
    /^સ/i,
    /^ઓક્ટો/i,
    /^ન/i,
    /^ડિ/i
  ],
  any: [
    /^જા/i,
    /^ફે/i,
    /^મા/i,
    /^એ/i,
    /^મે/i,
    /^જૂ/i,
    /^જુ/i,
    /^ઑગ/i,
    /^સ/i,
    /^ઓક્ટો/i,
    /^ન/i,
    /^ડિ/i
  ]
};
var matchDayPatterns32 = {
  narrow: /^(ર|સો|મં|બુ|ગુ|શુ|શ)/i,
  short: /^(ર|સો|મં|બુ|ગુ|શુ|શ)/i,
  abbreviated: /^(રવિ|સોમ|મંગળ|બુધ|ગુરુ|શુક્ર|શનિ)/i,
  wide: /^(રવિવાર|સોમવાર|મંગળવાર|બુધવાર|ગુરુવાર|શુક્રવાર|શનિવાર)/i
};
var parseDayPatterns32 = {
  narrow: [/^ર/i, /^સો/i, /^મં/i, /^બુ/i, /^ગુ/i, /^શુ/i, /^શ/i],
  any: [/^ર/i, /^સો/i, /^મં/i, /^બુ/i, /^ગુ/i, /^શુ/i, /^શ/i]
};
var matchDayPeriodPatterns32 = {
  narrow: /^(a|p|મ\.?|સ|બ|સાં|રા)/i,
  any: /^(a|p|મ\.?|સ|બ|સાં|રા)/i
};
var parseDayPeriodPatterns32 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^મ\.?/i,
    noon: /^બ/i,
    morning: /સ/i,
    afternoon: /બ/i,
    evening: /સાં/i,
    night: /રા/i
  }
};
var match32 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern32,
    parsePattern: parseOrdinalNumberPattern32,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns32,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns32,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns32,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns32,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns32,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns32,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns32,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns32,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns32,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns32,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/gu.mjs
var gu = {
  code: "gu",
  formatDistance: formatDistance34,
  formatLong: formatLong40,
  formatRelative: formatRelative33,
  localize: localize33,
  match: match32,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/he/_lib/formatDistance.mjs
var formatDistanceLocale34 = {
  lessThanXSeconds: {
    one: "פחות משנייה",
    two: "פחות משתי שניות",
    other: "פחות מ־{{count}} שניות"
  },
  xSeconds: {
    one: "שנייה",
    two: "שתי שניות",
    other: "{{count}} שניות"
  },
  halfAMinute: "חצי דקה",
  lessThanXMinutes: {
    one: "פחות מדקה",
    two: "פחות משתי דקות",
    other: "פחות מ־{{count}} דקות"
  },
  xMinutes: {
    one: "דקה",
    two: "שתי דקות",
    other: "{{count}} דקות"
  },
  aboutXHours: {
    one: "כשעה",
    two: "כשעתיים",
    other: "כ־{{count}} שעות"
  },
  xHours: {
    one: "שעה",
    two: "שעתיים",
    other: "{{count}} שעות"
  },
  xDays: {
    one: "יום",
    two: "יומיים",
    other: "{{count}} ימים"
  },
  aboutXWeeks: {
    one: "כשבוע",
    two: "כשבועיים",
    other: "כ־{{count}} שבועות"
  },
  xWeeks: {
    one: "שבוע",
    two: "שבועיים",
    other: "{{count}} שבועות"
  },
  aboutXMonths: {
    one: "כחודש",
    two: "כחודשיים",
    other: "כ־{{count}} חודשים"
  },
  xMonths: {
    one: "חודש",
    two: "חודשיים",
    other: "{{count}} חודשים"
  },
  aboutXYears: {
    one: "כשנה",
    two: "כשנתיים",
    other: "כ־{{count}} שנים"
  },
  xYears: {
    one: "שנה",
    two: "שנתיים",
    other: "{{count}} שנים"
  },
  overXYears: {
    one: "יותר משנה",
    two: "יותר משנתיים",
    other: "יותר מ־{{count}} שנים"
  },
  almostXYears: {
    one: "כמעט שנה",
    two: "כמעט שנתיים",
    other: "כמעט {{count}} שנים"
  }
};
var formatDistance35 = (token, count, options2) => {
  if (token === "xDays" && (options2 == null ? void 0 : options2.addSuffix) && count <= 2) {
    if (options2.comparison && options2.comparison > 0) {
      return count === 1 ? "מחר" : "מחרתיים";
    }
    return count === 1 ? "אתמול" : "שלשום";
  }
  let result;
  const tokenValue = formatDistanceLocale34[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "בעוד " + result;
    } else {
      return "לפני " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/he/_lib/formatLong.mjs
var dateFormats41 = {
  full: "EEEE, d בMMMM y",
  long: "d בMMMM y",
  medium: "d בMMM y",
  short: "d.M.y"
};
var timeFormats41 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats41 = {
  full: "{{date}} 'בשעה' {{time}}",
  long: "{{date}} 'בשעה' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong41 = {
  date: buildFormatLongFn({
    formats: dateFormats41,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats41,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats41,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/he/_lib/formatRelative.mjs
var formatRelativeLocale34 = {
  lastWeek: "eeee 'שעבר בשעה' p",
  yesterday: "'אתמול בשעה' p",
  today: "'היום בשעה' p",
  tomorrow: "'מחר בשעה' p",
  nextWeek: "eeee 'בשעה' p",
  other: "P"
};
var formatRelative34 = (token, _date, _baseDate, _options) => formatRelativeLocale34[token];

// ../../../node_modules/date-fns/locale/he/_lib/localize.mjs
var eraValues34 = {
  narrow: ["לפנה״ס", "לספירה"],
  abbreviated: ["לפנה״ס", "לספירה"],
  wide: ["לפני הספירה", "לספירה"]
};
var quarterValues34 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["רבעון 1", "רבעון 2", "רבעון 3", "רבעון 4"]
};
var monthValues34 = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "ינו׳",
    "פבר׳",
    "מרץ",
    "אפר׳",
    "מאי",
    "יוני",
    "יולי",
    "אוג׳",
    "ספט׳",
    "אוק׳",
    "נוב׳",
    "דצמ׳"
  ],
  wide: [
    "ינואר",
    "פברואר",
    "מרץ",
    "אפריל",
    "מאי",
    "יוני",
    "יולי",
    "אוגוסט",
    "ספטמבר",
    "אוקטובר",
    "נובמבר",
    "דצמבר"
  ]
};
var dayValues34 = {
  narrow: ["א׳", "ב׳", "ג׳", "ד׳", "ה׳", "ו׳", "ש׳"],
  short: ["א׳", "ב׳", "ג׳", "ד׳", "ה׳", "ו׳", "ש׳"],
  abbreviated: [
    "יום א׳",
    "יום ב׳",
    "יום ג׳",
    "יום ד׳",
    "יום ה׳",
    "יום ו׳",
    "שבת"
  ],
  wide: [
    "יום ראשון",
    "יום שני",
    "יום שלישי",
    "יום רביעי",
    "יום חמישי",
    "יום שישי",
    "יום שבת"
  ]
};
var dayPeriodValues34 = {
  narrow: {
    am: "לפנה״צ",
    pm: "אחה״צ",
    midnight: "חצות",
    noon: "צהריים",
    morning: "בוקר",
    afternoon: "אחר הצהריים",
    evening: "ערב",
    night: "לילה"
  },
  abbreviated: {
    am: "לפנה״צ",
    pm: "אחה״צ",
    midnight: "חצות",
    noon: "צהריים",
    morning: "בוקר",
    afternoon: "אחר הצהריים",
    evening: "ערב",
    night: "לילה"
  },
  wide: {
    am: "לפנה״צ",
    pm: "אחה״צ",
    midnight: "חצות",
    noon: "צהריים",
    morning: "בוקר",
    afternoon: "אחר הצהריים",
    evening: "ערב",
    night: "לילה"
  }
};
var formattingDayPeriodValues28 = {
  narrow: {
    am: "לפנה״צ",
    pm: "אחה״צ",
    midnight: "חצות",
    noon: "צהריים",
    morning: "בבוקר",
    afternoon: "בצהריים",
    evening: "בערב",
    night: "בלילה"
  },
  abbreviated: {
    am: "לפנה״צ",
    pm: "אחה״צ",
    midnight: "חצות",
    noon: "צהריים",
    morning: "בבוקר",
    afternoon: "אחר הצהריים",
    evening: "בערב",
    night: "בלילה"
  },
  wide: {
    am: "לפנה״צ",
    pm: "אחה״צ",
    midnight: "חצות",
    noon: "צהריים",
    morning: "בבוקר",
    afternoon: "אחר הצהריים",
    evening: "בערב",
    night: "בלילה"
  }
};
var ordinalNumber34 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  if (number2 <= 0 || number2 > 10) return String(number2);
  const unit = String(options2 == null ? void 0 : options2.unit);
  const isFemale = ["year", "hour", "minute", "second"].indexOf(unit) >= 0;
  const male = [
    "ראשון",
    "שני",
    "שלישי",
    "רביעי",
    "חמישי",
    "שישי",
    "שביעי",
    "שמיני",
    "תשיעי",
    "עשירי"
  ];
  const female = [
    "ראשונה",
    "שנייה",
    "שלישית",
    "רביעית",
    "חמישית",
    "שישית",
    "שביעית",
    "שמינית",
    "תשיעית",
    "עשירית"
  ];
  const index2 = number2 - 1;
  return isFemale ? female[index2] : male[index2];
};
var localize34 = {
  ordinalNumber: ordinalNumber34,
  era: buildLocalizeFn({
    values: eraValues34,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues34,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues34,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues34,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues34,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues28,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/he/_lib/match.mjs
var matchOrdinalNumberPattern33 = /^(\d+|(ראשון|שני|שלישי|רביעי|חמישי|שישי|שביעי|שמיני|תשיעי|עשירי|ראשונה|שנייה|שלישית|רביעית|חמישית|שישית|שביעית|שמינית|תשיעית|עשירית))/i;
var parseOrdinalNumberPattern33 = /^(\d+|רא|שנ|של|רב|ח|שי|שב|שמ|ת|ע)/i;
var matchEraPatterns33 = {
  narrow: /^ל(ספירה|פנה״ס)/i,
  abbreviated: /^ל(ספירה|פנה״ס)/i,
  wide: /^ל(פני ה)?ספירה/i
};
var parseEraPatterns33 = {
  any: [/^לפ/i, /^לס/i]
};
var matchQuarterPatterns33 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^רבעון [1234]/i
};
var parseQuarterPatterns33 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns33 = {
  narrow: /^\d+/i,
  abbreviated: /^(ינו|פבר|מרץ|אפר|מאי|יוני|יולי|אוג|ספט|אוק|נוב|דצמ)׳?/i,
  wide: /^(ינואר|פברואר|מרץ|אפריל|מאי|יוני|יולי|אוגוסט|ספטמבר|אוקטובר|נובמבר|דצמבר)/i
};
var parseMonthPatterns33 = {
  narrow: [
    /^1$/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i
  ],
  any: [
    /^ינ/i,
    /^פ/i,
    /^מר/i,
    /^אפ/i,
    /^מא/i,
    /^יונ/i,
    /^יול/i,
    /^אוג/i,
    /^ס/i,
    /^אוק/i,
    /^נ/i,
    /^ד/i
  ]
};
var matchDayPatterns33 = {
  narrow: /^[אבגדהוש]׳/i,
  short: /^[אבגדהוש]׳/i,
  abbreviated: /^(שבת|יום (א|ב|ג|ד|ה|ו)׳)/i,
  wide: /^יום (ראשון|שני|שלישי|רביעי|חמישי|שישי|שבת)/i
};
var parseDayPatterns33 = {
  abbreviated: [/א׳$/i, /ב׳$/i, /ג׳$/i, /ד׳$/i, /ה׳$/i, /ו׳$/i, /^ש/i],
  wide: [/ן$/i, /ני$/i, /לישי$/i, /עי$/i, /מישי$/i, /שישי$/i, /ת$/i],
  any: [/^א/i, /^ב/i, /^ג/i, /^ד/i, /^ה/i, /^ו/i, /^ש/i]
};
var matchDayPeriodPatterns33 = {
  any: /^(אחר ה|ב)?(חצות|צהריים|בוקר|ערב|לילה|אחה״צ|לפנה״צ)/i
};
var parseDayPeriodPatterns33 = {
  any: {
    am: /^לפ/i,
    pm: /^אחה/i,
    midnight: /^ח/i,
    noon: /^צ/i,
    morning: /בוקר/i,
    afternoon: /בצ|אחר/i,
    evening: /ערב/i,
    night: /לילה/i
  }
};
var ordinalName = ["רא", "שנ", "של", "רב", "ח", "שי", "שב", "שמ", "ת", "ע"];
var match33 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern33,
    parsePattern: parseOrdinalNumberPattern33,
    valueCallback: (value) => {
      const number2 = parseInt(value, 10);
      return isNaN(number2) ? ordinalName.indexOf(value) + 1 : number2;
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns33,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns33,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns33,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns33,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns33,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns33,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns33,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns33,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns33,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns33,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/he.mjs
var he = {
  code: "he",
  formatDistance: formatDistance35,
  formatLong: formatLong41,
  formatRelative: formatRelative34,
  localize: localize34,
  match: match33,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/hi/_lib/localize.mjs
var numberValues2 = {
  locale: {
    1: "१",
    2: "२",
    3: "३",
    4: "४",
    5: "५",
    6: "६",
    7: "७",
    8: "८",
    9: "९",
    0: "०"
  },
  number: {
    "१": "1",
    "२": "2",
    "३": "3",
    "४": "4",
    "५": "5",
    "६": "6",
    "७": "7",
    "८": "8",
    "९": "9",
    "०": "0"
  }
};
var eraValues35 = {
  narrow: ["ईसा-पूर्व", "ईस्वी"],
  abbreviated: ["ईसा-पूर्व", "ईस्वी"],
  wide: ["ईसा-पूर्व", "ईसवी सन"]
};
var quarterValues35 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ति1", "ति2", "ति3", "ति4"],
  wide: ["पहली तिमाही", "दूसरी तिमाही", "तीसरी तिमाही", "चौथी तिमाही"]
};
var monthValues35 = {
  narrow: [
    "ज",
    "फ़",
    "मा",
    "अ",
    "मई",
    "जू",
    "जु",
    "अग",
    "सि",
    "अक्टू",
    "न",
    "दि"
  ],
  abbreviated: [
    "जन",
    "फ़र",
    "मार्च",
    "अप्रैल",
    "मई",
    "जून",
    "जुल",
    "अग",
    "सित",
    "अक्टू",
    "नव",
    "दिस"
  ],
  wide: [
    "जनवरी",
    "फ़रवरी",
    "मार्च",
    "अप्रैल",
    "मई",
    "जून",
    "जुलाई",
    "अगस्त",
    "सितंबर",
    "अक्टूबर",
    "नवंबर",
    "दिसंबर"
  ]
};
var dayValues35 = {
  narrow: ["र", "सो", "मं", "बु", "गु", "शु", "श"],
  short: ["र", "सो", "मं", "बु", "गु", "शु", "श"],
  abbreviated: ["रवि", "सोम", "मंगल", "बुध", "गुरु", "शुक्र", "शनि"],
  wide: [
    "रविवार",
    "सोमवार",
    "मंगलवार",
    "बुधवार",
    "गुरुवार",
    "शुक्रवार",
    "शनिवार"
  ]
};
var dayPeriodValues35 = {
  narrow: {
    am: "पूर्वाह्न",
    pm: "अपराह्न",
    midnight: "मध्यरात्रि",
    noon: "दोपहर",
    morning: "सुबह",
    afternoon: "दोपहर",
    evening: "शाम",
    night: "रात"
  },
  abbreviated: {
    am: "पूर्वाह्न",
    pm: "अपराह्न",
    midnight: "मध्यरात्रि",
    noon: "दोपहर",
    morning: "सुबह",
    afternoon: "दोपहर",
    evening: "शाम",
    night: "रात"
  },
  wide: {
    am: "पूर्वाह्न",
    pm: "अपराह्न",
    midnight: "मध्यरात्रि",
    noon: "दोपहर",
    morning: "सुबह",
    afternoon: "दोपहर",
    evening: "शाम",
    night: "रात"
  }
};
var formattingDayPeriodValues29 = {
  narrow: {
    am: "पूर्वाह्न",
    pm: "अपराह्न",
    midnight: "मध्यरात्रि",
    noon: "दोपहर",
    morning: "सुबह",
    afternoon: "दोपहर",
    evening: "शाम",
    night: "रात"
  },
  abbreviated: {
    am: "पूर्वाह्न",
    pm: "अपराह्न",
    midnight: "मध्यरात्रि",
    noon: "दोपहर",
    morning: "सुबह",
    afternoon: "दोपहर",
    evening: "शाम",
    night: "रात"
  },
  wide: {
    am: "पूर्वाह्न",
    pm: "अपराह्न",
    midnight: "मध्यरात्रि",
    noon: "दोपहर",
    morning: "सुबह",
    afternoon: "दोपहर",
    evening: "शाम",
    night: "रात"
  }
};
var ordinalNumber35 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return numberToLocale2(number2);
};
function localeToNumber(locale) {
  const enNumber = locale.toString().replace(/[१२३४५६७८९०]/g, function(match85) {
    return numberValues2.number[match85];
  });
  return Number(enNumber);
}
function numberToLocale2(enNumber) {
  return enNumber.toString().replace(/\d/g, function(match85) {
    return numberValues2.locale[match85];
  });
}
var localize35 = {
  ordinalNumber: ordinalNumber35,
  era: buildLocalizeFn({
    values: eraValues35,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues35,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues35,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues35,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues35,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues29,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/hi/_lib/formatDistance.mjs
var formatDistanceLocale35 = {
  lessThanXSeconds: {
    one: "१ सेकंड से कम",
    // CLDR #1310
    other: "{{count}} सेकंड से कम"
  },
  xSeconds: {
    one: "१ सेकंड",
    other: "{{count}} सेकंड"
  },
  halfAMinute: "आधा मिनट",
  lessThanXMinutes: {
    one: "१ मिनट से कम",
    other: "{{count}} मिनट से कम"
  },
  xMinutes: {
    one: "१ मिनट",
    // CLDR #1307
    other: "{{count}} मिनट"
  },
  aboutXHours: {
    one: "लगभग १ घंटा",
    other: "लगभग {{count}} घंटे"
  },
  xHours: {
    one: "१ घंटा",
    // CLDR #1304
    other: "{{count}} घंटे"
    // CLDR #4467
  },
  xDays: {
    one: "१ दिन",
    // CLDR #1286
    other: "{{count}} दिन"
  },
  aboutXWeeks: {
    one: "लगभग १ सप्ताह",
    other: "लगभग {{count}} सप्ताह"
  },
  xWeeks: {
    one: "१ सप्ताह",
    other: "{{count}} सप्ताह"
  },
  aboutXMonths: {
    one: "लगभग १ महीना",
    other: "लगभग {{count}} महीने"
  },
  xMonths: {
    one: "१ महीना",
    other: "{{count}} महीने"
  },
  aboutXYears: {
    one: "लगभग १ वर्ष",
    other: "लगभग {{count}} वर्ष"
    // CLDR #4823
  },
  xYears: {
    one: "१ वर्ष",
    other: "{{count}} वर्ष"
  },
  overXYears: {
    one: "१ वर्ष से अधिक",
    other: "{{count}} वर्ष से अधिक"
  },
  almostXYears: {
    one: "लगभग १ वर्ष",
    other: "लगभग {{count}} वर्ष"
  }
};
var formatDistance36 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale35[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", numberToLocale2(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "मे ";
    } else {
      return result + " पहले";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/hi/_lib/formatLong.mjs
var dateFormats42 = {
  full: "EEEE, do MMMM, y",
  // CLDR #1787
  long: "do MMMM, y",
  // CLDR #1788
  medium: "d MMM, y",
  // CLDR #1789
  short: "dd/MM/yyyy"
  // CLDR #1790
};
var timeFormats42 = {
  full: "h:mm:ss a zzzz",
  // CLDR #1791
  long: "h:mm:ss a z",
  // CLDR #1792
  medium: "h:mm:ss a",
  // CLDR #1793
  short: "h:mm a"
  // CLDR #1794
};
var dateTimeFormats42 = {
  full: "{{date}} 'को' {{time}}",
  // CLDR #1795
  long: "{{date}} 'को' {{time}}",
  // CLDR #1796
  medium: "{{date}}, {{time}}",
  // CLDR #1797
  short: "{{date}}, {{time}}"
  // CLDR #1798
};
var formatLong42 = {
  date: buildFormatLongFn({
    formats: dateFormats42,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats42,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats42,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/hi/_lib/formatRelative.mjs
var formatRelativeLocale35 = {
  lastWeek: "'पिछले' eeee p",
  yesterday: "'कल' p",
  today: "'आज' p",
  tomorrow: "'कल' p",
  nextWeek: "eeee 'को' p",
  other: "P"
};
var formatRelative35 = (token, _date, _baseDate, _options) => formatRelativeLocale35[token];

// ../../../node_modules/date-fns/locale/hi/_lib/match.mjs
var matchOrdinalNumberPattern34 = /^[०१२३४५६७८९]+/i;
var parseOrdinalNumberPattern34 = /^[०१२३४५६७८९]+/i;
var matchEraPatterns34 = {
  narrow: /^(ईसा-पूर्व|ईस्वी)/i,
  abbreviated: /^(ईसा\.?\s?पूर्व\.?|ईसा\.?)/i,
  wide: /^(ईसा-पूर्व|ईसवी पूर्व|ईसवी सन|ईसवी)/i
};
var parseEraPatterns34 = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns34 = {
  narrow: /^[1234]/i,
  abbreviated: /^ति[1234]/i,
  wide: /^[1234](पहली|दूसरी|तीसरी|चौथी)? तिमाही/i
};
var parseQuarterPatterns34 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns34 = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[जफ़माअप्मईजूनजुअगसिअक्तनदि]/i,
  abbreviated: /^(जन|फ़र|मार्च|अप्|मई|जून|जुल|अग|सित|अक्तू|नव|दिस)/i,
  wide: /^(जनवरी|फ़रवरी|मार्च|अप्रैल|मई|जून|जुलाई|अगस्त|सितंबर|अक्तूबर|नवंबर|दिसंबर)/i
};
var parseMonthPatterns34 = {
  narrow: [
    /^ज/i,
    /^फ़/i,
    /^मा/i,
    /^अप्/i,
    /^मई/i,
    /^जू/i,
    /^जु/i,
    /^अग/i,
    /^सि/i,
    /^अक्तू/i,
    /^न/i,
    /^दि/i
  ],
  any: [
    /^जन/i,
    /^फ़/i,
    /^मा/i,
    /^अप्/i,
    /^मई/i,
    /^जू/i,
    /^जु/i,
    /^अग/i,
    /^सि/i,
    /^अक्तू/i,
    /^नव/i,
    /^दिस/i
  ]
};
var matchDayPatterns34 = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[रविसोममंगलबुधगुरुशुक्रशनि]/i,
  short: /^(रवि|सोम|मंगल|बुध|गुरु|शुक्र|शनि)/i,
  abbreviated: /^(रवि|सोम|मंगल|बुध|गुरु|शुक्र|शनि)/i,
  wide: /^(रविवार|सोमवार|मंगलवार|बुधवार|गुरुवार|शुक्रवार|शनिवार)/i
};
var parseDayPatterns34 = {
  narrow: [/^रवि/i, /^सोम/i, /^मंगल/i, /^बुध/i, /^गुरु/i, /^शुक्र/i, /^शनि/i],
  any: [/^रवि/i, /^सोम/i, /^मंगल/i, /^बुध/i, /^गुरु/i, /^शुक्र/i, /^शनि/i]
};
var matchDayPeriodPatterns34 = {
  narrow: /^(पू|अ|म|द.\?|सु|दो|शा|रा)/i,
  any: /^(पूर्वाह्न|अपराह्न|म|द.\?|सु|दो|शा|रा)/i
};
var parseDayPeriodPatterns34 = {
  any: {
    am: /^पूर्वाह्न/i,
    pm: /^अपराह्न/i,
    midnight: /^मध्य/i,
    noon: /^दो/i,
    morning: /सु/i,
    afternoon: /दो/i,
    evening: /शा/i,
    night: /रा/i
  }
};
var match34 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern34,
    parsePattern: parseOrdinalNumberPattern34,
    valueCallback: localeToNumber
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns34,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns34,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns34,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns34,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns34,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns34,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns34,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns34,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns34,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns34,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/hi.mjs
var hi = {
  code: "hi",
  formatDistance: formatDistance36,
  formatLong: formatLong42,
  formatRelative: formatRelative35,
  localize: localize35,
  match: match34,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/hr/_lib/formatDistance.mjs
var formatDistanceLocale36 = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu"
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi"
  },
  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu"
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi"
  },
  halfAMinute: "pola minute",
  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu"
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta"
  },
  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu"
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta"
  },
  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat"
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati"
  },
  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat"
    },
    dual: "{{count}} sata",
    other: "{{count}} sati"
  },
  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan"
    },
    dual: "{{count}} dana",
    other: "{{count}} dana"
  },
  aboutXWeeks: {
    one: {
      standalone: "oko 1 tjedan",
      withPrepositionAgo: "oko 1 tjedan",
      withPrepositionIn: "oko 1 tjedan"
    },
    dual: "oko {{count}} tjedna",
    other: "oko {{count}} tjedana"
  },
  xWeeks: {
    one: {
      standalone: "1 tjedan",
      withPrepositionAgo: "1 tjedan",
      withPrepositionIn: "1 tjedan"
    },
    dual: "{{count}} tjedna",
    other: "{{count}} tjedana"
  },
  aboutXMonths: {
    one: {
      standalone: "oko 1 mjesec",
      withPrepositionAgo: "oko 1 mjesec",
      withPrepositionIn: "oko 1 mjesec"
    },
    dual: "oko {{count}} mjeseca",
    other: "oko {{count}} mjeseci"
  },
  xMonths: {
    one: {
      standalone: "1 mjesec",
      withPrepositionAgo: "1 mjesec",
      withPrepositionIn: "1 mjesec"
    },
    dual: "{{count}} mjeseca",
    other: "{{count}} mjeseci"
  },
  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu"
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina"
  },
  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu"
    },
    dual: "{{count}} godine",
    other: "{{count}} godina"
  },
  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu"
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina"
  },
  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu"
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina"
  }
};
var formatDistance37 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale36[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options2 == null ? void 0 : options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
  String(count).substr(-2, 1) !== "1") {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "za " + result;
    } else {
      return "prije " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/hr/_lib/formatLong.mjs
var dateFormats43 = {
  full: "EEEE, d. MMMM y.",
  long: "d. MMMM y.",
  medium: "d. MMM y.",
  short: "dd. MM. y."
};
var timeFormats43 = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats43 = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong43 = {
  date: buildFormatLongFn({
    formats: dateFormats43,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats43,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats43,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/hr/_lib/formatRelative.mjs
var formatRelativeLocale36 = {
  lastWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'prošlu nedjelju u' p";
      case 3:
        return "'prošlu srijedu u' p";
      case 6:
        return "'prošlu subotu u' p";
      default:
        return "'prošli' EEEE 'u' p";
    }
  },
  yesterday: "'jučer u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'iduću nedjelju u' p";
      case 3:
        return "'iduću srijedu u' p";
      case 6:
        return "'iduću subotu u' p";
      default:
        return "'prošli' EEEE 'u' p";
    }
  },
  other: "P"
};
var formatRelative36 = (token, date2, _baseDate, _options) => {
  const format3 = formatRelativeLocale36[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/hr/_lib/localize.mjs
var eraValues36 = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Kr.", "po. Kr."],
  wide: ["Prije Krista", "Poslije Krista"]
};
var quarterValues36 = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
var monthValues36 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "sij",
    "velj",
    "ožu",
    "tra",
    "svi",
    "lip",
    "srp",
    "kol",
    "ruj",
    "lis",
    "stu",
    "pro"
  ],
  wide: [
    "siječanj",
    "veljača",
    "ožujak",
    "travanj",
    "svibanj",
    "lipanj",
    "srpanj",
    "kolovoz",
    "rujan",
    "listopad",
    "studeni",
    "prosinac"
  ]
};
var formattingMonthValues9 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "sij",
    "velj",
    "ožu",
    "tra",
    "svi",
    "lip",
    "srp",
    "kol",
    "ruj",
    "lis",
    "stu",
    "pro"
  ],
  wide: [
    "siječnja",
    "veljače",
    "ožujka",
    "travnja",
    "svibnja",
    "lipnja",
    "srpnja",
    "kolovoza",
    "rujna",
    "listopada",
    "studenog",
    "prosinca"
  ]
};
var dayValues36 = {
  narrow: ["N", "P", "U", "S", "Č", "P", "S"],
  short: ["ned", "pon", "uto", "sri", "čet", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sri", "čet", "pet", "sub"],
  wide: [
    "nedjelja",
    "ponedjeljak",
    "utorak",
    "srijeda",
    "četvrtak",
    "petak",
    "subota"
  ]
};
var formattingDayPeriodValues30 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "navečer",
    night: "noću"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "navečer",
    night: "noću"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutro",
    afternoon: "poslije podne",
    evening: "navečer",
    night: "noću"
  }
};
var dayPeriodValues36 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "navečer",
    night: "noću"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutro",
    afternoon: "popodne",
    evening: "navečer",
    night: "noću"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutro",
    afternoon: "poslije podne",
    evening: "navečer",
    night: "noću"
  }
};
var ordinalNumber36 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize36 = {
  ordinalNumber: ordinalNumber36,
  era: buildLocalizeFn({
    values: eraValues36,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues36,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues36,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues9,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues36,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues36,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues30,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/hr/_lib/match.mjs
var matchOrdinalNumberPattern35 = /^(\d+)\./i;
var parseOrdinalNumberPattern35 = /\d+/i;
var matchEraPatterns35 = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Kr\.|po\.\s?Kr\.)/i,
  wide: /^(Prije Krista|prije nove ere|Poslije Krista|nova era)/i
};
var parseEraPatterns35 = {
  any: [/^pr/i, /^(po|nova)/i]
};
var matchQuarterPatterns35 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i
};
var parseQuarterPatterns35 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns35 = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(sij|velj|(ožu|ozu)|tra|svi|lip|srp|kol|ruj|lis|stu|pro)/i,
  wide: /^((siječanj|siječnja|sijecanj|sijecnja)|(veljača|veljače|veljaca|veljace)|(ožujak|ožujka|ozujak|ozujka)|(travanj|travnja)|(svibanj|svibnja)|(lipanj|lipnja)|(srpanj|srpnja)|(kolovoz|kolovoza)|(rujan|rujna)|(listopad|listopada)|(studeni|studenog)|(prosinac|prosinca))/i
};
var parseMonthPatterns35 = {
  narrow: [
    /1/i,
    /2/i,
    /3/i,
    /4/i,
    /5/i,
    /6/i,
    /7/i,
    /8/i,
    /9/i,
    /10/i,
    /11/i,
    /12/i
  ],
  abbreviated: [
    /^sij/i,
    /^velj/i,
    /^(ožu|ozu)/i,
    /^tra/i,
    /^svi/i,
    /^lip/i,
    /^srp/i,
    /^kol/i,
    /^ruj/i,
    /^lis/i,
    /^stu/i,
    /^pro/i
  ],
  wide: [
    /^sij/i,
    /^velj/i,
    /^(ožu|ozu)/i,
    /^tra/i,
    /^svi/i,
    /^lip/i,
    /^srp/i,
    /^kol/i,
    /^ruj/i,
    /^lis/i,
    /^stu/i,
    /^pro/i
  ]
};
var matchDayPatterns35 = {
  narrow: /^[npusčc]/i,
  short: /^(ned|pon|uto|sri|(čet|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sri|(čet|cet)|pet|sub)/i,
  wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(četvrtak|cetvrtak)|petak|subota)/i
};
var parseDayPatterns35 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns35 = {
  any: /^(am|pm|ponoc|ponoć|(po)?podne|navecer|navečer|noću|poslije podne|ujutro)/i
};
var parseDayPeriodPatterns35 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(poslije\s|po)+podne/i,
    evening: /(navece|naveče)/i,
    night: /(nocu|noću)/i
  }
};
var match35 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern35,
    parsePattern: parseOrdinalNumberPattern35,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns35,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns35,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns35,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns35,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns35,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns35,
    defaultParseWidth: "wide"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns35,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns35,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns35,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns35,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/hr.mjs
var hr = {
  code: "hr",
  formatDistance: formatDistance37,
  formatLong: formatLong43,
  formatRelative: formatRelative36,
  localize: localize36,
  match: match35,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ht/_lib/formatDistance.mjs
var formatDistanceLocale37 = {
  lessThanXSeconds: {
    one: "mwens pase yon segond",
    other: "mwens pase {{count}} segond"
  },
  xSeconds: {
    one: "1 segond",
    other: "{{count}} segond"
  },
  halfAMinute: "30 segond",
  lessThanXMinutes: {
    one: "mwens pase yon minit",
    other: "mwens pase {{count}} minit"
  },
  xMinutes: {
    one: "1 minit",
    other: "{{count}} minit"
  },
  aboutXHours: {
    one: "anviwon inè",
    other: "anviwon {{count}} è"
  },
  xHours: {
    one: "1 lè",
    other: "{{count}} lè"
  },
  xDays: {
    one: "1 jou",
    other: "{{count}} jou"
  },
  aboutXWeeks: {
    one: "anviwon 1 semèn",
    other: "anviwon {{count}} semèn"
  },
  xWeeks: {
    one: "1 semèn",
    other: "{{count}} semèn"
  },
  aboutXMonths: {
    one: "anviwon 1 mwa",
    other: "anviwon {{count}} mwa"
  },
  xMonths: {
    one: "1 mwa",
    other: "{{count}} mwa"
  },
  aboutXYears: {
    one: "anviwon 1 an",
    other: "anviwon {{count}} an"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} an"
  },
  overXYears: {
    one: "plis pase 1 an",
    other: "plis pase {{count}} an"
  },
  almostXYears: {
    one: "prèske 1 an",
    other: "prèske {{count}} an"
  }
};
var formatDistance38 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale37[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "nan " + result;
    } else {
      return "sa fè " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ht/_lib/formatLong.mjs
var dateFormats44 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats44 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats44 = {
  full: "{{date}} 'nan lè' {{time}}",
  long: "{{date}} 'nan lè' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong44 = {
  date: buildFormatLongFn({
    formats: dateFormats44,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats44,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats44,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ht/_lib/formatRelative.mjs
var formatRelativeLocale37 = {
  lastWeek: "eeee 'pase nan lè' p",
  yesterday: "'yè nan lè' p",
  today: "'jodi a' p",
  tomorrow: "'demen nan lè' p'",
  nextWeek: "eeee 'pwochen nan lè' p",
  other: "P"
};
var formatRelative37 = (token, _date, _baseDate, _options) => formatRelativeLocale37[token];

// ../../../node_modules/date-fns/locale/ht/_lib/localize.mjs
var eraValues37 = {
  narrow: ["av. J.-K", "ap. J.-K"],
  abbreviated: ["av. J.-K", "ap. J.-K"],
  wide: ["anvan Jezi Kris", "apre Jezi Kris"]
};
var quarterValues37 = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1ye trim.", "2yèm trim.", "3yèm trim.", "4yèm trim."],
  wide: ["1ye trimès", "2yèm trimès", "3yèm trimès", "4yèm trimès"]
};
var monthValues37 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "O", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "fevr.",
    "mas",
    "avr.",
    "me",
    "jen",
    "jiyè",
    "out",
    "sept.",
    "okt.",
    "nov.",
    "des."
  ],
  wide: [
    "janvye",
    "fevrye",
    "mas",
    "avril",
    "me",
    "jen",
    "jiyè",
    "out",
    "septanm",
    "oktòb",
    "novanm",
    "desanm"
  ]
};
var dayValues37 = {
  narrow: ["D", "L", "M", "M", "J", "V", "S"],
  short: ["di", "le", "ma", "mè", "je", "va", "sa"],
  abbreviated: ["dim.", "len.", "mad.", "mèk.", "jed.", "van.", "sam."],
  wide: ["dimanch", "lendi", "madi", "mèkredi", "jedi", "vandredi", "samdi"]
};
var dayPeriodValues37 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "mat.",
    afternoon: "ap.m.",
    evening: "swa",
    night: "mat."
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "maten",
    afternoon: "aprèmidi",
    evening: "swa",
    night: "maten"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "minwit",
    noon: "midi",
    morning: "nan maten",
    afternoon: "nan aprèmidi",
    evening: "nan aswè",
    night: "nan maten"
  }
};
var ordinalNumber37 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  if (number2 === 0) return String(number2);
  const suffix2 = number2 === 1 ? "ye" : "yèm";
  return number2 + suffix2;
};
var localize37 = {
  ordinalNumber: ordinalNumber37,
  era: buildLocalizeFn({
    values: eraValues37,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues37,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues37,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues37,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues37,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ht/_lib/match.mjs
var matchOrdinalNumberPattern36 = /^(\d+)(ye|yèm)?/i;
var parseOrdinalNumberPattern36 = /\d+/i;
var matchEraPatterns36 = {
  narrow: /^(av\.J\.K|ap\.J\.K|ap\.J\.-K)/i,
  abbreviated: /^(av\.J\.-K|av\.J-K|apr\.J\.-K|apr\.J-K|ap\.J-K)/i,
  wide: /^(avan Jezi Kris|apre Jezi Kris)/i
};
var parseEraPatterns36 = {
  any: [/^av/i, /^ap/i]
};
var matchQuarterPatterns36 = {
  narrow: /^[1234]/i,
  abbreviated: /^t[1234]/i,
  wide: /^[1234](ye|yèm)? trimès/i
};
var parseQuarterPatterns36 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns36 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(janv|fevr|mas|avr|me|jen|jiyè|out|sept|okt|nov|des)\.?/i,
  wide: /^(janvye|fevrye|mas|avril|me|jen|jiyè|out|septanm|oktòb|novanm|desanm)/i
};
var parseMonthPatterns36 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^o/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^av/i,
    /^me/i,
    /^je/i,
    /^ji/i,
    /^ou/i,
    /^s/i,
    /^ok/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns36 = {
  narrow: /^[lmjvsd]/i,
  short: /^(di|le|ma|me|je|va|sa)/i,
  abbreviated: /^(dim|len|mad|mèk|jed|van|sam)\.?/i,
  wide: /^(dimanch|lendi|madi|mèkredi|jedi|vandredi|samdi)/i
};
var parseDayPatterns36 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^di/i, /^le/i, /^ma/i, /^mè/i, /^je/i, /^va/i, /^sa/i]
};
var matchDayPeriodPatterns36 = {
  narrow: /^(a|p|minwit|midi|mat\.?|ap\.?m\.?|swa)/i,
  any: /^([ap]\.?\s?m\.?|nan maten|nan aprèmidi|nan aswè)/i
};
var parseDayPeriodPatterns36 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^min/i,
    noon: /^mid/i,
    morning: /mat/i,
    afternoon: /ap/i,
    evening: /sw/i,
    night: /nwit/i
  }
};
var match36 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern36,
    parsePattern: parseOrdinalNumberPattern36,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns36,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns36,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns36,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns36,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns36,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns36,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns36,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns36,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns36,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns36,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ht.mjs
var ht = {
  code: "ht",
  formatDistance: formatDistance38,
  formatLong: formatLong44,
  formatRelative: formatRelative37,
  localize: localize37,
  match: match36,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/hu/_lib/formatDistance.mjs
var translations = {
  about: "körülbelül",
  over: "több mint",
  almost: "majdnem",
  lessthan: "kevesebb mint"
};
var withoutSuffixes = {
  xseconds: " másodperc",
  halfaminute: "fél perc",
  xminutes: " perc",
  xhours: " óra",
  xdays: " nap",
  xweeks: " hét",
  xmonths: " hónap",
  xyears: " év"
};
var withSuffixes = {
  xseconds: {
    "-1": " másodperccel ezelőtt",
    1: " másodperc múlva",
    0: " másodperce"
  },
  halfaminute: {
    "-1": "fél perccel ezelőtt",
    1: "fél perc múlva",
    0: "fél perce"
  },
  xminutes: {
    "-1": " perccel ezelőtt",
    1: " perc múlva",
    0: " perce"
  },
  xhours: {
    "-1": " órával ezelőtt",
    1: " óra múlva",
    0: " órája"
  },
  xdays: {
    "-1": " nappal ezelőtt",
    1: " nap múlva",
    0: " napja"
  },
  xweeks: {
    "-1": " héttel ezelőtt",
    1: " hét múlva",
    0: " hete"
  },
  xmonths: {
    "-1": " hónappal ezelőtt",
    1: " hónap múlva",
    0: " hónapja"
  },
  xyears: {
    "-1": " évvel ezelőtt",
    1: " év múlva",
    0: " éve"
  }
};
var formatDistance39 = (token, count, options2) => {
  const adverb = token.match(/about|over|almost|lessthan/i);
  const unit = adverb ? token.replace(adverb[0], "") : token;
  const addSuffix = (options2 == null ? void 0 : options2.addSuffix) === true;
  const key = unit.toLowerCase();
  const comparison = (options2 == null ? void 0 : options2.comparison) || 0;
  const translated = addSuffix ? withSuffixes[key][comparison] : withoutSuffixes[key];
  let result = key === "halfaminute" ? translated : count + translated;
  if (adverb) {
    const adv = adverb[0].toLowerCase();
    result = translations[adv] + " " + result;
  }
  return result;
};

// ../../../node_modules/date-fns/locale/hu/_lib/formatLong.mjs
var dateFormats45 = {
  full: "y. MMMM d., EEEE",
  long: "y. MMMM d.",
  medium: "y. MMM d.",
  short: "y. MM. dd."
};
var timeFormats45 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats45 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong45 = {
  date: buildFormatLongFn({
    formats: dateFormats45,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats45,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats45,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/hu/_lib/formatRelative.mjs
var accusativeWeekdays4 = [
  "vasárnap",
  "hétfőn",
  "kedden",
  "szerdán",
  "csütörtökön",
  "pénteken",
  "szombaton"
];
function week(isFuture) {
  return (date2) => {
    const weekday = accusativeWeekdays4[date2.getDay()];
    const prefix3 = isFuture ? "" : "'múlt' ";
    return `${prefix3}'${weekday}' p'-kor'`;
  };
}
var formatRelativeLocale38 = {
  lastWeek: week(false),
  yesterday: "'tegnap' p'-kor'",
  today: "'ma' p'-kor'",
  tomorrow: "'holnap' p'-kor'",
  nextWeek: week(true),
  other: "P"
};
var formatRelative38 = (token, date2) => {
  const format3 = formatRelativeLocale38[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/hu/_lib/localize.mjs
var eraValues38 = {
  narrow: ["ie.", "isz."],
  abbreviated: ["i. e.", "i. sz."],
  wide: ["Krisztus előtt", "időszámításunk szerint"]
};
var quarterValues38 = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. n.év", "2. n.év", "3. n.év", "4. n.év"],
  wide: ["1. negyedév", "2. negyedév", "3. negyedév", "4. negyedév"]
};
var formattingQuarterValues = {
  narrow: ["I.", "II.", "III.", "IV."],
  abbreviated: ["I. n.év", "II. n.év", "III. n.év", "IV. n.év"],
  wide: ["I. negyedév", "II. negyedév", "III. negyedév", "IV. negyedév"]
};
var monthValues38 = {
  narrow: ["J", "F", "M", "Á", "M", "J", "J", "A", "Sz", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "febr.",
    "márc.",
    "ápr.",
    "máj.",
    "jún.",
    "júl.",
    "aug.",
    "szept.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "január",
    "február",
    "március",
    "április",
    "május",
    "június",
    "július",
    "augusztus",
    "szeptember",
    "október",
    "november",
    "december"
  ]
};
var dayValues38 = {
  narrow: ["V", "H", "K", "Sz", "Cs", "P", "Sz"],
  short: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
  abbreviated: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
  wide: [
    "vasárnap",
    "hétfő",
    "kedd",
    "szerda",
    "csütörtök",
    "péntek",
    "szombat"
  ]
};
var dayPeriodValues38 = {
  narrow: {
    am: "de.",
    pm: "du.",
    midnight: "éjfél",
    noon: "dél",
    morning: "reggel",
    afternoon: "du.",
    evening: "este",
    night: "éjjel"
  },
  abbreviated: {
    am: "de.",
    pm: "du.",
    midnight: "éjfél",
    noon: "dél",
    morning: "reggel",
    afternoon: "du.",
    evening: "este",
    night: "éjjel"
  },
  wide: {
    am: "de.",
    pm: "du.",
    midnight: "éjfél",
    noon: "dél",
    morning: "reggel",
    afternoon: "délután",
    evening: "este",
    night: "éjjel"
  }
};
var ordinalNumber38 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize38 = {
  ordinalNumber: ordinalNumber38,
  era: buildLocalizeFn({
    values: eraValues38,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues38,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1,
    formattingValues: formattingQuarterValues,
    defaultFormattingWidth: "wide"
  }),
  month: buildLocalizeFn({
    values: monthValues38,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues38,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues38,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/hu/_lib/match.mjs
var matchOrdinalNumberPattern37 = /^(\d+)\.?/i;
var parseOrdinalNumberPattern37 = /\d+/i;
var matchEraPatterns37 = {
  narrow: /^(ie\.|isz\.)/i,
  abbreviated: /^(i\.\s?e\.?|b?\s?c\s?e|i\.\s?sz\.?)/i,
  wide: /^(Krisztus előtt|időszámításunk előtt|időszámításunk szerint|i\. sz\.)/i
};
var parseEraPatterns37 = {
  narrow: [/ie/i, /isz/i],
  abbreviated: [/^(i\.?\s?e\.?|b\s?ce)/i, /^(i\.?\s?sz\.?|c\s?e)/i],
  any: [/előtt/i, /(szerint|i. sz.)/i]
};
var matchQuarterPatterns37 = {
  narrow: /^[1234]\.?/i,
  abbreviated: /^[1234]?\.?\s?n\.év/i,
  wide: /^([1234]|I|II|III|IV)?\.?\s?negyedév/i
};
var parseQuarterPatterns37 = {
  any: [/1|I$/i, /2|II$/i, /3|III/i, /4|IV/i]
};
var matchMonthPatterns37 = {
  narrow: /^[jfmaásond]|sz/i,
  abbreviated: /^(jan\.?|febr\.?|márc\.?|ápr\.?|máj\.?|jún\.?|júl\.?|aug\.?|szept\.?|okt\.?|nov\.?|dec\.?)/i,
  wide: /^(január|február|március|április|május|június|július|augusztus|szeptember|október|november|december)/i
};
var parseMonthPatterns37 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a|á/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s|sz/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^már/i,
    /^áp/i,
    /^máj/i,
    /^jún/i,
    /^júl/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns37 = {
  narrow: /^([vhkpc]|sz|cs|sz)/i,
  short: /^([vhkp]|sze|cs|szo)/i,
  abbreviated: /^([vhkp]|sze|cs|szo)/i,
  wide: /^(vasárnap|hétfő|kedd|szerda|csütörtök|péntek|szombat)/i
};
var parseDayPatterns37 = {
  narrow: [/^v/i, /^h/i, /^k/i, /^sz/i, /^c/i, /^p/i, /^sz/i],
  any: [/^v/i, /^h/i, /^k/i, /^sze/i, /^c/i, /^p/i, /^szo/i]
};
var matchDayPeriodPatterns37 = {
  any: /^((de|du)\.?|éjfél|délután|dél|reggel|este|éjjel)/i
};
var parseDayPeriodPatterns37 = {
  any: {
    am: /^de\.?/i,
    pm: /^du\.?/i,
    midnight: /^éjf/i,
    noon: /^dé/i,
    morning: /reg/i,
    afternoon: /^délu\.?/i,
    evening: /es/i,
    night: /éjj/i
  }
};
var match37 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern37,
    parsePattern: parseOrdinalNumberPattern37,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns37,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns37,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns37,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns37,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns37,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns37,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns37,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns37,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns37,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns37,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/hu.mjs
var hu = {
  code: "hu",
  formatDistance: formatDistance39,
  formatLong: formatLong45,
  formatRelative: formatRelative38,
  localize: localize38,
  match: match37,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/hy/_lib/formatDistance.mjs
var formatDistanceLocale38 = {
  lessThanXSeconds: {
    one: "ավելի քիչ քան 1 վայրկյան",
    other: "ավելի քիչ քան {{count}} վայրկյան"
  },
  xSeconds: {
    one: "1 վայրկյան",
    other: "{{count}} վայրկյան"
  },
  halfAMinute: "կես րոպե",
  lessThanXMinutes: {
    one: "ավելի քիչ քան 1 րոպե",
    other: "ավելի քիչ քան {{count}} րոպե"
  },
  xMinutes: {
    one: "1 րոպե",
    other: "{{count}} րոպե"
  },
  aboutXHours: {
    one: "մոտ 1 ժամ",
    other: "մոտ {{count}} ժամ"
  },
  xHours: {
    one: "1 ժամ",
    other: "{{count}} ժամ"
  },
  xDays: {
    one: "1 օր",
    other: "{{count}} օր"
  },
  aboutXWeeks: {
    one: "մոտ 1 շաբաթ",
    other: "մոտ {{count}} շաբաթ"
  },
  xWeeks: {
    one: "1 շաբաթ",
    other: "{{count}} շաբաթ"
  },
  aboutXMonths: {
    one: "մոտ 1 ամիս",
    other: "մոտ {{count}} ամիս"
  },
  xMonths: {
    one: "1 ամիս",
    other: "{{count}} ամիս"
  },
  aboutXYears: {
    one: "մոտ 1 տարի",
    other: "մոտ {{count}} տարի"
  },
  xYears: {
    one: "1 տարի",
    other: "{{count}} տարի"
  },
  overXYears: {
    one: "ավելի քան 1 տարի",
    other: "ավելի քան {{count}} տարի"
  },
  almostXYears: {
    one: "համարյա 1 տարի",
    other: "համարյա {{count}} տարի"
  }
};
var formatDistance40 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale38[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + " հետո";
    } else {
      return result + " առաջ";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/hy/_lib/formatLong.mjs
var dateFormats46 = {
  full: "d MMMM, y, EEEE",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "dd.MM.yyyy"
};
var timeFormats46 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats46 = {
  full: "{{date}} 'ժ․'{{time}}",
  long: "{{date}} 'ժ․'{{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong46 = {
  date: buildFormatLongFn({
    formats: dateFormats46,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats46,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats46,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/hy/_lib/formatRelative.mjs
var formatRelativeLocale39 = {
  lastWeek: "'նախորդ' eeee p'֊ին'",
  yesterday: "'երեկ' p'֊ին'",
  today: "'այսօր' p'֊ին'",
  tomorrow: "'վաղը' p'֊ին'",
  nextWeek: "'հաջորդ' eeee p'֊ին'",
  other: "P"
};
var formatRelative39 = (token, _date, _baseDate, _options) => formatRelativeLocale39[token];

// ../../../node_modules/date-fns/locale/hy/_lib/localize.mjs
var eraValues39 = {
  narrow: ["Ք", "Մ"],
  abbreviated: ["ՔԱ", "ՄԹ"],
  wide: ["Քրիստոսից առաջ", "Մեր թվարկության"]
};
var quarterValues39 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Ք1", "Ք2", "Ք3", "Ք4"],
  wide: ["1֊ին քառորդ", "2֊րդ քառորդ", "3֊րդ քառորդ", "4֊րդ քառորդ"]
};
var monthValues39 = {
  narrow: ["Հ", "Փ", "Մ", "Ա", "Մ", "Հ", "Հ", "Օ", "Ս", "Հ", "Ն", "Դ"],
  abbreviated: [
    "հուն",
    "փետ",
    "մար",
    "ապր",
    "մայ",
    "հուն",
    "հուլ",
    "օգս",
    "սեպ",
    "հոկ",
    "նոյ",
    "դեկ"
  ],
  wide: [
    "հունվար",
    "փետրվար",
    "մարտ",
    "ապրիլ",
    "մայիս",
    "հունիս",
    "հուլիս",
    "օգոստոս",
    "սեպտեմբեր",
    "հոկտեմբեր",
    "նոյեմբեր",
    "դեկտեմբեր"
  ]
};
var dayValues39 = {
  narrow: ["Կ", "Ե", "Ե", "Չ", "Հ", "Ո", "Շ"],
  short: ["կր", "եր", "եք", "չք", "հգ", "ուր", "շբ"],
  abbreviated: ["կիր", "երկ", "երք", "չոր", "հնգ", "ուրբ", "շաբ"],
  wide: [
    "կիրակի",
    "երկուշաբթի",
    "երեքշաբթի",
    "չորեքշաբթի",
    "հինգշաբթի",
    "ուրբաթ",
    "շաբաթ"
  ]
};
var dayPeriodValues39 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "կեսգշ",
    noon: "կեսօր",
    morning: "առավոտ",
    afternoon: "ցերեկ",
    evening: "երեկո",
    night: "գիշեր"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "կեսգիշեր",
    noon: "կեսօր",
    morning: "առավոտ",
    afternoon: "ցերեկ",
    evening: "երեկո",
    night: "գիշեր"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "կեսգիշեր",
    noon: "կեսօր",
    morning: "առավոտ",
    afternoon: "ցերեկ",
    evening: "երեկո",
    night: "գիշեր"
  }
};
var formattingDayPeriodValues31 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "կեսգշ",
    noon: "կեսօր",
    morning: "առավոտը",
    afternoon: "ցերեկը",
    evening: "երեկոյան",
    night: "գիշերը"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "կեսգիշերին",
    noon: "կեսօրին",
    morning: "առավոտը",
    afternoon: "ցերեկը",
    evening: "երեկոյան",
    night: "գիշերը"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "կեսգիշերին",
    noon: "կեսօրին",
    morning: "առավոտը",
    afternoon: "ցերեկը",
    evening: "երեկոյան",
    night: "գիշերը"
  }
};
var ordinalNumber39 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 < 10) {
    if (rem100 % 10 === 1) {
      return number2 + "֊ին";
    }
  }
  return number2 + "֊րդ";
};
var localize39 = {
  ordinalNumber: ordinalNumber39,
  era: buildLocalizeFn({
    values: eraValues39,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues39,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues39,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues39,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues39,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues31,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/hy/_lib/match.mjs
var matchOrdinalNumberPattern38 = /^(\d+)((-|֊)?(ին|րդ))?/i;
var parseOrdinalNumberPattern38 = /\d+/i;
var matchEraPatterns38 = {
  narrow: /^(Ք|Մ)/i,
  abbreviated: /^(Ք\.?\s?Ա\.?|Մ\.?\s?Թ\.?\s?Ա\.?|Մ\.?\s?Թ\.?|Ք\.?\s?Հ\.?)/i,
  wide: /^(քրիստոսից առաջ|մեր թվարկությունից առաջ|մեր թվարկության|քրիստոսից հետո)/i
};
var parseEraPatterns38 = {
  any: [/^ք/i, /^մ/i]
};
var matchQuarterPatterns38 = {
  narrow: /^[1234]/i,
  abbreviated: /^ք[1234]/i,
  wide: /^[1234]((-|֊)?(ին|րդ)) քառորդ/i
};
var parseQuarterPatterns38 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns38 = {
  narrow: /^[հփմաօսնդ]/i,
  abbreviated: /^(հուն|փետ|մար|ապր|մայ|հուն|հուլ|օգս|սեպ|հոկ|նոյ|դեկ)/i,
  wide: /^(հունվար|փետրվար|մարտ|ապրիլ|մայիս|հունիս|հուլիս|օգոստոս|սեպտեմբեր|հոկտեմբեր|նոյեմբեր|դեկտեմբեր)/i
};
var parseMonthPatterns38 = {
  narrow: [
    /^հ/i,
    /^փ/i,
    /^մ/i,
    /^ա/i,
    /^մ/i,
    /^հ/i,
    /^հ/i,
    /^օ/i,
    /^ս/i,
    /^հ/i,
    /^ն/i,
    /^դ/i
  ],
  any: [
    /^հու/i,
    /^փ/i,
    /^մար/i,
    /^ա/i,
    /^մայ/i,
    /^հուն/i,
    /^հուլ/i,
    /^օ/i,
    /^ս/i,
    /^հոկ/i,
    /^ն/i,
    /^դ/i
  ]
};
var matchDayPatterns38 = {
  narrow: /^[եչհոշկ]/i,
  short: /^(կր|եր|եք|չք|հգ|ուր|շբ)/i,
  abbreviated: /^(կիր|երկ|երք|չոր|հնգ|ուրբ|շաբ)/i,
  wide: /^(կիրակի|երկուշաբթի|երեքշաբթի|չորեքշաբթի|հինգշաբթի|ուրբաթ|շաբաթ)/i
};
var parseDayPatterns38 = {
  narrow: [/^կ/i, /^ե/i, /^ե/i, /^չ/i, /^հ/i, /^(ո|Ո)/, /^շ/i],
  short: [/^կ/i, /^եր/i, /^եք/i, /^չ/i, /^հ/i, /^(ո|Ո)/, /^շ/i],
  abbreviated: [/^կ/i, /^երկ/i, /^երք/i, /^չ/i, /^հ/i, /^(ո|Ո)/, /^շ/i],
  wide: [/^կ/i, /^երկ/i, /^երե/i, /^չ/i, /^հ/i, /^(ո|Ո)/, /^շ/i]
};
var matchDayPeriodPatterns38 = {
  narrow: /^([ap]|կեսգշ|կեսօր|(առավոտը?|ցերեկը?|երեկո(յան)?|գիշերը?))/i,
  any: /^([ap]\.?\s?m\.?|կեսգիշեր(ին)?|կեսօր(ին)?|(առավոտը?|ցերեկը?|երեկո(յան)?|գիշերը?))/i
};
var parseDayPeriodPatterns38 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /կեսգիշեր/i,
    noon: /կեսօր/i,
    morning: /առավոտ/i,
    afternoon: /ցերեկ/i,
    evening: /երեկո/i,
    night: /գիշեր/i
  }
};
var match38 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern38,
    parsePattern: parseOrdinalNumberPattern38,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns38,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns38,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns38,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns38,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns38,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns38,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns38,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns38,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns38,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns38,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/hy.mjs
var hy = {
  code: "hy",
  formatDistance: formatDistance40,
  formatLong: formatLong46,
  formatRelative: formatRelative39,
  localize: localize39,
  match: match38,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/id/_lib/formatDistance.mjs
var formatDistanceLocale39 = {
  lessThanXSeconds: {
    one: "kurang dari 1 detik",
    other: "kurang dari {{count}} detik"
  },
  xSeconds: {
    one: "1 detik",
    other: "{{count}} detik"
  },
  halfAMinute: "setengah menit",
  lessThanXMinutes: {
    one: "kurang dari 1 menit",
    other: "kurang dari {{count}} menit"
  },
  xMinutes: {
    one: "1 menit",
    other: "{{count}} menit"
  },
  aboutXHours: {
    one: "sekitar 1 jam",
    other: "sekitar {{count}} jam"
  },
  xHours: {
    one: "1 jam",
    other: "{{count}} jam"
  },
  xDays: {
    one: "1 hari",
    other: "{{count}} hari"
  },
  aboutXWeeks: {
    one: "sekitar 1 minggu",
    other: "sekitar {{count}} minggu"
  },
  xWeeks: {
    one: "1 minggu",
    other: "{{count}} minggu"
  },
  aboutXMonths: {
    one: "sekitar 1 bulan",
    other: "sekitar {{count}} bulan"
  },
  xMonths: {
    one: "1 bulan",
    other: "{{count}} bulan"
  },
  aboutXYears: {
    one: "sekitar 1 tahun",
    other: "sekitar {{count}} tahun"
  },
  xYears: {
    one: "1 tahun",
    other: "{{count}} tahun"
  },
  overXYears: {
    one: "lebih dari 1 tahun",
    other: "lebih dari {{count}} tahun"
  },
  almostXYears: {
    one: "hampir 1 tahun",
    other: "hampir {{count}} tahun"
  }
};
var formatDistance41 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale39[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "dalam waktu " + result;
    } else {
      return result + " yang lalu";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/id/_lib/formatLong.mjs
var dateFormats47 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "d/M/yyyy"
};
var timeFormats47 = {
  full: "HH.mm.ss",
  long: "HH.mm.ss",
  medium: "HH.mm",
  short: "HH.mm"
};
var dateTimeFormats47 = {
  full: "{{date}} 'pukul' {{time}}",
  long: "{{date}} 'pukul' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong47 = {
  date: buildFormatLongFn({
    formats: dateFormats47,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats47,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats47,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/id/_lib/formatRelative.mjs
var formatRelativeLocale40 = {
  lastWeek: "eeee 'lalu pukul' p",
  yesterday: "'Kemarin pukul' p",
  today: "'Hari ini pukul' p",
  tomorrow: "'Besok pukul' p",
  nextWeek: "eeee 'pukul' p",
  other: "P"
};
var formatRelative40 = (token, _date, _baseDate, _options) => formatRelativeLocale40[token];

// ../../../node_modules/date-fns/locale/id/_lib/localize.mjs
var eraValues40 = {
  narrow: ["SM", "M"],
  abbreviated: ["SM", "M"],
  wide: ["Sebelum Masehi", "Masehi"]
};
var quarterValues40 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["Kuartal ke-1", "Kuartal ke-2", "Kuartal ke-3", "Kuartal ke-4"]
};
var monthValues40 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Agt",
    "Sep",
    "Okt",
    "Nov",
    "Des"
  ],
  wide: [
    "Januari",
    "Februari",
    "Maret",
    "April",
    "Mei",
    "Juni",
    "Juli",
    "Agustus",
    "September",
    "Oktober",
    "November",
    "Desember"
  ]
};
var dayValues40 = {
  narrow: ["M", "S", "S", "R", "K", "J", "S"],
  short: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
  abbreviated: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
  wide: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
};
var dayPeriodValues40 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  }
};
var formattingDayPeriodValues32 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "siang",
    evening: "sore",
    night: "malam"
  }
};
var ordinalNumber40 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return "ke-" + number2;
};
var localize40 = {
  ordinalNumber: ordinalNumber40,
  era: buildLocalizeFn({
    values: eraValues40,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues40,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues40,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues40,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues40,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues32,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/id/_lib/match.mjs
var matchOrdinalNumberPattern39 = /^ke-(\d+)?/i;
var parseOrdinalNumberPattern39 = /\d+/i;
var matchEraPatterns39 = {
  narrow: /^(sm|m)/i,
  abbreviated: /^(s\.?\s?m\.?|s\.?\s?e\.?\s?u\.?|m\.?|e\.?\s?u\.?)/i,
  wide: /^(sebelum masehi|sebelum era umum|masehi|era umum)/i
};
var parseEraPatterns39 = {
  any: [/^s/i, /^(m|e)/i]
};
var matchQuarterPatterns39 = {
  narrow: /^[1234]/i,
  abbreviated: /^K-?\s[1234]/i,
  wide: /^Kuartal ke-?\s?[1234]/i
};
var parseQuarterPatterns39 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns39 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|mei|jun|jul|agt|sep|okt|nov|des)/i,
  wide: /^(januari|februari|maret|april|mei|juni|juli|agustus|september|oktober|november|desember)/i
};
var parseMonthPatterns39 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^ap/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns39 = {
  narrow: /^[srkjm]/i,
  short: /^(min|sen|sel|rab|kam|jum|sab)/i,
  abbreviated: /^(min|sen|sel|rab|kam|jum|sab)/i,
  wide: /^(minggu|senin|selasa|rabu|kamis|jumat|sabtu)/i
};
var parseDayPatterns39 = {
  narrow: [/^m/i, /^s/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
  any: [/^m/i, /^sen/i, /^sel/i, /^r/i, /^k/i, /^j/i, /^sa/i]
};
var matchDayPeriodPatterns39 = {
  narrow: /^(a|p|tengah m|tengah h|(di(\swaktu)?) (pagi|siang|sore|malam))/i,
  any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|(di(\swaktu)?) (pagi|siang|sore|malam))/i
};
var parseDayPeriodPatterns39 = {
  any: {
    am: /^a/i,
    pm: /^pm/i,
    midnight: /^tengah m/i,
    noon: /^tengah h/i,
    morning: /pagi/i,
    afternoon: /siang/i,
    evening: /sore/i,
    night: /malam/i
  }
};
var match39 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern39,
    parsePattern: parseOrdinalNumberPattern39,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns39,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns39,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns39,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns39,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns39,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns39,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns39,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns39,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns39,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns39,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/id.mjs
var id = {
  code: "id",
  formatDistance: formatDistance41,
  formatLong: formatLong47,
  formatRelative: formatRelative40,
  localize: localize40,
  match: match39,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/is/_lib/formatDistance.mjs
var formatDistanceLocale40 = {
  lessThanXSeconds: {
    one: "minna en 1 sekúnda",
    other: "minna en {{count}} sekúndur"
  },
  xSeconds: {
    one: "1 sekúnda",
    other: "{{count}} sekúndur"
  },
  halfAMinute: "hálf mínúta",
  lessThanXMinutes: {
    one: "minna en 1 mínúta",
    other: "minna en {{count}} mínútur"
  },
  xMinutes: {
    one: "1 mínúta",
    other: "{{count}} mínútur"
  },
  aboutXHours: {
    one: "u.þ.b. 1 klukkustund",
    other: "u.þ.b. {{count}} klukkustundir"
  },
  xHours: {
    one: "1 klukkustund",
    other: "{{count}} klukkustundir"
  },
  xDays: {
    one: "1 dagur",
    other: "{{count}} dagar"
  },
  aboutXWeeks: {
    one: "um viku",
    other: "um {{count}} vikur"
  },
  xWeeks: {
    one: "1 viku",
    other: "{{count}} vikur"
  },
  aboutXMonths: {
    one: "u.þ.b. 1 mánuður",
    other: "u.þ.b. {{count}} mánuðir"
  },
  xMonths: {
    one: "1 mánuður",
    other: "{{count}} mánuðir"
  },
  aboutXYears: {
    one: "u.þ.b. 1 ár",
    other: "u.þ.b. {{count}} ár"
  },
  xYears: {
    one: "1 ár",
    other: "{{count}} ár"
  },
  overXYears: {
    one: "meira en 1 ár",
    other: "meira en {{count}} ár"
  },
  almostXYears: {
    one: "næstum 1 ár",
    other: "næstum {{count}} ár"
  }
};
var formatDistance42 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale40[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "í " + result;
    } else {
      return result + " síðan";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/is/_lib/formatLong.mjs
var dateFormats48 = {
  full: "EEEE, do MMMM y",
  long: "do MMMM y",
  medium: "do MMM y",
  short: "d.MM.y"
};
var timeFormats48 = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats48 = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong48 = {
  date: buildFormatLongFn({
    formats: dateFormats48,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats48,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats48,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/is/_lib/formatRelative.mjs
var formatRelativeLocale41 = {
  lastWeek: "'síðasta' dddd 'kl.' p",
  yesterday: "'í gær kl.' p",
  today: "'í dag kl.' p",
  tomorrow: "'á morgun kl.' p",
  nextWeek: "dddd 'kl.' p",
  other: "P"
};
var formatRelative41 = (token, _date, _baseDate, _options) => formatRelativeLocale41[token];

// ../../../node_modules/date-fns/locale/is/_lib/localize.mjs
var eraValues41 = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["fyrir Krist", "eftir Krist"]
};
var quarterValues41 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1F", "2F", "3F", "4F"],
  wide: ["1. fjórðungur", "2. fjórðungur", "3. fjórðungur", "4. fjórðungur"]
};
var monthValues41 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "Á", "S", "Ó", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apríl",
    "maí",
    "júní",
    "júlí",
    "ágúst",
    "sept.",
    "okt.",
    "nóv.",
    "des."
  ],
  wide: [
    "janúar",
    "febrúar",
    "mars",
    "apríl",
    "maí",
    "júní",
    "júlí",
    "ágúst",
    "september",
    "október",
    "nóvember",
    "desember"
  ]
};
var dayValues41 = {
  narrow: ["S", "M", "Þ", "M", "F", "F", "L"],
  short: ["Su", "Má", "Þr", "Mi", "Fi", "Fö", "La"],
  abbreviated: ["sun.", "mán.", "þri.", "mið.", "fim.", "fös.", "lau."],
  wide: [
    "sunnudagur",
    "mánudagur",
    "þriðjudagur",
    "miðvikudagur",
    "fimmtudagur",
    "föstudagur",
    "laugardagur"
  ]
};
var dayPeriodValues41 = {
  narrow: {
    am: "f",
    pm: "e",
    midnight: "miðnætti",
    noon: "hádegi",
    morning: "morgunn",
    afternoon: "síðdegi",
    evening: "kvöld",
    night: "nótt"
  },
  abbreviated: {
    am: "f.h.",
    pm: "e.h.",
    midnight: "miðnætti",
    noon: "hádegi",
    morning: "morgunn",
    afternoon: "síðdegi",
    evening: "kvöld",
    night: "nótt"
  },
  wide: {
    am: "fyrir hádegi",
    pm: "eftir hádegi",
    midnight: "miðnætti",
    noon: "hádegi",
    morning: "morgunn",
    afternoon: "síðdegi",
    evening: "kvöld",
    night: "nótt"
  }
};
var formattingDayPeriodValues33 = {
  narrow: {
    am: "f",
    pm: "e",
    midnight: "á miðnætti",
    noon: "á hádegi",
    morning: "að morgni",
    afternoon: "síðdegis",
    evening: "um kvöld",
    night: "um nótt"
  },
  abbreviated: {
    am: "f.h.",
    pm: "e.h.",
    midnight: "á miðnætti",
    noon: "á hádegi",
    morning: "að morgni",
    afternoon: "síðdegis",
    evening: "um kvöld",
    night: "um nótt"
  },
  wide: {
    am: "fyrir hádegi",
    pm: "eftir hádegi",
    midnight: "á miðnætti",
    noon: "á hádegi",
    morning: "að morgni",
    afternoon: "síðdegis",
    evening: "um kvöld",
    night: "um nótt"
  }
};
var ordinalNumber41 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize41 = {
  ordinalNumber: ordinalNumber41,
  era: buildLocalizeFn({
    values: eraValues41,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues41,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues41,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues41,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues41,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues33,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/is/_lib/match.mjs
var matchOrdinalNumberPattern40 = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern40 = /\d+(\.)?/i;
var matchEraPatterns40 = {
  narrow: /^(f\.Kr\.|e\.Kr\.)/i,
  abbreviated: /^(f\.Kr\.|e\.Kr\.)/i,
  wide: /^(fyrir Krist|eftir Krist)/i
};
var parseEraPatterns40 = {
  any: [/^(f\.Kr\.)/i, /^(e\.Kr\.)/i]
};
var matchQuarterPatterns40 = {
  narrow: /^[1234]\.?/i,
  abbreviated: /^q[1234]\.?/i,
  wide: /^[1234]\.? fjórðungur/i
};
var parseQuarterPatterns40 = {
  any: [/1\.?/i, /2\.?/i, /3\.?/i, /4\.?/i]
};
var matchMonthPatterns40 = {
  narrow: /^[jfmásónd]/i,
  abbreviated: /^(jan\.|feb\.|mars\.|apríl\.|maí|júní|júlí|águst|sep\.|oct\.|nov\.|dec\.)/i,
  wide: /^(januar|febrúar|mars|apríl|maí|júní|júlí|águst|september|október|nóvember|desember)/i
};
var parseMonthPatterns40 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^á/i,
    /^s/i,
    /^ó/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maí/i,
    /^jún/i,
    /^júl/i,
    /^áu/i,
    /^s/i,
    /^ó/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns40 = {
  narrow: /^[smtwf]/i,
  short: /^(su|má|þr|mi|fi|fö|la)/i,
  abbreviated: /^(sun|mán|þri|mið|fim|fös|lau)\.?/i,
  wide: /^(sunnudagur|mánudagur|þriðjudagur|miðvikudagur|fimmtudagur|föstudagur|laugardagur)/i
};
var parseDayPatterns40 = {
  narrow: [/^s/i, /^m/i, /^þ/i, /^m/i, /^f/i, /^f/i, /^l/i],
  any: [/^su/i, /^má/i, /^þr/i, /^mi/i, /^fi/i, /^fö/i, /^la/i]
};
var matchDayPeriodPatterns40 = {
  narrow: /^(f|e|síðdegis|(á|að|um) (morgni|kvöld|nótt|miðnætti))/i,
  any: /^(fyrir hádegi|eftir hádegi|[ef]\.?h\.?|síðdegis|morgunn|(á|að|um) (morgni|kvöld|nótt|miðnætti))/i
};
var parseDayPeriodPatterns40 = {
  any: {
    am: /^f/i,
    pm: /^e/i,
    midnight: /^mi/i,
    noon: /^há/i,
    morning: /morgunn/i,
    afternoon: /síðdegi/i,
    evening: /kvöld/i,
    night: /nótt/i
  }
};
var match40 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern40,
    parsePattern: parseOrdinalNumberPattern40,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns40,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns40,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns40,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns40,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns40,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns40,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns40,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns40,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns40,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns40,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/is.mjs
var is = {
  code: "is",
  formatDistance: formatDistance42,
  formatLong: formatLong48,
  formatRelative: formatRelative41,
  localize: localize41,
  match: match40,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/it/_lib/formatDistance.mjs
var formatDistanceLocale41 = {
  lessThanXSeconds: {
    one: "meno di un secondo",
    other: "meno di {{count}} secondi"
  },
  xSeconds: {
    one: "un secondo",
    other: "{{count}} secondi"
  },
  halfAMinute: "alcuni secondi",
  lessThanXMinutes: {
    one: "meno di un minuto",
    other: "meno di {{count}} minuti"
  },
  xMinutes: {
    one: "un minuto",
    other: "{{count}} minuti"
  },
  aboutXHours: {
    one: "circa un'ora",
    other: "circa {{count}} ore"
  },
  xHours: {
    one: "un'ora",
    other: "{{count}} ore"
  },
  xDays: {
    one: "un giorno",
    other: "{{count}} giorni"
  },
  aboutXWeeks: {
    one: "circa una settimana",
    other: "circa {{count}} settimane"
  },
  xWeeks: {
    one: "una settimana",
    other: "{{count}} settimane"
  },
  aboutXMonths: {
    one: "circa un mese",
    other: "circa {{count}} mesi"
  },
  xMonths: {
    one: "un mese",
    other: "{{count}} mesi"
  },
  aboutXYears: {
    one: "circa un anno",
    other: "circa {{count}} anni"
  },
  xYears: {
    one: "un anno",
    other: "{{count}} anni"
  },
  overXYears: {
    one: "più di un anno",
    other: "più di {{count}} anni"
  },
  almostXYears: {
    one: "quasi un anno",
    other: "quasi {{count}} anni"
  }
};
var formatDistance43 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale41[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "tra " + result;
    } else {
      return result + " fa";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/it/_lib/formatLong.mjs
var dateFormats49 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats49 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats49 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong49 = {
  date: buildFormatLongFn({
    formats: dateFormats49,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats49,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats49,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/it/_lib/formatRelative.mjs
var weekdays2 = [
  "domenica",
  "lunedì",
  "martedì",
  "mercoledì",
  "giovedì",
  "venerdì",
  "sabato"
];
function lastWeek4(day) {
  switch (day) {
    case 0:
      return "'domenica scorsa alle' p";
    default:
      return "'" + weekdays2[day] + " scorso alle' p";
  }
}
function thisWeek4(day) {
  return "'" + weekdays2[day] + " alle' p";
}
function nextWeek4(day) {
  switch (day) {
    case 0:
      return "'domenica prossima alle' p";
    default:
      return "'" + weekdays2[day] + " prossimo alle' p";
  }
}
var formatRelativeLocale42 = {
  lastWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek4(day);
    } else {
      return lastWeek4(day);
    }
  },
  yesterday: "'ieri alle' p",
  today: "'oggi alle' p",
  tomorrow: "'domani alle' p",
  nextWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek4(day);
    } else {
      return nextWeek4(day);
    }
  },
  other: "P"
};
var formatRelative42 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale42[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/it/_lib/localize.mjs
var eraValues42 = {
  narrow: ["aC", "dC"],
  abbreviated: ["a.C.", "d.C."],
  wide: ["avanti Cristo", "dopo Cristo"]
};
var quarterValues42 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
};
var monthValues42 = {
  narrow: ["G", "F", "M", "A", "M", "G", "L", "A", "S", "O", "N", "D"],
  abbreviated: [
    "gen",
    "feb",
    "mar",
    "apr",
    "mag",
    "giu",
    "lug",
    "ago",
    "set",
    "ott",
    "nov",
    "dic"
  ],
  wide: [
    "gennaio",
    "febbraio",
    "marzo",
    "aprile",
    "maggio",
    "giugno",
    "luglio",
    "agosto",
    "settembre",
    "ottobre",
    "novembre",
    "dicembre"
  ]
};
var dayValues42 = {
  narrow: ["D", "L", "M", "M", "G", "V", "S"],
  short: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
  abbreviated: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
  wide: [
    "domenica",
    "lunedì",
    "martedì",
    "mercoledì",
    "giovedì",
    "venerdì",
    "sabato"
  ]
};
var dayPeriodValues42 = {
  narrow: {
    am: "m.",
    pm: "p.",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "mattina",
    afternoon: "pomeriggio",
    evening: "sera",
    night: "notte"
  }
};
var formattingDayPeriodValues34 = {
  narrow: {
    am: "m.",
    pm: "p.",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "mezzanotte",
    noon: "mezzogiorno",
    morning: "di mattina",
    afternoon: "del pomeriggio",
    evening: "di sera",
    night: "di notte"
  }
};
var ordinalNumber42 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return String(number2);
};
var localize42 = {
  ordinalNumber: ordinalNumber42,
  era: buildLocalizeFn({
    values: eraValues42,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues42,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues42,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues42,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues42,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues34,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/it/_lib/match.mjs
var matchOrdinalNumberPattern41 = /^(\d+)(º)?/i;
var parseOrdinalNumberPattern41 = /\d+/i;
var matchEraPatterns41 = {
  narrow: /^(aC|dC)/i,
  abbreviated: /^(a\.?\s?C\.?|a\.?\s?e\.?\s?v\.?|d\.?\s?C\.?|e\.?\s?v\.?)/i,
  wide: /^(avanti Cristo|avanti Era Volgare|dopo Cristo|Era Volgare)/i
};
var parseEraPatterns41 = {
  any: [/^a/i, /^(d|e)/i]
};
var matchQuarterPatterns41 = {
  narrow: /^[1234]/i,
  abbreviated: /^t[1234]/i,
  wide: /^[1234](º)? trimestre/i
};
var parseQuarterPatterns41 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns41 = {
  narrow: /^[gfmalsond]/i,
  abbreviated: /^(gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)/i,
  wide: /^(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)/i
};
var parseMonthPatterns41 = {
  narrow: [
    /^g/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^g/i,
    /^l/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ge/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mag/i,
    /^gi/i,
    /^l/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns41 = {
  narrow: /^[dlmgvs]/i,
  short: /^(do|lu|ma|me|gi|ve|sa)/i,
  abbreviated: /^(dom|lun|mar|mer|gio|ven|sab)/i,
  wide: /^(domenica|luned[i|ì]|marted[i|ì]|mercoled[i|ì]|gioved[i|ì]|venerd[i|ì]|sabato)/i
};
var parseDayPatterns41 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^g/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^g/i, /^v/i, /^s/i]
};
var matchDayPeriodPatterns41 = {
  narrow: /^(a|m\.|p|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
  any: /^([ap]\.?\s?m\.?|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i
};
var parseDayPeriodPatterns41 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mezza/i,
    noon: /^mezzo/i,
    morning: /mattina/i,
    afternoon: /pomeriggio/i,
    evening: /sera/i,
    night: /notte/i
  }
};
var match41 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern41,
    parsePattern: parseOrdinalNumberPattern41,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns41,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns41,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns41,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns41,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns41,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns41,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns41,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns41,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns41,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns41,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/it.mjs
var it = {
  code: "it",
  formatDistance: formatDistance43,
  formatLong: formatLong49,
  formatRelative: formatRelative42,
  localize: localize42,
  match: match41,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/it-CH/_lib/formatLong.mjs
var dateFormats50 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y"
};
var timeFormats50 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats50 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong50 = {
  date: buildFormatLongFn({
    formats: dateFormats50,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats50,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats50,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/it-CH.mjs
var itCH = {
  code: "it-CH",
  formatDistance: formatDistance43,
  formatLong: formatLong50,
  formatRelative: formatRelative42,
  localize: localize42,
  match: match41,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/ja/_lib/formatDistance.mjs
var formatDistanceLocale42 = {
  lessThanXSeconds: {
    one: "1秒未満",
    other: "{{count}}秒未満",
    oneWithSuffix: "約1秒",
    otherWithSuffix: "約{{count}}秒"
  },
  xSeconds: {
    one: "1秒",
    other: "{{count}}秒"
  },
  halfAMinute: "30秒",
  lessThanXMinutes: {
    one: "1分未満",
    other: "{{count}}分未満",
    oneWithSuffix: "約1分",
    otherWithSuffix: "約{{count}}分"
  },
  xMinutes: {
    one: "1分",
    other: "{{count}}分"
  },
  aboutXHours: {
    one: "約1時間",
    other: "約{{count}}時間"
  },
  xHours: {
    one: "1時間",
    other: "{{count}}時間"
  },
  xDays: {
    one: "1日",
    other: "{{count}}日"
  },
  aboutXWeeks: {
    one: "約1週間",
    other: "約{{count}}週間"
  },
  xWeeks: {
    one: "1週間",
    other: "{{count}}週間"
  },
  aboutXMonths: {
    one: "約1か月",
    other: "約{{count}}か月"
  },
  xMonths: {
    one: "1か月",
    other: "{{count}}か月"
  },
  aboutXYears: {
    one: "約1年",
    other: "約{{count}}年"
  },
  xYears: {
    one: "1年",
    other: "{{count}}年"
  },
  overXYears: {
    one: "1年以上",
    other: "{{count}}年以上"
  },
  almostXYears: {
    one: "1年近く",
    other: "{{count}}年近く"
  }
};
var formatDistance44 = (token, count, options2) => {
  options2 = options2 || {};
  let result;
  const tokenValue = formatDistanceLocale42[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options2.addSuffix && tokenValue.oneWithSuffix) {
      result = tokenValue.oneWithSuffix;
    } else {
      result = tokenValue.one;
    }
  } else {
    if (options2.addSuffix && tokenValue.otherWithSuffix) {
      result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
    } else {
      result = tokenValue.other.replace("{{count}}", String(count));
    }
  }
  if (options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "後";
    } else {
      return result + "前";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ja/_lib/formatLong.mjs
var dateFormats51 = {
  full: "y年M月d日EEEE",
  long: "y年M月d日",
  medium: "y/MM/dd",
  short: "y/MM/dd"
};
var timeFormats51 = {
  full: "H時mm分ss秒 zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats51 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong51 = {
  date: buildFormatLongFn({
    formats: dateFormats51,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats51,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats51,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ja/_lib/formatRelative.mjs
var formatRelativeLocale43 = {
  lastWeek: "先週のeeeeのp",
  yesterday: "昨日のp",
  today: "今日のp",
  tomorrow: "明日のp",
  nextWeek: "翌週のeeeeのp",
  other: "P"
};
var formatRelative43 = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale43[token];
};

// ../../../node_modules/date-fns/locale/ja/_lib/localize.mjs
var eraValues43 = {
  narrow: ["BC", "AC"],
  abbreviated: ["紀元前", "西暦"],
  wide: ["紀元前", "西暦"]
};
var quarterValues43 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["第1四半期", "第2四半期", "第3四半期", "第4四半期"]
};
var monthValues43 = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "1月",
    "2月",
    "3月",
    "4月",
    "5月",
    "6月",
    "7月",
    "8月",
    "9月",
    "10月",
    "11月",
    "12月"
  ],
  wide: [
    "1月",
    "2月",
    "3月",
    "4月",
    "5月",
    "6月",
    "7月",
    "8月",
    "9月",
    "10月",
    "11月",
    "12月"
  ]
};
var dayValues43 = {
  narrow: ["日", "月", "火", "水", "木", "金", "土"],
  short: ["日", "月", "火", "水", "木", "金", "土"],
  abbreviated: ["日", "月", "火", "水", "木", "金", "土"],
  wide: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"]
};
var dayPeriodValues43 = {
  narrow: {
    am: "午前",
    pm: "午後",
    midnight: "深夜",
    noon: "正午",
    morning: "朝",
    afternoon: "午後",
    evening: "夜",
    night: "深夜"
  },
  abbreviated: {
    am: "午前",
    pm: "午後",
    midnight: "深夜",
    noon: "正午",
    morning: "朝",
    afternoon: "午後",
    evening: "夜",
    night: "深夜"
  },
  wide: {
    am: "午前",
    pm: "午後",
    midnight: "深夜",
    noon: "正午",
    morning: "朝",
    afternoon: "午後",
    evening: "夜",
    night: "深夜"
  }
};
var formattingDayPeriodValues35 = {
  narrow: {
    am: "午前",
    pm: "午後",
    midnight: "深夜",
    noon: "正午",
    morning: "朝",
    afternoon: "午後",
    evening: "夜",
    night: "深夜"
  },
  abbreviated: {
    am: "午前",
    pm: "午後",
    midnight: "深夜",
    noon: "正午",
    morning: "朝",
    afternoon: "午後",
    evening: "夜",
    night: "深夜"
  },
  wide: {
    am: "午前",
    pm: "午後",
    midnight: "深夜",
    noon: "正午",
    morning: "朝",
    afternoon: "午後",
    evening: "夜",
    night: "深夜"
  }
};
var ordinalNumber43 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = String(options2 == null ? void 0 : options2.unit);
  switch (unit) {
    case "year":
      return `${number2}年`;
    case "quarter":
      return `第${number2}四半期`;
    case "month":
      return `${number2}月`;
    case "week":
      return `第${number2}週`;
    case "date":
      return `${number2}日`;
    case "hour":
      return `${number2}時`;
    case "minute":
      return `${number2}分`;
    case "second":
      return `${number2}秒`;
    default:
      return `${number2}`;
  }
};
var localize43 = {
  ordinalNumber: ordinalNumber43,
  era: buildLocalizeFn({
    values: eraValues43,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues43,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues43,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues43,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues43,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues35,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ja/_lib/match.mjs
var matchOrdinalNumberPattern42 = /^第?\d+(年|四半期|月|週|日|時|分|秒)?/i;
var parseOrdinalNumberPattern42 = /\d+/i;
var matchEraPatterns42 = {
  narrow: /^(B\.?C\.?|A\.?D\.?)/i,
  abbreviated: /^(紀元[前後]|西暦)/i,
  wide: /^(紀元[前後]|西暦)/i
};
var parseEraPatterns42 = {
  narrow: [/^B/i, /^A/i],
  any: [/^(紀元前)/i, /^(西暦|紀元後)/i]
};
var matchQuarterPatterns42 = {
  narrow: /^[1234]/i,
  abbreviated: /^Q[1234]/i,
  wide: /^第[1234一二三四１２３４]四半期/i
};
var parseQuarterPatterns42 = {
  any: [/(1|一|１)/i, /(2|二|２)/i, /(3|三|３)/i, /(4|四|４)/i]
};
var matchMonthPatterns42 = {
  narrow: /^([123456789]|1[012])/,
  abbreviated: /^([123456789]|1[012])月/i,
  wide: /^([123456789]|1[012])月/i
};
var parseMonthPatterns42 = {
  any: [
    /^1\D/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/
  ]
};
var matchDayPatterns42 = {
  narrow: /^[日月火水木金土]/,
  short: /^[日月火水木金土]/,
  abbreviated: /^[日月火水木金土]/,
  wide: /^[日月火水木金土]曜日/
};
var parseDayPatterns42 = {
  any: [/^日/, /^月/, /^火/, /^水/, /^木/, /^金/, /^土/]
};
var matchDayPeriodPatterns42 = {
  any: /^(AM|PM|午前|午後|正午|深夜|真夜中|夜|朝)/i
};
var parseDayPeriodPatterns42 = {
  any: {
    am: /^(A|午前)/i,
    pm: /^(P|午後)/i,
    midnight: /^深夜|真夜中/i,
    noon: /^正午/i,
    morning: /^朝/i,
    afternoon: /^午後/i,
    evening: /^夜/i,
    night: /^深夜/i
  }
};
var match42 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern42,
    parsePattern: parseOrdinalNumberPattern42,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns42,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns42,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns42,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns42,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns42,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns42,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns42,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns42,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns42,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns42,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ja.mjs
var ja = {
  code: "ja",
  formatDistance: formatDistance44,
  formatLong: formatLong51,
  formatRelative: formatRelative43,
  localize: localize43,
  match: match42,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ja-Hira/_lib/formatDistance.mjs
var formatDistanceLocale43 = {
  lessThanXSeconds: {
    one: "1びょうみまん",
    other: "{{count}}びょうみまん",
    oneWithSuffix: "やく1びょう",
    otherWithSuffix: "やく{{count}}びょう"
  },
  xSeconds: {
    one: "1びょう",
    other: "{{count}}びょう"
  },
  halfAMinute: "30びょう",
  lessThanXMinutes: {
    one: "1ぷんみまん",
    other: "{{count}}ふんみまん",
    oneWithSuffix: "やく1ぷん",
    otherWithSuffix: "やく{{count}}ふん"
  },
  xMinutes: {
    one: "1ぷん",
    other: "{{count}}ふん"
  },
  aboutXHours: {
    one: "やく1じかん",
    other: "やく{{count}}じかん"
  },
  xHours: {
    one: "1じかん",
    other: "{{count}}じかん"
  },
  xDays: {
    one: "1にち",
    other: "{{count}}にち"
  },
  aboutXWeeks: {
    one: "やく1しゅうかん",
    other: "やく{{count}}しゅうかん"
  },
  xWeeks: {
    one: "1しゅうかん",
    other: "{{count}}しゅうかん"
  },
  aboutXMonths: {
    one: "やく1かげつ",
    other: "やく{{count}}かげつ"
  },
  xMonths: {
    one: "1かげつ",
    other: "{{count}}かげつ"
  },
  aboutXYears: {
    one: "やく1ねん",
    other: "やく{{count}}ねん"
  },
  xYears: {
    one: "1ねん",
    other: "{{count}}ねん"
  },
  overXYears: {
    one: "1ねんいじょう",
    other: "{{count}}ねんいじょう"
  },
  almostXYears: {
    one: "1ねんちかく",
    other: "{{count}}ねんちかく"
  }
};
var formatDistance45 = (token, count, options2) => {
  options2 = options2 || {};
  let result;
  const tokenValue = formatDistanceLocale43[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options2.addSuffix && tokenValue.oneWithSuffix) {
      result = tokenValue.oneWithSuffix;
    } else {
      result = tokenValue.one;
    }
  } else {
    if (options2.addSuffix && tokenValue.otherWithSuffix) {
      result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
    } else {
      result = tokenValue.other.replace("{{count}}", String(count));
    }
  }
  if (options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "あと";
    } else {
      return result + "まえ";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ja-Hira/_lib/formatLong.mjs
var dateFormats52 = {
  full: "yねんMがつdにちEEEE",
  long: "yねんMがつdにち",
  medium: "y/MM/dd",
  short: "y/MM/dd"
};
var timeFormats52 = {
  full: "Hじmmふんssびょう zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats52 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong52 = {
  date: buildFormatLongFn({
    formats: dateFormats52,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats52,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats52,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ja-Hira/_lib/formatRelative.mjs
var formatRelativeLocale44 = {
  lastWeek: "せんしゅうのeeeeのp",
  yesterday: "きのうのp",
  today: "きょうのp",
  tomorrow: "あしたのp",
  nextWeek: "よくしゅうのeeeeのp",
  other: "P"
};
var formatRelative44 = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale44[token];
};

// ../../../node_modules/date-fns/locale/ja-Hira/_lib/localize.mjs
var eraValues44 = {
  narrow: ["BC", "AC"],
  abbreviated: ["きげんぜん", "せいれき"],
  wide: ["きげんぜん", "せいれき"]
};
var quarterValues44 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["だい1しはんき", "だい2しはんき", "だい3しはんき", "だい4しはんき"]
};
var monthValues44 = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "1がつ",
    "2がつ",
    "3がつ",
    "4がつ",
    "5がつ",
    "6がつ",
    "7がつ",
    "8がつ",
    "9がつ",
    "10がつ",
    "11がつ",
    "12がつ"
  ],
  wide: [
    "1がつ",
    "2がつ",
    "3がつ",
    "4がつ",
    "5がつ",
    "6がつ",
    "7がつ",
    "8がつ",
    "9がつ",
    "10がつ",
    "11がつ",
    "12がつ"
  ]
};
var dayValues44 = {
  narrow: ["にち", "げつ", "か", "すい", "もく", "きん", "ど"],
  short: ["にち", "げつ", "か", "すい", "もく", "きん", "ど"],
  abbreviated: ["にち", "げつ", "か", "すい", "もく", "きん", "ど"],
  wide: [
    "にちようび",
    "げつようび",
    "かようび",
    "すいようび",
    "もくようび",
    "きんようび",
    "どようび"
  ]
};
var dayPeriodValues44 = {
  narrow: {
    am: "ごぜん",
    pm: "ごご",
    midnight: "しんや",
    noon: "しょうご",
    morning: "あさ",
    afternoon: "ごご",
    evening: "よる",
    night: "しんや"
  },
  abbreviated: {
    am: "ごぜん",
    pm: "ごご",
    midnight: "しんや",
    noon: "しょうご",
    morning: "あさ",
    afternoon: "ごご",
    evening: "よる",
    night: "しんや"
  },
  wide: {
    am: "ごぜん",
    pm: "ごご",
    midnight: "しんや",
    noon: "しょうご",
    morning: "あさ",
    afternoon: "ごご",
    evening: "よる",
    night: "しんや"
  }
};
var formattingDayPeriodValues36 = {
  narrow: {
    am: "ごぜん",
    pm: "ごご",
    midnight: "しんや",
    noon: "しょうご",
    morning: "あさ",
    afternoon: "ごご",
    evening: "よる",
    night: "しんや"
  },
  abbreviated: {
    am: "ごぜん",
    pm: "ごご",
    midnight: "しんや",
    noon: "しょうご",
    morning: "あさ",
    afternoon: "ごご",
    evening: "よる",
    night: "しんや"
  },
  wide: {
    am: "ごぜん",
    pm: "ごご",
    midnight: "しんや",
    noon: "しょうご",
    morning: "あさ",
    afternoon: "ごご",
    evening: "よる",
    night: "しんや"
  }
};
var ordinalNumber44 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = String(options2 == null ? void 0 : options2.unit);
  switch (unit) {
    case "year":
      return `${number2}ねん`;
    case "quarter":
      return `だい${number2}しはんき`;
    case "month":
      return `${number2}がつ`;
    case "week":
      return `だい${number2}しゅう`;
    case "date":
      return `${number2}にち`;
    case "hour":
      return `${number2}じ`;
    case "minute":
      return `${number2}ふん`;
    case "second":
      return `${number2}びょう`;
    default:
      return `${number2}`;
  }
};
var localize44 = {
  ordinalNumber: ordinalNumber44,
  era: buildLocalizeFn({
    values: eraValues44,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues44,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues44,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues44,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues44,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues36,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ja-Hira/_lib/match.mjs
var matchOrdinalNumberPattern43 = /^だ?い?\d+(ねん|しはんき|がつ|しゅう|にち|じ|ふん|びょう)?/i;
var parseOrdinalNumberPattern43 = /\d+/i;
var matchEraPatterns43 = {
  narrow: /^(B\.?C\.?|A\.?D\.?)/i,
  abbreviated: /^(きげん[前後]|せいれき)/i,
  wide: /^(きげん[前後]|せいれき)/i
};
var parseEraPatterns43 = {
  narrow: [/^B/i, /^A/i],
  any: [/^(きげんぜん)/i, /^(せいれき|きげんご)/i]
};
var matchQuarterPatterns43 = {
  narrow: /^[1234]/i,
  abbreviated: /^Q[1234]/i,
  wide: /^だい[1234一二三四１２３４]しはんき/i
};
var parseQuarterPatterns43 = {
  any: [/(1|一|１)/i, /(2|二|２)/i, /(3|三|３)/i, /(4|四|４)/i]
};
var matchMonthPatterns43 = {
  narrow: /^([123456789]|1[012])/,
  abbreviated: /^([123456789]|1[012])がつ/i,
  wide: /^([123456789]|1[012])がつ/i
};
var parseMonthPatterns43 = {
  any: [
    /^1\D/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/
  ]
};
var matchDayPatterns43 = {
  narrow: /^(にち|げつ|か|すい|もく|きん|ど)/,
  short: /^(にち|げつ|か|すい|もく|きん|ど)/,
  abbreviated: /^(にち|げつ|か|すい|もく|きん|ど)/,
  wide: /^(にち|げつ|か|すい|もく|きん|ど)ようび/
};
var parseDayPatterns43 = {
  any: [/^にち/, /^げつ/, /^か/, /^すい/, /^もく/, /^きん/, /^ど/]
};
var matchDayPeriodPatterns43 = {
  any: /^(AM|PM|ごぜん|ごご|しょうご|しんや|まよなか|よる|あさ)/i
};
var parseDayPeriodPatterns43 = {
  any: {
    am: /^(A|ごぜん)/i,
    pm: /^(P|ごご)/i,
    midnight: /^しんや|まよなか/i,
    noon: /^しょうご/i,
    morning: /^あさ/i,
    afternoon: /^ごご/i,
    evening: /^よる/i,
    night: /^しんや/i
  }
};
var match43 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern43,
    parsePattern: parseOrdinalNumberPattern43,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns43,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns43,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns43,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns43,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns43,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns43,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns43,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns43,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns43,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns43,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ja-Hira.mjs
var jaHira = {
  code: "ja-Hira",
  formatDistance: formatDistance45,
  formatLong: formatLong52,
  formatRelative: formatRelative44,
  localize: localize44,
  match: match43,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ka/_lib/formatDistance.mjs
var formatDistanceLocale44 = {
  lessThanXSeconds: {
    past: "{{count}} წამზე ნაკლები ხნის წინ",
    present: "{{count}} წამზე ნაკლები",
    future: "{{count}} წამზე ნაკლებში"
  },
  xSeconds: {
    past: "{{count}} წამის წინ",
    present: "{{count}} წამი",
    future: "{{count}} წამში"
  },
  halfAMinute: {
    past: "ნახევარი წუთის წინ",
    present: "ნახევარი წუთი",
    future: "ნახევარი წუთში"
  },
  lessThanXMinutes: {
    past: "{{count}} წუთზე ნაკლები ხნის წინ",
    present: "{{count}} წუთზე ნაკლები",
    future: "{{count}} წუთზე ნაკლებში"
  },
  xMinutes: {
    past: "{{count}} წუთის წინ",
    present: "{{count}} წუთი",
    future: "{{count}} წუთში"
  },
  aboutXHours: {
    past: "დაახლოებით {{count}} საათის წინ",
    present: "დაახლოებით {{count}} საათი",
    future: "დაახლოებით {{count}} საათში"
  },
  xHours: {
    past: "{{count}} საათის წინ",
    present: "{{count}} საათი",
    future: "{{count}} საათში"
  },
  xDays: {
    past: "{{count}} დღის წინ",
    present: "{{count}} დღე",
    future: "{{count}} დღეში"
  },
  aboutXWeeks: {
    past: "დაახლოებით {{count}} კვირას წინ",
    present: "დაახლოებით {{count}} კვირა",
    future: "დაახლოებით {{count}} კვირაში"
  },
  xWeeks: {
    past: "{{count}} კვირას კვირა",
    present: "{{count}} კვირა",
    future: "{{count}} კვირაში"
  },
  aboutXMonths: {
    past: "დაახლოებით {{count}} თვის წინ",
    present: "დაახლოებით {{count}} თვე",
    future: "დაახლოებით {{count}} თვეში"
  },
  xMonths: {
    past: "{{count}} თვის წინ",
    present: "{{count}} თვე",
    future: "{{count}} თვეში"
  },
  aboutXYears: {
    past: "დაახლოებით {{count}} წლის წინ",
    present: "დაახლოებით {{count}} წელი",
    future: "დაახლოებით {{count}} წელში"
  },
  xYears: {
    past: "{{count}} წლის წინ",
    present: "{{count}} წელი",
    future: "{{count}} წელში"
  },
  overXYears: {
    past: "{{count}} წელზე მეტი ხნის წინ",
    present: "{{count}} წელზე მეტი",
    future: "{{count}} წელზე მეტი ხნის შემდეგ"
  },
  almostXYears: {
    past: "თითქმის {{count}} წლის წინ",
    present: "თითქმის {{count}} წელი",
    future: "თითქმის {{count}} წელში"
  }
};
var formatDistance46 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale44[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if ((options2 == null ? void 0 : options2.addSuffix) && options2.comparison && options2.comparison > 0) {
    result = tokenValue.future.replace("{{count}}", String(count));
  } else if (options2 == null ? void 0 : options2.addSuffix) {
    result = tokenValue.past.replace("{{count}}", String(count));
  } else {
    result = tokenValue.present.replace("{{count}}", String(count));
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ka/_lib/formatLong.mjs
var dateFormats53 = {
  full: "EEEE, do MMMM, y",
  long: "do, MMMM, y",
  medium: "d, MMM, y",
  short: "dd/MM/yyyy"
};
var timeFormats53 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats53 = {
  full: "{{date}} {{time}}'-ზე'",
  long: "{{date}} {{time}}'-ზე'",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong53 = {
  date: buildFormatLongFn({
    formats: dateFormats53,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats53,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats53,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ka/_lib/formatRelative.mjs
var formatRelativeLocale45 = {
  lastWeek: "'წინა' eeee p'-ზე'",
  yesterday: "'გუშინ' p'-ზე'",
  today: "'დღეს' p'-ზე'",
  tomorrow: "'ხვალ' p'-ზე'",
  nextWeek: "'შემდეგი' eeee p'-ზე'",
  other: "P"
};
var formatRelative45 = (token, _date, _baseDate, _options) => formatRelativeLocale45[token];

// ../../../node_modules/date-fns/locale/ka/_lib/localize.mjs
var eraValues45 = {
  narrow: ["ჩ.წ-მდე", "ჩ.წ"],
  abbreviated: ["ჩვ.წ-მდე", "ჩვ.წ"],
  wide: ["ჩვენს წელთაღრიცხვამდე", "ჩვენი წელთაღრიცხვით"]
};
var quarterValues45 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-ლი კვ", "2-ე კვ", "3-ე კვ", "4-ე კვ"],
  wide: ["1-ლი კვარტალი", "2-ე კვარტალი", "3-ე კვარტალი", "4-ე კვარტალი"]
};
var monthValues45 = {
  narrow: [
    "ია",
    "თე",
    "მა",
    "აპ",
    "მს",
    "ვნ",
    "ვლ",
    "აგ",
    "სე",
    "ოქ",
    "ნო",
    "დე"
  ],
  abbreviated: [
    "იან",
    "თებ",
    "მარ",
    "აპრ",
    "მაი",
    "ივნ",
    "ივლ",
    "აგვ",
    "სექ",
    "ოქტ",
    "ნოე",
    "დეკ"
  ],
  wide: [
    "იანვარი",
    "თებერვალი",
    "მარტი",
    "აპრილი",
    "მაისი",
    "ივნისი",
    "ივლისი",
    "აგვისტო",
    "სექტემბერი",
    "ოქტომბერი",
    "ნოემბერი",
    "დეკემბერი"
  ]
};
var dayValues45 = {
  narrow: ["კვ", "ორ", "სა", "ოთ", "ხუ", "პა", "შა"],
  short: ["კვი", "ორშ", "სამ", "ოთხ", "ხუთ", "პარ", "შაბ"],
  abbreviated: ["კვი", "ორშ", "სამ", "ოთხ", "ხუთ", "პარ", "შაბ"],
  wide: [
    "კვირა",
    "ორშაბათი",
    "სამშაბათი",
    "ოთხშაბათი",
    "ხუთშაბათი",
    "პარასკევი",
    "შაბათი"
  ]
};
var dayPeriodValues45 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "შუაღამე",
    noon: "შუადღე",
    morning: "დილა",
    afternoon: "საღამო",
    evening: "საღამო",
    night: "ღამე"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "შუაღამე",
    noon: "შუადღე",
    morning: "დილა",
    afternoon: "საღამო",
    evening: "საღამო",
    night: "ღამე"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "შუაღამე",
    noon: "შუადღე",
    morning: "დილა",
    afternoon: "საღამო",
    evening: "საღამო",
    night: "ღამე"
  }
};
var formattingDayPeriodValues37 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "შუაღამით",
    noon: "შუადღისას",
    morning: "დილით",
    afternoon: "ნაშუადღევს",
    evening: "საღამოს",
    night: "ღამით"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "შუაღამით",
    noon: "შუადღისას",
    morning: "დილით",
    afternoon: "ნაშუადღევს",
    evening: "საღამოს",
    night: "ღამით"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "შუაღამით",
    noon: "შუადღისას",
    morning: "დილით",
    afternoon: "ნაშუადღევს",
    evening: "საღამოს",
    night: "ღამით"
  }
};
var ordinalNumber45 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  if (number2 === 1) {
    return number2 + "-ლი";
  }
  return number2 + "-ე";
};
var localize45 = {
  ordinalNumber: ordinalNumber45,
  era: buildLocalizeFn({
    values: eraValues45,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues45,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues45,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues45,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues45,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues37,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ka/_lib/match.mjs
var matchOrdinalNumberPattern44 = /^(\d+)(-ლი|-ე)?/i;
var parseOrdinalNumberPattern44 = /\d+/i;
var matchEraPatterns44 = {
  narrow: /^(ჩვ?\.წ)/i,
  abbreviated: /^(ჩვ?\.წ)/i,
  wide: /^(ჩვენს წელთაღრიცხვამდე|ქრისტეშობამდე|ჩვენი წელთაღრიცხვით|ქრისტეშობიდან)/i
};
var parseEraPatterns44 = {
  any: [
    /^(ჩვენს წელთაღრიცხვამდე|ქრისტეშობამდე)/i,
    /^(ჩვენი წელთაღრიცხვით|ქრისტეშობიდან)/i
  ]
};
var matchQuarterPatterns44 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]-(ლი|ე)? კვ/i,
  wide: /^[1234]-(ლი|ე)? კვარტალი/i
};
var parseQuarterPatterns44 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns44 = {
  any: /^(ია|თე|მა|აპ|მს|ვნ|ვლ|აგ|სე|ოქ|ნო|დე)/i
};
var parseMonthPatterns44 = {
  any: [
    /^ია/i,
    /^თ/i,
    /^მარ/i,
    /^აპ/i,
    /^მაი/i,
    /^ი?ვნ/i,
    /^ი?ვლ/i,
    /^აგ/i,
    /^ს/i,
    /^ო/i,
    /^ნ/i,
    /^დ/i
  ]
};
var matchDayPatterns44 = {
  narrow: /^(კვ|ორ|სა|ოთ|ხუ|პა|შა)/i,
  short: /^(კვი|ორშ|სამ|ოთხ|ხუთ|პარ|შაბ)/i,
  wide: /^(კვირა|ორშაბათი|სამშაბათი|ოთხშაბათი|ხუთშაბათი|პარასკევი|შაბათი)/i
};
var parseDayPatterns44 = {
  any: [/^კვ/i, /^ორ/i, /^სა/i, /^ოთ/i, /^ხუ/i, /^პა/i, /^შა/i]
};
var matchDayPeriodPatterns44 = {
  any: /^([ap]\.?\s?m\.?|შუაღ|დილ)/i
};
var parseDayPeriodPatterns44 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^შუაღ/i,
    noon: /^შუადღ/i,
    morning: /^დილ/i,
    afternoon: /ნაშუადღევს/i,
    evening: /საღამო/i,
    night: /ღამ/i
  }
};
var match44 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern44,
    parsePattern: parseOrdinalNumberPattern44,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns44,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns44,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns44,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns44,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns44,
    defaultMatchWidth: "any",
    parsePatterns: parseMonthPatterns44,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns44,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns44,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns44,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns44,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ka.mjs
var ka = {
  code: "ka",
  formatDistance: formatDistance46,
  formatLong: formatLong53,
  formatRelative: formatRelative45,
  localize: localize45,
  match: match44,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/kk/_lib/formatDistance.mjs
var formatDistanceLocale45 = {
  lessThanXSeconds: {
    regular: {
      one: "1 секундтан аз",
      singularNominative: "{{count}} секундтан аз",
      singularGenitive: "{{count}} секундтан аз",
      pluralGenitive: "{{count}} секундтан аз"
    },
    future: {
      one: "бір секундтан кейін",
      singularNominative: "{{count}} секундтан кейін",
      singularGenitive: "{{count}} секундтан кейін",
      pluralGenitive: "{{count}} секундтан кейін"
    }
  },
  xSeconds: {
    regular: {
      singularNominative: "{{count}} секунд",
      singularGenitive: "{{count}} секунд",
      pluralGenitive: "{{count}} секунд"
    },
    past: {
      singularNominative: "{{count}} секунд бұрын",
      singularGenitive: "{{count}} секунд бұрын",
      pluralGenitive: "{{count}} секунд бұрын"
    },
    future: {
      singularNominative: "{{count}} секундтан кейін",
      singularGenitive: "{{count}} секундтан кейін",
      pluralGenitive: "{{count}} секундтан кейін"
    }
  },
  halfAMinute: (options2) => {
    if (options2 == null ? void 0 : options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        return "жарты минут ішінде";
      } else {
        return "жарты минут бұрын";
      }
    }
    return "жарты минут";
  },
  lessThanXMinutes: {
    regular: {
      one: "1 минуттан аз",
      singularNominative: "{{count}} минуттан аз",
      singularGenitive: "{{count}} минуттан аз",
      pluralGenitive: "{{count}} минуттан аз"
    },
    future: {
      one: "минуттан кем ",
      singularNominative: "{{count}} минуттан кем",
      singularGenitive: "{{count}} минуттан кем",
      pluralGenitive: "{{count}} минуттан кем"
    }
  },
  xMinutes: {
    regular: {
      singularNominative: "{{count}} минут",
      singularGenitive: "{{count}} минут",
      pluralGenitive: "{{count}} минут"
    },
    past: {
      singularNominative: "{{count}} минут бұрын",
      singularGenitive: "{{count}} минут бұрын",
      pluralGenitive: "{{count}} минут бұрын"
    },
    future: {
      singularNominative: "{{count}} минуттан кейін",
      singularGenitive: "{{count}} минуттан кейін",
      pluralGenitive: "{{count}} минуттан кейін"
    }
  },
  aboutXHours: {
    regular: {
      singularNominative: "шамамен {{count}} сағат",
      singularGenitive: "шамамен {{count}} сағат",
      pluralGenitive: "шамамен {{count}} сағат"
    },
    future: {
      singularNominative: "шамамен {{count}} сағаттан кейін",
      singularGenitive: "шамамен {{count}} сағаттан кейін",
      pluralGenitive: "шамамен {{count}} сағаттан кейін"
    }
  },
  xHours: {
    regular: {
      singularNominative: "{{count}} сағат",
      singularGenitive: "{{count}} сағат",
      pluralGenitive: "{{count}} сағат"
    }
  },
  xDays: {
    regular: {
      singularNominative: "{{count}} күн",
      singularGenitive: "{{count}} күн",
      pluralGenitive: "{{count}} күн"
    },
    future: {
      singularNominative: "{{count}} күннен кейін",
      singularGenitive: "{{count}} күннен кейін",
      pluralGenitive: "{{count}} күннен кейін"
    }
  },
  aboutXWeeks: {
    type: "weeks",
    one: "шамамен 1 апта",
    other: "шамамен {{count}} апта"
  },
  xWeeks: {
    type: "weeks",
    one: "1 апта",
    other: "{{count}} апта"
  },
  aboutXMonths: {
    regular: {
      singularNominative: "шамамен {{count}} ай",
      singularGenitive: "шамамен {{count}} ай",
      pluralGenitive: "шамамен {{count}} ай"
    },
    future: {
      singularNominative: "шамамен {{count}} айдан кейін",
      singularGenitive: "шамамен {{count}} айдан кейін",
      pluralGenitive: "шамамен {{count}} айдан кейін"
    }
  },
  xMonths: {
    regular: {
      singularNominative: "{{count}} ай",
      singularGenitive: "{{count}} ай",
      pluralGenitive: "{{count}} ай"
    }
  },
  aboutXYears: {
    regular: {
      singularNominative: "шамамен {{count}} жыл",
      singularGenitive: "шамамен {{count}} жыл",
      pluralGenitive: "шамамен {{count}} жыл"
    },
    future: {
      singularNominative: "шамамен {{count}} жылдан кейін",
      singularGenitive: "шамамен {{count}} жылдан кейін",
      pluralGenitive: "шамамен {{count}} жылдан кейін"
    }
  },
  xYears: {
    regular: {
      singularNominative: "{{count}} жыл",
      singularGenitive: "{{count}} жыл",
      pluralGenitive: "{{count}} жыл"
    },
    future: {
      singularNominative: "{{count}} жылдан кейін",
      singularGenitive: "{{count}} жылдан кейін",
      pluralGenitive: "{{count}} жылдан кейін"
    }
  },
  overXYears: {
    regular: {
      singularNominative: "{{count}} жылдан астам",
      singularGenitive: "{{count}} жылдан астам",
      pluralGenitive: "{{count}} жылдан астам"
    },
    future: {
      singularNominative: "{{count}} жылдан астам",
      singularGenitive: "{{count}} жылдан астам",
      pluralGenitive: "{{count}} жылдан астам"
    }
  },
  almostXYears: {
    regular: {
      singularNominative: "{{count}} жылға жақын",
      singularGenitive: "{{count}} жылға жақын",
      pluralGenitive: "{{count}} жылға жақын"
    },
    future: {
      singularNominative: "{{count}} жылдан кейін",
      singularGenitive: "{{count}} жылдан кейін",
      pluralGenitive: "{{count}} жылдан кейін"
    }
  }
};
function declension3(scheme2, count) {
  if (scheme2.one && count === 1) return scheme2.one;
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
var formatDistance47 = (token, count, options2) => {
  const tokenValue = formatDistanceLocale45[token];
  if (typeof tokenValue === "function") return tokenValue(options2);
  if (tokenValue.type === "weeks") {
    return count === 1 ? tokenValue.one : tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      if (tokenValue.future) {
        return declension3(tokenValue.future, count);
      } else {
        return declension3(tokenValue.regular, count) + " кейін";
      }
    } else {
      if (tokenValue.past) {
        return declension3(tokenValue.past, count);
      } else {
        return declension3(tokenValue.regular, count) + " бұрын";
      }
    }
  } else {
    return declension3(tokenValue.regular, count);
  }
};

// ../../../node_modules/date-fns/locale/kk/_lib/formatLong.mjs
var dateFormats54 = {
  full: "EEEE, do MMMM y 'ж.'",
  long: "do MMMM y 'ж.'",
  medium: "d MMM y 'ж.'",
  short: "dd.MM.yyyy"
};
var timeFormats54 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats54 = {
  any: "{{date}}, {{time}}"
};
var formatLong54 = {
  date: buildFormatLongFn({
    formats: dateFormats54,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats54,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats54,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/kk/_lib/formatRelative.mjs
var accusativeWeekdays5 = [
  "жексенбіде",
  "дүйсенбіде",
  "сейсенбіде",
  "сәрсенбіде",
  "бейсенбіде",
  "жұмада",
  "сенбіде"
];
function lastWeek5(day) {
  const weekday = accusativeWeekdays5[day];
  return "'өткен " + weekday + " сағат' p'-де'";
}
function thisWeek5(day) {
  const weekday = accusativeWeekdays5[day];
  return "'" + weekday + " сағат' p'-де'";
}
function nextWeek5(day) {
  const weekday = accusativeWeekdays5[day];
  return "'келесі " + weekday + " сағат' p'-де'";
}
var formatRelativeLocale46 = {
  lastWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek5(day);
    } else {
      return lastWeek5(day);
    }
  },
  yesterday: "'кеше сағат' p'-де'",
  today: "'бүгін сағат' p'-де'",
  tomorrow: "'ертең сағат' p'-де'",
  nextWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek5(day);
    } else {
      return nextWeek5(day);
    }
  },
  other: "P"
};
var formatRelative46 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale46[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/kk/_lib/localize.mjs
var eraValues46 = {
  narrow: ["б.з.д.", "б.з."],
  abbreviated: ["б.з.д.", "б.з."],
  wide: ["біздің заманымызға дейін", "біздің заманымыз"]
};
var quarterValues46 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-ші тоқ.", "2-ші тоқ.", "3-ші тоқ.", "4-ші тоқ."],
  wide: ["1-ші тоқсан", "2-ші тоқсан", "3-ші тоқсан", "4-ші тоқсан"]
};
var monthValues46 = {
  narrow: ["Қ", "А", "Н", "С", "М", "М", "Ш", "Т", "Қ", "Қ", "Қ", "Ж"],
  abbreviated: [
    "қаң",
    "ақп",
    "нау",
    "сәу",
    "мам",
    "мау",
    "шіл",
    "там",
    "қыр",
    "қаз",
    "қар",
    "жел"
  ],
  wide: [
    "қаңтар",
    "ақпан",
    "наурыз",
    "сәуір",
    "мамыр",
    "маусым",
    "шілде",
    "тамыз",
    "қыркүйек",
    "қазан",
    "қараша",
    "желтоқсан"
  ]
};
var formattingMonthValues10 = {
  narrow: ["Қ", "А", "Н", "С", "М", "М", "Ш", "Т", "Қ", "Қ", "Қ", "Ж"],
  abbreviated: [
    "қаң",
    "ақп",
    "нау",
    "сәу",
    "мам",
    "мау",
    "шіл",
    "там",
    "қыр",
    "қаз",
    "қар",
    "жел"
  ],
  wide: [
    "қаңтар",
    "ақпан",
    "наурыз",
    "сәуір",
    "мамыр",
    "маусым",
    "шілде",
    "тамыз",
    "қыркүйек",
    "қазан",
    "қараша",
    "желтоқсан"
  ]
};
var dayValues46 = {
  narrow: ["Ж", "Д", "С", "С", "Б", "Ж", "С"],
  short: ["жс", "дс", "сс", "ср", "бс", "жм", "сб"],
  abbreviated: ["жс", "дс", "сс", "ср", "бс", "жм", "сб"],
  wide: [
    "жексенбі",
    "дүйсенбі",
    "сейсенбі",
    "сәрсенбі",
    "бейсенбі",
    "жұма",
    "сенбі"
  ]
};
var dayPeriodValues46 = {
  narrow: {
    am: "ТД",
    pm: "ТК",
    midnight: "түн ортасы",
    noon: "түс",
    morning: "таң",
    afternoon: "күндіз",
    evening: "кеш",
    night: "түн"
  },
  wide: {
    am: "ТД",
    pm: "ТК",
    midnight: "түн ортасы",
    noon: "түс",
    morning: "таң",
    afternoon: "күндіз",
    evening: "кеш",
    night: "түн"
  }
};
var formattingDayPeriodValues38 = {
  narrow: {
    am: "ТД",
    pm: "ТК",
    midnight: "түн ортасында",
    noon: "түс",
    morning: "таң",
    afternoon: "күн",
    evening: "кеш",
    night: "түн"
  },
  wide: {
    am: "ТД",
    pm: "ТК",
    midnight: "түн ортасында",
    noon: "түсте",
    morning: "таңертең",
    afternoon: "күндіз",
    evening: "кеште",
    night: "түнде"
  }
};
var suffixes2 = {
  0: "-ші",
  1: "-ші",
  2: "-ші",
  3: "-ші",
  4: "-ші",
  5: "-ші",
  6: "-шы",
  7: "-ші",
  8: "-ші",
  9: "-шы",
  10: "-шы",
  20: "-шы",
  30: "-шы",
  40: "-шы",
  50: "-ші",
  60: "-шы",
  70: "-ші",
  80: "-ші",
  90: "-шы",
  100: "-ші"
};
var ordinalNumber46 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const mod10 = number2 % 10;
  const b2 = number2 >= 100 ? 100 : null;
  const suffix2 = suffixes2[number2] || suffixes2[mod10] || b2 && suffixes2[b2] || "";
  return number2 + suffix2;
};
var localize46 = {
  ordinalNumber: ordinalNumber46,
  era: buildLocalizeFn({
    values: eraValues46,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues46,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues46,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues10,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues46,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues46,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues38,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/kk/_lib/match.mjs
var matchOrdinalNumberPattern45 = /^(\d+)(-?(ші|шы))?/i;
var parseOrdinalNumberPattern45 = /\d+/i;
var matchEraPatterns45 = {
  narrow: /^((б )?з\.?\s?д\.?)/i,
  abbreviated: /^((б )?з\.?\s?д\.?)/i,
  wide: /^(біздің заманымызға дейін|біздің заманымыз|біздің заманымыздан)/i
};
var parseEraPatterns45 = {
  any: [/^б/i, /^з/i]
};
var matchQuarterPatterns45 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?ші)? тоқ.?/i,
  wide: /^[1234](-?ші)? тоқсан/i
};
var parseQuarterPatterns45 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns45 = {
  narrow: /^(қ|а|н|с|м|мау|ш|т|қыр|қаз|қар|ж)/i,
  abbreviated: /^(қаң|ақп|нау|сәу|мам|мау|шіл|там|қыр|қаз|қар|жел)/i,
  wide: /^(қаңтар|ақпан|наурыз|сәуір|мамыр|маусым|шілде|тамыз|қыркүйек|қазан|қараша|желтоқсан)/i
};
var parseMonthPatterns45 = {
  narrow: [
    /^қ/i,
    /^а/i,
    /^н/i,
    /^с/i,
    /^м/i,
    /^м/i,
    /^ш/i,
    /^т/i,
    /^қ/i,
    /^қ/i,
    /^қ/i,
    /^ж/i
  ],
  abbreviated: [
    /^қаң/i,
    /^ақп/i,
    /^нау/i,
    /^сәу/i,
    /^мам/i,
    /^мау/i,
    /^шіл/i,
    /^там/i,
    /^қыр/i,
    /^қаз/i,
    /^қар/i,
    /^жел/i
  ],
  any: [
    /^қ/i,
    /^а/i,
    /^н/i,
    /^с/i,
    /^м/i,
    /^м/i,
    /^ш/i,
    /^т/i,
    /^қ/i,
    /^қ/i,
    /^қ/i,
    /^ж/i
  ]
};
var matchDayPatterns45 = {
  narrow: /^(ж|д|с|с|б|ж|с)/i,
  short: /^(жс|дс|сс|ср|бс|жм|сб)/i,
  wide: /^(жексенбі|дүйсенбі|сейсенбі|сәрсенбі|бейсенбі|жұма|сенбі)/i
};
var parseDayPatterns45 = {
  narrow: [/^ж/i, /^д/i, /^с/i, /^с/i, /^б/i, /^ж/i, /^с/i],
  short: [/^жс/i, /^дс/i, /^сс/i, /^ср/i, /^бс/i, /^жм/i, /^сб/i],
  any: [
    /^ж[ек]/i,
    /^д[үй]/i,
    /^сe[й]/i,
    /^сә[р]/i,
    /^б[ей]/i,
    /^ж[ұм]/i,
    /^се[н]/i
  ]
};
var matchDayPeriodPatterns45 = {
  narrow: /^Т\.?\s?[ДК]\.?|түн ортасында|((түсте|таңертең|таңда|таңертең|таңмен|таң|күндіз|күн|кеште|кеш|түнде|түн)\.?)/i,
  wide: /^Т\.?\s?[ДК]\.?|түн ортасында|((түсте|таңертең|таңда|таңертең|таңмен|таң|күндіз|күн|кеште|кеш|түнде|түн)\.?)/i,
  any: /^Т\.?\s?[ДК]\.?|түн ортасында|((түсте|таңертең|таңда|таңертең|таңмен|таң|күндіз|күн|кеште|кеш|түнде|түн)\.?)/i
};
var parseDayPeriodPatterns45 = {
  any: {
    am: /^ТД/i,
    pm: /^ТК/i,
    midnight: /^түн орта/i,
    noon: /^күндіз/i,
    morning: /таң/i,
    afternoon: /түс/i,
    evening: /кеш/i,
    night: /түн/i
  }
};
var match45 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern45,
    parsePattern: parseOrdinalNumberPattern45,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns45,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns45,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns45,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns45,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns45,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns45,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns45,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns45,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns45,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns45,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/kk.mjs
var kk = {
  code: "kk",
  formatDistance: formatDistance47,
  formatLong: formatLong54,
  formatRelative: formatRelative46,
  localize: localize46,
  match: match45,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/km/_lib/formatDistance.mjs
var formatDistanceLocale46 = {
  lessThanXSeconds: "តិចជាង {{count}} វិនាទី",
  xSeconds: "{{count}} វិនាទី",
  halfAMinute: "កន្លះនាទី",
  lessThanXMinutes: "តិចជាង {{count}} នាទី",
  xMinutes: "{{count}} នាទី",
  aboutXHours: "ប្រហែល {{count}} ម៉ោង",
  xHours: "{{count}} ម៉ោង",
  xDays: "{{count}} ថ្ងៃ",
  aboutXWeeks: "ប្រហែល {{count}} សប្តាហ៍",
  xWeeks: "{{count}} សប្តាហ៍",
  aboutXMonths: "ប្រហែល {{count}} ខែ",
  xMonths: "{{count}} ខែ",
  aboutXYears: "ប្រហែល {{count}} ឆ្នាំ",
  xYears: "{{count}} ឆ្នាំ",
  overXYears: "ជាង {{count}} ឆ្នាំ",
  almostXYears: "ជិត {{count}} ឆ្នាំ"
};
var formatDistance48 = (token, count, options2) => {
  const tokenValue = formatDistanceLocale46[token];
  let result = tokenValue;
  if (typeof count === "number") {
    result = result.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "ក្នុងរយៈពេល " + result;
    } else {
      return result + "មុន";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/km/_lib/formatLong.mjs
var dateFormats55 = {
  full: "EEEE do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
var timeFormats55 = {
  full: "h:mm:ss a",
  long: "h:mm:ss a",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats55 = {
  full: "{{date}} 'ម៉ោង' {{time}}",
  long: "{{date}} 'ម៉ោង' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong55 = {
  date: buildFormatLongFn({
    formats: dateFormats55,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats55,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats55,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/km/_lib/formatRelative.mjs
var formatRelativeLocale47 = {
  lastWeek: "'ថ្ងៃ'eeee'ស​ប្តា​ហ៍​មុនម៉ោង' p",
  yesterday: "'ម្សិលមិញនៅម៉ោង' p",
  today: "'ថ្ងៃនេះម៉ោង' p",
  tomorrow: "'ថ្ងៃស្អែកម៉ោង' p",
  nextWeek: "'ថ្ងៃ'eeee'ស​ប្តា​ហ៍​ក្រោយម៉ោង' p",
  other: "P"
};
var formatRelative47 = (token, _date, _baseDate, _options) => formatRelativeLocale47[token];

// ../../../node_modules/date-fns/locale/km/_lib/localize.mjs
var eraValues47 = {
  narrow: ["ម.គស", "គស"],
  abbreviated: ["មុនគ.ស", "គ.ស"],
  wide: ["មុនគ្រិស្តសករាជ", "នៃគ្រិស្តសករាជ"]
};
var quarterValues47 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["ត្រីមាសទី 1", "ត្រីមាសទី 2", "ត្រីមាសទី 3", "ត្រីមាសទី 4"]
};
var monthValues47 = {
  narrow: [
    "ម.ក",
    "ក.ម",
    "មិ",
    "ម.ស",
    "ឧ.ស",
    "ម.ថ",
    "ក.ដ",
    "សី",
    "កញ",
    "តុ",
    "វិ",
    "ធ"
  ],
  abbreviated: [
    "មករា",
    "កុម្ភៈ",
    "មីនា",
    "មេសា",
    "ឧសភា",
    "មិថុនា",
    "កក្កដា",
    "សីហា",
    "កញ្ញា",
    "តុលា",
    "វិច្ឆិកា",
    "ធ្នូ"
  ],
  wide: [
    "មករា",
    "កុម្ភៈ",
    "មីនា",
    "មេសា",
    "ឧសភា",
    "មិថុនា",
    "កក្កដា",
    "សីហា",
    "កញ្ញា",
    "តុលា",
    "វិច្ឆិកា",
    "ធ្នូ"
  ]
};
var dayValues47 = {
  narrow: ["អា", "ច", "អ", "ព", "ព្រ", "សុ", "ស"],
  short: ["អា", "ច", "អ", "ព", "ព្រ", "សុ", "ស"],
  abbreviated: ["អា", "ច", "អ", "ព", "ព្រ", "សុ", "ស"],
  wide: ["អាទិត្យ", "ចន្ទ", "អង្គារ", "ពុធ", "ព្រហស្បតិ៍", "សុក្រ", "សៅរ៍"]
};
var dayPeriodValues47 = {
  narrow: {
    am: "ព្រឹក",
    pm: "ល្ងាច",
    midnight: "​ពេលកណ្ដាលអធ្រាត្រ",
    noon: "ពេលថ្ងៃត្រង់",
    morning: "ពេលព្រឹក",
    afternoon: "ពេលរសៀល",
    evening: "ពេលល្ងាច",
    night: "ពេលយប់"
  },
  abbreviated: {
    am: "ព្រឹក",
    pm: "ល្ងាច",
    midnight: "​ពេលកណ្ដាលអធ្រាត្រ",
    noon: "ពេលថ្ងៃត្រង់",
    morning: "ពេលព្រឹក",
    afternoon: "ពេលរសៀល",
    evening: "ពេលល្ងាច",
    night: "ពេលយប់"
  },
  wide: {
    am: "ព្រឹក",
    pm: "ល្ងាច",
    midnight: "​ពេលកណ្ដាលអធ្រាត្រ",
    noon: "ពេលថ្ងៃត្រង់",
    morning: "ពេលព្រឹក",
    afternoon: "ពេលរសៀល",
    evening: "ពេលល្ងាច",
    night: "ពេលយប់"
  }
};
var formattingDayPeriodValues39 = {
  narrow: {
    am: "ព្រឹក",
    pm: "ល្ងាច",
    midnight: "​ពេលកណ្ដាលអធ្រាត្រ",
    noon: "ពេលថ្ងៃត្រង់",
    morning: "ពេលព្រឹក",
    afternoon: "ពេលរសៀល",
    evening: "ពេលល្ងាច",
    night: "ពេលយប់"
  },
  abbreviated: {
    am: "ព្រឹក",
    pm: "ល្ងាច",
    midnight: "​ពេលកណ្ដាលអធ្រាត្រ",
    noon: "ពេលថ្ងៃត្រង់",
    morning: "ពេលព្រឹក",
    afternoon: "ពេលរសៀល",
    evening: "ពេលល្ងាច",
    night: "ពេលយប់"
  },
  wide: {
    am: "ព្រឹក",
    pm: "ល្ងាច",
    midnight: "​ពេលកណ្ដាលអធ្រាត្រ",
    noon: "ពេលថ្ងៃត្រង់",
    morning: "ពេលព្រឹក",
    afternoon: "ពេលរសៀល",
    evening: "ពេលល្ងាច",
    night: "ពេលយប់"
  }
};
var ordinalNumber47 = (dirtyNumber, _) => {
  const number2 = Number(dirtyNumber);
  return number2.toString();
};
var localize47 = {
  ordinalNumber: ordinalNumber47,
  era: buildLocalizeFn({
    values: eraValues47,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues47,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues47,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues47,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues47,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues39,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/km/_lib/match.mjs
var matchOrdinalNumberPattern46 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern46 = /\d+/i;
var matchEraPatterns46 = {
  narrow: /^(ម\.)?គស/i,
  abbreviated: /^(មុន)?គ\.ស/i,
  wide: /^(មុន|នៃ)គ្រិស្តសករាជ/i
};
var parseEraPatterns46 = {
  any: [/^(ម|មុន)គ\.?ស/i, /^(នៃ)?គ\.?ស/i]
};
var matchQuarterPatterns46 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^(ត្រីមាស)(ទី)?\s?[1234]/i
};
var parseQuarterPatterns46 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns46 = {
  narrow: /^(ម\.ក|ក\.ម|មិ|ម\.ស|ឧ\.ស|ម\.ថ|ក\.ដ|សី|កញ|តុ|វិ|ធ)/i,
  abbreviated: /^(មករា|កុម្ភៈ|មីនា|មេសា|ឧសភា|មិថុនា|កក្កដា|សីហា|កញ្ញា|តុលា|វិច្ឆិកា|ធ្នូ)/i,
  wide: /^(មករា|កុម្ភៈ|មីនា|មេសា|ឧសភា|មិថុនា|កក្កដា|សីហា|កញ្ញា|តុលា|វិច្ឆិកា|ធ្នូ)/i
};
var parseMonthPatterns46 = {
  narrow: [
    /^ម\.ក/i,
    /^ក\.ម/i,
    /^មិ/i,
    /^ម\.ស/i,
    /^ឧ\.ស/i,
    /^ម\.ថ/i,
    /^ក\.ដ/i,
    /^សី/i,
    /^កញ/i,
    /^តុ/i,
    /^វិ/i,
    /^ធ/i
  ],
  any: [
    /^មក/i,
    /^កុ/i,
    /^មីន/i,
    /^មេ/i,
    /^ឧស/i,
    /^មិថ/i,
    /^កក/i,
    /^សី/i,
    /^កញ/i,
    /^តុ/i,
    /^វិច/i,
    /^ធ/i
  ]
};
var matchDayPatterns46 = {
  narrow: /^(អា|ច|អ|ព|ព្រ|សុ|ស)/i,
  short: /^(អា|ច|អ|ព|ព្រ|សុ|ស)/i,
  abbreviated: /^(អា|ច|អ|ព|ព្រ|សុ|ស)/i,
  wide: /^(អាទិត្យ|ចន្ទ|អង្គារ|ពុធ|ព្រហស្បតិ៍|សុក្រ|សៅរ៍)/i
};
var parseDayPatterns46 = {
  narrow: [/^អា/i, /^ច/i, /^អ/i, /^ព/i, /^ព្រ/i, /^សុ/i, /^ស/i],
  any: [/^អា/i, /^ច/i, /^អ/i, /^ព/i, /^ព្រ/i, /^សុ/i, /^សៅ/i]
};
var matchDayPeriodPatterns46 = {
  narrow: /^(ព្រឹក|ល្ងាច|ពេលព្រឹក|ពេលថ្ងៃត្រង់|ពេលល្ងាច|ពេលរសៀល|ពេលយប់|ពេលកណ្ដាលអធ្រាត្រ)/i,
  any: /^(ព្រឹក|ល្ងាច|ពេលព្រឹក|ពេលថ្ងៃត្រង់|ពេលល្ងាច|ពេលរសៀល|ពេលយប់|ពេលកណ្ដាលអធ្រាត្រ)/i
};
var parseDayPeriodPatterns46 = {
  any: {
    am: /^ព្រឹក/i,
    pm: /^ល្ងាច/i,
    midnight: /^ពេលកណ្ដាលអធ្រាត្រ/i,
    noon: /^ពេលថ្ងៃត្រង់/i,
    morning: /ពេលព្រឹក/i,
    afternoon: /ពេលរសៀល/i,
    evening: /ពេលល្ងាច/i,
    night: /ពេលយប់/i
  }
};
var match46 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern46,
    parsePattern: parseOrdinalNumberPattern46,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns46,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns46,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns46,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns46,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns46,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns46,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns46,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns46,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns46,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns46,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/km.mjs
var km = {
  code: "km",
  formatDistance: formatDistance48,
  formatLong: formatLong55,
  formatRelative: formatRelative47,
  localize: localize47,
  match: match46,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/kn/_lib/formatDistance.mjs
var formatDistanceLocale47 = {
  lessThanXSeconds: {
    one: {
      default: "1 ಸೆಕೆಂಡ್‌ಗಿಂತ ಕಡಿಮೆ",
      future: "1 ಸೆಕೆಂಡ್‌ಗಿಂತ ಕಡಿಮೆ",
      past: "1 ಸೆಕೆಂಡ್‌ಗಿಂತ ಕಡಿಮೆ"
    },
    other: {
      default: "{{count}} ಸೆಕೆಂಡ್‌ಗಿಂತ ಕಡಿಮೆ",
      future: "{{count}} ಸೆಕೆಂಡ್‌ಗಿಂತ ಕಡಿಮೆ",
      past: "{{count}} ಸೆಕೆಂಡ್‌ಗಿಂತ ಕಡಿಮೆ"
    }
  },
  xSeconds: {
    one: {
      default: "1 ಸೆಕೆಂಡ್",
      future: "1 ಸೆಕೆಂಡ್‌ನಲ್ಲಿ",
      past: "1 ಸೆಕೆಂಡ್ ಹಿಂದೆ"
    },
    other: {
      default: "{{count}} ಸೆಕೆಂಡುಗಳು",
      future: "{{count}} ಸೆಕೆಂಡ್‌ಗಳಲ್ಲಿ",
      past: "{{count}} ಸೆಕೆಂಡ್ ಹಿಂದೆ"
    }
  },
  halfAMinute: {
    other: {
      default: "ಅರ್ಧ ನಿಮಿಷ",
      future: "ಅರ್ಧ ನಿಮಿಷದಲ್ಲಿ",
      past: "ಅರ್ಧ ನಿಮಿಷದ ಹಿಂದೆ"
    }
  },
  lessThanXMinutes: {
    one: {
      default: "1 ನಿಮಿಷಕ್ಕಿಂತ ಕಡಿಮೆ",
      future: "1 ನಿಮಿಷಕ್ಕಿಂತ ಕಡಿಮೆ",
      past: "1 ನಿಮಿಷಕ್ಕಿಂತ ಕಡಿಮೆ"
    },
    other: {
      default: "{{count}} ನಿಮಿಷಕ್ಕಿಂತ ಕಡಿಮೆ",
      future: "{{count}} ನಿಮಿಷಕ್ಕಿಂತ ಕಡಿಮೆ",
      past: "{{count}} ನಿಮಿಷಕ್ಕಿಂತ ಕಡಿಮೆ"
    }
  },
  xMinutes: {
    one: {
      default: "1 ನಿಮಿಷ",
      future: "1 ನಿಮಿಷದಲ್ಲಿ",
      past: "1 ನಿಮಿಷದ ಹಿಂದೆ"
    },
    other: {
      default: "{{count}} ನಿಮಿಷಗಳು",
      future: "{{count}} ನಿಮಿಷಗಳಲ್ಲಿ",
      past: "{{count}} ನಿಮಿಷಗಳ ಹಿಂದೆ"
    }
  },
  aboutXHours: {
    one: {
      default: "ಸುಮಾರು 1 ಗಂಟೆ",
      future: "ಸುಮಾರು 1 ಗಂಟೆಯಲ್ಲಿ",
      past: "ಸುಮಾರು 1 ಗಂಟೆ ಹಿಂದೆ"
    },
    other: {
      default: "ಸುಮಾರು {{count}} ಗಂಟೆಗಳು",
      future: "ಸುಮಾರು {{count}} ಗಂಟೆಗಳಲ್ಲಿ",
      past: "ಸುಮಾರು {{count}} ಗಂಟೆಗಳ ಹಿಂದೆ"
    }
  },
  xHours: {
    one: {
      default: "1 ಗಂಟೆ",
      future: "1 ಗಂಟೆಯಲ್ಲಿ",
      past: "1 ಗಂಟೆ ಹಿಂದೆ"
    },
    other: {
      default: "{{count}} ಗಂಟೆಗಳು",
      future: "{{count}} ಗಂಟೆಗಳಲ್ಲಿ",
      past: "{{count}} ಗಂಟೆಗಳ ಹಿಂದೆ"
    }
  },
  xDays: {
    one: {
      default: "1 ದಿನ",
      future: "1 ದಿನದಲ್ಲಿ",
      past: "1 ದಿನದ ಹಿಂದೆ"
    },
    other: {
      default: "{{count}} ದಿನಗಳು",
      future: "{{count}} ದಿನಗಳಲ್ಲಿ",
      past: "{{count}} ದಿನಗಳ ಹಿಂದೆ"
    }
  },
  // TODO
  // aboutXWeeks: {},
  // TODO
  // xWeeks: {},
  aboutXMonths: {
    one: {
      default: "ಸುಮಾರು 1 ತಿಂಗಳು",
      future: "ಸುಮಾರು 1 ತಿಂಗಳಲ್ಲಿ",
      past: "ಸುಮಾರು 1 ತಿಂಗಳ ಹಿಂದೆ"
    },
    other: {
      default: "ಸುಮಾರು {{count}} ತಿಂಗಳು",
      future: "ಸುಮಾರು {{count}} ತಿಂಗಳುಗಳಲ್ಲಿ",
      past: "ಸುಮಾರು {{count}} ತಿಂಗಳುಗಳ ಹಿಂದೆ"
    }
  },
  xMonths: {
    one: {
      default: "1 ತಿಂಗಳು",
      future: "1 ತಿಂಗಳಲ್ಲಿ",
      past: "1 ತಿಂಗಳ ಹಿಂದೆ"
    },
    other: {
      default: "{{count}} ತಿಂಗಳು",
      future: "{{count}} ತಿಂಗಳುಗಳಲ್ಲಿ",
      past: "{{count}} ತಿಂಗಳುಗಳ ಹಿಂದೆ"
    }
  },
  aboutXYears: {
    one: {
      default: "ಸುಮಾರು 1 ವರ್ಷ",
      future: "ಸುಮಾರು 1 ವರ್ಷದಲ್ಲಿ",
      past: "ಸುಮಾರು 1 ವರ್ಷದ ಹಿಂದೆ"
    },
    other: {
      default: "ಸುಮಾರು {{count}} ವರ್ಷಗಳು",
      future: "ಸುಮಾರು {{count}} ವರ್ಷಗಳಲ್ಲಿ",
      past: "ಸುಮಾರು {{count}} ವರ್ಷಗಳ ಹಿಂದೆ"
    }
  },
  xYears: {
    one: {
      default: "1 ವರ್ಷ",
      future: "1 ವರ್ಷದಲ್ಲಿ",
      past: "1 ವರ್ಷದ ಹಿಂದೆ"
    },
    other: {
      default: "{{count}} ವರ್ಷಗಳು",
      future: "{{count}} ವರ್ಷಗಳಲ್ಲಿ",
      past: "{{count}} ವರ್ಷಗಳ ಹಿಂದೆ"
    }
  },
  overXYears: {
    one: {
      default: "1 ವರ್ಷದ ಮೇಲೆ",
      future: "1 ವರ್ಷದ ಮೇಲೆ",
      past: "1 ವರ್ಷದ ಮೇಲೆ"
    },
    other: {
      default: "{{count}} ವರ್ಷಗಳ ಮೇಲೆ",
      future: "{{count}} ವರ್ಷಗಳ ಮೇಲೆ",
      past: "{{count}} ವರ್ಷಗಳ ಮೇಲೆ"
    }
  },
  almostXYears: {
    one: {
      default: "ಬಹುತೇಕ 1 ವರ್ಷದಲ್ಲಿ",
      future: "ಬಹುತೇಕ 1 ವರ್ಷದಲ್ಲಿ",
      past: "ಬಹುತೇಕ 1 ವರ್ಷದಲ್ಲಿ"
    },
    other: {
      default: "ಬಹುತೇಕ {{count}} ವರ್ಷಗಳಲ್ಲಿ",
      future: "ಬಹುತೇಕ {{count}} ವರ್ಷಗಳಲ್ಲಿ",
      past: "ಬಹುತೇಕ {{count}} ವರ್ಷಗಳಲ್ಲಿ"
    }
  }
};
function getResultByTense(parentToken, options2) {
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return parentToken.future;
    } else {
      return parentToken.past;
    }
  }
  return parentToken.default;
}
var formatDistance49 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale47[token];
  if (tokenValue.one && count === 1) {
    result = getResultByTense(tokenValue.one, options2);
  } else {
    result = getResultByTense(tokenValue.other, options2);
  }
  return result.replace("{{count}}", String(count));
};

// ../../../node_modules/date-fns/locale/kn/_lib/formatLong.mjs
var dateFormats56 = {
  full: "EEEE, MMMM d, y",
  // CLDR 1816
  long: "MMMM d, y",
  // CLDR 1817
  medium: "MMM d, y",
  // CLDR 1818
  short: "d/M/yy"
  // CLDR 1819
};
var timeFormats56 = {
  full: "hh:mm:ss a zzzz",
  // CLDR 1820
  long: "hh:mm:ss a z",
  // CLDR 1821
  medium: "hh:mm:ss a",
  // CLDR 1822
  short: "hh:mm a"
  // CLDR 1823
};
var dateTimeFormats56 = {
  full: "{{date}} {{time}}",
  // CLDR 1824
  long: "{{date}} {{time}}",
  // CLDR 1825
  medium: "{{date}} {{time}}",
  // CLDR 1826
  short: "{{date}} {{time}}"
  // CLDR 1827
};
var formatLong56 = {
  date: buildFormatLongFn({
    formats: dateFormats56,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats56,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats56,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/kn/_lib/formatRelative.mjs
var formatRelativeLocale48 = {
  lastWeek: "'ಕಳೆದ' eeee p 'ಕ್ಕೆ'",
  yesterday: "'ನಿನ್ನೆ' p 'ಕ್ಕೆ'",
  today: "'ಇಂದು' p 'ಕ್ಕೆ'",
  tomorrow: "'ನಾಳೆ' p 'ಕ್ಕೆ'",
  nextWeek: "eeee p 'ಕ್ಕೆ'",
  other: "P"
};
var formatRelative48 = (token, _date, _baseDate, _options) => formatRelativeLocale48[token];

// ../../../node_modules/date-fns/locale/kn/_lib/localize.mjs
var eraValues48 = {
  narrow: ["ಕ್ರಿ.ಪೂ", "ಕ್ರಿ.ಶ"],
  abbreviated: ["ಕ್ರಿ.ಪೂ", "ಕ್ರಿ.ಶ"],
  // CLDR #1618, #1620
  wide: ["ಕ್ರಿಸ್ತ ಪೂರ್ವ", "ಕ್ರಿಸ್ತ ಶಕ"]
  // CLDR #1614, #1616
};
var quarterValues48 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["ತ್ರೈ 1", "ತ್ರೈ 2", "ತ್ರೈ 3", "ತ್ರೈ 4"],
  // CLDR #1630 - #1638
  wide: ["1ನೇ ತ್ರೈಮಾಸಿಕ", "2ನೇ ತ್ರೈಮಾಸಿಕ", "3ನೇ ತ್ರೈಮಾಸಿಕ", "4ನೇ ತ್ರೈಮಾಸಿಕ"]
  // CLDR #1622 - #1629
};
var monthValues48 = {
  narrow: ["ಜ", "ಫೆ", "ಮಾ", "ಏ", "ಮೇ", "ಜೂ", "ಜು", "ಆ", "ಸೆ", "ಅ", "ನ", "ಡಿ"],
  abbreviated: [
    "ಜನ",
    "ಫೆಬ್ರ",
    "ಮಾರ್ಚ್",
    "ಏಪ್ರಿ",
    "ಮೇ",
    "ಜೂನ್",
    "ಜುಲೈ",
    "ಆಗ",
    "ಸೆಪ್ಟೆಂ",
    "ಅಕ್ಟೋ",
    "ನವೆಂ",
    "ಡಿಸೆಂ"
  ],
  wide: [
    "ಜನವರಿ",
    "ಫೆಬ್ರವರಿ",
    "ಮಾರ್ಚ್",
    "ಏಪ್ರಿಲ್",
    "ಮೇ",
    "ಜೂನ್",
    "ಜುಲೈ",
    "ಆಗಸ್ಟ್",
    "ಸೆಪ್ಟೆಂಬರ್",
    "ಅಕ್ಟೋಬರ್",
    "ನವೆಂಬರ್",
    "ಡಿಸೆಂಬರ್"
  ]
};
var dayValues48 = {
  narrow: ["ಭಾ", "ಸೋ", "ಮಂ", "ಬು", "ಗು", "ಶು", "ಶ"],
  short: ["ಭಾನು", "ಸೋಮ", "ಮಂಗಳ", "ಬುಧ", "ಗುರು", "ಶುಕ್ರ", "ಶನಿ"],
  abbreviated: ["ಭಾನು", "ಸೋಮ", "ಮಂಗಳ", "ಬುಧ", "ಗುರು", "ಶುಕ್ರ", "ಶನಿ"],
  wide: [
    "ಭಾನುವಾರ",
    "ಸೋಮವಾರ",
    "ಮಂಗಳವಾರ",
    "ಬುಧವಾರ",
    "ಗುರುವಾರ",
    "ಶುಕ್ರವಾರ",
    "ಶನಿವಾರ"
  ]
};
var dayPeriodValues48 = {
  narrow: {
    am: "ಪೂರ್ವಾಹ್ನ",
    pm: "ಅಪರಾಹ್ನ",
    midnight: "ಮಧ್ಯರಾತ್ರಿ",
    noon: "ಮಧ್ಯಾಹ್ನ",
    morning: "ಬೆಳಗ್ಗೆ",
    afternoon: "ಮಧ್ಯಾಹ್ನ",
    evening: "ಸಂಜೆ",
    night: "ರಾತ್ರಿ"
  },
  abbreviated: {
    am: "ಪೂರ್ವಾಹ್ನ",
    pm: "ಅಪರಾಹ್ನ",
    midnight: "ಮಧ್ಯರಾತ್ರಿ",
    noon: "ಮಧ್ಯಾನ್ಹ",
    morning: "ಬೆಳಗ್ಗೆ",
    afternoon: "ಮಧ್ಯಾನ್ಹ",
    evening: "ಸಂಜೆ",
    night: "ರಾತ್ರಿ"
  },
  wide: {
    am: "ಪೂರ್ವಾಹ್ನ",
    pm: "ಅಪರಾಹ್ನ",
    midnight: "ಮಧ್ಯರಾತ್ರಿ",
    noon: "ಮಧ್ಯಾನ್ಹ",
    morning: "ಬೆಳಗ್ಗೆ",
    afternoon: "ಮಧ್ಯಾನ್ಹ",
    evening: "ಸಂಜೆ",
    night: "ರಾತ್ರಿ"
  }
};
var formattingDayPeriodValues40 = {
  narrow: {
    am: "ಪೂ",
    pm: "ಅ",
    midnight: "ಮಧ್ಯರಾತ್ರಿ",
    noon: "ಮಧ್ಯಾನ್ಹ",
    morning: "ಬೆಳಗ್ಗೆ",
    afternoon: "ಮಧ್ಯಾನ್ಹ",
    evening: "ಸಂಜೆ",
    night: "ರಾತ್ರಿ"
  },
  abbreviated: {
    am: "ಪೂರ್ವಾಹ್ನ",
    pm: "ಅಪರಾಹ್ನ",
    midnight: "ಮಧ್ಯ ರಾತ್ರಿ",
    noon: "ಮಧ್ಯಾನ್ಹ",
    morning: "ಬೆಳಗ್ಗೆ",
    afternoon: "ಮಧ್ಯಾನ್ಹ",
    evening: "ಸಂಜೆ",
    night: "ರಾತ್ರಿ"
  },
  wide: {
    am: "ಪೂರ್ವಾಹ್ನ",
    pm: "ಅಪರಾಹ್ನ",
    midnight: "ಮಧ್ಯ ರಾತ್ರಿ",
    noon: "ಮಧ್ಯಾನ್ಹ",
    morning: "ಬೆಳಗ್ಗೆ",
    afternoon: "ಮಧ್ಯಾನ್ಹ",
    evening: "ಸಂಜೆ",
    night: "ರಾತ್ರಿ"
  }
};
var ordinalNumber48 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "ನೇ";
};
var localize48 = {
  ordinalNumber: ordinalNumber48,
  era: buildLocalizeFn({
    values: eraValues48,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues48,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues48,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues48,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues48,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues40,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/kn/_lib/match.mjs
var matchOrdinalNumberPattern47 = /^(\d+)(ನೇ|ನೆ)?/i;
var parseOrdinalNumberPattern47 = /\d+/i;
var matchEraPatterns47 = {
  narrow: /^(ಕ್ರಿ.ಪೂ|ಕ್ರಿ.ಶ)/i,
  abbreviated: /^(ಕ್ರಿ\.?\s?ಪೂ\.?|ಕ್ರಿ\.?\s?ಶ\.?|ಪ್ರ\.?\s?ಶ\.?)/i,
  wide: /^(ಕ್ರಿಸ್ತ ಪೂರ್ವ|ಕ್ರಿಸ್ತ ಶಕ|ಪ್ರಸಕ್ತ ಶಕ)/i
};
var parseEraPatterns47 = {
  any: [/^ಪೂ/i, /^(ಶ|ಪ್ರ)/i]
};
var matchQuarterPatterns47 = {
  narrow: /^[1234]/i,
  abbreviated: /^ತ್ರೈ[1234]|ತ್ರೈ [1234]| [1234]ತ್ರೈ/i,
  wide: /^[1234](ನೇ)? ತ್ರೈಮಾಸಿಕ/i
};
var parseQuarterPatterns47 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns47 = {
  narrow: /^(ಜೂ|ಜು|ಜ|ಫೆ|ಮಾ|ಏ|ಮೇ|ಆ|ಸೆ|ಅ|ನ|ಡಿ)/i,
  abbreviated: /^(ಜನ|ಫೆಬ್ರ|ಮಾರ್ಚ್|ಏಪ್ರಿ|ಮೇ|ಜೂನ್|ಜುಲೈ|ಆಗ|ಸೆಪ್ಟೆಂ|ಅಕ್ಟೋ|ನವೆಂ|ಡಿಸೆಂ)/i,
  wide: /^(ಜನವರಿ|ಫೆಬ್ರವರಿ|ಮಾರ್ಚ್|ಏಪ್ರಿಲ್|ಮೇ|ಜೂನ್|ಜುಲೈ|ಆಗಸ್ಟ್|ಸೆಪ್ಟೆಂಬರ್|ಅಕ್ಟೋಬರ್|ನವೆಂಬರ್|ಡಿಸೆಂಬರ್)/i
};
var parseMonthPatterns47 = {
  narrow: [
    /^ಜ$/i,
    /^ಫೆ/i,
    /^ಮಾ/i,
    /^ಏ/i,
    /^ಮೇ/i,
    /^ಜೂ/i,
    /^ಜು$/i,
    /^ಆ/i,
    /^ಸೆ/i,
    /^ಅ/i,
    /^ನ/i,
    /^ಡಿ/i
  ],
  any: [
    /^ಜನ/i,
    /^ಫೆ/i,
    /^ಮಾ/i,
    /^ಏ/i,
    /^ಮೇ/i,
    /^ಜೂನ್/i,
    /^ಜುಲೈ/i,
    /^ಆ/i,
    /^ಸೆ/i,
    /^ಅ/i,
    /^ನ/i,
    /^ಡಿ/i
  ]
};
var matchDayPatterns47 = {
  narrow: /^(ಭಾ|ಸೋ|ಮ|ಬು|ಗು|ಶು|ಶ)/i,
  short: /^(ಭಾನು|ಸೋಮ|ಮಂಗಳ|ಬುಧ|ಗುರು|ಶುಕ್ರ|ಶನಿ)/i,
  abbreviated: /^(ಭಾನು|ಸೋಮ|ಮಂಗಳ|ಬುಧ|ಗುರು|ಶುಕ್ರ|ಶನಿ)/i,
  wide: /^(ಭಾನುವಾರ|ಸೋಮವಾರ|ಮಂಗಳವಾರ|ಬುಧವಾರ|ಗುರುವಾರ|ಶುಕ್ರವಾರ|ಶನಿವಾರ)/i
};
var parseDayPatterns47 = {
  narrow: [/^ಭಾ/i, /^ಸೋ/i, /^ಮ/i, /^ಬು/i, /^ಗು/i, /^ಶು/i, /^ಶ/i],
  any: [/^ಭಾ/i, /^ಸೋ/i, /^ಮ/i, /^ಬು/i, /^ಗು/i, /^ಶು/i, /^ಶ/i]
};
var matchDayPeriodPatterns47 = {
  narrow: /^(ಪೂ|ಅ|ಮಧ್ಯರಾತ್ರಿ|ಮಧ್ಯಾನ್ಹ|ಬೆಳಗ್ಗೆ|ಸಂಜೆ|ರಾತ್ರಿ)/i,
  any: /^(ಪೂರ್ವಾಹ್ನ|ಅಪರಾಹ್ನ|ಮಧ್ಯರಾತ್ರಿ|ಮಧ್ಯಾನ್ಹ|ಬೆಳಗ್ಗೆ|ಸಂಜೆ|ರಾತ್ರಿ)/i
};
var parseDayPeriodPatterns47 = {
  any: {
    am: /^ಪೂ/i,
    pm: /^ಅ/i,
    midnight: /ಮಧ್ಯರಾತ್ರಿ/i,
    noon: /ಮಧ್ಯಾನ್ಹ/i,
    morning: /ಬೆಳಗ್ಗೆ/i,
    afternoon: /ಮಧ್ಯಾನ್ಹ/i,
    evening: /ಸಂಜೆ/i,
    night: /ರಾತ್ರಿ/i
  }
};
var match47 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern47,
    parsePattern: parseOrdinalNumberPattern47,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns47,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns47,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns47,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns47,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns47,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns47,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns47,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns47,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns47,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns47,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/kn.mjs
var kn = {
  code: "kn",
  formatDistance: formatDistance49,
  formatLong: formatLong56,
  formatRelative: formatRelative48,
  localize: localize48,
  match: match47,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ko/_lib/formatDistance.mjs
var formatDistanceLocale48 = {
  lessThanXSeconds: {
    one: "1초 미만",
    other: "{{count}}초 미만"
  },
  xSeconds: {
    one: "1초",
    other: "{{count}}초"
  },
  halfAMinute: "30초",
  lessThanXMinutes: {
    one: "1분 미만",
    other: "{{count}}분 미만"
  },
  xMinutes: {
    one: "1분",
    other: "{{count}}분"
  },
  aboutXHours: {
    one: "약 1시간",
    other: "약 {{count}}시간"
  },
  xHours: {
    one: "1시간",
    other: "{{count}}시간"
  },
  xDays: {
    one: "1일",
    other: "{{count}}일"
  },
  aboutXWeeks: {
    one: "약 1주",
    other: "약 {{count}}주"
  },
  xWeeks: {
    one: "1주",
    other: "{{count}}주"
  },
  aboutXMonths: {
    one: "약 1개월",
    other: "약 {{count}}개월"
  },
  xMonths: {
    one: "1개월",
    other: "{{count}}개월"
  },
  aboutXYears: {
    one: "약 1년",
    other: "약 {{count}}년"
  },
  xYears: {
    one: "1년",
    other: "{{count}}년"
  },
  overXYears: {
    one: "1년 이상",
    other: "{{count}}년 이상"
  },
  almostXYears: {
    one: "거의 1년",
    other: "거의 {{count}}년"
  }
};
var formatDistance50 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale48[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + " 후";
    } else {
      return result + " 전";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ko/_lib/formatLong.mjs
var dateFormats57 = {
  full: "y년 M월 d일 EEEE",
  long: "y년 M월 d일",
  medium: "y.MM.dd",
  short: "y.MM.dd"
};
var timeFormats57 = {
  full: "a H시 mm분 ss초 zzzz",
  long: "a H:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats57 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong57 = {
  date: buildFormatLongFn({
    formats: dateFormats57,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats57,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats57,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ko/_lib/formatRelative.mjs
var formatRelativeLocale49 = {
  lastWeek: "'지난' eeee p",
  yesterday: "'어제' p",
  today: "'오늘' p",
  tomorrow: "'내일' p",
  nextWeek: "'다음' eeee p",
  other: "P"
};
var formatRelative49 = (token, _date, _baseDate, _options) => formatRelativeLocale49[token];

// ../../../node_modules/date-fns/locale/ko/_lib/localize.mjs
var eraValues49 = {
  narrow: ["BC", "AD"],
  abbreviated: ["BC", "AD"],
  wide: ["기원전", "서기"]
};
var quarterValues49 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1분기", "2분기", "3분기", "4분기"]
};
var monthValues49 = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "1월",
    "2월",
    "3월",
    "4월",
    "5월",
    "6월",
    "7월",
    "8월",
    "9월",
    "10월",
    "11월",
    "12월"
  ],
  wide: [
    "1월",
    "2월",
    "3월",
    "4월",
    "5월",
    "6월",
    "7월",
    "8월",
    "9월",
    "10월",
    "11월",
    "12월"
  ]
};
var dayValues49 = {
  narrow: ["일", "월", "화", "수", "목", "금", "토"],
  short: ["일", "월", "화", "수", "목", "금", "토"],
  abbreviated: ["일", "월", "화", "수", "목", "금", "토"],
  wide: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
};
var dayPeriodValues49 = {
  narrow: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  },
  abbreviated: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  },
  wide: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  }
};
var formattingDayPeriodValues41 = {
  narrow: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  },
  abbreviated: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  },
  wide: {
    am: "오전",
    pm: "오후",
    midnight: "자정",
    noon: "정오",
    morning: "아침",
    afternoon: "오후",
    evening: "저녁",
    night: "밤"
  }
};
var ordinalNumber49 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = String(options2 == null ? void 0 : options2.unit);
  switch (unit) {
    case "minute":
    case "second":
      return String(number2);
    case "date":
      return number2 + "일";
    default:
      return number2 + "번째";
  }
};
var localize49 = {
  ordinalNumber: ordinalNumber49,
  era: buildLocalizeFn({
    values: eraValues49,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues49,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues49,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues49,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues49,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues41,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ko/_lib/match.mjs
var matchOrdinalNumberPattern48 = /^(\d+)(일|번째)?/i;
var parseOrdinalNumberPattern48 = /\d+/i;
var matchEraPatterns48 = {
  narrow: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(기원전|서기)/i
};
var parseEraPatterns48 = {
  any: [/^(bc|기원전)/i, /^(ad|서기)/i]
};
var matchQuarterPatterns48 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]사?분기/i
};
var parseQuarterPatterns48 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns48 = {
  narrow: /^(1[012]|[123456789])/,
  abbreviated: /^(1[012]|[123456789])월/i,
  wide: /^(1[012]|[123456789])월/i
};
var parseMonthPatterns48 = {
  any: [
    /^1월?$/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/
  ]
};
var matchDayPatterns48 = {
  narrow: /^[일월화수목금토]/,
  short: /^[일월화수목금토]/,
  abbreviated: /^[일월화수목금토]/,
  wide: /^[일월화수목금토]요일/
};
var parseDayPatterns48 = {
  any: [/^일/, /^월/, /^화/, /^수/, /^목/, /^금/, /^토/]
};
var matchDayPeriodPatterns48 = {
  any: /^(am|pm|오전|오후|자정|정오|아침|저녁|밤)/i
};
var parseDayPeriodPatterns48 = {
  any: {
    am: /^(am|오전)/i,
    pm: /^(pm|오후)/i,
    midnight: /^자정/i,
    noon: /^정오/i,
    morning: /^아침/i,
    afternoon: /^오후/i,
    evening: /^저녁/i,
    night: /^밤/i
  }
};
var match48 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern48,
    parsePattern: parseOrdinalNumberPattern48,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns48,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns48,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns48,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns48,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns48,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns48,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns48,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns48,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns48,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns48,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ko.mjs
var ko = {
  code: "ko",
  formatDistance: formatDistance50,
  formatLong: formatLong57,
  formatRelative: formatRelative49,
  localize: localize49,
  match: match48,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/lb/_lib/formatDistance.mjs
var formatDistanceLocale49 = {
  lessThanXSeconds: {
    standalone: {
      one: "manner wéi eng Sekonn",
      other: "manner wéi {{count}} Sekonnen"
    },
    withPreposition: {
      one: "manner wéi enger Sekonn",
      other: "manner wéi {{count}} Sekonnen"
    }
  },
  xSeconds: {
    standalone: {
      one: "eng Sekonn",
      other: "{{count}} Sekonnen"
    },
    withPreposition: {
      one: "enger Sekonn",
      other: "{{count}} Sekonnen"
    }
  },
  halfAMinute: {
    standalone: "eng hallef Minutt",
    withPreposition: "enger hallwer Minutt"
  },
  lessThanXMinutes: {
    standalone: {
      one: "manner wéi eng Minutt",
      other: "manner wéi {{count}} Minutten"
    },
    withPreposition: {
      one: "manner wéi enger Minutt",
      other: "manner wéi {{count}} Minutten"
    }
  },
  xMinutes: {
    standalone: {
      one: "eng Minutt",
      other: "{{count}} Minutten"
    },
    withPreposition: {
      one: "enger Minutt",
      other: "{{count}} Minutten"
    }
  },
  aboutXHours: {
    standalone: {
      one: "ongeféier eng Stonn",
      other: "ongeféier {{count}} Stonnen"
    },
    withPreposition: {
      one: "ongeféier enger Stonn",
      other: "ongeféier {{count}} Stonnen"
    }
  },
  xHours: {
    standalone: {
      one: "eng Stonn",
      other: "{{count}} Stonnen"
    },
    withPreposition: {
      one: "enger Stonn",
      other: "{{count}} Stonnen"
    }
  },
  xDays: {
    standalone: {
      one: "een Dag",
      other: "{{count}} Deeg"
    },
    withPreposition: {
      one: "engem Dag",
      other: "{{count}} Deeg"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "ongeféier eng Woch",
      other: "ongeféier {{count}} Wochen"
    },
    withPreposition: {
      one: "ongeféier enger Woche",
      other: "ongeféier {{count}} Wochen"
    }
  },
  xWeeks: {
    standalone: {
      one: "eng Woch",
      other: "{{count}} Wochen"
    },
    withPreposition: {
      one: "enger Woch",
      other: "{{count}} Wochen"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "ongeféier ee Mount",
      other: "ongeféier {{count}} Méint"
    },
    withPreposition: {
      one: "ongeféier engem Mount",
      other: "ongeféier {{count}} Méint"
    }
  },
  xMonths: {
    standalone: {
      one: "ee Mount",
      other: "{{count}} Méint"
    },
    withPreposition: {
      one: "engem Mount",
      other: "{{count}} Méint"
    }
  },
  aboutXYears: {
    standalone: {
      one: "ongeféier ee Joer",
      other: "ongeféier {{count}} Joer"
    },
    withPreposition: {
      one: "ongeféier engem Joer",
      other: "ongeféier {{count}} Joer"
    }
  },
  xYears: {
    standalone: {
      one: "ee Joer",
      other: "{{count}} Joer"
    },
    withPreposition: {
      one: "engem Joer",
      other: "{{count}} Joer"
    }
  },
  overXYears: {
    standalone: {
      one: "méi wéi ee Joer",
      other: "méi wéi {{count}} Joer"
    },
    withPreposition: {
      one: "méi wéi engem Joer",
      other: "méi wéi {{count}} Joer"
    }
  },
  almostXYears: {
    standalone: {
      one: "bal ee Joer",
      other: "bal {{count}} Joer"
    },
    withPreposition: {
      one: "bal engem Joer",
      other: "bal {{count}} Joer"
    }
  }
};
var EXCEPTION_CONSONANTS = ["d", "h", "n", "t", "z"];
var VOWELS = ["a,", "e", "i", "o", "u"];
var DIGITS_SPOKEN_N_NEEDED = [0, 1, 2, 3, 8, 9];
var FIRST_TWO_DIGITS_SPOKEN_NO_N_NEEDED = [40, 50, 60, 70];
function isFinalNNeeded(nextWords) {
  const firstLetter = nextWords.charAt(0).toLowerCase();
  if (VOWELS.indexOf(firstLetter) != -1 || EXCEPTION_CONSONANTS.indexOf(firstLetter) != -1) {
    return true;
  }
  const firstWord = nextWords.split(" ")[0];
  const number2 = parseInt(firstWord);
  if (!isNaN(number2) && DIGITS_SPOKEN_N_NEEDED.indexOf(number2 % 10) != -1 && FIRST_TWO_DIGITS_SPOKEN_NO_N_NEEDED.indexOf(
    parseInt(firstWord.substring(0, 2))
  ) == -1) {
    return true;
  }
  return false;
}
var formatDistance51 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale49[token];
  const usageGroup = (options2 == null ? void 0 : options2.addSuffix) ? tokenValue.withPreposition : tokenValue.standalone;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else {
    result = usageGroup.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "a" + (isFinalNNeeded(result) ? "n" : "") + " " + result;
    } else {
      return "viru" + (isFinalNNeeded(result) ? "n" : "") + " " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/lb/_lib/formatLong.mjs
var dateFormats58 = {
  full: "EEEE, do MMMM y",
  // Méindeg, 7. Januar 2018
  long: "do MMMM y",
  // 7. Januar 2018
  medium: "do MMM y",
  // 7. Jan 2018
  short: "dd.MM.yy"
  // 07.01.18
};
var timeFormats58 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats58 = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong58 = {
  date: buildFormatLongFn({
    formats: dateFormats58,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats58,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats58,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/lb/_lib/formatRelative.mjs
var formatRelativeLocale50 = {
  lastWeek: (date2) => {
    const day = date2.getDay();
    let result = "'läschte";
    if (day === 2 || day === 4) {
      result += "n";
    }
    result += "' eeee 'um' p";
    return result;
  },
  yesterday: "'gëschter um' p",
  today: "'haut um' p",
  tomorrow: "'moien um' p",
  nextWeek: "eeee 'um' p",
  other: "P"
};
var formatRelative50 = (token, date2, _baseDate, _options) => {
  const format3 = formatRelativeLocale50[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/lb/_lib/localize.mjs
var eraValues50 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["viru Christus", "no Christus"]
};
var quarterValues50 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
var monthValues50 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mäe",
    "Abr",
    "Mee",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez"
  ],
  wide: [
    "Januar",
    "Februar",
    "Mäerz",
    "Abrëll",
    "Mee",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember"
  ]
};
var dayValues50 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mé", "Dë", "Më", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mé.", "Dë.", "Më.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonndeg",
    "Méindeg",
    "Dënschdeg",
    "Mëttwoch",
    "Donneschdeg",
    "Freideg",
    "Samschdeg"
  ]
};
var dayPeriodValues50 = {
  narrow: {
    am: "mo.",
    pm: "nomë.",
    midnight: "Mëtternuecht",
    noon: "Mëtteg",
    morning: "Moien",
    afternoon: "Nomëtteg",
    evening: "Owend",
    night: "Nuecht"
  },
  abbreviated: {
    am: "moies",
    pm: "nomëttes",
    midnight: "Mëtternuecht",
    noon: "Mëtteg",
    morning: "Moien",
    afternoon: "Nomëtteg",
    evening: "Owend",
    night: "Nuecht"
  },
  wide: {
    am: "moies",
    pm: "nomëttes",
    midnight: "Mëtternuecht",
    noon: "Mëtteg",
    morning: "Moien",
    afternoon: "Nomëtteg",
    evening: "Owend",
    night: "Nuecht"
  }
};
var formattingDayPeriodValues42 = {
  narrow: {
    am: "mo.",
    pm: "nom.",
    midnight: "Mëtternuecht",
    noon: "mëttes",
    morning: "moies",
    afternoon: "nomëttes",
    evening: "owes",
    night: "nuets"
  },
  abbreviated: {
    am: "moies",
    pm: "nomëttes",
    midnight: "Mëtternuecht",
    noon: "mëttes",
    morning: "moies",
    afternoon: "nomëttes",
    evening: "owes",
    night: "nuets"
  },
  wide: {
    am: "moies",
    pm: "nomëttes",
    midnight: "Mëtternuecht",
    noon: "mëttes",
    morning: "moies",
    afternoon: "nomëttes",
    evening: "owes",
    night: "nuets"
  }
};
var ordinalNumber50 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize50 = {
  ordinalNumber: ordinalNumber50,
  era: buildLocalizeFn({
    values: eraValues50,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues50,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues50,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues50,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues50,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues42,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/lb/_lib/match.mjs
var matchOrdinalNumberPattern49 = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern49 = /\d+/i;
var matchEraPatterns49 = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(viru Christus|virun eiser Zäitrechnung|no Christus|eiser Zäitrechnung)/i
};
var parseEraPatterns49 = {
  any: [/^v/i, /^n/i]
};
var matchQuarterPatterns49 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
var parseQuarterPatterns49 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns49 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mäe|abr|mee|jun|jul|aug|sep|okt|nov|dez)/i,
  wide: /^(januar|februar|mäerz|abrëll|mee|juni|juli|august|september|oktober|november|dezember)/i
};
var parseMonthPatterns49 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mä/i,
    /^ab/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns49 = {
  narrow: /^[smdf]/i,
  short: /^(so|mé|dë|më|do|fr|sa)/i,
  abbreviated: /^(son?|méi?|dën?|mët?|don?|fre?|sam?)\.?/i,
  wide: /^(sonndeg|méindeg|dënschdeg|mëttwoch|donneschdeg|freideg|samschdeg)/i
};
var parseDayPatterns49 = {
  any: [/^so/i, /^mé/i, /^dë/i, /^më/i, /^do/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns49 = {
  narrow: /^(mo\.?|nomë\.?|Mëtternuecht|mëttes|moies|nomëttes|owes|nuets)/i,
  abbreviated: /^(moi\.?|nomët\.?|Mëtternuecht|mëttes|moies|nomëttes|owes|nuets)/i,
  wide: /^(moies|nomëttes|Mëtternuecht|mëttes|moies|nomëttes|owes|nuets)/i
};
var parseDayPeriodPatterns49 = {
  any: {
    am: /^m/i,
    pm: /^n/i,
    midnight: /^Mëtter/i,
    noon: /^mëttes/i,
    morning: /moies/i,
    afternoon: /nomëttes/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /owes/i,
    night: /nuets/i
    // will never be matched. Night is matched by `pm`
  }
};
var match49 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern49,
    parsePattern: parseOrdinalNumberPattern49,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns49,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns49,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns49,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns49,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns49,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns49,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns49,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns49,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns49,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns49,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/lb.mjs
var lb = {
  code: "lb",
  formatDistance: formatDistance51,
  formatLong: formatLong58,
  formatRelative: formatRelative50,
  localize: localize50,
  match: match49,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/lt/_lib/formatDistance.mjs
var translations2 = {
  xseconds_other: "sekundė_sekundžių_sekundes",
  xminutes_one: "minutė_minutės_minutę",
  xminutes_other: "minutės_minučių_minutes",
  xhours_one: "valanda_valandos_valandą",
  xhours_other: "valandos_valandų_valandas",
  xdays_one: "diena_dienos_dieną",
  xdays_other: "dienos_dienų_dienas",
  xweeks_one: "savaitė_savaitės_savaitę",
  xweeks_other: "savaitės_savaičių_savaites",
  xmonths_one: "mėnuo_mėnesio_mėnesį",
  xmonths_other: "mėnesiai_mėnesių_mėnesius",
  xyears_one: "metai_metų_metus",
  xyears_other: "metai_metų_metus",
  about: "apie",
  over: "daugiau nei",
  almost: "beveik",
  lessthan: "mažiau nei"
};
var translateSeconds = (_number, addSuffix, _key, isFuture) => {
  if (!addSuffix) {
    return "kelios sekundės";
  } else {
    return isFuture ? "kelių sekundžių" : "kelias sekundes";
  }
};
var translateSingular = (_number, addSuffix, key, isFuture) => {
  return !addSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
};
var translate = (number2, addSuffix, key, isFuture) => {
  const result = number2 + " ";
  if (number2 === 1) {
    return result + translateSingular(number2, addSuffix, key, isFuture);
  } else if (!addSuffix) {
    return result + (special(number2) ? forms(key)[1] : forms(key)[0]);
  } else {
    if (isFuture) {
      return result + forms(key)[1];
    } else {
      return result + (special(number2) ? forms(key)[1] : forms(key)[2]);
    }
  }
};
function special(number2) {
  return number2 % 10 === 0 || number2 > 10 && number2 < 20;
}
function forms(key) {
  return translations2[key].split("_");
}
var formatDistanceLocale50 = {
  lessThanXSeconds: {
    one: translateSeconds,
    other: translate
  },
  xSeconds: {
    one: translateSeconds,
    other: translate
  },
  halfAMinute: "pusė minutės",
  lessThanXMinutes: {
    one: translateSingular,
    other: translate
  },
  xMinutes: {
    one: translateSingular,
    other: translate
  },
  aboutXHours: {
    one: translateSingular,
    other: translate
  },
  xHours: {
    one: translateSingular,
    other: translate
  },
  xDays: {
    one: translateSingular,
    other: translate
  },
  aboutXWeeks: {
    one: translateSingular,
    other: translate
  },
  xWeeks: {
    one: translateSingular,
    other: translate
  },
  aboutXMonths: {
    one: translateSingular,
    other: translate
  },
  xMonths: {
    one: translateSingular,
    other: translate
  },
  aboutXYears: {
    one: translateSingular,
    other: translate
  },
  xYears: {
    one: translateSingular,
    other: translate
  },
  overXYears: {
    one: translateSingular,
    other: translate
  },
  almostXYears: {
    one: translateSingular,
    other: translate
  }
};
var formatDistance52 = (token, count, options2) => {
  const adverb = token.match(/about|over|almost|lessthan/i);
  const unit = adverb ? token.replace(adverb[0], "") : token;
  const isFuture = (options2 == null ? void 0 : options2.comparison) !== void 0 && options2.comparison > 0;
  let result;
  const tokenValue = formatDistanceLocale50[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one(
      count,
      (options2 == null ? void 0 : options2.addSuffix) === true,
      unit.toLowerCase() + "_one",
      isFuture
    );
  } else {
    result = tokenValue.other(
      count,
      (options2 == null ? void 0 : options2.addSuffix) === true,
      unit.toLowerCase() + "_other",
      isFuture
    );
  }
  if (adverb) {
    const key = adverb[0].toLowerCase();
    result = translations2[key] + " " + result;
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "po " + result;
    } else {
      return "prieš " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/lt/_lib/formatLong.mjs
var dateFormats59 = {
  full: "y 'm'. MMMM d 'd'., EEEE",
  long: "y 'm'. MMMM d 'd'.",
  medium: "y-MM-dd",
  short: "y-MM-dd"
};
var timeFormats59 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats59 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong59 = {
  date: buildFormatLongFn({
    formats: dateFormats59,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats59,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats59,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/lt/_lib/formatRelative.mjs
var formatRelativeLocale51 = {
  lastWeek: "'Praėjusį' eeee p",
  yesterday: "'Vakar' p",
  today: "'Šiandien' p",
  tomorrow: "'Rytoj' p",
  nextWeek: "eeee p",
  other: "P"
};
var formatRelative51 = (token, _date, _baseDate, _options) => formatRelativeLocale51[token];

// ../../../node_modules/date-fns/locale/lt/_lib/localize.mjs
var eraValues51 = {
  narrow: ["pr. Kr.", "po Kr."],
  abbreviated: ["pr. Kr.", "po Kr."],
  wide: ["prieš Kristų", "po Kristaus"]
};
var quarterValues51 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I ketv.", "II ketv.", "III ketv.", "IV ketv."],
  wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"]
};
var formattingQuarterValues2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I k.", "II k.", "III k.", "IV k."],
  wide: ["I ketvirtis", "II ketvirtis", "III ketvirtis", "IV ketvirtis"]
};
var monthValues51 = {
  narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
  abbreviated: [
    "saus.",
    "vas.",
    "kov.",
    "bal.",
    "geg.",
    "birž.",
    "liep.",
    "rugp.",
    "rugs.",
    "spal.",
    "lapkr.",
    "gruod."
  ],
  wide: [
    "sausis",
    "vasaris",
    "kovas",
    "balandis",
    "gegužė",
    "birželis",
    "liepa",
    "rugpjūtis",
    "rugsėjis",
    "spalis",
    "lapkritis",
    "gruodis"
  ]
};
var formattingMonthValues11 = {
  narrow: ["S", "V", "K", "B", "G", "B", "L", "R", "R", "S", "L", "G"],
  abbreviated: [
    "saus.",
    "vas.",
    "kov.",
    "bal.",
    "geg.",
    "birž.",
    "liep.",
    "rugp.",
    "rugs.",
    "spal.",
    "lapkr.",
    "gruod."
  ],
  wide: [
    "sausio",
    "vasario",
    "kovo",
    "balandžio",
    "gegužės",
    "birželio",
    "liepos",
    "rugpjūčio",
    "rugsėjo",
    "spalio",
    "lapkričio",
    "gruodžio"
  ]
};
var dayValues51 = {
  narrow: ["S", "P", "A", "T", "K", "P", "Š"],
  short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "Št"],
  abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "št"],
  wide: [
    "sekmadienis",
    "pirmadienis",
    "antradienis",
    "trečiadienis",
    "ketvirtadienis",
    "penktadienis",
    "šeštadienis"
  ]
};
var formattingDayValues2 = {
  narrow: ["S", "P", "A", "T", "K", "P", "Š"],
  short: ["Sk", "Pr", "An", "Tr", "Kt", "Pn", "Št"],
  abbreviated: ["sk", "pr", "an", "tr", "kt", "pn", "št"],
  wide: [
    "sekmadienį",
    "pirmadienį",
    "antradienį",
    "trečiadienį",
    "ketvirtadienį",
    "penktadienį",
    "šeštadienį"
  ]
};
var dayPeriodValues51 = {
  narrow: {
    am: "pr. p.",
    pm: "pop.",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis"
  },
  abbreviated: {
    am: "priešpiet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis"
  },
  wide: {
    am: "priešpiet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "vidurdienis",
    morning: "rytas",
    afternoon: "diena",
    evening: "vakaras",
    night: "naktis"
  }
};
var formattingDayPeriodValues43 = {
  narrow: {
    am: "pr. p.",
    pm: "pop.",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popietė",
    evening: "vakaras",
    night: "naktis"
  },
  abbreviated: {
    am: "priešpiet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popietė",
    evening: "vakaras",
    night: "naktis"
  },
  wide: {
    am: "priešpiet",
    pm: "popiet",
    midnight: "vidurnaktis",
    noon: "perpiet",
    morning: "rytas",
    afternoon: "popietė",
    evening: "vakaras",
    night: "naktis"
  }
};
var ordinalNumber51 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "-oji";
};
var localize51 = {
  ordinalNumber: ordinalNumber51,
  era: buildLocalizeFn({
    values: eraValues51,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues51,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues2,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues51,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues11,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues51,
    defaultWidth: "wide",
    formattingValues: formattingDayValues2,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues51,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues43,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/lt/_lib/match.mjs
var matchOrdinalNumberPattern50 = /^(\d+)(-oji)?/i;
var parseOrdinalNumberPattern50 = /\d+/i;
var matchEraPatterns50 = {
  narrow: /^p(r|o)\.?\s?(kr\.?|me)/i,
  abbreviated: /^(pr\.\s?(kr\.|m\.\s?e\.)|po\s?kr\.|mūsų eroje)/i,
  wide: /^(prieš Kristų|prieš mūsų erą|po Kristaus|mūsų eroje)/i
};
var parseEraPatterns50 = {
  wide: [/prieš/i, /(po|mūsų)/i],
  any: [/^pr/i, /^(po|m)/i]
};
var matchQuarterPatterns50 = {
  narrow: /^([1234])/i,
  abbreviated: /^(I|II|III|IV)\s?ketv?\.?/i,
  wide: /^(I|II|III|IV)\s?ketvirtis/i
};
var parseQuarterPatterns50 = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [/I$/i, /II$/i, /III/i, /IV/i]
};
var matchMonthPatterns50 = {
  narrow: /^[svkbglr]/i,
  abbreviated: /^(saus\.|vas\.|kov\.|bal\.|geg\.|birž\.|liep\.|rugp\.|rugs\.|spal\.|lapkr\.|gruod\.)/i,
  wide: /^(sausi(s|o)|vasari(s|o)|kov(a|o)s|balandž?i(s|o)|gegužės?|birželi(s|o)|liep(a|os)|rugpjū(t|č)i(s|o)|rugsėj(is|o)|spali(s|o)|lapkri(t|č)i(s|o)|gruodž?i(s|o))/i
};
var parseMonthPatterns50 = {
  narrow: [
    /^s/i,
    /^v/i,
    /^k/i,
    /^b/i,
    /^g/i,
    /^b/i,
    /^l/i,
    /^r/i,
    /^r/i,
    /^s/i,
    /^l/i,
    /^g/i
  ],
  any: [
    /^saus/i,
    /^vas/i,
    /^kov/i,
    /^bal/i,
    /^geg/i,
    /^birž/i,
    /^liep/i,
    /^rugp/i,
    /^rugs/i,
    /^spal/i,
    /^lapkr/i,
    /^gruod/i
  ]
};
var matchDayPatterns50 = {
  narrow: /^[spatkš]/i,
  short: /^(sk|pr|an|tr|kt|pn|št)/i,
  abbreviated: /^(sk|pr|an|tr|kt|pn|št)/i,
  wide: /^(sekmadien(is|į)|pirmadien(is|į)|antradien(is|į)|trečiadien(is|į)|ketvirtadien(is|į)|penktadien(is|į)|šeštadien(is|į))/i
};
var parseDayPatterns50 = {
  narrow: [/^s/i, /^p/i, /^a/i, /^t/i, /^k/i, /^p/i, /^š/i],
  wide: [/^se/i, /^pi/i, /^an/i, /^tr/i, /^ke/i, /^pe/i, /^še/i],
  any: [/^sk/i, /^pr/i, /^an/i, /^tr/i, /^kt/i, /^pn/i, /^št/i]
};
var matchDayPeriodPatterns50 = {
  narrow: /^(pr.\s?p.|pop.|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popietė)|vakaras|naktis)/i,
  any: /^(priešpiet|popiet$|vidurnaktis|(vidurdienis|perpiet)|rytas|(diena|popietė)|vakaras|naktis)/i
};
var parseDayPeriodPatterns50 = {
  narrow: {
    am: /^pr/i,
    pm: /^pop./i,
    midnight: /^vidurnaktis/i,
    noon: /^(vidurdienis|perp)/i,
    morning: /rytas/i,
    afternoon: /(die|popietė)/i,
    evening: /vakaras/i,
    night: /naktis/i
  },
  any: {
    am: /^pr/i,
    pm: /^popiet$/i,
    midnight: /^vidurnaktis/i,
    noon: /^(vidurdienis|perp)/i,
    morning: /rytas/i,
    afternoon: /(die|popietė)/i,
    evening: /vakaras/i,
    night: /naktis/i
  }
};
var match50 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern50,
    parsePattern: parseOrdinalNumberPattern50,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns50,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns50,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns50,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns50,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns50,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns50,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns50,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns50,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns50,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns50,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/lt.mjs
var lt = {
  code: "lt",
  formatDistance: formatDistance52,
  formatLong: formatLong59,
  formatRelative: formatRelative51,
  localize: localize51,
  match: match50,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/lv/_lib/formatDistance.mjs
function buildLocalizeTokenFn3(schema2) {
  return (count, options2) => {
    if (count === 1) {
      if (options2 == null ? void 0 : options2.addSuffix) {
        return schema2.one[0].replace("{{time}}", schema2.one[2]);
      } else {
        return schema2.one[0].replace("{{time}}", schema2.one[1]);
      }
    } else {
      const rem = count % 10 === 1 && count % 100 !== 11;
      if (options2 == null ? void 0 : options2.addSuffix) {
        return schema2.other[0].replace("{{time}}", rem ? schema2.other[3] : schema2.other[4]).replace("{{count}}", String(count));
      } else {
        return schema2.other[0].replace("{{time}}", rem ? schema2.other[1] : schema2.other[2]).replace("{{count}}", String(count));
      }
    }
  };
}
var formatDistanceLocale51 = {
  lessThanXSeconds: buildLocalizeTokenFn3({
    one: ["mazāk par {{time}}", "sekundi", "sekundi"],
    other: [
      "mazāk nekā {{count}} {{time}}",
      "sekunde",
      "sekundes",
      "sekundes",
      "sekundēm"
    ]
  }),
  xSeconds: buildLocalizeTokenFn3({
    one: ["1 {{time}}", "sekunde", "sekundes"],
    other: [
      "{{count}} {{time}}",
      "sekunde",
      "sekundes",
      "sekundes",
      "sekundēm"
    ]
  }),
  halfAMinute: (_count, options2) => {
    if (options2 == null ? void 0 : options2.addSuffix) {
      return "pusminūtes";
    } else {
      return "pusminūte";
    }
  },
  lessThanXMinutes: buildLocalizeTokenFn3({
    one: ["mazāk par {{time}}", "minūti", "minūti"],
    other: [
      "mazāk nekā {{count}} {{time}}",
      "minūte",
      "minūtes",
      "minūtes",
      "minūtēm"
    ]
  }),
  xMinutes: buildLocalizeTokenFn3({
    one: ["1 {{time}}", "minūte", "minūtes"],
    other: ["{{count}} {{time}}", "minūte", "minūtes", "minūtes", "minūtēm"]
  }),
  aboutXHours: buildLocalizeTokenFn3({
    one: ["apmēram 1 {{time}}", "stunda", "stundas"],
    other: [
      "apmēram {{count}} {{time}}",
      "stunda",
      "stundas",
      "stundas",
      "stundām"
    ]
  }),
  xHours: buildLocalizeTokenFn3({
    one: ["1 {{time}}", "stunda", "stundas"],
    other: ["{{count}} {{time}}", "stunda", "stundas", "stundas", "stundām"]
  }),
  xDays: buildLocalizeTokenFn3({
    one: ["1 {{time}}", "diena", "dienas"],
    other: ["{{count}} {{time}}", "diena", "dienas", "dienas", "dienām"]
  }),
  aboutXWeeks: buildLocalizeTokenFn3({
    one: ["apmēram 1 {{time}}", "nedēļa", "nedēļas"],
    other: [
      "apmēram {{count}} {{time}}",
      "nedēļa",
      "nedēļu",
      "nedēļas",
      "nedēļām"
    ]
  }),
  xWeeks: buildLocalizeTokenFn3({
    one: ["1 {{time}}", "nedēļa", "nedēļas"],
    other: [
      "{{count}} {{time}}",
      // TODO
      "nedēļa",
      "nedēļu",
      "nedēļas",
      "nedēļām"
    ]
  }),
  aboutXMonths: buildLocalizeTokenFn3({
    one: ["apmēram 1 {{time}}", "mēnesis", "mēneša"],
    other: [
      "apmēram {{count}} {{time}}",
      "mēnesis",
      "mēneši",
      "mēneša",
      "mēnešiem"
    ]
  }),
  xMonths: buildLocalizeTokenFn3({
    one: ["1 {{time}}", "mēnesis", "mēneša"],
    other: ["{{count}} {{time}}", "mēnesis", "mēneši", "mēneša", "mēnešiem"]
  }),
  aboutXYears: buildLocalizeTokenFn3({
    one: ["apmēram 1 {{time}}", "gads", "gada"],
    other: ["apmēram {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
  }),
  xYears: buildLocalizeTokenFn3({
    one: ["1 {{time}}", "gads", "gada"],
    other: ["{{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
  }),
  overXYears: buildLocalizeTokenFn3({
    one: ["ilgāk par 1 {{time}}", "gadu", "gadu"],
    other: ["vairāk nekā {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
  }),
  almostXYears: buildLocalizeTokenFn3({
    one: ["gandrīz 1 {{time}}", "gads", "gada"],
    other: ["vairāk nekā {{count}} {{time}}", "gads", "gadi", "gada", "gadiem"]
  })
};
var formatDistance53 = (token, count, options2) => {
  const result = formatDistanceLocale51[token](count, options2);
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "pēc " + result;
    } else {
      return "pirms " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/lv/_lib/formatLong.mjs
var dateFormats60 = {
  full: "EEEE, y. 'gada' d. MMMM",
  long: "y. 'gada' d. MMMM",
  medium: "dd.MM.y.",
  short: "dd.MM.y."
};
var timeFormats60 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats60 = {
  full: "{{date}} 'plkst.' {{time}}",
  long: "{{date}} 'plkst.' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong60 = {
  date: buildFormatLongFn({
    formats: dateFormats60,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats60,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats60,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/lv/_lib/formatRelative.mjs
var weekdays3 = [
  "svētdienā",
  "pirmdienā",
  "otrdienā",
  "trešdienā",
  "ceturtdienā",
  "piektdienā",
  "sestdienā"
];
var formatRelativeLocale52 = {
  lastWeek: (date2, baseDate, options2) => {
    if (isSameWeek(date2, baseDate, options2)) {
      return "eeee 'plkst.' p";
    }
    const weekday = weekdays3[date2.getDay()];
    return "'Pagājušā " + weekday + " plkst.' p";
  },
  yesterday: "'Vakar plkst.' p",
  today: "'Šodien plkst.' p",
  tomorrow: "'Rīt plkst.' p",
  nextWeek: (date2, baseDate, options2) => {
    if (isSameWeek(date2, baseDate, options2)) {
      return "eeee 'plkst.' p";
    }
    const weekday = weekdays3[date2.getDay()];
    return "'Nākamajā " + weekday + " plkst.' p";
  },
  other: "P"
};
var formatRelative52 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale52[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/lv/_lib/localize.mjs
var eraValues52 = {
  narrow: ["p.m.ē", "m.ē"],
  abbreviated: ["p. m. ē.", "m. ē."],
  wide: ["pirms mūsu ēras", "mūsu ērā"]
};
var quarterValues52 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. cet.", "2. cet.", "3. cet.", "4. cet."],
  wide: [
    "pirmais ceturksnis",
    "otrais ceturksnis",
    "trešais ceturksnis",
    "ceturtais ceturksnis"
  ]
};
var formattingQuarterValues3 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. cet.", "2. cet.", "3. cet.", "4. cet."],
  wide: [
    "pirmajā ceturksnī",
    "otrajā ceturksnī",
    "trešajā ceturksnī",
    "ceturtajā ceturksnī"
  ]
};
var monthValues52 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "febr.",
    "marts",
    "apr.",
    "maijs",
    "jūn.",
    "jūl.",
    "aug.",
    "sept.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "janvāris",
    "februāris",
    "marts",
    "aprīlis",
    "maijs",
    "jūnijs",
    "jūlijs",
    "augusts",
    "septembris",
    "oktobris",
    "novembris",
    "decembris"
  ]
};
var formattingMonthValues12 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "janv.",
    "febr.",
    "martā",
    "apr.",
    "maijs",
    "jūn.",
    "jūl.",
    "aug.",
    "sept.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "janvārī",
    "februārī",
    "martā",
    "aprīlī",
    "maijā",
    "jūnijā",
    "jūlijā",
    "augustā",
    "septembrī",
    "oktobrī",
    "novembrī",
    "decembrī"
  ]
};
var dayValues52 = {
  narrow: ["S", "P", "O", "T", "C", "P", "S"],
  short: ["Sv", "P", "O", "T", "C", "Pk", "S"],
  abbreviated: [
    "svētd.",
    "pirmd.",
    "otrd.",
    "trešd.",
    "ceturtd.",
    "piektd.",
    "sestd."
  ],
  wide: [
    "svētdiena",
    "pirmdiena",
    "otrdiena",
    "trešdiena",
    "ceturtdiena",
    "piektdiena",
    "sestdiena"
  ]
};
var formattingDayValues3 = {
  narrow: ["S", "P", "O", "T", "C", "P", "S"],
  short: ["Sv", "P", "O", "T", "C", "Pk", "S"],
  abbreviated: [
    "svētd.",
    "pirmd.",
    "otrd.",
    "trešd.",
    "ceturtd.",
    "piektd.",
    "sestd."
  ],
  wide: [
    "svētdienā",
    "pirmdienā",
    "otrdienā",
    "trešdienā",
    "ceturtdienā",
    "piektdienā",
    "sestdienā"
  ]
};
var dayPeriodValues52 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rīts",
    afternoon: "diena",
    evening: "vakars",
    night: "nakts"
  },
  abbreviated: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rīts",
    afternoon: "pēcpusd.",
    evening: "vakars",
    night: "nakts"
  },
  wide: {
    am: "am",
    pm: "pm",
    midnight: "pusnakts",
    noon: "pusdienlaiks",
    morning: "rīts",
    afternoon: "pēcpusdiena",
    evening: "vakars",
    night: "nakts"
  }
};
var formattingDayPeriodValues44 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rītā",
    afternoon: "dienā",
    evening: "vakarā",
    night: "naktī"
  },
  abbreviated: {
    am: "am",
    pm: "pm",
    midnight: "pusn.",
    noon: "pusd.",
    morning: "rītā",
    afternoon: "pēcpusd.",
    evening: "vakarā",
    night: "naktī"
  },
  wide: {
    am: "am",
    pm: "pm",
    midnight: "pusnaktī",
    noon: "pusdienlaikā",
    morning: "rītā",
    afternoon: "pēcpusdienā",
    evening: "vakarā",
    night: "naktī"
  }
};
var ordinalNumber52 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize52 = {
  ordinalNumber: ordinalNumber52,
  era: buildLocalizeFn({
    values: eraValues52,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues52,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues3,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues52,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues12,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues52,
    defaultWidth: "wide",
    formattingValues: formattingDayValues3,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues52,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues44,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/lv/_lib/match.mjs
var matchOrdinalNumberPattern51 = /^(\d+)\./i;
var parseOrdinalNumberPattern51 = /\d+/i;
var matchEraPatterns51 = {
  narrow: /^(p\.m\.ē|m\.ē)/i,
  abbreviated: /^(p\. m\. ē\.|m\. ē\.)/i,
  wide: /^(pirms mūsu ēras|mūsu ērā)/i
};
var parseEraPatterns51 = {
  any: [/^p/i, /^m/i]
};
var matchQuarterPatterns51 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](\. cet\.)/i,
  wide: /^(pirma(is|jā)|otra(is|jā)|treša(is|jā)|ceturta(is|jā)) ceturksn(is|ī)/i
};
var parseQuarterPatterns51 = {
  narrow: [/^1/i, /^2/i, /^3/i, /^4/i],
  abbreviated: [/^1/i, /^2/i, /^3/i, /^4/i],
  wide: [/^p/i, /^o/i, /^t/i, /^c/i]
};
var matchMonthPatterns51 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(janv\.|febr\.|marts|apr\.|maijs|jūn\.|jūl\.|aug\.|sept\.|okt\.|nov\.|dec\.)/i,
  wide: /^(janvār(is|ī)|februār(is|ī)|mart[sā]|aprīl(is|ī)|maij[sā]|jūnij[sā]|jūlij[sā]|august[sā]|septembr(is|ī)|oktobr(is|ī)|novembr(is|ī)|decembr(is|ī))/i
};
var parseMonthPatterns51 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jūn/i,
    /^jūl/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns51 = {
  narrow: /^[spotc]/i,
  short: /^(sv|pi|o|t|c|pk|s)/i,
  abbreviated: /^(svētd\.|pirmd\.|otrd.\|trešd\.|ceturtd\.|piektd\.|sestd\.)/i,
  wide: /^(svētdien(a|ā)|pirmdien(a|ā)|otrdien(a|ā)|trešdien(a|ā)|ceturtdien(a|ā)|piektdien(a|ā)|sestdien(a|ā))/i
};
var parseDayPatterns51 = {
  narrow: [/^s/i, /^p/i, /^o/i, /^t/i, /^c/i, /^p/i, /^s/i],
  any: [/^sv/i, /^pi/i, /^o/i, /^t/i, /^c/i, /^p/i, /^se/i]
};
var matchDayPeriodPatterns51 = {
  narrow: /^(am|pm|pusn\.|pusd\.|rīt(s|ā)|dien(a|ā)|vakar(s|ā)|nakt(s|ī))/,
  abbreviated: /^(am|pm|pusn\.|pusd\.|rīt(s|ā)|pēcpusd\.|vakar(s|ā)|nakt(s|ī))/,
  wide: /^(am|pm|pusnakt(s|ī)|pusdienlaik(s|ā)|rīt(s|ā)|pēcpusdien(a|ā)|vakar(s|ā)|nakt(s|ī))/i
};
var parseDayPeriodPatterns51 = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^pusn/i,
    noon: /^pusd/i,
    morning: /^r/i,
    afternoon: /^(d|pēc)/i,
    evening: /^v/i,
    night: /^n/i
  }
};
var match51 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern51,
    parsePattern: parseOrdinalNumberPattern51,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns51,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns51,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns51,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns51,
    defaultParseWidth: "wide",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns51,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns51,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns51,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns51,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns51,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns51,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/lv.mjs
var lv = {
  code: "lv",
  formatDistance: formatDistance53,
  formatLong: formatLong60,
  formatRelative: formatRelative52,
  localize: localize52,
  match: match51,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/mk/_lib/formatDistance.mjs
var formatDistanceLocale52 = {
  lessThanXSeconds: {
    one: "помалку од секунда",
    other: "помалку од {{count}} секунди"
  },
  xSeconds: {
    one: "1 секунда",
    other: "{{count}} секунди"
  },
  halfAMinute: "половина минута",
  lessThanXMinutes: {
    one: "помалку од минута",
    other: "помалку од {{count}} минути"
  },
  xMinutes: {
    one: "1 минута",
    other: "{{count}} минути"
  },
  aboutXHours: {
    one: "околу 1 час",
    other: "околу {{count}} часа"
  },
  xHours: {
    one: "1 час",
    other: "{{count}} часа"
  },
  xDays: {
    one: "1 ден",
    other: "{{count}} дена"
  },
  aboutXWeeks: {
    one: "околу 1 недела",
    other: "околу {{count}} месеци"
  },
  xWeeks: {
    one: "1 недела",
    other: "{{count}} недели"
  },
  aboutXMonths: {
    one: "околу 1 месец",
    other: "околу {{count}} недели"
  },
  xMonths: {
    one: "1 месец",
    other: "{{count}} месеци"
  },
  aboutXYears: {
    one: "околу 1 година",
    other: "околу {{count}} години"
  },
  xYears: {
    one: "1 година",
    other: "{{count}} години"
  },
  overXYears: {
    one: "повеќе од 1 година",
    other: "повеќе од {{count}} години"
  },
  almostXYears: {
    one: "безмалку 1 година",
    other: "безмалку {{count}} години"
  }
};
var formatDistance54 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale52[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "за " + result;
    } else {
      return "пред " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/mk/_lib/formatLong.mjs
var dateFormats61 = {
  full: "EEEE, dd MMMM yyyy",
  long: "dd MMMM yyyy",
  medium: "dd MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats61 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "H:mm"
};
var dateTimeFormats61 = {
  any: "{{date}} {{time}}"
};
var formatLong61 = {
  date: buildFormatLongFn({
    formats: dateFormats61,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats61,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats61,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/mk/_lib/formatRelative.mjs
var weekdays4 = [
  "недела",
  "понеделник",
  "вторник",
  "среда",
  "четврток",
  "петок",
  "сабота"
];
function lastWeek6(day) {
  const weekday = weekdays4[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'минатата " + weekday + " во' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'минатиот " + weekday + " во' p";
  }
}
function thisWeek6(day) {
  const weekday = weekdays4[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'ова " + weekday + " вo' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'овој " + weekday + " вo' p";
  }
}
function nextWeek6(day) {
  const weekday = weekdays4[day];
  switch (day) {
    case 0:
    case 3:
    case 6:
      return "'следната " + weekday + " вo' p";
    case 1:
    case 2:
    case 4:
    case 5:
      return "'следниот " + weekday + " вo' p";
  }
}
var formatRelativeLocale53 = {
  lastWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek6(day);
    } else {
      return lastWeek6(day);
    }
  },
  yesterday: "'вчера во' p",
  today: "'денес во' p",
  tomorrow: "'утре во' p",
  nextWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek6(day);
    } else {
      return nextWeek6(day);
    }
  },
  other: "P"
};
var formatRelative53 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale53[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/mk/_lib/localize.mjs
var eraValues53 = {
  narrow: ["пр.н.е.", "н.е."],
  abbreviated: ["пред н. е.", "н. е."],
  wide: ["пред нашата ера", "нашата ера"]
};
var quarterValues53 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-ви кв.", "2-ри кв.", "3-ти кв.", "4-ти кв."],
  wide: ["1-ви квартал", "2-ри квартал", "3-ти квартал", "4-ти квартал"]
};
var monthValues53 = {
  abbreviated: [
    "јан",
    "фев",
    "мар",
    "апр",
    "мај",
    "јун",
    "јул",
    "авг",
    "септ",
    "окт",
    "ноем",
    "дек"
  ],
  wide: [
    "јануари",
    "февруари",
    "март",
    "април",
    "мај",
    "јуни",
    "јули",
    "август",
    "септември",
    "октомври",
    "ноември",
    "декември"
  ]
};
var dayValues53 = {
  narrow: ["Н", "П", "В", "С", "Ч", "П", "С"],
  short: ["не", "по", "вт", "ср", "че", "пе", "са"],
  abbreviated: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
  wide: [
    "недела",
    "понеделник",
    "вторник",
    "среда",
    "четврток",
    "петок",
    "сабота"
  ]
};
var dayPeriodValues53 = {
  wide: {
    am: "претпладне",
    pm: "попладне",
    midnight: "полноќ",
    noon: "напладне",
    morning: "наутро",
    afternoon: "попладне",
    evening: "навечер",
    night: "ноќе"
  }
};
var ordinalNumber53 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "-ви";
      case 2:
        return number2 + "-ри";
      case 7:
      case 8:
        return number2 + "-ми";
    }
  }
  return number2 + "-ти";
};
var localize53 = {
  ordinalNumber: ordinalNumber53,
  era: buildLocalizeFn({
    values: eraValues53,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues53,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues53,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues53,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues53,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/mk/_lib/match.mjs
var matchOrdinalNumberPattern52 = /^(\d+)(-?[врмт][и])?/i;
var parseOrdinalNumberPattern52 = /\d+/i;
var matchEraPatterns52 = {
  narrow: /^((пр)?н\.?\s?е\.?)/i,
  abbreviated: /^((пр)?н\.?\s?е\.?)/i,
  wide: /^(пред нашата ера|нашата ера)/i
};
var parseEraPatterns52 = {
  any: [/^п/i, /^н/i]
};
var matchQuarterPatterns52 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[врт]?и?)? кв.?/i,
  wide: /^[1234](-?[врт]?и?)? квартал/i
};
var parseQuarterPatterns52 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchDayPatterns52 = {
  narrow: /^[нпвсч]/i,
  short: /^(не|по|вт|ср|че|пе|са)/i,
  abbreviated: /^(нед|пон|вто|сре|чет|пет|саб)/i,
  wide: /^(недела|понеделник|вторник|среда|четврток|петок|сабота)/i
};
var parseDayPatterns52 = {
  narrow: [/^н/i, /^п/i, /^в/i, /^с/i, /^ч/i, /^п/i, /^с/i],
  any: [/^н[ед]/i, /^п[он]/i, /^вт/i, /^ср/i, /^ч[ет]/i, /^п[ет]/i, /^с[аб]/i]
};
var matchMonthPatterns52 = {
  abbreviated: /^(јан|фев|мар|апр|мај|јун|јул|авг|сеп|окт|ноем|дек)/i,
  wide: /^(јануари|февруари|март|април|мај|јуни|јули|август|септември|октомври|ноември|декември)/i
};
var parseMonthPatterns52 = {
  any: [
    /^ја/i,
    /^Ф/i,
    /^мар/i,
    /^ап/i,
    /^мај/i,
    /^јун/i,
    /^јул/i,
    /^ав/i,
    /^се/i,
    /^окт/i,
    /^но/i,
    /^де/i
  ]
};
var matchDayPeriodPatterns52 = {
  any: /^(претп|попл|полноќ|утро|пладне|вечер|ноќ)/i
};
var parseDayPeriodPatterns52 = {
  any: {
    am: /претпладне/i,
    pm: /попладне/i,
    midnight: /полноќ/i,
    noon: /напладне/i,
    morning: /наутро/i,
    afternoon: /попладне/i,
    evening: /навечер/i,
    night: /ноќе/i
  }
};
var match52 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern52,
    parsePattern: parseOrdinalNumberPattern52,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns52,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns52,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns52,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns52,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns52,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns52,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns52,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns52,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns52,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns52,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/mk.mjs
var mk = {
  code: "mk",
  formatDistance: formatDistance54,
  formatLong: formatLong61,
  formatRelative: formatRelative53,
  localize: localize53,
  match: match52,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/mn/_lib/formatDistance.mjs
var formatDistanceLocale53 = {
  lessThanXSeconds: {
    one: "секунд хүрэхгүй",
    other: "{{count}} секунд хүрэхгүй"
  },
  xSeconds: {
    one: "1 секунд",
    other: "{{count}} секунд"
  },
  halfAMinute: "хагас минут",
  lessThanXMinutes: {
    one: "минут хүрэхгүй",
    other: "{{count}} минут хүрэхгүй"
  },
  xMinutes: {
    one: "1 минут",
    other: "{{count}} минут"
  },
  aboutXHours: {
    one: "ойролцоогоор 1 цаг",
    other: "ойролцоогоор {{count}} цаг"
  },
  xHours: {
    one: "1 цаг",
    other: "{{count}} цаг"
  },
  xDays: {
    one: "1 өдөр",
    other: "{{count}} өдөр"
  },
  aboutXWeeks: {
    one: "ойролцоогоор 1 долоо хоног",
    other: "ойролцоогоор {{count}} долоо хоног"
  },
  xWeeks: {
    one: "1 долоо хоног",
    other: "{{count}} долоо хоног"
  },
  aboutXMonths: {
    one: "ойролцоогоор 1 сар",
    other: "ойролцоогоор {{count}} сар"
  },
  xMonths: {
    one: "1 сар",
    other: "{{count}} сар"
  },
  aboutXYears: {
    one: "ойролцоогоор 1 жил",
    other: "ойролцоогоор {{count}} жил"
  },
  xYears: {
    one: "1 жил",
    other: "{{count}} жил"
  },
  overXYears: {
    one: "1 жил гаран",
    other: "{{count}} жил гаран"
  },
  almostXYears: {
    one: "бараг 1 жил",
    other: "бараг {{count}} жил"
  }
};
var formatDistance55 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale53[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    const words = result.split(" ");
    const lastword = words.pop();
    result = words.join(" ");
    switch (lastword) {
      case "секунд":
        result += " секундийн";
        break;
      case "минут":
        result += " минутын";
        break;
      case "цаг":
        result += " цагийн";
        break;
      case "өдөр":
        result += " өдрийн";
        break;
      case "сар":
        result += " сарын";
        break;
      case "жил":
        result += " жилийн";
        break;
      case "хоног":
        result += " хоногийн";
        break;
      case "гаран":
        result += " гараны";
        break;
      case "хүрэхгүй":
        result += " хүрэхгүй хугацааны";
        break;
      default:
        result += lastword + "-н";
    }
    if (options2.comparison && options2.comparison > 0) {
      return result + " дараа";
    } else {
      return result + " өмнө";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/mn/_lib/formatLong.mjs
var dateFormats62 = {
  full: "y 'оны' MMMM'ын' d, EEEE 'гараг'",
  long: "y 'оны' MMMM'ын' d",
  medium: "y 'оны' MMM'ын' d",
  short: "y.MM.dd"
};
var timeFormats62 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats62 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong62 = {
  date: buildFormatLongFn({
    formats: dateFormats62,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats62,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats62,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/mn/_lib/formatRelative.mjs
var formatRelativeLocale54 = {
  lastWeek: "'өнгөрсөн' eeee 'гарагийн' p 'цагт'",
  yesterday: "'өчигдөр' p 'цагт'",
  today: "'өнөөдөр' p 'цагт'",
  tomorrow: "'маргааш' p 'цагт'",
  nextWeek: "'ирэх' eeee 'гарагийн' p 'цагт'",
  other: "P"
};
var formatRelative54 = (token, _date, _baseDate, _options) => formatRelativeLocale54[token];

// ../../../node_modules/date-fns/locale/mn/_lib/localize.mjs
var eraValues54 = {
  narrow: ["НТӨ", "НТ"],
  abbreviated: ["НТӨ", "НТ"],
  wide: ["нийтийн тооллын өмнөх", "нийтийн тооллын"]
};
var quarterValues54 = {
  narrow: ["I", "II", "III", "IV"],
  abbreviated: ["I улирал", "II улирал", "III улирал", "IV улирал"],
  wide: ["1-р улирал", "2-р улирал", "3-р улирал", "4-р улирал"]
};
var monthValues54 = {
  narrow: [
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX",
    "X",
    "XI",
    "XII"
  ],
  abbreviated: [
    "1-р сар",
    "2-р сар",
    "3-р сар",
    "4-р сар",
    "5-р сар",
    "6-р сар",
    "7-р сар",
    "8-р сар",
    "9-р сар",
    "10-р сар",
    "11-р сар",
    "12-р сар"
  ],
  wide: [
    "Нэгдүгээр сар",
    "Хоёрдугаар сар",
    "Гуравдугаар сар",
    "Дөрөвдүгээр сар",
    "Тавдугаар сар",
    "Зургаадугаар сар",
    "Долоодугаар сар",
    "Наймдугаар сар",
    "Есдүгээр сар",
    "Аравдугаар сар",
    "Арваннэгдүгээр сар",
    "Арван хоёрдугаар сар"
  ]
};
var formattingMonthValues13 = {
  narrow: [
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX",
    "X",
    "XI",
    "XII"
  ],
  abbreviated: [
    "1-р сар",
    "2-р сар",
    "3-р сар",
    "4-р сар",
    "5-р сар",
    "6-р сар",
    "7-р сар",
    "8-р сар",
    "9-р сар",
    "10-р сар",
    "11-р сар",
    "12-р сар"
  ],
  wide: [
    "нэгдүгээр сар",
    "хоёрдугаар сар",
    "гуравдугаар сар",
    "дөрөвдүгээр сар",
    "тавдугаар сар",
    "зургаадугаар сар",
    "долоодугаар сар",
    "наймдугаар сар",
    "есдүгээр сар",
    "аравдугаар сар",
    "арваннэгдүгээр сар",
    "арван хоёрдугаар сар"
  ]
};
var dayValues54 = {
  narrow: ["Н", "Д", "М", "Л", "П", "Б", "Б"],
  short: ["Ня", "Да", "Мя", "Лх", "Пү", "Ба", "Бя"],
  abbreviated: ["Ням", "Дав", "Мяг", "Лха", "Пүр", "Баа", "Бям"],
  wide: ["Ням", "Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба"]
};
var formattingDayValues4 = {
  narrow: ["Н", "Д", "М", "Л", "П", "Б", "Б"],
  short: ["Ня", "Да", "Мя", "Лх", "Пү", "Ба", "Бя"],
  abbreviated: ["Ням", "Дав", "Мяг", "Лха", "Пүр", "Баа", "Бям"],
  wide: ["ням", "даваа", "мягмар", "лхагва", "пүрэв", "баасан", "бямба"]
};
var dayPeriodValues54 = {
  narrow: {
    am: "ү.ө.",
    pm: "ү.х.",
    midnight: "шөнө дунд",
    noon: "үд дунд",
    morning: "өглөө",
    afternoon: "өдөр",
    evening: "орой",
    night: "шөнө"
  },
  abbreviated: {
    am: "ү.ө.",
    pm: "ү.х.",
    midnight: "шөнө дунд",
    noon: "үд дунд",
    morning: "өглөө",
    afternoon: "өдөр",
    evening: "орой",
    night: "шөнө"
  },
  wide: {
    am: "ү.ө.",
    pm: "ү.х.",
    midnight: "шөнө дунд",
    noon: "үд дунд",
    morning: "өглөө",
    afternoon: "өдөр",
    evening: "орой",
    night: "шөнө"
  }
};
var ordinalNumber54 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize54 = {
  ordinalNumber: ordinalNumber54,
  era: buildLocalizeFn({
    values: eraValues54,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues54,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues54,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues13,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues54,
    defaultWidth: "wide",
    formattingValues: formattingDayValues4,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues54,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/mn/_lib/match.mjs
var matchOrdinalNumberPattern53 = /\d+/i;
var parseOrdinalNumberPattern53 = /\d+/i;
var matchEraPatterns53 = {
  narrow: /^(нтө|нт)/i,
  abbreviated: /^(нтө|нт)/i,
  wide: /^(нийтийн тооллын өмнө|нийтийн тооллын)/i
};
var parseEraPatterns53 = {
  any: [/^(нтө|нийтийн тооллын өмнө)/i, /^(нт|нийтийн тооллын)/i]
};
var matchQuarterPatterns53 = {
  narrow: /^(iv|iii|ii|i)/i,
  abbreviated: /^(iv|iii|ii|i) улирал/i,
  wide: /^[1-4]-р улирал/i
};
var parseQuarterPatterns53 = {
  any: [/^(i(\s|$)|1)/i, /^(ii(\s|$)|2)/i, /^(iii(\s|$)|3)/i, /^(iv(\s|$)|4)/i]
};
var matchMonthPatterns53 = {
  narrow: /^(xii|xi|x|ix|viii|vii|vi|v|iv|iii|ii|i)/i,
  abbreviated: /^(1-р сар|2-р сар|3-р сар|4-р сар|5-р сар|6-р сар|7-р сар|8-р сар|9-р сар|10-р сар|11-р сар|12-р сар)/i,
  wide: /^(нэгдүгээр сар|хоёрдугаар сар|гуравдугаар сар|дөрөвдүгээр сар|тавдугаар сар|зургаадугаар сар|долоодугаар сар|наймдугаар сар|есдүгээр сар|аравдугаар сар|арван нэгдүгээр сар|арван хоёрдугаар сар)/i
};
var parseMonthPatterns53 = {
  narrow: [
    /^i$/i,
    /^ii$/i,
    /^iii$/i,
    /^iv$/i,
    /^v$/i,
    /^vi$/i,
    /^vii$/i,
    /^viii$/i,
    /^ix$/i,
    /^x$/i,
    /^xi$/i,
    /^xii$/i
  ],
  any: [
    /^(1|нэгдүгээр)/i,
    /^(2|хоёрдугаар)/i,
    /^(3|гуравдугаар)/i,
    /^(4|дөрөвдүгээр)/i,
    /^(5|тавдугаар)/i,
    /^(6|зургаадугаар)/i,
    /^(7|долоодугаар)/i,
    /^(8|наймдугаар)/i,
    /^(9|есдүгээр)/i,
    /^(10|аравдугаар)/i,
    /^(11|арван нэгдүгээр)/i,
    /^(12|арван хоёрдугаар)/i
  ]
};
var matchDayPatterns53 = {
  narrow: /^[ндмлпбб]/i,
  short: /^(ня|да|мя|лх|пү|ба|бя)/i,
  abbreviated: /^(ням|дав|мяг|лха|пүр|баа|бям)/i,
  wide: /^(ням|даваа|мягмар|лхагва|пүрэв|баасан|бямба)/i
};
var parseDayPatterns53 = {
  narrow: [/^н/i, /^д/i, /^м/i, /^л/i, /^п/i, /^б/i, /^б/i],
  any: [/^ня/i, /^да/i, /^мя/i, /^лх/i, /^пү/i, /^ба/i, /^бя/i]
};
var matchDayPeriodPatterns53 = {
  narrow: /^(ү\.ө\.|ү\.х\.|шөнө дунд|үд дунд|өглөө|өдөр|орой|шөнө)/i,
  any: /^(ү\.ө\.|ү\.х\.|шөнө дунд|үд дунд|өглөө|өдөр|орой|шөнө)/i
};
var parseDayPeriodPatterns53 = {
  any: {
    am: /^ү\.ө\./i,
    pm: /^ү\.х\./i,
    midnight: /^шөнө дунд/i,
    noon: /^үд дунд/i,
    morning: /өглөө/i,
    afternoon: /өдөр/i,
    evening: /орой/i,
    night: /шөнө/i
  }
};
var match53 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern53,
    parsePattern: parseOrdinalNumberPattern53,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns53,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns53,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns53,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns53,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns53,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns53,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns53,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns53,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns53,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns53,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/mn.mjs
var mn = {
  code: "mn",
  formatDistance: formatDistance55,
  formatLong: formatLong62,
  formatRelative: formatRelative54,
  localize: localize54,
  match: match53,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ms/_lib/formatDistance.mjs
var formatDistanceLocale54 = {
  lessThanXSeconds: {
    one: "kurang dari 1 saat",
    other: "kurang dari {{count}} saat"
  },
  xSeconds: {
    one: "1 saat",
    other: "{{count}} saat"
  },
  halfAMinute: "setengah minit",
  lessThanXMinutes: {
    one: "kurang dari 1 minit",
    other: "kurang dari {{count}} minit"
  },
  xMinutes: {
    one: "1 minit",
    other: "{{count}} minit"
  },
  aboutXHours: {
    one: "sekitar 1 jam",
    other: "sekitar {{count}} jam"
  },
  xHours: {
    one: "1 jam",
    other: "{{count}} jam"
  },
  xDays: {
    one: "1 hari",
    other: "{{count}} hari"
  },
  aboutXWeeks: {
    one: "sekitar 1 minggu",
    other: "sekitar {{count}} minggu"
  },
  xWeeks: {
    one: "1 minggu",
    other: "{{count}} minggu"
  },
  aboutXMonths: {
    one: "sekitar 1 bulan",
    other: "sekitar {{count}} bulan"
  },
  xMonths: {
    one: "1 bulan",
    other: "{{count}} bulan"
  },
  aboutXYears: {
    one: "sekitar 1 tahun",
    other: "sekitar {{count}} tahun"
  },
  xYears: {
    one: "1 tahun",
    other: "{{count}} tahun"
  },
  overXYears: {
    one: "lebih dari 1 tahun",
    other: "lebih dari {{count}} tahun"
  },
  almostXYears: {
    one: "hampir 1 tahun",
    other: "hampir {{count}} tahun"
  }
};
var formatDistance56 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale54[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "dalam masa " + result;
    } else {
      return result + " yang lalu";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ms/_lib/formatLong.mjs
var dateFormats63 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "d/M/yyyy"
};
var timeFormats63 = {
  full: "HH.mm.ss",
  long: "HH.mm.ss",
  medium: "HH.mm",
  short: "HH.mm"
};
var dateTimeFormats63 = {
  full: "{{date}} 'pukul' {{time}}",
  long: "{{date}} 'pukul' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong63 = {
  date: buildFormatLongFn({
    formats: dateFormats63,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats63,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats63,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ms/_lib/formatRelative.mjs
var formatRelativeLocale55 = {
  lastWeek: "eeee 'lepas pada jam' p",
  yesterday: "'Semalam pada jam' p",
  today: "'Hari ini pada jam' p",
  tomorrow: "'Esok pada jam' p",
  nextWeek: "eeee 'pada jam' p",
  other: "P"
};
var formatRelative55 = (token, _date, _baseDate, _options) => formatRelativeLocale55[token];

// ../../../node_modules/date-fns/locale/ms/_lib/localize.mjs
var eraValues55 = {
  narrow: ["SM", "M"],
  abbreviated: ["SM", "M"],
  wide: ["Sebelum Masihi", "Masihi"]
};
var quarterValues55 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["S1", "S2", "S3", "S4"],
  wide: ["Suku pertama", "Suku kedua", "Suku ketiga", "Suku keempat"]
};
var monthValues55 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "O", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mac",
    "Apr",
    "Mei",
    "Jun",
    "Jul",
    "Ogo",
    "Sep",
    "Okt",
    "Nov",
    "Dis"
  ],
  wide: [
    "Januari",
    "Februari",
    "Mac",
    "April",
    "Mei",
    "Jun",
    "Julai",
    "Ogos",
    "September",
    "Oktober",
    "November",
    "Disember"
  ]
};
var dayValues55 = {
  narrow: ["A", "I", "S", "R", "K", "J", "S"],
  short: ["Ahd", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
  abbreviated: ["Ahd", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
  wide: ["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
};
var dayPeriodValues55 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "tgh malam",
    noon: "tgh hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  }
};
var formattingDayPeriodValues45 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "tengah malam",
    noon: "tengah hari",
    morning: "pagi",
    afternoon: "tengah hari",
    evening: "petang",
    night: "malam"
  }
};
var ordinalNumber55 = (dirtyNumber, _options) => {
  return "ke-" + Number(dirtyNumber);
};
var localize55 = {
  ordinalNumber: ordinalNumber55,
  era: buildLocalizeFn({
    values: eraValues55,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues55,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues55,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues55,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues55,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues45,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ms/_lib/match.mjs
var matchOrdinalNumberPattern54 = /^ke-(\d+)?/i;
var parseOrdinalNumberPattern54 = /petama|\d+/i;
var matchEraPatterns54 = {
  narrow: /^(sm|m)/i,
  abbreviated: /^(s\.?\s?m\.?|m\.?)/i,
  wide: /^(sebelum masihi|masihi)/i
};
var parseEraPatterns54 = {
  any: [/^s/i, /^(m)/i]
};
var matchQuarterPatterns54 = {
  narrow: /^[1234]/i,
  abbreviated: /^S[1234]/i,
  wide: /Suku (pertama|kedua|ketiga|keempat)/i
};
var parseQuarterPatterns54 = {
  any: [/pertama|1/i, /kedua|2/i, /ketiga|3/i, /keempat|4/i]
};
var matchMonthPatterns54 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mac|apr|mei|jun|jul|ogo|sep|okt|nov|dis)/i,
  wide: /^(januari|februari|mac|april|mei|jun|julai|ogos|september|oktober|november|disember)/i
};
var parseMonthPatterns54 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^o/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^ma/i,
    /^ap/i,
    /^me/i,
    /^jun/i,
    /^jul/i,
    /^og/i,
    /^s/i,
    /^ok/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns54 = {
  narrow: /^[aisrkj]/i,
  short: /^(ahd|isn|sel|rab|kha|jum|sab)/i,
  abbreviated: /^(ahd|isn|sel|rab|kha|jum|sab)/i,
  wide: /^(ahad|isnin|selasa|rabu|khamis|jumaat|sabtu)/i
};
var parseDayPatterns54 = {
  narrow: [/^a/i, /^i/i, /^s/i, /^r/i, /^k/i, /^j/i, /^s/i],
  any: [/^a/i, /^i/i, /^se/i, /^r/i, /^k/i, /^j/i, /^sa/i]
};
var matchDayPeriodPatterns54 = {
  narrow: /^(am|pm|tengah malam|tengah hari|pagi|petang|malam)/i,
  any: /^([ap]\.?\s?m\.?|tengah malam|tengah hari|pagi|petang|malam)/i
};
var parseDayPeriodPatterns54 = {
  any: {
    am: /^a/i,
    pm: /^pm/i,
    midnight: /^tengah m/i,
    noon: /^tengah h/i,
    morning: /pa/i,
    afternoon: /tengah h/i,
    evening: /pe/i,
    night: /m/i
  }
};
var match54 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern54,
    parsePattern: parseOrdinalNumberPattern54,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns54,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns54,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns54,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns54,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns54,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns54,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns54,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns54,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns54,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns54,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ms.mjs
var ms = {
  code: "ms",
  formatDistance: formatDistance56,
  formatLong: formatLong63,
  formatRelative: formatRelative55,
  localize: localize55,
  match: match54,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/mt/_lib/formatDistance.mjs
var formatDistanceLocale55 = {
  lessThanXSeconds: {
    one: "inqas minn sekonda",
    other: "inqas minn {{count}} sekondi"
  },
  xSeconds: {
    one: "sekonda",
    other: "{{count}} sekondi"
  },
  halfAMinute: "nofs minuta",
  lessThanXMinutes: {
    one: "inqas minn minuta",
    other: "inqas minn {{count}} minuti"
  },
  xMinutes: {
    one: "minuta",
    other: "{{count}} minuti"
  },
  aboutXHours: {
    one: "madwar siegħa",
    other: "madwar {{count}} siegħat"
  },
  xHours: {
    one: "siegħa",
    other: "{{count}} siegħat"
  },
  xDays: {
    one: "ġurnata",
    other: "{{count}} ġranet"
  },
  aboutXWeeks: {
    one: "madwar ġimgħa",
    other: "madwar {{count}} ġimgħat"
  },
  xWeeks: {
    one: "ġimgħa",
    other: "{{count}} ġimgħat"
  },
  aboutXMonths: {
    one: "madwar xahar",
    other: "madwar {{count}} xhur"
  },
  xMonths: {
    one: "xahar",
    other: "{{count}} xhur"
  },
  aboutXYears: {
    one: "madwar sena",
    two: "madwar sentejn",
    other: "madwar {{count}} snin"
  },
  xYears: {
    one: "sena",
    two: "sentejn",
    other: "{{count}} snin"
  },
  overXYears: {
    one: "aktar minn sena",
    two: "aktar minn sentejn",
    other: "aktar minn {{count}} snin"
  },
  almostXYears: {
    one: "kważi sena",
    two: "kważi sentejn",
    other: "kważi {{count}} snin"
  }
};
var formatDistance57 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale55[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else if (count === 2 && tokenValue.two) {
    result = tokenValue.two;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "f'" + result;
    } else {
      return result + " ilu";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/mt/_lib/formatLong.mjs
var dateFormats64 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats64 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats64 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong64 = {
  date: buildFormatLongFn({
    formats: dateFormats64,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats64,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats64,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/mt/_lib/formatRelative.mjs
var formatRelativeLocale56 = {
  lastWeek: "eeee 'li għadda' 'fil-'p",
  yesterday: "'Il-bieraħ fil-'p",
  today: "'Illum fil-'p",
  tomorrow: "'Għada fil-'p",
  nextWeek: "eeee 'fil-'p",
  other: "P"
};
var formatRelative56 = (token, _date, _baseDate, _options) => formatRelativeLocale56[token];

// ../../../node_modules/date-fns/locale/mt/_lib/localize.mjs
var eraValues56 = {
  narrow: ["Q", "W"],
  abbreviated: ["QK", "WK"],
  wide: ["qabel Kristu", "wara Kristu"]
};
var quarterValues56 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1. kwart", "2. kwart", "3. kwart", "4. kwart"]
};
var monthValues56 = {
  narrow: ["J", "F", "M", "A", "M", "Ġ", "L", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Fra",
    "Mar",
    "Apr",
    "Mej",
    "Ġun",
    "Lul",
    "Aww",
    "Set",
    "Ott",
    "Nov",
    "Diċ"
  ],
  wide: [
    "Jannar",
    "Frar",
    "Marzu",
    "April",
    "Mejju",
    "Ġunju",
    "Lulju",
    "Awwissu",
    "Settembru",
    "Ottubru",
    "Novembru",
    "Diċembru"
  ]
};
var dayValues56 = {
  narrow: ["Ħ", "T", "T", "E", "Ħ", "Ġ", "S"],
  short: ["Ħa", "Tn", "Tl", "Er", "Ħa", "Ġi", "Si"],
  abbreviated: ["Ħad", "Tne", "Tli", "Erb", "Ħam", "Ġim", "Sib"],
  wide: [
    "Il-Ħadd",
    "It-Tnejn",
    "It-Tlieta",
    "L-Erbgħa",
    "Il-Ħamis",
    "Il-Ġimgħa",
    "Is-Sibt"
  ]
};
var dayPeriodValues56 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "għodwa",
    afternoon: "wara nofsinhar",
    evening: "filgħaxija",
    night: "lejl"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "għodwa",
    afternoon: "wara nofsinhar",
    evening: "filgħaxija",
    night: "lejl"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "nofsillejl",
    noon: "nofsinhar",
    morning: "għodwa",
    afternoon: "wara nofsinhar",
    evening: "filgħaxija",
    night: "lejl"
  }
};
var formattingDayPeriodValues46 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgħodu",
    afternoon: "wara nofsinhar",
    evening: "filgħaxija",
    night: "billejl"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgħodu",
    afternoon: "wara nofsinhar",
    evening: "filgħaxija",
    night: "billejl"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "f'nofsillejl",
    noon: "f'nofsinhar",
    morning: "filgħodu",
    afternoon: "wara nofsinhar",
    evening: "filgħaxija",
    night: "billejl"
  }
};
var ordinalNumber56 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "º";
};
var localize56 = {
  ordinalNumber: ordinalNumber56,
  era: buildLocalizeFn({
    values: eraValues56,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues56,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues56,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues56,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues56,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues46,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/mt/_lib/match.mjs
var matchOrdinalNumberPattern55 = /^(\d+)(º)?/i;
var parseOrdinalNumberPattern55 = /\d+/i;
var matchEraPatterns55 = {
  narrow: /^(q|w)/i,
  abbreviated: /^(q\.?\s?k\.?|b\.?\s?c\.?\s?e\.?|w\.?\s?k\.?)/i,
  wide: /^(qabel kristu|before common era|wara kristu|common era)/i
};
var parseEraPatterns55 = {
  any: [/^(q|b)/i, /^(w|c)/i]
};
var matchQuarterPatterns55 = {
  narrow: /^[1234]/i,
  abbreviated: /^k[1234]/i,
  wide: /^[1234](\.)? kwart/i
};
var parseQuarterPatterns55 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns55 = {
  narrow: /^[jfmaglsond]/i,
  abbreviated: /^(jan|fra|mar|apr|mej|ġun|lul|aww|set|ott|nov|diċ)/i,
  wide: /^(jannar|frar|marzu|april|mejju|ġunju|lulju|awwissu|settembru|ottubru|novembru|diċembru)/i
};
var parseMonthPatterns55 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^ġ/i,
    /^l/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mej/i,
    /^ġ/i,
    /^l/i,
    /^aw/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns55 = {
  narrow: /^[ħteġs]/i,
  short: /^(ħa|tn|tl|er|ħa|ġi|si)/i,
  abbreviated: /^(ħad|tne|tli|erb|ħam|ġim|sib)/i,
  wide: /^(il-ħadd|it-tnejn|it-tlieta|l-erbgħa|il-ħamis|il-ġimgħa|is-sibt)/i
};
var parseDayPatterns55 = {
  narrow: [/^ħ/i, /^t/i, /^t/i, /^e/i, /^ħ/i, /^ġ/i, /^s/i],
  any: [
    /^(il-)?ħad/i,
    /^(it-)?tn/i,
    /^(it-)?tl/i,
    /^(l-)?er/i,
    /^(il-)?ham/i,
    /^(il-)?ġi/i,
    /^(is-)?si/i
  ]
};
var matchDayPeriodPatterns55 = {
  narrow: /^(a|p|f'nofsillejl|f'nofsinhar|(ta') (għodwa|wara nofsinhar|filgħaxija|lejl))/i,
  any: /^([ap]\.?\s?m\.?|f'nofsillejl|f'nofsinhar|(ta') (għodwa|wara nofsinhar|filgħaxija|lejl))/i
};
var parseDayPeriodPatterns55 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^f'nofsillejl/i,
    noon: /^f'nofsinhar/i,
    morning: /għodwa/i,
    afternoon: /wara(\s.*)nofsinhar/i,
    evening: /filgħaxija/i,
    night: /lejl/i
  }
};
var match55 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern55,
    parsePattern: parseOrdinalNumberPattern55,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns55,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns55,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns55,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns55,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns55,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns55,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns55,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns55,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns55,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns55,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/mt.mjs
var mt = {
  code: "mt",
  formatDistance: formatDistance57,
  formatLong: formatLong64,
  formatRelative: formatRelative56,
  localize: localize56,
  match: match55,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/nb/_lib/formatDistance.mjs
var formatDistanceLocale56 = {
  lessThanXSeconds: {
    one: "mindre enn ett sekund",
    other: "mindre enn {{count}} sekunder"
  },
  xSeconds: {
    one: "ett sekund",
    other: "{{count}} sekunder"
  },
  halfAMinute: "et halvt minutt",
  lessThanXMinutes: {
    one: "mindre enn ett minutt",
    other: "mindre enn {{count}} minutter"
  },
  xMinutes: {
    one: "ett minutt",
    other: "{{count}} minutter"
  },
  aboutXHours: {
    one: "omtrent en time",
    other: "omtrent {{count}} timer"
  },
  xHours: {
    one: "en time",
    other: "{{count}} timer"
  },
  xDays: {
    one: "en dag",
    other: "{{count}} dager"
  },
  aboutXWeeks: {
    one: "omtrent en uke",
    other: "omtrent {{count}} uker"
  },
  xWeeks: {
    one: "en uke",
    other: "{{count}} uker"
  },
  aboutXMonths: {
    one: "omtrent en måned",
    other: "omtrent {{count}} måneder"
  },
  xMonths: {
    one: "en måned",
    other: "{{count}} måneder"
  },
  aboutXYears: {
    one: "omtrent ett år",
    other: "omtrent {{count}} år"
  },
  xYears: {
    one: "ett år",
    other: "{{count}} år"
  },
  overXYears: {
    one: "over ett år",
    other: "over {{count}} år"
  },
  almostXYears: {
    one: "nesten ett år",
    other: "nesten {{count}} år"
  }
};
var formatDistance58 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale56[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "om " + result;
    } else {
      return result + " siden";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/nb/_lib/formatLong.mjs
var dateFormats65 = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y"
};
var timeFormats65 = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats65 = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong65 = {
  date: buildFormatLongFn({
    formats: dateFormats65,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats65,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats65,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/nb/_lib/formatRelative.mjs
var formatRelativeLocale57 = {
  lastWeek: "'forrige' eeee 'kl.' p",
  yesterday: "'i går kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgen kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P"
};
var formatRelative57 = (token, _date, _baseDate, _options) => formatRelativeLocale57[token];

// ../../../node_modules/date-fns/locale/nb/_lib/localize.mjs
var eraValues57 = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["før Kristus", "etter Kristus"]
};
var quarterValues57 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
var monthValues57 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "mai",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des."
  ],
  wide: [
    "januar",
    "februar",
    "mars",
    "april",
    "mai",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "desember"
  ]
};
var dayValues57 = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["sø", "ma", "ti", "on", "to", "fr", "lø"],
  abbreviated: ["søn", "man", "tir", "ons", "tor", "fre", "lør"],
  wide: [
    "søndag",
    "mandag",
    "tirsdag",
    "onsdag",
    "torsdag",
    "fredag",
    "lørdag"
  ]
};
var dayPeriodValues57 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morg.",
    afternoon: "på etterm.",
    evening: "på kvelden",
    night: "på natten"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morg.",
    afternoon: "på etterm.",
    evening: "på kvelden",
    night: "på natten"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morgenen",
    afternoon: "på ettermiddagen",
    evening: "på kvelden",
    night: "på natten"
  }
};
var ordinalNumber57 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize57 = {
  ordinalNumber: ordinalNumber57,
  era: buildLocalizeFn({
    values: eraValues57,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues57,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues57,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues57,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues57,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/nb/_lib/match.mjs
var matchOrdinalNumberPattern56 = /^(\d+)\.?/i;
var parseOrdinalNumberPattern56 = /\d+/i;
var matchEraPatterns56 = {
  narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  wide: /^(før Kristus|før vår tid|etter Kristus|vår tid)/i
};
var parseEraPatterns56 = {
  any: [/^f/i, /^e/i]
};
var matchQuarterPatterns56 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartal/i
};
var parseQuarterPatterns56 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns56 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
  wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
};
var parseMonthPatterns56 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns56 = {
  narrow: /^[smtofl]/i,
  short: /^(sø|ma|ti|on|to|fr|lø)/i,
  abbreviated: /^(søn|man|tir|ons|tor|fre|lør)/i,
  wide: /^(søndag|mandag|tirsdag|onsdag|torsdag|fredag|lørdag)/i
};
var parseDayPatterns56 = {
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
var matchDayPeriodPatterns56 = {
  narrow: /^(midnatt|middag|(på) (morgenen|ettermiddagen|kvelden|natten)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|midnatt|middag|(på) (morgenen|ettermiddagen|kvelden|natten))/i
};
var parseDayPeriodPatterns56 = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgen/i,
    afternoon: /ettermiddag/i,
    evening: /kveld/i,
    night: /natt/i
  }
};
var match56 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern56,
    parsePattern: parseOrdinalNumberPattern56,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns56,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns56,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns56,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns56,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns56,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns56,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns56,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns56,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns56,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns56,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/nb.mjs
var nb = {
  code: "nb",
  formatDistance: formatDistance58,
  formatLong: formatLong65,
  formatRelative: formatRelative57,
  localize: localize57,
  match: match56,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/nl/_lib/formatDistance.mjs
var formatDistanceLocale57 = {
  lessThanXSeconds: {
    one: "minder dan een seconde",
    other: "minder dan {{count}} seconden"
  },
  xSeconds: {
    one: "1 seconde",
    other: "{{count}} seconden"
  },
  halfAMinute: "een halve minuut",
  lessThanXMinutes: {
    one: "minder dan een minuut",
    other: "minder dan {{count}} minuten"
  },
  xMinutes: {
    one: "een minuut",
    other: "{{count}} minuten"
  },
  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} uur"
  },
  xHours: {
    one: "1 uur",
    other: "{{count}} uur"
  },
  xDays: {
    one: "1 dag",
    other: "{{count}} dagen"
  },
  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weken"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weken"
  },
  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maanden"
  },
  xMonths: {
    one: "1 maand",
    other: "{{count}} maanden"
  },
  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar"
  },
  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar"
  },
  overXYears: {
    one: "meer dan 1 jaar",
    other: "meer dan {{count}} jaar"
  },
  almostXYears: {
    one: "bijna 1 jaar",
    other: "bijna {{count}} jaar"
  }
};
var formatDistance59 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale57[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "over " + result;
    } else {
      return result + " geleden";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/nl/_lib/formatLong.mjs
var dateFormats66 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd-MM-y"
};
var timeFormats66 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats66 = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong66 = {
  date: buildFormatLongFn({
    formats: dateFormats66,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats66,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats66,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/nl/_lib/formatRelative.mjs
var formatRelativeLocale58 = {
  lastWeek: "'afgelopen' eeee 'om' p",
  yesterday: "'gisteren om' p",
  today: "'vandaag om' p",
  tomorrow: "'morgen om' p",
  nextWeek: "eeee 'om' p",
  other: "P"
};
var formatRelative58 = (token, _date, _baseDate, _options) => formatRelativeLocale58[token];

// ../../../node_modules/date-fns/locale/nl/_lib/localize.mjs
var eraValues58 = {
  narrow: ["v.C.", "n.C."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["voor Christus", "na Christus"]
};
var quarterValues58 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"]
};
var monthValues58 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mei",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januari",
    "februari",
    "maart",
    "april",
    "mei",
    "juni",
    "juli",
    "augustus",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
var dayValues58 = {
  narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
  short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
  abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
  wide: [
    "zondag",
    "maandag",
    "dinsdag",
    "woensdag",
    "donderdag",
    "vrijdag",
    "zaterdag"
  ]
};
var dayPeriodValues58 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middaguur",
    morning: "'s ochtends",
    afternoon: "'s middags",
    evening: "'s avonds",
    night: "'s nachts"
  }
};
var ordinalNumber58 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "e";
};
var localize58 = {
  ordinalNumber: ordinalNumber58,
  era: buildLocalizeFn({
    values: eraValues58,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues58,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues58,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues58,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues58,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/nl/_lib/match.mjs
var matchOrdinalNumberPattern57 = /^(\d+)e?/i;
var parseOrdinalNumberPattern57 = /\d+/i;
var matchEraPatterns57 = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?Chr\.?)/,
  wide: /^((voor|na) Christus)/
};
var parseEraPatterns57 = {
  any: [/^v/, /^n/]
};
var matchQuarterPatterns57 = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e kwartaal/i
};
var parseQuarterPatterns57 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns57 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i
};
var parseMonthPatterns57 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mei/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^dec/i
  ]
};
var matchDayPatterns57 = {
  narrow: /^[zmdwv]/i,
  short: /^(zo|ma|di|wo|do|vr|za)/i,
  abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
  wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i
};
var parseDayPatterns57 = {
  narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
  any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i]
};
var matchDayPeriodPatterns57 = {
  any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i
};
var parseDayPeriodPatterns57 = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^het middaguur/i,
    morning: /ochtend/i,
    afternoon: /middag/i,
    evening: /avond/i,
    night: /nacht/i
  }
};
var match57 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern57,
    parsePattern: parseOrdinalNumberPattern57,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns57,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns57,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns57,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns57,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns57,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns57,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns57,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns57,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns57,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns57,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/nl.mjs
var nl = {
  code: "nl",
  formatDistance: formatDistance59,
  formatLong: formatLong66,
  formatRelative: formatRelative58,
  localize: localize58,
  match: match57,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/nl-BE/_lib/formatDistance.mjs
var formatDistanceLocale58 = {
  lessThanXSeconds: {
    one: "minder dan een seconde",
    other: "minder dan {{count}} seconden"
  },
  xSeconds: {
    one: "1 seconde",
    other: "{{count}} seconden"
  },
  halfAMinute: "een halve minuut",
  lessThanXMinutes: {
    one: "minder dan een minuut",
    other: "minder dan {{count}} minuten"
  },
  xMinutes: {
    one: "een minuut",
    other: "{{count}} minuten"
  },
  aboutXHours: {
    one: "ongeveer 1 uur",
    other: "ongeveer {{count}} uur"
  },
  xHours: {
    one: "1 uur",
    other: "{{count}} uur"
  },
  xDays: {
    one: "1 dag",
    other: "{{count}} dagen"
  },
  aboutXWeeks: {
    one: "ongeveer 1 week",
    other: "ongeveer {{count}} weken"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weken"
  },
  aboutXMonths: {
    one: "ongeveer 1 maand",
    other: "ongeveer {{count}} maanden"
  },
  xMonths: {
    one: "1 maand",
    other: "{{count}} maanden"
  },
  aboutXYears: {
    one: "ongeveer 1 jaar",
    other: "ongeveer {{count}} jaar"
  },
  xYears: {
    one: "1 jaar",
    other: "{{count}} jaar"
  },
  overXYears: {
    one: "meer dan 1 jaar",
    other: "meer dan {{count}} jaar"
  },
  almostXYears: {
    one: "bijna 1 jaar",
    other: "bijna {{count}} jaar"
  }
};
var formatDistance60 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale58[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "over " + result;
    } else {
      return result + " geleden";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/nl-BE/_lib/formatLong.mjs
var dateFormats67 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.y"
};
var timeFormats67 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats67 = {
  full: "{{date}} 'om' {{time}}",
  long: "{{date}} 'om' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong67 = {
  date: buildFormatLongFn({
    formats: dateFormats67,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats67,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats67,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/nl-BE/_lib/formatRelative.mjs
var formatRelativeLocale59 = {
  lastWeek: "'vorige' eeee 'om' p",
  yesterday: "'gisteren om' p",
  today: "'vandaag om' p",
  tomorrow: "'morgen om' p",
  nextWeek: "eeee 'om' p",
  other: "P"
};
var formatRelative59 = (token, _date, _baseDate, _options) => formatRelativeLocale59[token];

// ../../../node_modules/date-fns/locale/nl-BE/_lib/localize.mjs
var eraValues59 = {
  narrow: ["v.C.", "n.C."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["voor Christus", "na Christus"]
};
var quarterValues59 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["K1", "K2", "K3", "K4"],
  wide: ["1e kwartaal", "2e kwartaal", "3e kwartaal", "4e kwartaal"]
};
var monthValues59 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mrt.",
    "apr.",
    "mei",
    "jun.",
    "jul.",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januari",
    "februari",
    "maart",
    "april",
    "mei",
    "juni",
    "juli",
    "augustus",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
var dayValues59 = {
  narrow: ["Z", "M", "D", "W", "D", "V", "Z"],
  short: ["zo", "ma", "di", "wo", "do", "vr", "za"],
  abbreviated: ["zon", "maa", "din", "woe", "don", "vri", "zat"],
  wide: [
    "zondag",
    "maandag",
    "dinsdag",
    "woensdag",
    "donderdag",
    "vrijdag",
    "zaterdag"
  ]
};
var dayPeriodValues59 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "middernacht",
    noon: "het middag",
    morning: "'s ochtends",
    afternoon: "'s namiddags",
    evening: "'s avonds",
    night: "'s nachts"
  }
};
var ordinalNumber59 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "e";
};
var localize59 = {
  ordinalNumber: ordinalNumber59,
  era: buildLocalizeFn({
    values: eraValues59,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues59,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues59,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues59,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues59,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/nl-BE/_lib/match.mjs
var matchOrdinalNumberPattern58 = /^(\d+)e?/i;
var parseOrdinalNumberPattern58 = /\d+/i;
var matchEraPatterns58 = {
  narrow: /^([vn]\.? ?C\.?)/,
  abbreviated: /^([vn]\. ?Chr\.?)/,
  wide: /^((voor|na) Christus)/
};
var parseEraPatterns58 = {
  any: [/^v/, /^n/]
};
var matchQuarterPatterns58 = {
  narrow: /^[1234]/i,
  abbreviated: /^K[1234]/i,
  wide: /^[1234]e kwartaal/i
};
var parseQuarterPatterns58 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns58 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan.|feb.|mrt.|apr.|mei|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
  wide: /^(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)/i
};
var parseMonthPatterns58 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^jan/i,
    /^feb/i,
    /^m(r|a)/i,
    /^apr/i,
    /^mei/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^sep/i,
    /^okt/i,
    /^nov/i,
    /^dec/i
  ]
};
var matchDayPatterns58 = {
  narrow: /^[zmdwv]/i,
  short: /^(zo|ma|di|wo|do|vr|za)/i,
  abbreviated: /^(zon|maa|din|woe|don|vri|zat)/i,
  wide: /^(zondag|maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag)/i
};
var parseDayPatterns58 = {
  narrow: [/^z/i, /^m/i, /^d/i, /^w/i, /^d/i, /^v/i, /^z/i],
  any: [/^zo/i, /^ma/i, /^di/i, /^wo/i, /^do/i, /^vr/i, /^za/i]
};
var matchDayPeriodPatterns58 = {
  any: /^(am|pm|middernacht|het middaguur|'s (ochtends|middags|avonds|nachts))/i
};
var parseDayPeriodPatterns58 = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /^middernacht/i,
    noon: /^het middaguur/i,
    morning: /ochtend/i,
    afternoon: /middag/i,
    evening: /avond/i,
    night: /nacht/i
  }
};
var match58 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern58,
    parsePattern: parseOrdinalNumberPattern58,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns58,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns58,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns58,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns58,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns58,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns58,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns58,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns58,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns58,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns58,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/nl-BE.mjs
var nlBE = {
  code: "nl-BE",
  formatDistance: formatDistance60,
  formatLong: formatLong67,
  formatRelative: formatRelative59,
  localize: localize59,
  match: match58,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/nn/_lib/formatDistance.mjs
var formatDistanceLocale59 = {
  lessThanXSeconds: {
    one: "mindre enn eitt sekund",
    other: "mindre enn {{count}} sekund"
  },
  xSeconds: {
    one: "eitt sekund",
    other: "{{count}} sekund"
  },
  halfAMinute: "eit halvt minutt",
  lessThanXMinutes: {
    one: "mindre enn eitt minutt",
    other: "mindre enn {{count}} minutt"
  },
  xMinutes: {
    one: "eitt minutt",
    other: "{{count}} minutt"
  },
  aboutXHours: {
    one: "omtrent ein time",
    other: "omtrent {{count}} timar"
  },
  xHours: {
    one: "ein time",
    other: "{{count}} timar"
  },
  xDays: {
    one: "ein dag",
    other: "{{count}} dagar"
  },
  aboutXWeeks: {
    one: "omtrent ei veke",
    other: "omtrent {{count}} veker"
  },
  xWeeks: {
    one: "ei veke",
    other: "{{count}} veker"
  },
  aboutXMonths: {
    one: "omtrent ein månad",
    other: "omtrent {{count}} månader"
  },
  xMonths: {
    one: "ein månad",
    other: "{{count}} månader"
  },
  aboutXYears: {
    one: "omtrent eitt år",
    other: "omtrent {{count}} år"
  },
  xYears: {
    one: "eitt år",
    other: "{{count}} år"
  },
  overXYears: {
    one: "over eitt år",
    other: "over {{count}} år"
  },
  almostXYears: {
    one: "nesten eitt år",
    other: "nesten {{count}} år"
  }
};
var wordMapping = [
  "null",
  "ein",
  "to",
  "tre",
  "fire",
  "fem",
  "seks",
  "sju",
  "åtte",
  "ni",
  "ti",
  "elleve",
  "tolv"
];
var formatDistance61 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale59[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace(
      "{{count}}",
      count < 13 ? wordMapping[count] : String(count)
    );
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "om " + result;
    } else {
      return result + " sidan";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/nn/_lib/formatLong.mjs
var dateFormats68 = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y"
};
var timeFormats68 = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats68 = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong68 = {
  date: buildFormatLongFn({
    formats: dateFormats68,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats68,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats68,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/nn/_lib/formatRelative.mjs
var formatRelativeLocale60 = {
  lastWeek: "'førre' eeee 'kl.' p",
  yesterday: "'i går kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgon kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P"
};
var formatRelative60 = (token, _date, _baseDate, _options) => formatRelativeLocale60[token];

// ../../../node_modules/date-fns/locale/nn/_lib/localize.mjs
var eraValues60 = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["før Kristus", "etter Kristus"]
};
var quarterValues60 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
var monthValues60 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "mai",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "des."
  ],
  wide: [
    "januar",
    "februar",
    "mars",
    "april",
    "mai",
    "juni",
    "juli",
    "august",
    "september",
    "oktober",
    "november",
    "desember"
  ]
};
var dayValues60 = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["su", "må", "ty", "on", "to", "fr", "lau"],
  abbreviated: ["sun", "mån", "tys", "ons", "tor", "fre", "laur"],
  wide: [
    "sundag",
    "måndag",
    "tysdag",
    "onsdag",
    "torsdag",
    "fredag",
    "laurdag"
  ]
};
var dayPeriodValues60 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morg.",
    afternoon: "på etterm.",
    evening: "på kvelden",
    night: "på natta"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morg.",
    afternoon: "på etterm.",
    evening: "på kvelden",
    night: "på natta"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morgonen",
    afternoon: "på ettermiddagen",
    evening: "på kvelden",
    night: "på natta"
  }
};
var ordinalNumber60 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize60 = {
  ordinalNumber: ordinalNumber60,
  era: buildLocalizeFn({
    values: eraValues60,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues60,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues60,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues60,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues60,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/nn/_lib/match.mjs
var matchOrdinalNumberPattern59 = /^(\d+)\.?/i;
var parseOrdinalNumberPattern59 = /\d+/i;
var matchEraPatterns59 = {
  narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  wide: /^(før Kristus|før vår tid|etter Kristus|vår tid)/i
};
var parseEraPatterns59 = {
  any: [/^f/i, /^e/i]
};
var matchQuarterPatterns59 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartal/i
};
var parseQuarterPatterns59 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns59 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
  wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
};
var parseMonthPatterns59 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^aug/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns59 = {
  narrow: /^[smtofl]/i,
  short: /^(su|må|ty|on|to|fr|la)/i,
  abbreviated: /^(sun|mån|tys|ons|tor|fre|laur)/i,
  wide: /^(sundag|måndag|tysdag|onsdag|torsdag|fredag|laurdag)/i
};
var parseDayPatterns59 = {
  any: [/^s/i, /^m/i, /^ty/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
var matchDayPeriodPatterns59 = {
  narrow: /^(midnatt|middag|(på) (morgonen|ettermiddagen|kvelden|natta)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|midnatt|middag|(på) (morgonen|ettermiddagen|kvelden|natta))/i
};
var parseDayPeriodPatterns59 = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgon/i,
    afternoon: /ettermiddag/i,
    evening: /kveld/i,
    night: /natt/i
  }
};
var match59 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern59,
    parsePattern: parseOrdinalNumberPattern59,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns59,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns59,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns59,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns59,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns59,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns59,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns59,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns59,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns59,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns59,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/nn.mjs
var nn = {
  code: "nn",
  formatDistance: formatDistance61,
  formatLong: formatLong68,
  formatRelative: formatRelative60,
  localize: localize60,
  match: match59,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/oc/_lib/formatDistance.mjs
var formatDistanceLocale60 = {
  lessThanXSeconds: {
    one: "mens d’una segonda",
    other: "mens de {{count}} segondas"
  },
  xSeconds: {
    one: "1 segonda",
    other: "{{count}} segondas"
  },
  halfAMinute: "30 segondas",
  lessThanXMinutes: {
    one: "mens d’una minuta",
    other: "mens de {{count}} minutas"
  },
  xMinutes: {
    one: "1 minuta",
    other: "{{count}} minutas"
  },
  aboutXHours: {
    one: "environ 1 ora",
    other: "environ {{count}} oras"
  },
  xHours: {
    one: "1 ora",
    other: "{{count}} oras"
  },
  xDays: {
    one: "1 jorn",
    other: "{{count}} jorns"
  },
  aboutXWeeks: {
    one: "environ 1 setmana",
    other: "environ {{count}} setmanas"
  },
  xWeeks: {
    one: "1 setmana",
    other: "{{count}} setmanas"
  },
  aboutXMonths: {
    one: "environ 1 mes",
    other: "environ {{count}} meses"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "environ 1 an",
    other: "environ {{count}} ans"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} ans"
  },
  overXYears: {
    one: "mai d’un an",
    other: "mai de {{count}} ans"
  },
  almostXYears: {
    one: "gaireben un an",
    other: "gaireben {{count}} ans"
  }
};
var formatDistance62 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale60[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "d’aquí " + result;
    } else {
      return "fa " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/oc/_lib/formatLong.mjs
var dateFormats69 = {
  full: "EEEE d 'de' MMMM y",
  long: "d 'de' MMMM y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
var timeFormats69 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats69 = {
  full: "{{date}} 'a' {{time}}",
  long: "{{date}} 'a' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong69 = {
  date: buildFormatLongFn({
    formats: dateFormats69,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats69,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats69,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/oc/_lib/formatRelative.mjs
var formatRelativeLocale61 = {
  lastWeek: "eeee 'passat a' p",
  yesterday: "'ièr a' p",
  today: "'uèi a' p",
  tomorrow: "'deman a' p",
  nextWeek: "eeee 'a' p",
  other: "P"
};
var formatRelative61 = (token, _date, _baseDate, _options) => formatRelativeLocale61[token];

// ../../../node_modules/date-fns/locale/oc/_lib/localize.mjs
var eraValues61 = {
  narrow: ["ab. J.C.", "apr. J.C."],
  abbreviated: ["ab. J.C.", "apr. J.C."],
  wide: ["abans Jèsus-Crist", "après Jèsus-Crist"]
};
var quarterValues61 = {
  narrow: ["T1", "T2", "T3", "T4"],
  abbreviated: ["1èr trim.", "2nd trim.", "3en trim.", "4en trim."],
  wide: ["1èr trimèstre", "2nd trimèstre", "3en trimèstre", "4en trimèstre"]
};
var monthValues61 = {
  narrow: [
    "GN",
    "FB",
    "MÇ",
    "AB",
    "MA",
    "JN",
    "JL",
    "AG",
    "ST",
    "OC",
    "NV",
    "DC"
  ],
  abbreviated: [
    "gen.",
    "febr.",
    "març",
    "abr.",
    "mai",
    "junh",
    "jul.",
    "ag.",
    "set.",
    "oct.",
    "nov.",
    "dec."
  ],
  wide: [
    "genièr",
    "febrièr",
    "març",
    "abril",
    "mai",
    "junh",
    "julhet",
    "agost",
    "setembre",
    "octòbre",
    "novembre",
    "decembre"
  ]
};
var dayValues61 = {
  narrow: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  short: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  abbreviated: ["dg.", "dl.", "dm.", "dc.", "dj.", "dv.", "ds."],
  wide: [
    "dimenge",
    "diluns",
    "dimars",
    "dimècres",
    "dijòus",
    "divendres",
    "dissabte"
  ]
};
var dayPeriodValues61 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "mièjanuèch",
    noon: "miègjorn",
    morning: "matin",
    afternoon: "aprèp-miègjorn",
    evening: "vèspre",
    night: "nuèch"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "mièjanuèch",
    noon: "miègjorn",
    morning: "matin",
    afternoon: "aprèp-miègjorn",
    evening: "vèspre",
    night: "nuèch"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "mièjanuèch",
    noon: "miègjorn",
    morning: "matin",
    afternoon: "aprèp-miègjorn",
    evening: "vèspre",
    night: "nuèch"
  }
};
var formattingDayPeriodValues47 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "mièjanuèch",
    noon: "miègjorn",
    morning: "del matin",
    afternoon: "de l’aprèp-miègjorn",
    evening: "del ser",
    night: "de la nuèch"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "mièjanuèch",
    noon: "miègjorn",
    morning: "del matin",
    afternoon: "de l’aprèp-miègjorn",
    evening: "del ser",
    night: "de la nuèch"
  },
  wide: {
    am: "ante meridiem",
    pm: "post meridiem",
    midnight: "mièjanuèch",
    noon: "miègjorn",
    morning: "del matin",
    afternoon: "de l’aprèp-miègjorn",
    evening: "del ser",
    night: "de la nuèch"
  }
};
var ordinalNumber61 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = options2 == null ? void 0 : options2.unit;
  let ordinal;
  switch (number2) {
    case 1:
      ordinal = "èr";
      break;
    case 2:
      ordinal = "nd";
      break;
    default:
      ordinal = "en";
  }
  if (unit === "year" || unit === "week" || unit === "hour" || unit === "minute" || unit === "second") {
    ordinal += "a";
  }
  return number2 + ordinal;
};
var localize61 = {
  ordinalNumber: ordinalNumber61,
  era: buildLocalizeFn({
    values: eraValues61,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues61,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues61,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues61,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues61,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues47,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/oc/_lib/match.mjs
var matchOrdinalNumberPattern60 = /^(\d+)(èr|nd|en)?[a]?/i;
var parseOrdinalNumberPattern60 = /\d+/i;
var matchEraPatterns60 = {
  narrow: /^(ab\.J\.C|apr\.J\.C|apr\.J\.-C)/i,
  abbreviated: /^(ab\.J\.-C|ab\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
  wide: /^(abans Jèsus-Crist|après Jèsus-Crist)/i
};
var parseEraPatterns60 = {
  any: [/^ab/i, /^ap/i]
};
var matchQuarterPatterns60 = {
  narrow: /^T[1234]/i,
  abbreviated: /^[1234](èr|nd|en)? trim\.?/i,
  wide: /^[1234](èr|nd|en)? trimèstre/i
};
var parseQuarterPatterns60 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns60 = {
  narrow: /^(GN|FB|MÇ|AB|MA|JN|JL|AG|ST|OC|NV|DC)/i,
  abbreviated: /^(gen|febr|març|abr|mai|junh|jul|ag|set|oct|nov|dec)\.?/i,
  wide: /^(genièr|febrièr|març|abril|mai|junh|julhet|agost|setembre|octòbre|novembre|decembre)/i
};
var parseMonthPatterns60 = {
  any: [
    /^g/i,
    /^f/i,
    /^ma[r?]|MÇ/i,
    /^ab/i,
    /^ma[i?]/i,
    /^ju[n?]|JN/i,
    /^ju[l?]|JL/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns60 = {
  narrow: /^d[glmcjvs]\.?/i,
  short: /^d[glmcjvs]\.?/i,
  abbreviated: /^d[glmcjvs]\.?/i,
  wide: /^(dimenge|diluns|dimars|dimècres|dijòus|divendres|dissabte)/i
};
var parseDayPatterns60 = {
  narrow: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
  short: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
  abbreviated: [/^dg/i, /^dl/i, /^dm/i, /^dc/i, /^dj/i, /^dv/i, /^ds/i],
  any: [
    /^dg|dime/i,
    /^dl|dil/i,
    /^dm|dima/i,
    /^dc|dimè/i,
    /^dj|dij/i,
    /^dv|div/i,
    /^ds|dis/i
  ]
};
var matchDayPeriodPatterns60 = {
  any: /(^(a\.?m|p\.?m))|(ante meridiem|post meridiem)|((del |de la |de l’)(matin|aprèp-miègjorn|vèspre|ser|nuèch))/i
};
var parseDayPeriodPatterns60 = {
  any: {
    am: /(^a)|ante meridiem/i,
    pm: /(^p)|post meridiem/i,
    midnight: /^mièj/i,
    noon: /^mièg/i,
    morning: /matin/i,
    afternoon: /aprèp-miègjorn/i,
    evening: /vèspre|ser/i,
    night: /nuèch/i
  }
};
var match60 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern60,
    parsePattern: parseOrdinalNumberPattern60,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns60,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns60,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns60,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns60,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns60,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns60,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns60,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns60,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns60,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns60,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/oc.mjs
var oc = {
  code: "oc",
  formatDistance: formatDistance62,
  formatLong: formatLong69,
  formatRelative: formatRelative61,
  localize: localize61,
  match: match60,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/pl/_lib/formatDistance.mjs
var formatDistanceLocale61 = {
  lessThanXSeconds: {
    one: {
      regular: "mniej niż sekunda",
      past: "mniej niż sekundę",
      future: "mniej niż sekundę"
    },
    twoFour: "mniej niż {{count}} sekundy",
    other: "mniej niż {{count}} sekund"
  },
  xSeconds: {
    one: {
      regular: "sekunda",
      past: "sekundę",
      future: "sekundę"
    },
    twoFour: "{{count}} sekundy",
    other: "{{count}} sekund"
  },
  halfAMinute: {
    one: "pół minuty",
    twoFour: "pół minuty",
    other: "pół minuty"
  },
  lessThanXMinutes: {
    one: {
      regular: "mniej niż minuta",
      past: "mniej niż minutę",
      future: "mniej niż minutę"
    },
    twoFour: "mniej niż {{count}} minuty",
    other: "mniej niż {{count}} minut"
  },
  xMinutes: {
    one: {
      regular: "minuta",
      past: "minutę",
      future: "minutę"
    },
    twoFour: "{{count}} minuty",
    other: "{{count}} minut"
  },
  aboutXHours: {
    one: {
      regular: "około godziny",
      past: "około godziny",
      future: "około godzinę"
    },
    twoFour: "około {{count}} godziny",
    other: "około {{count}} godzin"
  },
  xHours: {
    one: {
      regular: "godzina",
      past: "godzinę",
      future: "godzinę"
    },
    twoFour: "{{count}} godziny",
    other: "{{count}} godzin"
  },
  xDays: {
    one: {
      regular: "dzień",
      past: "dzień",
      future: "1 dzień"
    },
    twoFour: "{{count}} dni",
    other: "{{count}} dni"
  },
  aboutXWeeks: {
    one: "około tygodnia",
    twoFour: "około {{count}} tygodni",
    other: "około {{count}} tygodni"
  },
  xWeeks: {
    one: "tydzień",
    twoFour: "{{count}} tygodnie",
    other: "{{count}} tygodni"
  },
  aboutXMonths: {
    one: "około miesiąc",
    twoFour: "około {{count}} miesiące",
    other: "około {{count}} miesięcy"
  },
  xMonths: {
    one: "miesiąc",
    twoFour: "{{count}} miesiące",
    other: "{{count}} miesięcy"
  },
  aboutXYears: {
    one: "około rok",
    twoFour: "około {{count}} lata",
    other: "około {{count}} lat"
  },
  xYears: {
    one: "rok",
    twoFour: "{{count}} lata",
    other: "{{count}} lat"
  },
  overXYears: {
    one: "ponad rok",
    twoFour: "ponad {{count}} lata",
    other: "ponad {{count}} lat"
  },
  almostXYears: {
    one: "prawie rok",
    twoFour: "prawie {{count}} lata",
    other: "prawie {{count}} lat"
  }
};
function declensionGroup(scheme2, count) {
  if (count === 1) {
    return scheme2.one;
  }
  const rem100 = count % 100;
  if (rem100 <= 20 && rem100 > 10) {
    return scheme2.other;
  }
  const rem10 = rem100 % 10;
  if (rem10 >= 2 && rem10 <= 4) {
    return scheme2.twoFour;
  }
  return scheme2.other;
}
function declension4(scheme2, count, time) {
  const group = declensionGroup(scheme2, count);
  const finalText = typeof group === "string" ? group : group[time];
  return finalText.replace("{{count}}", String(count));
}
var formatDistance63 = (token, count, options2) => {
  const scheme2 = formatDistanceLocale61[token];
  if (!(options2 == null ? void 0 : options2.addSuffix)) {
    return declension4(scheme2, count, "regular");
  }
  if (options2.comparison && options2.comparison > 0) {
    return "za " + declension4(scheme2, count, "future");
  } else {
    return declension4(scheme2, count, "past") + " temu";
  }
};

// ../../../node_modules/date-fns/locale/pl/_lib/formatLong.mjs
var dateFormats70 = {
  full: "EEEE, do MMMM y",
  long: "do MMMM y",
  medium: "do MMM y",
  short: "dd.MM.y"
};
var timeFormats70 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats70 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong70 = {
  date: buildFormatLongFn({
    formats: dateFormats70,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats70,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats70,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/pl/_lib/formatRelative.mjs
var adjectivesLastWeek = {
  masculine: "ostatni",
  feminine: "ostatnia"
};
var adjectivesThisWeek = {
  masculine: "ten",
  feminine: "ta"
};
var adjectivesNextWeek = {
  masculine: "następny",
  feminine: "następna"
};
var dayGrammaticalGender = {
  0: "feminine",
  1: "masculine",
  2: "masculine",
  3: "feminine",
  4: "masculine",
  5: "masculine",
  6: "feminine"
};
function dayAndTimeWithAdjective(token, date2, baseDate, options2) {
  let adjectives;
  if (isSameWeek(date2, baseDate, options2)) {
    adjectives = adjectivesThisWeek;
  } else if (token === "lastWeek") {
    adjectives = adjectivesLastWeek;
  } else if (token === "nextWeek") {
    adjectives = adjectivesNextWeek;
  } else {
    throw new Error(`Cannot determine adjectives for token ${token}`);
  }
  const day = date2.getDay();
  const grammaticalGender = dayGrammaticalGender[day];
  const adjective = adjectives[grammaticalGender];
  return `'${adjective}' eeee 'o' p`;
}
var formatRelativeLocale62 = {
  lastWeek: dayAndTimeWithAdjective,
  yesterday: "'wczoraj o' p",
  today: "'dzisiaj o' p",
  tomorrow: "'jutro o' p",
  nextWeek: dayAndTimeWithAdjective,
  other: "P"
};
var formatRelative62 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale62[token];
  if (typeof format3 === "function") {
    return format3(token, date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/pl/_lib/localize.mjs
var eraValues62 = {
  narrow: ["p.n.e.", "n.e."],
  abbreviated: ["p.n.e.", "n.e."],
  wide: ["przed naszą erą", "naszej ery"]
};
var quarterValues62 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["I kw.", "II kw.", "III kw.", "IV kw."],
  wide: ["I kwartał", "II kwartał", "III kwartał", "IV kwartał"]
};
var monthValues62 = {
  narrow: ["S", "L", "M", "K", "M", "C", "L", "S", "W", "P", "L", "G"],
  abbreviated: [
    "sty",
    "lut",
    "mar",
    "kwi",
    "maj",
    "cze",
    "lip",
    "sie",
    "wrz",
    "paź",
    "lis",
    "gru"
  ],
  wide: [
    "styczeń",
    "luty",
    "marzec",
    "kwiecień",
    "maj",
    "czerwiec",
    "lipiec",
    "sierpień",
    "wrzesień",
    "październik",
    "listopad",
    "grudzień"
  ]
};
var monthFormattingValues = {
  narrow: ["s", "l", "m", "k", "m", "c", "l", "s", "w", "p", "l", "g"],
  abbreviated: [
    "sty",
    "lut",
    "mar",
    "kwi",
    "maj",
    "cze",
    "lip",
    "sie",
    "wrz",
    "paź",
    "lis",
    "gru"
  ],
  wide: [
    "stycznia",
    "lutego",
    "marca",
    "kwietnia",
    "maja",
    "czerwca",
    "lipca",
    "sierpnia",
    "września",
    "października",
    "listopada",
    "grudnia"
  ]
};
var dayValues62 = {
  narrow: ["N", "P", "W", "Ś", "C", "P", "S"],
  short: ["nie", "pon", "wto", "śro", "czw", "pią", "sob"],
  abbreviated: ["niedz.", "pon.", "wt.", "śr.", "czw.", "pt.", "sob."],
  wide: [
    "niedziela",
    "poniedziałek",
    "wtorek",
    "środa",
    "czwartek",
    "piątek",
    "sobota"
  ]
};
var dayFormattingValues = {
  narrow: ["n", "p", "w", "ś", "c", "p", "s"],
  short: ["nie", "pon", "wto", "śro", "czw", "pią", "sob"],
  abbreviated: ["niedz.", "pon.", "wt.", "śr.", "czw.", "pt.", "sob."],
  wide: [
    "niedziela",
    "poniedziałek",
    "wtorek",
    "środa",
    "czwartek",
    "piątek",
    "sobota"
  ]
};
var dayPeriodValues62 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "półn.",
    noon: "poł",
    morning: "rano",
    afternoon: "popoł.",
    evening: "wiecz.",
    night: "noc"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "północ",
    noon: "południe",
    morning: "rano",
    afternoon: "popołudnie",
    evening: "wieczór",
    night: "noc"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "północ",
    noon: "południe",
    morning: "rano",
    afternoon: "popołudnie",
    evening: "wieczór",
    night: "noc"
  }
};
var dayPeriodFormattingValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "o półn.",
    noon: "w poł.",
    morning: "rano",
    afternoon: "po poł.",
    evening: "wiecz.",
    night: "w nocy"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "o północy",
    noon: "w południe",
    morning: "rano",
    afternoon: "po południu",
    evening: "wieczorem",
    night: "w nocy"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "o północy",
    noon: "w południe",
    morning: "rano",
    afternoon: "po południu",
    evening: "wieczorem",
    night: "w nocy"
  }
};
var ordinalNumber62 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize62 = {
  ordinalNumber: ordinalNumber62,
  era: buildLocalizeFn({
    values: eraValues62,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues62,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues62,
    defaultWidth: "wide",
    formattingValues: monthFormattingValues,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues62,
    defaultWidth: "wide",
    formattingValues: dayFormattingValues,
    defaultFormattingWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues62,
    defaultWidth: "wide",
    formattingValues: dayPeriodFormattingValues,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/pl/_lib/match.mjs
var matchOrdinalNumberPattern61 = /^(\d+)?/i;
var parseOrdinalNumberPattern61 = /\d+/i;
var matchEraPatterns61 = {
  narrow: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
  abbreviated: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
  wide: /^(przed\s*nasz(ą|a)\s*er(ą|a)|naszej\s*ery)/i
};
var parseEraPatterns61 = {
  any: [/^p/i, /^n/i]
};
var matchQuarterPatterns61 = {
  narrow: /^[1234]/i,
  abbreviated: /^(I|II|III|IV)\s*kw\.?/i,
  wide: /^(I|II|III|IV)\s*kwarta(ł|l)/i
};
var parseQuarterPatterns61 = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [/^I kw/i, /^II kw/i, /^III kw/i, /^IV kw/i]
};
var matchMonthPatterns61 = {
  narrow: /^[slmkcwpg]/i,
  abbreviated: /^(sty|lut|mar|kwi|maj|cze|lip|sie|wrz|pa(ź|z)|lis|gru)/i,
  wide: /^(stycznia|stycze(ń|n)|lutego|luty|marca|marzec|kwietnia|kwiecie(ń|n)|maja|maj|czerwca|czerwiec|lipca|lipiec|sierpnia|sierpie(ń|n)|wrze(ś|s)nia|wrzesie(ń|n)|pa(ź|z)dziernika|pa(ź|z)dziernik|listopada|listopad|grudnia|grudzie(ń|n))/i
};
var parseMonthPatterns61 = {
  narrow: [
    /^s/i,
    /^l/i,
    /^m/i,
    /^k/i,
    /^m/i,
    /^c/i,
    /^l/i,
    /^s/i,
    /^w/i,
    /^p/i,
    /^l/i,
    /^g/i
  ],
  any: [
    /^st/i,
    /^lu/i,
    /^mar/i,
    /^k/i,
    /^maj/i,
    /^c/i,
    /^lip/i,
    /^si/i,
    /^w/i,
    /^p/i,
    /^lis/i,
    /^g/i
  ]
};
var matchDayPatterns61 = {
  narrow: /^[npwścs]/i,
  short: /^(nie|pon|wto|(ś|s)ro|czw|pi(ą|a)|sob)/i,
  abbreviated: /^(niedz|pon|wt|(ś|s)r|czw|pt|sob)\.?/i,
  wide: /^(niedziela|poniedzia(ł|l)ek|wtorek|(ś|s)roda|czwartek|pi(ą|a)tek|sobota)/i
};
var parseDayPatterns61 = {
  narrow: [/^n/i, /^p/i, /^w/i, /^ś/i, /^c/i, /^p/i, /^s/i],
  abbreviated: [/^n/i, /^po/i, /^w/i, /^(ś|s)r/i, /^c/i, /^pt/i, /^so/i],
  any: [/^n/i, /^po/i, /^w/i, /^(ś|s)r/i, /^c/i, /^pi/i, /^so/i]
};
var matchDayPeriodPatterns61 = {
  narrow: /^(^a$|^p$|pó(ł|l)n\.?|o\s*pó(ł|l)n\.?|po(ł|l)\.?|w\s*po(ł|l)\.?|po\s*po(ł|l)\.?|rano|wiecz\.?|noc|w\s*nocy)/i,
  any: /^(am|pm|pó(ł|l)noc|o\s*pó(ł|l)nocy|po(ł|l)udnie|w\s*po(ł|l)udnie|popo(ł|l)udnie|po\s*po(ł|l)udniu|rano|wieczór|wieczorem|noc|w\s*nocy)/i
};
var parseDayPeriodPatterns61 = {
  narrow: {
    am: /^a$/i,
    pm: /^p$/i,
    midnight: /pó(ł|l)n/i,
    noon: /po(ł|l)/i,
    morning: /rano/i,
    afternoon: /po\s*po(ł|l)/i,
    evening: /wiecz/i,
    night: /noc/i
  },
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /pó(ł|l)n/i,
    noon: /po(ł|l)/i,
    morning: /rano/i,
    afternoon: /po\s*po(ł|l)/i,
    evening: /wiecz/i,
    night: /noc/i
  }
};
var match61 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern61,
    parsePattern: parseOrdinalNumberPattern61,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns61,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns61,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns61,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns61,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns61,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns61,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns61,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns61,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns61,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns61,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/pl.mjs
var pl = {
  code: "pl",
  formatDistance: formatDistance63,
  formatLong: formatLong70,
  formatRelative: formatRelative62,
  localize: localize62,
  match: match61,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/pt/_lib/formatDistance.mjs
var formatDistanceLocale62 = {
  lessThanXSeconds: {
    one: "menos de um segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "meio minuto",
  lessThanXMinutes: {
    one: "menos de um minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "aproximadamente 1 hora",
    other: "aproximadamente {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 dia",
    other: "{{count}} dias"
  },
  aboutXWeeks: {
    one: "aproximadamente 1 semana",
    other: "aproximadamente {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "aproximadamente 1 mês",
    other: "aproximadamente {{count}} meses"
  },
  xMonths: {
    one: "1 mês",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "aproximadamente 1 ano",
    other: "aproximadamente {{count}} anos"
  },
  xYears: {
    one: "1 ano",
    other: "{{count}} anos"
  },
  overXYears: {
    one: "mais de 1 ano",
    other: "mais de {{count}} anos"
  },
  almostXYears: {
    one: "quase 1 ano",
    other: "quase {{count}} anos"
  }
};
var formatDistance64 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale62[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "daqui a " + result;
    } else {
      return "há " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/pt/_lib/formatLong.mjs
var dateFormats71 = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d 'de' MMM 'de' y",
  short: "dd/MM/y"
};
var timeFormats71 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats71 = {
  full: "{{date}} 'às' {{time}}",
  long: "{{date}} 'às' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong71 = {
  date: buildFormatLongFn({
    formats: dateFormats71,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats71,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats71,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/pt/_lib/formatRelative.mjs
var formatRelativeLocale63 = {
  lastWeek: (date2) => {
    const weekday = date2.getDay();
    const last = weekday === 0 || weekday === 6 ? "último" : "última";
    return "'" + last + "' eeee 'às' p";
  },
  yesterday: "'ontem às' p",
  today: "'hoje às' p",
  tomorrow: "'amanhã às' p",
  nextWeek: "eeee 'às' p",
  other: "P"
};
var formatRelative63 = (token, date2, _baseDate, _options) => {
  const format3 = formatRelativeLocale63[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/pt/_lib/localize.mjs
var eraValues63 = {
  narrow: ["aC", "dC"],
  abbreviated: ["a.C.", "d.C."],
  wide: ["antes de Cristo", "depois de Cristo"]
};
var quarterValues63 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
};
var monthValues63 = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "fev",
    "mar",
    "abr",
    "mai",
    "jun",
    "jul",
    "ago",
    "set",
    "out",
    "nov",
    "dez"
  ],
  wide: [
    "janeiro",
    "fevereiro",
    "março",
    "abril",
    "maio",
    "junho",
    "julho",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "dezembro"
  ]
};
var dayValues63 = {
  narrow: ["d", "s", "t", "q", "q", "s", "s"],
  short: ["dom", "seg", "ter", "qua", "qui", "sex", "sáb"],
  abbreviated: ["dom", "seg", "ter", "qua", "qui", "sex", "sáb"],
  wide: [
    "domingo",
    "segunda-feira",
    "terça-feira",
    "quarta-feira",
    "quinta-feira",
    "sexta-feira",
    "sábado"
  ]
};
var dayPeriodValues63 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhã",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhã",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhã",
    afternoon: "tarde",
    evening: "noite",
    night: "madrugada"
  }
};
var formattingDayPeriodValues48 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhã",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhã",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhã",
    afternoon: "da tarde",
    evening: "da noite",
    night: "da madrugada"
  }
};
var ordinalNumber63 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "º";
};
var localize63 = {
  ordinalNumber: ordinalNumber63,
  era: buildLocalizeFn({
    values: eraValues63,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues63,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues63,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues63,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues63,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues48,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/pt/_lib/match.mjs
var matchOrdinalNumberPattern62 = /^(\d+)(º|ª)?/i;
var parseOrdinalNumberPattern62 = /\d+/i;
var matchEraPatterns62 = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes da era comum|depois de cristo|era comum)/i
};
var parseEraPatterns62 = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes da era comum)/i,
    /^(depois de cristo|era comum)/i
  ]
};
var matchQuarterPatterns62 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](º|ª)? trimestre/i
};
var parseQuarterPatterns62 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns62 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
  wide: /^(janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
};
var parseMonthPatterns62 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ab/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^ag/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns62 = {
  narrow: /^[dstq]/i,
  short: /^(dom|seg|ter|qua|qui|sex|s[áa]b)/i,
  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[áa]b)/i,
  wide: /^(domingo|segunda-?\s?feira|terça-?\s?feira|quarta-?\s?feira|quinta-?\s?feira|sexta-?\s?feira|s[áa]bado)/i
};
var parseDayPatterns62 = {
  narrow: [/^d/i, /^s/i, /^t/i, /^q/i, /^q/i, /^s/i, /^s/i],
  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[áa]/i]
};
var matchDayPeriodPatterns62 = {
  narrow: /^(a|p|meia-?\s?noite|meio-?\s?dia|(da) (manh[ãa]|tarde|noite|madrugada))/i,
  any: /^([ap]\.?\s?m\.?|meia-?\s?noite|meio-?\s?dia|(da) (manh[ãa]|tarde|noite|madrugada))/i
};
var parseDayPeriodPatterns62 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^meia/i,
    noon: /^meio/i,
    morning: /manh[ãa]/i,
    afternoon: /tarde/i,
    evening: /noite/i,
    night: /madrugada/i
  }
};
var match62 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern62,
    parsePattern: parseOrdinalNumberPattern62,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns62,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns62,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns62,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns62,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns62,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns62,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns62,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns62,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns62,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns62,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/pt.mjs
var pt = {
  code: "pt",
  formatDistance: formatDistance64,
  formatLong: formatLong71,
  formatRelative: formatRelative63,
  localize: localize63,
  match: match62,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/pt-BR/_lib/formatDistance.mjs
var formatDistanceLocale63 = {
  lessThanXSeconds: {
    one: "menos de um segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "meio minuto",
  lessThanXMinutes: {
    one: "menos de um minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "cerca de 1 hora",
    other: "cerca de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 dia",
    other: "{{count}} dias"
  },
  aboutXWeeks: {
    one: "cerca de 1 semana",
    other: "cerca de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "cerca de 1 mês",
    other: "cerca de {{count}} meses"
  },
  xMonths: {
    one: "1 mês",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "cerca de 1 ano",
    other: "cerca de {{count}} anos"
  },
  xYears: {
    one: "1 ano",
    other: "{{count}} anos"
  },
  overXYears: {
    one: "mais de 1 ano",
    other: "mais de {{count}} anos"
  },
  almostXYears: {
    one: "quase 1 ano",
    other: "quase {{count}} anos"
  }
};
var formatDistance65 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale63[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "em " + result;
    } else {
      return "há " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/pt-BR/_lib/formatLong.mjs
var dateFormats72 = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
var timeFormats72 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats72 = {
  full: "{{date}} 'às' {{time}}",
  long: "{{date}} 'às' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong72 = {
  date: buildFormatLongFn({
    formats: dateFormats72,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats72,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats72,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/pt-BR/_lib/formatRelative.mjs
var formatRelativeLocale64 = {
  lastWeek: (date2) => {
    const weekday = date2.getDay();
    const last = weekday === 0 || weekday === 6 ? "último" : "última";
    return "'" + last + "' eeee 'às' p";
  },
  yesterday: "'ontem às' p",
  today: "'hoje às' p",
  tomorrow: "'amanhã às' p",
  nextWeek: "eeee 'às' p",
  other: "P"
};
var formatRelative64 = (token, date2, _baseDate, _options) => {
  const format3 = formatRelativeLocale64[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/pt-BR/_lib/localize.mjs
var eraValues64 = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "depois de cristo"]
};
var quarterValues64 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
};
var monthValues64 = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "fev",
    "mar",
    "abr",
    "mai",
    "jun",
    "jul",
    "ago",
    "set",
    "out",
    "nov",
    "dez"
  ],
  wide: [
    "janeiro",
    "fevereiro",
    "março",
    "abril",
    "maio",
    "junho",
    "julho",
    "agosto",
    "setembro",
    "outubro",
    "novembro",
    "dezembro"
  ]
};
var dayValues64 = {
  narrow: ["D", "S", "T", "Q", "Q", "S", "S"],
  short: ["dom", "seg", "ter", "qua", "qui", "sex", "sab"],
  abbreviated: [
    "domingo",
    "segunda",
    "terça",
    "quarta",
    "quinta",
    "sexta",
    "sábado"
  ],
  wide: [
    "domingo",
    "segunda-feira",
    "terça-feira",
    "quarta-feira",
    "quinta-feira",
    "sexta-feira",
    "sábado"
  ]
};
var dayPeriodValues64 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "manhã",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhã",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "manhã",
    afternoon: "tarde",
    evening: "tarde",
    night: "noite"
  }
};
var formattingDayPeriodValues49 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "da manhã",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhã",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "meia-noite",
    noon: "meio-dia",
    morning: "da manhã",
    afternoon: "da tarde",
    evening: "da tarde",
    night: "da noite"
  }
};
var ordinalNumber64 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  if ((options2 == null ? void 0 : options2.unit) === "week") {
    return number2 + "ª";
  }
  return number2 + "º";
};
var localize64 = {
  ordinalNumber: ordinalNumber64,
  era: buildLocalizeFn({
    values: eraValues64,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues64,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues64,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues64,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues64,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues49,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/pt-BR/_lib/match.mjs
var matchOrdinalNumberPattern63 = /^(\d+)[ºªo]?/i;
var parseOrdinalNumberPattern63 = /\d+/i;
var matchEraPatterns63 = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|d\.?\s?c\.?)/i,
  wide: /^(antes de cristo|depois de cristo)/i
};
var parseEraPatterns63 = {
  any: [/^ac/i, /^dc/i],
  wide: [/^antes de cristo/i, /^depois de cristo/i]
};
var matchQuarterPatterns63 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](º)? trimestre/i
};
var parseQuarterPatterns63 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns63 = {
  narrow: /^[jfmajsond]/i,
  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
  wide: /^(janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
};
var parseMonthPatterns63 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^fev/i,
    /^mar/i,
    /^abr/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^ago/i,
    /^set/i,
    /^out/i,
    /^nov/i,
    /^dez/i
  ]
};
var matchDayPatterns63 = {
  narrow: /^(dom|[23456]ª?|s[aá]b)/i,
  short: /^(dom|[23456]ª?|s[aá]b)/i,
  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[aá]b)/i,
  wide: /^(domingo|(segunda|ter[cç]a|quarta|quinta|sexta)([- ]feira)?|s[aá]bado)/i
};
var parseDayPatterns63 = {
  short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i],
  narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i],
  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[aá]b/i]
};
var matchDayPeriodPatterns63 = {
  narrow: /^(a|p|mn|md|(da) (manhã|tarde|noite))/i,
  any: /^([ap]\.?\s?m\.?|meia[-\s]noite|meio[-\s]dia|(da) (manhã|tarde|noite))/i
};
var parseDayPeriodPatterns63 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn|^meia[-\s]noite/i,
    noon: /^md|^meio[-\s]dia/i,
    morning: /manhã/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noite/i
  }
};
var match63 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern63,
    parsePattern: parseOrdinalNumberPattern63,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns63,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns63,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns63,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns63,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns63,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns63,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns63,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns63,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns63,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns63,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/pt-BR.mjs
var ptBR = {
  code: "pt-BR",
  formatDistance: formatDistance65,
  formatLong: formatLong72,
  formatRelative: formatRelative64,
  localize: localize64,
  match: match63,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ro/_lib/formatDistance.mjs
var formatDistanceLocale64 = {
  lessThanXSeconds: {
    one: "mai puțin de o secundă",
    other: "mai puțin de {{count}} secunde"
  },
  xSeconds: {
    one: "1 secundă",
    other: "{{count}} secunde"
  },
  halfAMinute: "jumătate de minut",
  lessThanXMinutes: {
    one: "mai puțin de un minut",
    other: "mai puțin de {{count}} minute"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minute"
  },
  aboutXHours: {
    one: "circa 1 oră",
    other: "circa {{count}} ore"
  },
  xHours: {
    one: "1 oră",
    other: "{{count}} ore"
  },
  xDays: {
    one: "1 zi",
    other: "{{count}} zile"
  },
  aboutXWeeks: {
    one: "circa o săptămână",
    other: "circa {{count}} săptămâni"
  },
  xWeeks: {
    one: "1 săptămână",
    other: "{{count}} săptămâni"
  },
  aboutXMonths: {
    one: "circa 1 lună",
    other: "circa {{count}} luni"
  },
  xMonths: {
    one: "1 lună",
    other: "{{count}} luni"
  },
  aboutXYears: {
    one: "circa 1 an",
    other: "circa {{count}} ani"
  },
  xYears: {
    one: "1 an",
    other: "{{count}} ani"
  },
  overXYears: {
    one: "peste 1 an",
    other: "peste {{count}} ani"
  },
  almostXYears: {
    one: "aproape 1 an",
    other: "aproape {{count}} ani"
  }
};
var formatDistance66 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale64[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "în " + result;
    } else {
      return result + " în urmă";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ro/_lib/formatLong.mjs
var dateFormats73 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd.MM.yyyy"
};
var timeFormats73 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats73 = {
  full: "{{date}} 'la' {{time}}",
  long: "{{date}} 'la' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong73 = {
  date: buildFormatLongFn({
    formats: dateFormats73,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats73,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats73,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ro/_lib/formatRelative.mjs
var formatRelativeLocale65 = {
  lastWeek: "eeee 'trecută la' p",
  yesterday: "'ieri la' p",
  today: "'astăzi la' p",
  tomorrow: "'mâine la' p",
  nextWeek: "eeee 'viitoare la' p",
  other: "P"
};
var formatRelative65 = (token, _date, _baseDate, _options) => formatRelativeLocale65[token];

// ../../../node_modules/date-fns/locale/ro/_lib/localize.mjs
var eraValues65 = {
  narrow: ["Î", "D"],
  abbreviated: ["Î.d.C.", "D.C."],
  wide: ["Înainte de Cristos", "După Cristos"]
};
var quarterValues65 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: [
    "primul trimestru",
    "al doilea trimestru",
    "al treilea trimestru",
    "al patrulea trimestru"
  ]
};
var monthValues65 = {
  narrow: ["I", "F", "M", "A", "M", "I", "I", "A", "S", "O", "N", "D"],
  abbreviated: [
    "ian",
    "feb",
    "mar",
    "apr",
    "mai",
    "iun",
    "iul",
    "aug",
    "sep",
    "oct",
    "noi",
    "dec"
  ],
  wide: [
    "ianuarie",
    "februarie",
    "martie",
    "aprilie",
    "mai",
    "iunie",
    "iulie",
    "august",
    "septembrie",
    "octombrie",
    "noiembrie",
    "decembrie"
  ]
};
var dayValues65 = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["du", "lu", "ma", "mi", "jo", "vi", "sâ"],
  abbreviated: ["dum", "lun", "mar", "mie", "joi", "vin", "sâm"],
  wide: ["duminică", "luni", "marți", "miercuri", "joi", "vineri", "sâmbătă"]
};
var dayPeriodValues65 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "ami",
    morning: "dim",
    afternoon: "da",
    evening: "s",
    night: "n"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "miezul nopții",
    noon: "amiază",
    morning: "dimineață",
    afternoon: "după-amiază",
    evening: "seară",
    night: "noapte"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "miezul nopții",
    noon: "amiază",
    morning: "dimineață",
    afternoon: "după-amiază",
    evening: "seară",
    night: "noapte"
  }
};
var formattingDayPeriodValues50 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "amiază",
    morning: "dimineață",
    afternoon: "după-amiază",
    evening: "seară",
    night: "noapte"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "miezul nopții",
    noon: "amiază",
    morning: "dimineață",
    afternoon: "după-amiază",
    evening: "seară",
    night: "noapte"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "miezul nopții",
    noon: "amiază",
    morning: "dimineață",
    afternoon: "după-amiază",
    evening: "seară",
    night: "noapte"
  }
};
var ordinalNumber65 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize65 = {
  ordinalNumber: ordinalNumber65,
  era: buildLocalizeFn({
    values: eraValues65,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues65,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues65,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues65,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues65,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues50,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ro/_lib/match.mjs
var matchOrdinalNumberPattern64 = /^(\d+)?/i;
var parseOrdinalNumberPattern64 = /\d+/i;
var matchEraPatterns64 = {
  narrow: /^(Î|D)/i,
  abbreviated: /^(Î\.?\s?d\.?\s?C\.?|Î\.?\s?e\.?\s?n\.?|D\.?\s?C\.?|e\.?\s?n\.?)/i,
  wide: /^(Înainte de Cristos|Înaintea erei noastre|După Cristos|Era noastră)/i
};
var parseEraPatterns64 = {
  any: [/^ÎC/i, /^DC/i],
  wide: [
    /^(Înainte de Cristos|Înaintea erei noastre)/i,
    /^(După Cristos|Era noastră)/i
  ]
};
var matchQuarterPatterns64 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^trimestrul [1234]/i
};
var parseQuarterPatterns64 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns64 = {
  narrow: /^[ifmaasond]/i,
  abbreviated: /^(ian|feb|mar|apr|mai|iun|iul|aug|sep|oct|noi|dec)/i,
  wide: /^(ianuarie|februarie|martie|aprilie|mai|iunie|iulie|august|septembrie|octombrie|noiembrie|decembrie)/i
};
var parseMonthPatterns64 = {
  narrow: [
    /^i/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^i/i,
    /^i/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ia/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^mai/i,
    /^iun/i,
    /^iul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns64 = {
  narrow: /^[dlmjvs]/i,
  short: /^(d|l|ma|mi|j|v|s)/i,
  abbreviated: /^(dum|lun|mar|mie|jo|vi|sâ)/i,
  wide: /^(duminica|luni|marţi|miercuri|joi|vineri|sâmbătă)/i
};
var parseDayPatterns64 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^d/i, /^l/i, /^ma/i, /^mi/i, /^j/i, /^v/i, /^s/i]
};
var matchDayPeriodPatterns64 = {
  narrow: /^(a|p|mn|a|(dimineaţa|după-amiaza|seara|noaptea))/i,
  any: /^([ap]\.?\s?m\.?|miezul nopții|amiaza|(dimineaţa|după-amiaza|seara|noaptea))/i
};
var parseDayPeriodPatterns64 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /amiaza/i,
    morning: /dimineaţa/i,
    afternoon: /după-amiaza/i,
    evening: /seara/i,
    night: /noaptea/i
  }
};
var match64 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern64,
    parsePattern: parseOrdinalNumberPattern64,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns64,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns64,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns64,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns64,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns64,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns64,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns64,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns64,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns64,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns64,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ro.mjs
var ro = {
  code: "ro",
  formatDistance: formatDistance66,
  formatLong: formatLong73,
  formatRelative: formatRelative65,
  localize: localize65,
  match: match64,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ru/_lib/formatDistance.mjs
function declension5(scheme2, count) {
  if (scheme2.one !== void 0 && count === 1) {
    return scheme2.one;
  }
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
function buildLocalizeTokenFn4(scheme2) {
  return (count, options2) => {
    if (options2 == null ? void 0 : options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        if (scheme2.future) {
          return declension5(scheme2.future, count);
        } else {
          return "через " + declension5(scheme2.regular, count);
        }
      } else {
        if (scheme2.past) {
          return declension5(scheme2.past, count);
        } else {
          return declension5(scheme2.regular, count) + " назад";
        }
      }
    } else {
      return declension5(scheme2.regular, count);
    }
  };
}
var formatDistanceLocale65 = {
  lessThanXSeconds: buildLocalizeTokenFn4({
    regular: {
      one: "меньше секунды",
      singularNominative: "меньше {{count}} секунды",
      singularGenitive: "меньше {{count}} секунд",
      pluralGenitive: "меньше {{count}} секунд"
    },
    future: {
      one: "меньше, чем через секунду",
      singularNominative: "меньше, чем через {{count}} секунду",
      singularGenitive: "меньше, чем через {{count}} секунды",
      pluralGenitive: "меньше, чем через {{count}} секунд"
    }
  }),
  xSeconds: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "{{count}} секунда",
      singularGenitive: "{{count}} секунды",
      pluralGenitive: "{{count}} секунд"
    },
    past: {
      singularNominative: "{{count}} секунду назад",
      singularGenitive: "{{count}} секунды назад",
      pluralGenitive: "{{count}} секунд назад"
    },
    future: {
      singularNominative: "через {{count}} секунду",
      singularGenitive: "через {{count}} секунды",
      pluralGenitive: "через {{count}} секунд"
    }
  }),
  halfAMinute: (_count, options2) => {
    if (options2 == null ? void 0 : options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        return "через полминуты";
      } else {
        return "полминуты назад";
      }
    }
    return "полминуты";
  },
  lessThanXMinutes: buildLocalizeTokenFn4({
    regular: {
      one: "меньше минуты",
      singularNominative: "меньше {{count}} минуты",
      singularGenitive: "меньше {{count}} минут",
      pluralGenitive: "меньше {{count}} минут"
    },
    future: {
      one: "меньше, чем через минуту",
      singularNominative: "меньше, чем через {{count}} минуту",
      singularGenitive: "меньше, чем через {{count}} минуты",
      pluralGenitive: "меньше, чем через {{count}} минут"
    }
  }),
  xMinutes: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "{{count}} минута",
      singularGenitive: "{{count}} минуты",
      pluralGenitive: "{{count}} минут"
    },
    past: {
      singularNominative: "{{count}} минуту назад",
      singularGenitive: "{{count}} минуты назад",
      pluralGenitive: "{{count}} минут назад"
    },
    future: {
      singularNominative: "через {{count}} минуту",
      singularGenitive: "через {{count}} минуты",
      pluralGenitive: "через {{count}} минут"
    }
  }),
  aboutXHours: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "около {{count}} часа",
      singularGenitive: "около {{count}} часов",
      pluralGenitive: "около {{count}} часов"
    },
    future: {
      singularNominative: "приблизительно через {{count}} час",
      singularGenitive: "приблизительно через {{count}} часа",
      pluralGenitive: "приблизительно через {{count}} часов"
    }
  }),
  xHours: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "{{count}} час",
      singularGenitive: "{{count}} часа",
      pluralGenitive: "{{count}} часов"
    }
  }),
  xDays: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "{{count}} день",
      singularGenitive: "{{count}} дня",
      pluralGenitive: "{{count}} дней"
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "около {{count}} недели",
      singularGenitive: "около {{count}} недель",
      pluralGenitive: "около {{count}} недель"
    },
    future: {
      singularNominative: "приблизительно через {{count}} неделю",
      singularGenitive: "приблизительно через {{count}} недели",
      pluralGenitive: "приблизительно через {{count}} недель"
    }
  }),
  xWeeks: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "{{count}} неделя",
      singularGenitive: "{{count}} недели",
      pluralGenitive: "{{count}} недель"
    }
  }),
  aboutXMonths: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "около {{count}} месяца",
      singularGenitive: "около {{count}} месяцев",
      pluralGenitive: "около {{count}} месяцев"
    },
    future: {
      singularNominative: "приблизительно через {{count}} месяц",
      singularGenitive: "приблизительно через {{count}} месяца",
      pluralGenitive: "приблизительно через {{count}} месяцев"
    }
  }),
  xMonths: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "{{count}} месяц",
      singularGenitive: "{{count}} месяца",
      pluralGenitive: "{{count}} месяцев"
    }
  }),
  aboutXYears: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "около {{count}} года",
      singularGenitive: "около {{count}} лет",
      pluralGenitive: "около {{count}} лет"
    },
    future: {
      singularNominative: "приблизительно через {{count}} год",
      singularGenitive: "приблизительно через {{count}} года",
      pluralGenitive: "приблизительно через {{count}} лет"
    }
  }),
  xYears: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "{{count}} год",
      singularGenitive: "{{count}} года",
      pluralGenitive: "{{count}} лет"
    }
  }),
  overXYears: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "больше {{count}} года",
      singularGenitive: "больше {{count}} лет",
      pluralGenitive: "больше {{count}} лет"
    },
    future: {
      singularNominative: "больше, чем через {{count}} год",
      singularGenitive: "больше, чем через {{count}} года",
      pluralGenitive: "больше, чем через {{count}} лет"
    }
  }),
  almostXYears: buildLocalizeTokenFn4({
    regular: {
      singularNominative: "почти {{count}} год",
      singularGenitive: "почти {{count}} года",
      pluralGenitive: "почти {{count}} лет"
    },
    future: {
      singularNominative: "почти через {{count}} год",
      singularGenitive: "почти через {{count}} года",
      pluralGenitive: "почти через {{count}} лет"
    }
  })
};
var formatDistance67 = (token, count, options2) => {
  return formatDistanceLocale65[token](count, options2);
};

// ../../../node_modules/date-fns/locale/ru/_lib/formatLong.mjs
var dateFormats74 = {
  full: "EEEE, d MMMM y 'г.'",
  long: "d MMMM y 'г.'",
  medium: "d MMM y 'г.'",
  short: "dd.MM.y"
};
var timeFormats74 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats74 = {
  any: "{{date}}, {{time}}"
};
var formatLong74 = {
  date: buildFormatLongFn({
    formats: dateFormats74,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats74,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats74,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ru/_lib/formatRelative.mjs
var accusativeWeekdays6 = [
  "воскресенье",
  "понедельник",
  "вторник",
  "среду",
  "четверг",
  "пятницу",
  "субботу"
];
function lastWeek7(day) {
  const weekday = accusativeWeekdays6[day];
  switch (day) {
    case 0:
      return "'в прошлое " + weekday + " в' p";
    case 1:
    case 2:
    case 4:
      return "'в прошлый " + weekday + " в' p";
    case 3:
    case 5:
    case 6:
      return "'в прошлую " + weekday + " в' p";
  }
}
function thisWeek7(day) {
  const weekday = accusativeWeekdays6[day];
  if (day === 2) {
    return "'во " + weekday + " в' p";
  } else {
    return "'в " + weekday + " в' p";
  }
}
function nextWeek7(day) {
  const weekday = accusativeWeekdays6[day];
  switch (day) {
    case 0:
      return "'в следующее " + weekday + " в' p";
    case 1:
    case 2:
    case 4:
      return "'в следующий " + weekday + " в' p";
    case 3:
    case 5:
    case 6:
      return "'в следующую " + weekday + " в' p";
  }
}
var formatRelativeLocale66 = {
  lastWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek7(day);
    } else {
      return lastWeek7(day);
    }
  },
  yesterday: "'вчера в' p",
  today: "'сегодня в' p",
  tomorrow: "'завтра в' p",
  nextWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek7(day);
    } else {
      return nextWeek7(day);
    }
  },
  other: "P"
};
var formatRelative66 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale66[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/ru/_lib/localize.mjs
var eraValues66 = {
  narrow: ["до н.э.", "н.э."],
  abbreviated: ["до н. э.", "н. э."],
  wide: ["до нашей эры", "нашей эры"]
};
var quarterValues66 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-й кв.", "2-й кв.", "3-й кв.", "4-й кв."],
  wide: ["1-й квартал", "2-й квартал", "3-й квартал", "4-й квартал"]
};
var monthValues66 = {
  narrow: ["Я", "Ф", "М", "А", "М", "И", "И", "А", "С", "О", "Н", "Д"],
  abbreviated: [
    "янв.",
    "фев.",
    "март",
    "апр.",
    "май",
    "июнь",
    "июль",
    "авг.",
    "сент.",
    "окт.",
    "нояб.",
    "дек."
  ],
  wide: [
    "январь",
    "февраль",
    "март",
    "апрель",
    "май",
    "июнь",
    "июль",
    "август",
    "сентябрь",
    "октябрь",
    "ноябрь",
    "декабрь"
  ]
};
var formattingMonthValues14 = {
  narrow: ["Я", "Ф", "М", "А", "М", "И", "И", "А", "С", "О", "Н", "Д"],
  abbreviated: [
    "янв.",
    "фев.",
    "мар.",
    "апр.",
    "мая",
    "июн.",
    "июл.",
    "авг.",
    "сент.",
    "окт.",
    "нояб.",
    "дек."
  ],
  wide: [
    "января",
    "февраля",
    "марта",
    "апреля",
    "мая",
    "июня",
    "июля",
    "августа",
    "сентября",
    "октября",
    "ноября",
    "декабря"
  ]
};
var dayValues66 = {
  narrow: ["В", "П", "В", "С", "Ч", "П", "С"],
  short: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
  abbreviated: ["вск", "пнд", "втр", "срд", "чтв", "птн", "суб"],
  wide: [
    "воскресенье",
    "понедельник",
    "вторник",
    "среда",
    "четверг",
    "пятница",
    "суббота"
  ]
};
var dayPeriodValues66 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "полн.",
    noon: "полд.",
    morning: "утро",
    afternoon: "день",
    evening: "веч.",
    night: "ночь"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "полн.",
    noon: "полд.",
    morning: "утро",
    afternoon: "день",
    evening: "веч.",
    night: "ночь"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "полночь",
    noon: "полдень",
    morning: "утро",
    afternoon: "день",
    evening: "вечер",
    night: "ночь"
  }
};
var formattingDayPeriodValues51 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "полн.",
    noon: "полд.",
    morning: "утра",
    afternoon: "дня",
    evening: "веч.",
    night: "ночи"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "полн.",
    noon: "полд.",
    morning: "утра",
    afternoon: "дня",
    evening: "веч.",
    night: "ночи"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "полночь",
    noon: "полдень",
    morning: "утра",
    afternoon: "дня",
    evening: "вечера",
    night: "ночи"
  }
};
var ordinalNumber66 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = options2 == null ? void 0 : options2.unit;
  let suffix2;
  if (unit === "date") {
    suffix2 = "-е";
  } else if (unit === "week" || unit === "minute" || unit === "second") {
    suffix2 = "-я";
  } else {
    suffix2 = "-й";
  }
  return number2 + suffix2;
};
var localize66 = {
  ordinalNumber: ordinalNumber66,
  era: buildLocalizeFn({
    values: eraValues66,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues66,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues66,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues14,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues66,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues66,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues51,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ru/_lib/match.mjs
var matchOrdinalNumberPattern65 = /^(\d+)(-?(е|я|й|ое|ье|ая|ья|ый|ой|ий|ый))?/i;
var parseOrdinalNumberPattern65 = /\d+/i;
var matchEraPatterns65 = {
  narrow: /^((до )?н\.?\s?э\.?)/i,
  abbreviated: /^((до )?н\.?\s?э\.?)/i,
  wide: /^(до нашей эры|нашей эры|наша эра)/i
};
var parseEraPatterns65 = {
  any: [/^д/i, /^н/i]
};
var matchQuarterPatterns65 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[ыои]?й?)? кв.?/i,
  wide: /^[1234](-?[ыои]?й?)? квартал/i
};
var parseQuarterPatterns65 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns65 = {
  narrow: /^[яфмаисонд]/i,
  abbreviated: /^(янв|фев|март?|апр|ма[йя]|июн[ья]?|июл[ья]?|авг|сент?|окт|нояб?|дек)\.?/i,
  wide: /^(январ[ья]|феврал[ья]|марта?|апрел[ья]|ма[йя]|июн[ья]|июл[ья]|августа?|сентябр[ья]|октябр[ья]|октябр[ья]|ноябр[ья]|декабр[ья])/i
};
var parseMonthPatterns65 = {
  narrow: [
    /^я/i,
    /^ф/i,
    /^м/i,
    /^а/i,
    /^м/i,
    /^и/i,
    /^и/i,
    /^а/i,
    /^с/i,
    /^о/i,
    /^н/i,
    /^я/i
  ],
  any: [
    /^я/i,
    /^ф/i,
    /^мар/i,
    /^ап/i,
    /^ма[йя]/i,
    /^июн/i,
    /^июл/i,
    /^ав/i,
    /^с/i,
    /^о/i,
    /^н/i,
    /^д/i
  ]
};
var matchDayPatterns65 = {
  narrow: /^[впсч]/i,
  short: /^(вс|во|пн|по|вт|ср|чт|че|пт|пя|сб|су)\.?/i,
  abbreviated: /^(вск|вос|пнд|пон|втр|вто|срд|сре|чтв|чет|птн|пят|суб).?/i,
  wide: /^(воскресень[ея]|понедельника?|вторника?|сред[аы]|четверга?|пятниц[аы]|суббот[аы])/i
};
var parseDayPatterns65 = {
  narrow: [/^в/i, /^п/i, /^в/i, /^с/i, /^ч/i, /^п/i, /^с/i],
  any: [/^в[ос]/i, /^п[он]/i, /^в/i, /^ср/i, /^ч/i, /^п[ят]/i, /^с[уб]/i]
};
var matchDayPeriodPatterns65 = {
  narrow: /^([дп]п|полн\.?|полд\.?|утр[оа]|день|дня|веч\.?|ноч[ьи])/i,
  abbreviated: /^([дп]п|полн\.?|полд\.?|утр[оа]|день|дня|веч\.?|ноч[ьи])/i,
  wide: /^([дп]п|полночь|полдень|утр[оа]|день|дня|вечера?|ноч[ьи])/i
};
var parseDayPeriodPatterns65 = {
  any: {
    am: /^дп/i,
    pm: /^пп/i,
    midnight: /^полн/i,
    noon: /^полд/i,
    morning: /^у/i,
    afternoon: /^д[ен]/i,
    evening: /^в/i,
    night: /^н/i
  }
};
var match65 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern65,
    parsePattern: parseOrdinalNumberPattern65,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns65,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns65,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns65,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns65,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns65,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns65,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns65,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns65,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns65,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns65,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ru.mjs
var ru = {
  code: "ru",
  formatDistance: formatDistance67,
  formatLong: formatLong74,
  formatRelative: formatRelative66,
  localize: localize66,
  match: match65,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/se/_lib/formatDistance.mjs
var formatDistanceLocale66 = {
  lessThanXSeconds: {
    one: "unnit go ovtta sekundda",
    other: "unnit go {{count}} sekundda"
  },
  xSeconds: {
    one: "sekundda",
    other: "{{count}} sekundda"
  },
  halfAMinute: "bealle minuhta",
  lessThanXMinutes: {
    one: "unnit go bealle minuhta",
    other: "unnit go {{count}} minuhta"
  },
  xMinutes: {
    one: "minuhta",
    other: "{{count}} minuhta"
  },
  aboutXHours: {
    one: "sullii ovtta diimmu",
    other: "sullii {{count}} diimmu"
  },
  xHours: {
    one: "diimmu",
    other: "{{count}} diimmu"
  },
  xDays: {
    one: "beaivvi",
    other: "{{count}} beaivvi"
  },
  aboutXWeeks: {
    one: "sullii ovtta vahku",
    other: "sullii {{count}} vahku"
  },
  xWeeks: {
    one: "vahku",
    other: "{{count}} vahku"
  },
  aboutXMonths: {
    one: "sullii ovtta mánu",
    other: "sullii {{count}} mánu"
  },
  xMonths: {
    one: "mánu",
    other: "{{count}} mánu"
  },
  aboutXYears: {
    one: "sullii ovtta jagi",
    other: "sullii {{count}} jagi"
  },
  xYears: {
    one: "jagi",
    other: "{{count}} jagi"
  },
  overXYears: {
    one: "guhkit go jagi",
    other: "guhkit go {{count}} jagi"
  },
  almostXYears: {
    one: "measta jagi",
    other: "measta {{count}} jagi"
  }
};
var formatDistance68 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale66[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "geahčen " + result;
    } else {
      return result + " áigi";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/se/_lib/formatLong.mjs
var dateFormats75 = {
  full: "EEEE MMMM d. 'b.' y",
  long: "MMMM d. 'b.' y",
  medium: "MMM d. 'b.' y",
  short: "dd.MM.y"
};
var timeFormats75 = {
  full: "'dii.' HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats75 = {
  full: "{{date}} 'dii.' {{time}}",
  long: "{{date}} 'dii.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong75 = {
  date: buildFormatLongFn({
    formats: dateFormats75,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats75,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats75,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/se/_lib/formatRelative.mjs
var formatRelativeLocale67 = {
  lastWeek: "'ovddit' eeee 'dii.' p",
  yesterday: "'ikte dii.' p",
  today: "'odne dii.' p",
  tomorrow: "'ihtin dii.' p",
  nextWeek: "EEEE 'dii.' p",
  other: "P"
};
var formatRelative67 = (token, _date, _baseDate, _options) => formatRelativeLocale67[token];

// ../../../node_modules/date-fns/locale/se/_lib/localize.mjs
var eraValues67 = {
  narrow: ["o.Kr.", "m.Kr."],
  abbreviated: ["o.Kr.", "m.Kr."],
  wide: ["ovdal Kristusa", "maŋŋel Kristusa"]
};
var quarterValues67 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartála", "2. kvartála", "3. kvartála", "4. kvartála"]
};
var monthValues67 = {
  narrow: ["O", "G", "N", "C", "M", "G", "S", "B", "Č", "G", "S", "J"],
  abbreviated: [
    "ođđa",
    "guov",
    "njuk",
    "cuo",
    "mies",
    "geas",
    "suoi",
    "borg",
    "čakč",
    "golg",
    "skáb",
    "juov"
  ],
  wide: [
    "ođđajagemánnu",
    "guovvamánnu",
    "njukčamánnu",
    "cuoŋománnu",
    "miessemánnu",
    "geassemánnu",
    "suoidnemánnu",
    "borgemánnu",
    "čakčamánnu",
    "golggotmánnu",
    "skábmamánnu",
    "juovlamánnu"
  ]
};
var dayValues67 = {
  narrow: ["S", "V", "M", "G", "D", "B", "L"],
  short: ["sotn", "vuos", "maŋ", "gask", "duor", "bear", "láv"],
  abbreviated: ["sotn", "vuos", "maŋ", "gask", "duor", "bear", "láv"],
  wide: [
    "sotnabeaivi",
    "vuossárga",
    "maŋŋebárga",
    "gaskavahkku",
    "duorastat",
    "bearjadat",
    "lávvardat"
  ]
};
var dayPeriodValues67 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "gaskaidja",
    noon: "gaskabeaivi",
    morning: "iđđes",
    afternoon: "maŋŋel gaska.",
    evening: "eahkes",
    night: "ihkku"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gaskaidja",
    noon: "gaskabeaivvi",
    morning: "iđđes",
    afternoon: "maŋŋel gaskabea.",
    evening: "eahkes",
    night: "ihkku"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "gaskaidja",
    noon: "gaskabeavvi",
    morning: "iđđes",
    afternoon: "maŋŋel gaskabeaivvi",
    evening: "eahkes",
    night: "ihkku"
  }
};
var ordinalNumber67 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize67 = {
  ordinalNumber: ordinalNumber67,
  era: buildLocalizeFn({
    values: eraValues67,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues67,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues67,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues67,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues67,
    defaultWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/se/_lib/match.mjs
var matchOrdinalNumberPattern66 = /^(\d+)\.?/i;
var parseOrdinalNumberPattern66 = /\d+/i;
var matchEraPatterns66 = {
  narrow: /^(o\.? ?Kr\.?|m\.? ?Kr\.?)/i,
  abbreviated: /^(o\.? ?Kr\.?|m\.? ?Kr\.?)/i,
  wide: /^(ovdal Kristusa|ovdal min áiggi|maŋŋel Kristusa|min áigi)/i
};
var parseEraPatterns66 = {
  any: [/^o/i, /^m/i]
};
var matchQuarterPatterns66 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartála/i
};
var parseQuarterPatterns66 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns66 = {
  narrow: /^[ogncmsbčj]/i,
  abbreviated: /^(ođđa|guov|njuk|cuo|mies|geas|suoi|borg|čakč|golg|skáb|juov)\.?/i,
  wide: /^(ođđajagemánnu|guovvamánnu|njukčamánnu|cuoŋománnu|miessemánnu|geassemánnu|suoidnemánnu|borgemánnu|čakčamánnu|golggotmánnu|skábmamánnu|juovlamánnu)/i
};
var parseMonthPatterns66 = {
  narrow: [
    /^o/i,
    /^g/i,
    /^n/i,
    /^c/i,
    /^m/i,
    /^g/i,
    /^s/i,
    /^b/i,
    /^č/i,
    /^g/i,
    /^s/i,
    /^j/i
  ],
  any: [
    /^o/i,
    /^gu/i,
    /^n/i,
    /^c/i,
    /^m/i,
    /^ge/i,
    /^su/i,
    /^b/i,
    /^č/i,
    /^go/i,
    /^sk/i,
    /^j/i
  ]
};
var matchDayPatterns66 = {
  narrow: /^[svmgdbl]/i,
  short: /^(sotn|vuos|maŋ|gask|duor|bear|láv)/i,
  abbreviated: /^(sotn|vuos|maŋ|gask|duor|bear|láv)/i,
  wide: /^(sotnabeaivi|vuossárga|maŋŋebárga|gaskavahkku|duorastat|bearjadat|lávvardat)/i
};
var parseDayPatterns66 = {
  any: [/^s/i, /^v/i, /^m/i, /^g/i, /^d/i, /^b/i, /^l/i]
};
var matchDayPeriodPatterns66 = {
  narrow: /^(gaskaidja|gaskabeaivvi|(på) (iđđes|maŋŋel gaskabeaivvi|eahkes|ihkku)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|gaskaidja|gaskabeaivvi|(på) (iđđes|maŋŋel gaskabeaivvi|eahkes|ihkku))/i
};
var parseDayPeriodPatterns66 = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^gaskai/i,
    noon: /^gaskab/i,
    morning: /iđđes/i,
    afternoon: /maŋŋel gaskabeaivvi/i,
    evening: /eahkes/i,
    night: /ihkku/i
  }
};
var match66 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern66,
    parsePattern: parseOrdinalNumberPattern66,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns66,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns66,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns66,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns66,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns66,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns66,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns66,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns66,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns66,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns66,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/se.mjs
var se = {
  code: "se",
  formatDistance: formatDistance68,
  formatLong: formatLong75,
  formatRelative: formatRelative67,
  localize: localize67,
  match: match66,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/sk/_lib/formatDistance.mjs
function declensionGroup2(scheme2, count) {
  if (count === 1 && scheme2.one) {
    return scheme2.one;
  }
  if (count >= 2 && count <= 4 && scheme2.twoFour) {
    return scheme2.twoFour;
  }
  return scheme2.other;
}
function declension6(scheme2, count, time) {
  const group = declensionGroup2(scheme2, count);
  const finalText = group[time];
  return finalText.replace("{{count}}", String(count));
}
function extractPreposition(token) {
  const result = ["lessThan", "about", "over", "almost"].filter(
    function(preposition) {
      return !!token.match(new RegExp("^" + preposition));
    }
  );
  return result[0];
}
function prefixPreposition(preposition) {
  let translation = "";
  if (preposition === "almost") {
    translation = "takmer";
  }
  if (preposition === "about") {
    translation = "približne";
  }
  return translation.length > 0 ? translation + " " : "";
}
function suffixPreposition(preposition) {
  let translation = "";
  if (preposition === "lessThan") {
    translation = "menej než";
  }
  if (preposition === "over") {
    translation = "viac než";
  }
  return translation.length > 0 ? translation + " " : "";
}
function lowercaseFirstLetter(string2) {
  return string2.charAt(0).toLowerCase() + string2.slice(1);
}
var formatDistanceLocale67 = {
  xSeconds: {
    one: {
      present: "sekunda",
      past: "sekundou",
      future: "sekundu"
    },
    twoFour: {
      present: "{{count}} sekundy",
      past: "{{count}} sekundami",
      future: "{{count}} sekundy"
    },
    other: {
      present: "{{count}} sekúnd",
      past: "{{count}} sekundami",
      future: "{{count}} sekúnd"
    }
  },
  halfAMinute: {
    other: {
      present: "pol minúty",
      past: "pol minútou",
      future: "pol minúty"
    }
  },
  xMinutes: {
    one: {
      present: "minúta",
      past: "minútou",
      future: "minútu"
    },
    twoFour: {
      present: "{{count}} minúty",
      past: "{{count}} minútami",
      future: "{{count}} minúty"
    },
    other: {
      present: "{{count}} minút",
      past: "{{count}} minútami",
      future: "{{count}} minút"
    }
  },
  xHours: {
    one: {
      present: "hodina",
      past: "hodinou",
      future: "hodinu"
    },
    twoFour: {
      present: "{{count}} hodiny",
      past: "{{count}} hodinami",
      future: "{{count}} hodiny"
    },
    other: {
      present: "{{count}} hodín",
      past: "{{count}} hodinami",
      future: "{{count}} hodín"
    }
  },
  xDays: {
    one: {
      present: "deň",
      past: "dňom",
      future: "deň"
    },
    twoFour: {
      present: "{{count}} dni",
      past: "{{count}} dňami",
      future: "{{count}} dni"
    },
    other: {
      present: "{{count}} dní",
      past: "{{count}} dňami",
      future: "{{count}} dní"
    }
  },
  xWeeks: {
    one: {
      present: "týždeň",
      past: "týždňom",
      future: "týždeň"
    },
    twoFour: {
      present: "{{count}} týždne",
      past: "{{count}} týždňami",
      future: "{{count}} týždne"
    },
    other: {
      present: "{{count}} týždňov",
      past: "{{count}} týždňami",
      future: "{{count}} týždňov"
    }
  },
  xMonths: {
    one: {
      present: "mesiac",
      past: "mesiacom",
      future: "mesiac"
    },
    twoFour: {
      present: "{{count}} mesiace",
      past: "{{count}} mesiacmi",
      future: "{{count}} mesiace"
    },
    other: {
      present: "{{count}} mesiacov",
      past: "{{count}} mesiacmi",
      future: "{{count}} mesiacov"
    }
  },
  xYears: {
    one: {
      present: "rok",
      past: "rokom",
      future: "rok"
    },
    twoFour: {
      present: "{{count}} roky",
      past: "{{count}} rokmi",
      future: "{{count}} roky"
    },
    other: {
      present: "{{count}} rokov",
      past: "{{count}} rokmi",
      future: "{{count}} rokov"
    }
  }
};
var formatDistance69 = (token, count, options2) => {
  const preposition = extractPreposition(token) || "";
  const key = lowercaseFirstLetter(token.substring(preposition.length));
  const scheme2 = formatDistanceLocale67[key];
  if (!(options2 == null ? void 0 : options2.addSuffix)) {
    return prefixPreposition(preposition) + suffixPreposition(preposition) + declension6(scheme2, count, "present");
  }
  if (options2.comparison && options2.comparison > 0) {
    return prefixPreposition(preposition) + "o " + suffixPreposition(preposition) + declension6(scheme2, count, "future");
  } else {
    return prefixPreposition(preposition) + "pred " + suffixPreposition(preposition) + declension6(scheme2, count, "past");
  }
};

// ../../../node_modules/date-fns/locale/sk/_lib/formatLong.mjs
var dateFormats76 = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. M. y",
  short: "d. M. y"
};
var timeFormats76 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats76 = {
  full: "{{date}}, {{time}}",
  long: "{{date}}, {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong76 = {
  date: buildFormatLongFn({
    formats: dateFormats76,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats76,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats76,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/sk/_lib/formatRelative.mjs
var accusativeWeekdays7 = [
  "nedeľu",
  "pondelok",
  "utorok",
  "stredu",
  "štvrtok",
  "piatok",
  "sobotu"
];
function lastWeek8(day) {
  const weekday = accusativeWeekdays7[day];
  switch (day) {
    case 0:
    /* Sun */
    case 3:
    /* Wed */
    case 6:
      return "'minulú " + weekday + " o' p";
    default:
      return "'minulý' eeee 'o' p";
  }
}
function thisWeek8(day) {
  const weekday = accusativeWeekdays7[day];
  if (day === 4) {
    return "'vo' eeee 'o' p";
  } else {
    return "'v " + weekday + " o' p";
  }
}
function nextWeek8(day) {
  const weekday = accusativeWeekdays7[day];
  switch (day) {
    case 0:
    /* Sun */
    case 4:
    /* Wed */
    case 6:
      return "'budúcu " + weekday + " o' p";
    default:
      return "'budúci' eeee 'o' p";
  }
}
var formatRelativeLocale68 = {
  lastWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek8(day);
    } else {
      return lastWeek8(day);
    }
  },
  yesterday: "'včera o' p",
  today: "'dnes o' p",
  tomorrow: "'zajtra o' p",
  nextWeek: (date2, baseDate, options2) => {
    const day = date2.getDay();
    if (isSameWeek(date2, baseDate, options2)) {
      return thisWeek8(day);
    } else {
      return nextWeek8(day);
    }
  },
  other: "P"
};
var formatRelative68 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale68[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/sk/_lib/localize.mjs
var eraValues68 = {
  narrow: ["pred Kr.", "po Kr."],
  abbreviated: ["pred Kr.", "po Kr."],
  wide: ["pred Kristom", "po Kristovi"]
};
var quarterValues68 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. štvrťrok", "2. štvrťrok", "3. štvrťrok", "4. štvrťrok"]
};
var monthValues68 = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "máj",
    "jún",
    "júl",
    "aug",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "január",
    "február",
    "marec",
    "apríl",
    "máj",
    "jún",
    "júl",
    "august",
    "september",
    "október",
    "november",
    "december"
  ]
};
var formattingMonthValues15 = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "máj",
    "jún",
    "júl",
    "aug",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januára",
    "februára",
    "marca",
    "apríla",
    "mája",
    "júna",
    "júla",
    "augusta",
    "septembra",
    "októbra",
    "novembra",
    "decembra"
  ]
};
var dayValues68 = {
  narrow: ["n", "p", "u", "s", "š", "p", "s"],
  short: ["ne", "po", "ut", "st", "št", "pi", "so"],
  abbreviated: ["ne", "po", "ut", "st", "št", "pi", "so"],
  wide: [
    "nedeľa",
    "pondelok",
    "utorok",
    "streda",
    "štvrtok",
    "piatok",
    "sobota"
  ]
};
var dayPeriodValues68 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "poln.",
    noon: "pol.",
    morning: "ráno",
    afternoon: "pop.",
    evening: "več.",
    night: "noc"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "poln.",
    noon: "pol.",
    morning: "ráno",
    afternoon: "popol.",
    evening: "večer",
    night: "noc"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "polnoc",
    noon: "poludnie",
    morning: "ráno",
    afternoon: "popoludnie",
    evening: "večer",
    night: "noc"
  }
};
var formattingDayPeriodValues52 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "o poln.",
    noon: "nap.",
    morning: "ráno",
    afternoon: "pop.",
    evening: "več.",
    night: "v n."
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "o poln.",
    noon: "napol.",
    morning: "ráno",
    afternoon: "popol.",
    evening: "večer",
    night: "v noci"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "o polnoci",
    noon: "napoludnie",
    morning: "ráno",
    afternoon: "popoludní",
    evening: "večer",
    night: "v noci"
  }
};
var ordinalNumber68 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize68 = {
  ordinalNumber: ordinalNumber68,
  era: buildLocalizeFn({
    values: eraValues68,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues68,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues68,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues15,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues68,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues68,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues52,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/sk/_lib/match.mjs
var matchOrdinalNumberPattern67 = /^(\d+)\.?/i;
var parseOrdinalNumberPattern67 = /\d+/i;
var matchEraPatterns67 = {
  narrow: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
  abbreviated: /^(pred Kr\.|pred n\. l\.|po Kr\.|n\. l\.)/i,
  wide: /^(pred Kristom|pred na[šs][íi]m letopo[čc]tom|po Kristovi|n[áa][šs]ho letopo[čc]tu)/i
};
var parseEraPatterns67 = {
  any: [/^pr/i, /^(po|n)/i]
};
var matchQuarterPatterns67 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]\. [šs]tvr[ťt]rok/i
};
var parseQuarterPatterns67 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns67 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|m[áa]j|j[úu]n|j[úu]l|aug|sep|okt|nov|dec)/i,
  wide: /^(janu[áa]ra?|febru[áa]ra?|(marec|marca)|apr[íi]la?|m[áa]ja?|j[úu]na?|j[úu]la?|augusta?|(september|septembra)|(okt[óo]ber|okt[óo]bra)|(november|novembra)|(december|decembra))/i
};
var parseMonthPatterns67 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^m[áa]j/i,
    /^j[úu]n/i,
    /^j[úu]l/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns67 = {
  narrow: /^[npusšp]/i,
  short: /^(ne|po|ut|st|št|pi|so)/i,
  abbreviated: /^(ne|po|ut|st|št|pi|so)/i,
  wide: /^(nede[ľl]a|pondelok|utorok|streda|[šs]tvrtok|piatok|sobota])/i
};
var parseDayPatterns67 = {
  narrow: [/^n/i, /^p/i, /^u/i, /^s/i, /^š/i, /^p/i, /^s/i],
  any: [/^n/i, /^po/i, /^u/i, /^st/i, /^(št|stv)/i, /^pi/i, /^so/i]
};
var matchDayPeriodPatterns67 = {
  narrow: /^(am|pm|(o )?poln\.?|(nap\.?|pol\.?)|r[áa]no|pop\.?|ve[čc]\.?|(v n\.?|noc))/i,
  abbreviated: /^(am|pm|(o )?poln\.?|(napol\.?|pol\.?)|r[áa]no|pop\.?|ve[čc]er|(v )?noci?)/i,
  any: /^(am|pm|(o )?polnoci?|(na)?poludnie|r[áa]no|popoludn(ie|í|i)|ve[čc]er|(v )?noci?)/i
};
var parseDayPeriodPatterns67 = {
  any: {
    am: /^am/i,
    pm: /^pm/i,
    midnight: /poln/i,
    noon: /^(nap|(na)?pol(\.|u))/i,
    morning: /^r[áa]no/i,
    afternoon: /^pop/i,
    evening: /^ve[čc]/i,
    night: /^(noc|v n\.)/i
  }
};
var match67 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern67,
    parsePattern: parseOrdinalNumberPattern67,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns67,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns67,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns67,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns67,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns67,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns67,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns67,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns67,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns67,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns67,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/sk.mjs
var sk = {
  code: "sk",
  formatDistance: formatDistance69,
  formatLong: formatLong76,
  formatRelative: formatRelative68,
  localize: localize68,
  match: match67,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/sl/_lib/formatDistance.mjs
function isPluralType(val) {
  return val.one !== void 0;
}
var formatDistanceLocale68 = {
  lessThanXSeconds: {
    present: {
      one: "manj kot {{count}} sekunda",
      two: "manj kot {{count}} sekundi",
      few: "manj kot {{count}} sekunde",
      other: "manj kot {{count}} sekund"
    },
    past: {
      one: "manj kot {{count}} sekundo",
      two: "manj kot {{count}} sekundama",
      few: "manj kot {{count}} sekundami",
      other: "manj kot {{count}} sekundami"
    },
    future: {
      one: "manj kot {{count}} sekundo",
      two: "manj kot {{count}} sekundi",
      few: "manj kot {{count}} sekunde",
      other: "manj kot {{count}} sekund"
    }
  },
  xSeconds: {
    present: {
      one: "{{count}} sekunda",
      two: "{{count}} sekundi",
      few: "{{count}} sekunde",
      other: "{{count}} sekund"
    },
    past: {
      one: "{{count}} sekundo",
      two: "{{count}} sekundama",
      few: "{{count}} sekundami",
      other: "{{count}} sekundami"
    },
    future: {
      one: "{{count}} sekundo",
      two: "{{count}} sekundi",
      few: "{{count}} sekunde",
      other: "{{count}} sekund"
    }
  },
  halfAMinute: "pol minute",
  lessThanXMinutes: {
    present: {
      one: "manj kot {{count}} minuta",
      two: "manj kot {{count}} minuti",
      few: "manj kot {{count}} minute",
      other: "manj kot {{count}} minut"
    },
    past: {
      one: "manj kot {{count}} minuto",
      two: "manj kot {{count}} minutama",
      few: "manj kot {{count}} minutami",
      other: "manj kot {{count}} minutami"
    },
    future: {
      one: "manj kot {{count}} minuto",
      two: "manj kot {{count}} minuti",
      few: "manj kot {{count}} minute",
      other: "manj kot {{count}} minut"
    }
  },
  xMinutes: {
    present: {
      one: "{{count}} minuta",
      two: "{{count}} minuti",
      few: "{{count}} minute",
      other: "{{count}} minut"
    },
    past: {
      one: "{{count}} minuto",
      two: "{{count}} minutama",
      few: "{{count}} minutami",
      other: "{{count}} minutami"
    },
    future: {
      one: "{{count}} minuto",
      two: "{{count}} minuti",
      few: "{{count}} minute",
      other: "{{count}} minut"
    }
  },
  aboutXHours: {
    present: {
      one: "približno {{count}} ura",
      two: "približno {{count}} uri",
      few: "približno {{count}} ure",
      other: "približno {{count}} ur"
    },
    past: {
      one: "približno {{count}} uro",
      two: "približno {{count}} urama",
      few: "približno {{count}} urami",
      other: "približno {{count}} urami"
    },
    future: {
      one: "približno {{count}} uro",
      two: "približno {{count}} uri",
      few: "približno {{count}} ure",
      other: "približno {{count}} ur"
    }
  },
  xHours: {
    present: {
      one: "{{count}} ura",
      two: "{{count}} uri",
      few: "{{count}} ure",
      other: "{{count}} ur"
    },
    past: {
      one: "{{count}} uro",
      two: "{{count}} urama",
      few: "{{count}} urami",
      other: "{{count}} urami"
    },
    future: {
      one: "{{count}} uro",
      two: "{{count}} uri",
      few: "{{count}} ure",
      other: "{{count}} ur"
    }
  },
  xDays: {
    present: {
      one: "{{count}} dan",
      two: "{{count}} dni",
      few: "{{count}} dni",
      other: "{{count}} dni"
    },
    past: {
      one: "{{count}} dnem",
      two: "{{count}} dnevoma",
      few: "{{count}} dnevi",
      other: "{{count}} dnevi"
    },
    future: {
      one: "{{count}} dan",
      two: "{{count}} dni",
      few: "{{count}} dni",
      other: "{{count}} dni"
    }
  },
  // no tenses for weeks?
  aboutXWeeks: {
    one: "približno {{count}} teden",
    two: "približno {{count}} tedna",
    few: "približno {{count}} tedne",
    other: "približno {{count}} tednov"
  },
  // no tenses for weeks?
  xWeeks: {
    one: "{{count}} teden",
    two: "{{count}} tedna",
    few: "{{count}} tedne",
    other: "{{count}} tednov"
  },
  aboutXMonths: {
    present: {
      one: "približno {{count}} mesec",
      two: "približno {{count}} meseca",
      few: "približno {{count}} mesece",
      other: "približno {{count}} mesecev"
    },
    past: {
      one: "približno {{count}} mesecem",
      two: "približno {{count}} mesecema",
      few: "približno {{count}} meseci",
      other: "približno {{count}} meseci"
    },
    future: {
      one: "približno {{count}} mesec",
      two: "približno {{count}} meseca",
      few: "približno {{count}} mesece",
      other: "približno {{count}} mesecev"
    }
  },
  xMonths: {
    present: {
      one: "{{count}} mesec",
      two: "{{count}} meseca",
      few: "{{count}} meseci",
      other: "{{count}} mesecev"
    },
    past: {
      one: "{{count}} mesecem",
      two: "{{count}} mesecema",
      few: "{{count}} meseci",
      other: "{{count}} meseci"
    },
    future: {
      one: "{{count}} mesec",
      two: "{{count}} meseca",
      few: "{{count}} mesece",
      other: "{{count}} mesecev"
    }
  },
  aboutXYears: {
    present: {
      one: "približno {{count}} leto",
      two: "približno {{count}} leti",
      few: "približno {{count}} leta",
      other: "približno {{count}} let"
    },
    past: {
      one: "približno {{count}} letom",
      two: "približno {{count}} letoma",
      few: "približno {{count}} leti",
      other: "približno {{count}} leti"
    },
    future: {
      one: "približno {{count}} leto",
      two: "približno {{count}} leti",
      few: "približno {{count}} leta",
      other: "približno {{count}} let"
    }
  },
  xYears: {
    present: {
      one: "{{count}} leto",
      two: "{{count}} leti",
      few: "{{count}} leta",
      other: "{{count}} let"
    },
    past: {
      one: "{{count}} letom",
      two: "{{count}} letoma",
      few: "{{count}} leti",
      other: "{{count}} leti"
    },
    future: {
      one: "{{count}} leto",
      two: "{{count}} leti",
      few: "{{count}} leta",
      other: "{{count}} let"
    }
  },
  overXYears: {
    present: {
      one: "več kot {{count}} leto",
      two: "več kot {{count}} leti",
      few: "več kot {{count}} leta",
      other: "več kot {{count}} let"
    },
    past: {
      one: "več kot {{count}} letom",
      two: "več kot {{count}} letoma",
      few: "več kot {{count}} leti",
      other: "več kot {{count}} leti"
    },
    future: {
      one: "več kot {{count}} leto",
      two: "več kot {{count}} leti",
      few: "več kot {{count}} leta",
      other: "več kot {{count}} let"
    }
  },
  almostXYears: {
    present: {
      one: "skoraj {{count}} leto",
      two: "skoraj {{count}} leti",
      few: "skoraj {{count}} leta",
      other: "skoraj {{count}} let"
    },
    past: {
      one: "skoraj {{count}} letom",
      two: "skoraj {{count}} letoma",
      few: "skoraj {{count}} leti",
      other: "skoraj {{count}} leti"
    },
    future: {
      one: "skoraj {{count}} leto",
      two: "skoraj {{count}} leti",
      few: "skoraj {{count}} leta",
      other: "skoraj {{count}} let"
    }
  }
};
function getFormFromCount(count) {
  switch (count % 100) {
    case 1:
      return "one";
    case 2:
      return "two";
    case 3:
    case 4:
      return "few";
    default:
      return "other";
  }
}
var formatDistance70 = (token, count, options2) => {
  let result = "";
  let tense = "present";
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      tense = "future";
      result = "čez ";
    } else {
      tense = "past";
      result = "pred ";
    }
  }
  const tokenValue = formatDistanceLocale68[token];
  if (typeof tokenValue === "string") {
    result += tokenValue;
  } else {
    const form = getFormFromCount(count);
    if (isPluralType(tokenValue)) {
      result += tokenValue[form].replace("{{count}}", String(count));
    } else {
      result += tokenValue[tense][form].replace("{{count}}", String(count));
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/sl/_lib/formatLong.mjs
var dateFormats77 = {
  full: "EEEE, dd. MMMM y",
  long: "dd. MMMM y",
  medium: "d. MMM y",
  short: "d. MM. yy"
};
var timeFormats77 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats77 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong77 = {
  date: buildFormatLongFn({
    formats: dateFormats77,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats77,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats77,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/sl/_lib/formatRelative.mjs
var formatRelativeLocale69 = {
  lastWeek: (date2) => {
    const day = date2.getDay();
    switch (day) {
      case 0:
        return "'prejšnjo nedeljo ob' p";
      case 3:
        return "'prejšnjo sredo ob' p";
      case 6:
        return "'prejšnjo soboto ob' p";
      default:
        return "'prejšnji' EEEE 'ob' p";
    }
  },
  yesterday: "'včeraj ob' p",
  today: "'danes ob' p",
  tomorrow: "'jutri ob' p",
  nextWeek: (date2) => {
    const day = date2.getDay();
    switch (day) {
      case 0:
        return "'naslednjo nedeljo ob' p";
      case 3:
        return "'naslednjo sredo ob' p";
      case 6:
        return "'naslednjo soboto ob' p";
      default:
        return "'naslednji' EEEE 'ob' p";
    }
  },
  other: "P"
};
var formatRelative69 = (token, date2, _baseDate, _options) => {
  const format3 = formatRelativeLocale69[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/sl/_lib/localize.mjs
var eraValues69 = {
  narrow: ["pr. n. št.", "po n. št."],
  abbreviated: ["pr. n. št.", "po n. št."],
  wide: ["pred našim štetjem", "po našem štetju"]
};
var quarterValues69 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1. čet.", "2. čet.", "3. čet.", "4. čet."],
  wide: ["1. četrtletje", "2. četrtletje", "3. četrtletje", "4. četrtletje"]
};
var monthValues69 = {
  narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "jan.",
    "feb.",
    "mar.",
    "apr.",
    "maj",
    "jun.",
    "jul.",
    "avg.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januar",
    "februar",
    "marec",
    "april",
    "maj",
    "junij",
    "julij",
    "avgust",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
var dayValues69 = {
  narrow: ["n", "p", "t", "s", "č", "p", "s"],
  short: ["ned.", "pon.", "tor.", "sre.", "čet.", "pet.", "sob."],
  abbreviated: ["ned.", "pon.", "tor.", "sre.", "čet.", "pet.", "sob."],
  wide: [
    "nedelja",
    "ponedeljek",
    "torek",
    "sreda",
    "četrtek",
    "petek",
    "sobota"
  ]
};
var dayPeriodValues69 = {
  narrow: {
    am: "d",
    pm: "p",
    midnight: "24.00",
    noon: "12.00",
    morning: "j",
    afternoon: "p",
    evening: "v",
    night: "n"
  },
  abbreviated: {
    am: "dop.",
    pm: "pop.",
    midnight: "poln.",
    noon: "pold.",
    morning: "jut.",
    afternoon: "pop.",
    evening: "več.",
    night: "noč"
  },
  wide: {
    am: "dop.",
    pm: "pop.",
    midnight: "polnoč",
    noon: "poldne",
    morning: "jutro",
    afternoon: "popoldne",
    evening: "večer",
    night: "noč"
  }
};
var formattingDayPeriodValues53 = {
  narrow: {
    am: "d",
    pm: "p",
    midnight: "24.00",
    noon: "12.00",
    morning: "zj",
    afternoon: "p",
    evening: "zv",
    night: "po"
  },
  abbreviated: {
    am: "dop.",
    pm: "pop.",
    midnight: "opoln.",
    noon: "opold.",
    morning: "zjut.",
    afternoon: "pop.",
    evening: "zveč.",
    night: "ponoči"
  },
  wide: {
    am: "dop.",
    pm: "pop.",
    midnight: "opolnoči",
    noon: "opoldne",
    morning: "zjutraj",
    afternoon: "popoldan",
    evening: "zvečer",
    night: "ponoči"
  }
};
var ordinalNumber69 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize69 = {
  ordinalNumber: ordinalNumber69,
  era: buildLocalizeFn({
    values: eraValues69,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues69,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues69,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues69,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues69,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues53,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/sl/_lib/match.mjs
var matchOrdinalNumberPattern68 = /^(\d+)\./i;
var parseOrdinalNumberPattern68 = /\d+/i;
var matchEraPatterns68 = {
  abbreviated: /^(pr\. n\. št\.|po n\. št\.)/i,
  wide: /^(pred Kristusom|pred na[sš]im [sš]tetjem|po Kristusu|po na[sš]em [sš]tetju|na[sš]ega [sš]tetja)/i
};
var parseEraPatterns68 = {
  any: [/^pr/i, /^(po|na[sš]em)/i]
};
var matchQuarterPatterns68 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?[čc]et\.?/i,
  wide: /^[1234]\. [čc]etrtletje/i
};
var parseQuarterPatterns68 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns68 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan\.|feb\.|mar\.|apr\.|maj|jun\.|jul\.|avg\.|sep\.|okt\.|nov\.|dec\.)/i,
  wide: /^(januar|februar|marec|april|maj|junij|julij|avgust|september|oktober|november|december)/i
};
var parseMonthPatterns68 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  abbreviated: [
    /^ja/i,
    /^fe/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  wide: [
    /^ja/i,
    /^fe/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns68 = {
  narrow: /^[nptsčc]/i,
  short: /^(ned\.|pon\.|tor\.|sre\.|[cč]et\.|pet\.|sob\.)/i,
  abbreviated: /^(ned\.|pon\.|tor\.|sre\.|[cč]et\.|pet\.|sob\.)/i,
  wide: /^(nedelja|ponedeljek|torek|sreda|[cč]etrtek|petek|sobota)/i
};
var parseDayPatterns68 = {
  narrow: [/^n/i, /^p/i, /^t/i, /^s/i, /^[cč]/i, /^p/i, /^s/i],
  any: [/^n/i, /^po/i, /^t/i, /^sr/i, /^[cč]/i, /^pe/i, /^so/i]
};
var matchDayPeriodPatterns68 = {
  narrow: /^(d|po?|z?v|n|z?j|24\.00|12\.00)/i,
  any: /^(dop\.|pop\.|o?poln(\.|o[cč]i?)|o?pold(\.|ne)|z?ve[cč](\.|er)|(po)?no[cč]i?|popold(ne|an)|jut(\.|ro)|zjut(\.|raj))/i
};
var parseDayPeriodPatterns68 = {
  narrow: {
    am: /^d/i,
    pm: /^p/i,
    midnight: /^24/i,
    noon: /^12/i,
    morning: /^(z?j)/i,
    afternoon: /^p/i,
    evening: /^(z?v)/i,
    night: /^(n|po)/i
  },
  any: {
    am: /^dop\./i,
    pm: /^pop\./i,
    midnight: /^o?poln/i,
    noon: /^o?pold/i,
    morning: /j/i,
    afternoon: /^pop\./i,
    evening: /^z?ve/i,
    night: /(po)?no/i
  }
};
var match68 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern68,
    parsePattern: parseOrdinalNumberPattern68,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns68,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns68,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns68,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns68,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns68,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns68,
    defaultParseWidth: "wide"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns68,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns68,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns68,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns68,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/sl.mjs
var sl = {
  code: "sl",
  formatDistance: formatDistance70,
  formatLong: formatLong77,
  formatRelative: formatRelative69,
  localize: localize69,
  match: match68,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/sq/_lib/formatDistance.mjs
var formatDistanceLocale69 = {
  lessThanXSeconds: {
    one: "më pak se një sekondë",
    other: "më pak se {{count}} sekonda"
  },
  xSeconds: {
    one: "1 sekondë",
    other: "{{count}} sekonda"
  },
  halfAMinute: "gjysëm minuti",
  lessThanXMinutes: {
    one: "më pak se një minute",
    other: "më pak se {{count}} minuta"
  },
  xMinutes: {
    one: "1 minutë",
    other: "{{count}} minuta"
  },
  aboutXHours: {
    one: "rreth 1 orë",
    other: "rreth {{count}} orë"
  },
  xHours: {
    one: "1 orë",
    other: "{{count}} orë"
  },
  xDays: {
    one: "1 ditë",
    other: "{{count}} ditë"
  },
  aboutXWeeks: {
    one: "rreth 1 javë",
    other: "rreth {{count}} javë"
  },
  xWeeks: {
    one: "1 javë",
    other: "{{count}} javë"
  },
  aboutXMonths: {
    one: "rreth 1 muaj",
    other: "rreth {{count}} muaj"
  },
  xMonths: {
    one: "1 muaj",
    other: "{{count}} muaj"
  },
  aboutXYears: {
    one: "rreth 1 vit",
    other: "rreth {{count}} vite"
  },
  xYears: {
    one: "1 vit",
    other: "{{count}} vite"
  },
  overXYears: {
    one: "mbi 1 vit",
    other: "mbi {{count}} vite"
  },
  almostXYears: {
    one: "pothuajse 1 vit",
    other: "pothuajse {{count}} vite"
  }
};
var formatDistance71 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale69[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "në " + result;
    } else {
      return result + " më parë";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/sq/_lib/formatLong.mjs
var dateFormats78 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats78 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats78 = {
  full: "{{date}} 'në' {{time}}",
  long: "{{date}} 'në' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong78 = {
  date: buildFormatLongFn({
    formats: dateFormats78,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats78,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats78,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/sq/_lib/formatRelative.mjs
var formatRelativeLocale70 = {
  lastWeek: "'të' eeee 'e shkuar në' p",
  yesterday: "'dje në' p",
  today: "'sot në' p",
  tomorrow: "'nesër në' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative70 = (token, _date, _baseDate, _options) => formatRelativeLocale70[token];

// ../../../node_modules/date-fns/locale/sq/_lib/localize.mjs
var eraValues70 = {
  narrow: ["P", "M"],
  abbreviated: ["PK", "MK"],
  wide: ["Para Krishtit", "Mbas Krishtit"]
};
var quarterValues70 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["4-mujori I", "4-mujori II", "4-mujori III", "4-mujori IV"]
};
var monthValues70 = {
  narrow: ["J", "S", "M", "P", "M", "Q", "K", "G", "S", "T", "N", "D"],
  abbreviated: [
    "Jan",
    "Shk",
    "Mar",
    "Pri",
    "Maj",
    "Qer",
    "Kor",
    "Gus",
    "Sht",
    "Tet",
    "Nën",
    "Dhj"
  ],
  wide: [
    "Janar",
    "Shkurt",
    "Mars",
    "Prill",
    "Maj",
    "Qershor",
    "Korrik",
    "Gusht",
    "Shtator",
    "Tetor",
    "Nëntor",
    "Dhjetor"
  ]
};
var dayValues70 = {
  narrow: ["D", "H", "M", "M", "E", "P", "S"],
  short: ["Di", "Hë", "Ma", "Më", "En", "Pr", "Sh"],
  abbreviated: ["Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Sht"],
  wide: ["Dielë", "Hënë", "Martë", "Mërkurë", "Enjte", "Premte", "Shtunë"]
};
var dayPeriodValues70 = {
  narrow: {
    am: "p",
    pm: "m",
    midnight: "m",
    noon: "d",
    morning: "mëngjes",
    afternoon: "dite",
    evening: "mbrëmje",
    night: "natë"
  },
  abbreviated: {
    am: "PD",
    pm: "MD",
    midnight: "mesnëtë",
    noon: "drek",
    morning: "mëngjes",
    afternoon: "mbasdite",
    evening: "mbrëmje",
    night: "natë"
  },
  wide: {
    am: "p.d.",
    pm: "m.d.",
    midnight: "mesnëtë",
    noon: "drek",
    morning: "mëngjes",
    afternoon: "mbasdite",
    evening: "mbrëmje",
    night: "natë"
  }
};
var formattingDayPeriodValues54 = {
  narrow: {
    am: "p",
    pm: "m",
    midnight: "m",
    noon: "d",
    morning: "në mëngjes",
    afternoon: "në mbasdite",
    evening: "në mbrëmje",
    night: "në mesnatë"
  },
  abbreviated: {
    am: "PD",
    pm: "MD",
    midnight: "mesnatë",
    noon: "drek",
    morning: "në mëngjes",
    afternoon: "në mbasdite",
    evening: "në mbrëmje",
    night: "në mesnatë"
  },
  wide: {
    am: "p.d.",
    pm: "m.d.",
    midnight: "mesnatë",
    noon: "drek",
    morning: "në mëngjes",
    afternoon: "në mbasdite",
    evening: "në mbrëmje",
    night: "në mesnatë"
  }
};
var ordinalNumber70 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  if ((options2 == null ? void 0 : options2.unit) === "hour") return String(number2);
  if (number2 === 1) return number2 + "-rë";
  if (number2 === 4) return number2 + "t";
  return number2 + "-të";
};
var localize70 = {
  ordinalNumber: ordinalNumber70,
  era: buildLocalizeFn({
    values: eraValues70,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues70,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues70,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues70,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues70,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues54,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/sq/_lib/match.mjs
var matchOrdinalNumberPattern69 = /^(\d+)(-rë|-të|t|)?/i;
var parseOrdinalNumberPattern69 = /\d+/i;
var matchEraPatterns69 = {
  narrow: /^(p|m)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(para krishtit|mbas krishtit)/i
};
var parseEraPatterns69 = {
  any: [/^b/i, /^(p|m)/i]
};
var matchQuarterPatterns69 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234]-mujori (i{1,3}|iv)/i
};
var parseQuarterPatterns69 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns69 = {
  narrow: /^[jsmpqkftnd]/i,
  abbreviated: /^(jan|shk|mar|pri|maj|qer|kor|gus|sht|tet|nën|dhj)/i,
  wide: /^(janar|shkurt|mars|prill|maj|qershor|korrik|gusht|shtator|tetor|nëntor|dhjetor)/i
};
var parseMonthPatterns69 = {
  narrow: [
    /^j/i,
    /^s/i,
    /^m/i,
    /^p/i,
    /^m/i,
    /^q/i,
    /^k/i,
    /^g/i,
    /^s/i,
    /^t/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^shk/i,
    /^mar/i,
    /^pri/i,
    /^maj/i,
    /^qer/i,
    /^kor/i,
    /^gu/i,
    /^sht/i,
    /^tet/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns69 = {
  narrow: /^[dhmeps]/i,
  short: /^(di|hë|ma|më|en|pr|sh)/i,
  abbreviated: /^(die|hën|mar|mër|enj|pre|sht)/i,
  wide: /^(dielë|hënë|martë|mërkurë|enjte|premte|shtunë)/i
};
var parseDayPatterns69 = {
  narrow: [/^d/i, /^h/i, /^m/i, /^m/i, /^e/i, /^p/i, /^s/i],
  any: [/^d/i, /^h/i, /^ma/i, /^më/i, /^e/i, /^p/i, /^s/i]
};
var matchDayPeriodPatterns69 = {
  narrow: /^(p|m|me|në (mëngjes|mbasdite|mbrëmje|mesnatë))/i,
  any: /^([pm]\.?\s?d\.?|drek|në (mëngjes|mbasdite|mbrëmje|mesnatë))/i
};
var parseDayPeriodPatterns69 = {
  any: {
    am: /^p/i,
    pm: /^m/i,
    midnight: /^me/i,
    noon: /^dr/i,
    morning: /mëngjes/i,
    afternoon: /mbasdite/i,
    evening: /mbrëmje/i,
    night: /natë/i
  }
};
var match69 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern69,
    parsePattern: parseOrdinalNumberPattern69,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns69,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns69,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns69,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns69,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns69,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns69,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns69,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns69,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns69,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns69,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/sq.mjs
var sq = {
  code: "sq",
  formatDistance: formatDistance71,
  formatLong: formatLong78,
  formatRelative: formatRelative70,
  localize: localize70,
  match: match69,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/sr/_lib/formatDistance.mjs
var formatDistanceLocale70 = {
  lessThanXSeconds: {
    one: {
      standalone: "мање од 1 секунде",
      withPrepositionAgo: "мање од 1 секунде",
      withPrepositionIn: "мање од 1 секунду"
    },
    dual: "мање од {{count}} секунде",
    other: "мање од {{count}} секунди"
  },
  xSeconds: {
    one: {
      standalone: "1 секунда",
      withPrepositionAgo: "1 секунде",
      withPrepositionIn: "1 секунду"
    },
    dual: "{{count}} секунде",
    other: "{{count}} секунди"
  },
  halfAMinute: "пола минуте",
  lessThanXMinutes: {
    one: {
      standalone: "мање од 1 минуте",
      withPrepositionAgo: "мање од 1 минуте",
      withPrepositionIn: "мање од 1 минуту"
    },
    dual: "мање од {{count}} минуте",
    other: "мање од {{count}} минута"
  },
  xMinutes: {
    one: {
      standalone: "1 минута",
      withPrepositionAgo: "1 минуте",
      withPrepositionIn: "1 минуту"
    },
    dual: "{{count}} минуте",
    other: "{{count}} минута"
  },
  aboutXHours: {
    one: {
      standalone: "око 1 сат",
      withPrepositionAgo: "око 1 сат",
      withPrepositionIn: "око 1 сат"
    },
    dual: "око {{count}} сата",
    other: "око {{count}} сати"
  },
  xHours: {
    one: {
      standalone: "1 сат",
      withPrepositionAgo: "1 сат",
      withPrepositionIn: "1 сат"
    },
    dual: "{{count}} сата",
    other: "{{count}} сати"
  },
  xDays: {
    one: {
      standalone: "1 дан",
      withPrepositionAgo: "1 дан",
      withPrepositionIn: "1 дан"
    },
    dual: "{{count}} дана",
    other: "{{count}} дана"
  },
  aboutXWeeks: {
    one: {
      standalone: "око 1 недељу",
      withPrepositionAgo: "око 1 недељу",
      withPrepositionIn: "око 1 недељу"
    },
    dual: "око {{count}} недеље",
    other: "око {{count}} недеље"
  },
  xWeeks: {
    one: {
      standalone: "1 недељу",
      withPrepositionAgo: "1 недељу",
      withPrepositionIn: "1 недељу"
    },
    dual: "{{count}} недеље",
    other: "{{count}} недеље"
  },
  aboutXMonths: {
    one: {
      standalone: "око 1 месец",
      withPrepositionAgo: "око 1 месец",
      withPrepositionIn: "око 1 месец"
    },
    dual: "око {{count}} месеца",
    other: "око {{count}} месеци"
  },
  xMonths: {
    one: {
      standalone: "1 месец",
      withPrepositionAgo: "1 месец",
      withPrepositionIn: "1 месец"
    },
    dual: "{{count}} месеца",
    other: "{{count}} месеци"
  },
  aboutXYears: {
    one: {
      standalone: "око 1 годину",
      withPrepositionAgo: "око 1 годину",
      withPrepositionIn: "око 1 годину"
    },
    dual: "око {{count}} године",
    other: "око {{count}} година"
  },
  xYears: {
    one: {
      standalone: "1 година",
      withPrepositionAgo: "1 године",
      withPrepositionIn: "1 годину"
    },
    dual: "{{count}} године",
    other: "{{count}} година"
  },
  overXYears: {
    one: {
      standalone: "преко 1 годину",
      withPrepositionAgo: "преко 1 годину",
      withPrepositionIn: "преко 1 годину"
    },
    dual: "преко {{count}} године",
    other: "преко {{count}} година"
  },
  almostXYears: {
    one: {
      standalone: "готово 1 годину",
      withPrepositionAgo: "готово 1 годину",
      withPrepositionIn: "готово 1 годину"
    },
    dual: "готово {{count}} године",
    other: "готово {{count}} година"
  }
};
var formatDistance72 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale70[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options2 == null ? void 0 : options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
  String(count).substr(-2, 1) !== "1") {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "за " + result;
    } else {
      return "пре " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/sr/_lib/formatLong.mjs
var dateFormats79 = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy."
};
var timeFormats79 = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats79 = {
  full: "{{date}} 'у' {{time}}",
  long: "{{date}} 'у' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong79 = {
  date: buildFormatLongFn({
    formats: dateFormats79,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats79,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats79,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/sr/_lib/formatRelative.mjs
var formatRelativeLocale71 = {
  lastWeek: (date2) => {
    const day = date2.getDay();
    switch (day) {
      case 0:
        return "'прошле недеље у' p";
      case 3:
        return "'прошле среде у' p";
      case 6:
        return "'прошле суботе у' p";
      default:
        return "'прошли' EEEE 'у' p";
    }
  },
  yesterday: "'јуче у' p",
  today: "'данас у' p",
  tomorrow: "'сутра у' p",
  nextWeek: (date2) => {
    const day = date2.getDay();
    switch (day) {
      case 0:
        return "'следеће недеље у' p";
      case 3:
        return "'следећу среду у' p";
      case 6:
        return "'следећу суботу у' p";
      default:
        return "'следећи' EEEE 'у' p";
    }
  },
  other: "P"
};
var formatRelative71 = (token, date2, _baseDate, _options) => {
  const format3 = formatRelativeLocale71[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/sr/_lib/localize.mjs
var eraValues71 = {
  narrow: ["пр.н.е.", "АД"],
  abbreviated: ["пр. Хр.", "по. Хр."],
  wide: ["Пре Христа", "После Христа"]
};
var quarterValues71 = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. кв.", "2. кв.", "3. кв.", "4. кв."],
  wide: ["1. квартал", "2. квартал", "3. квартал", "4. квартал"]
};
var monthValues71 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "јан",
    "феб",
    "мар",
    "апр",
    "мај",
    "јун",
    "јул",
    "авг",
    "сеп",
    "окт",
    "нов",
    "дец"
  ],
  wide: [
    "јануар",
    "фебруар",
    "март",
    "април",
    "мај",
    "јун",
    "јул",
    "август",
    "септембар",
    "октобар",
    "новембар",
    "децембар"
  ]
};
var formattingMonthValues16 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "јан",
    "феб",
    "мар",
    "апр",
    "мај",
    "јун",
    "јул",
    "авг",
    "сеп",
    "окт",
    "нов",
    "дец"
  ],
  wide: [
    "јануар",
    "фебруар",
    "март",
    "април",
    "мај",
    "јун",
    "јул",
    "август",
    "септембар",
    "октобар",
    "новембар",
    "децембар"
  ]
};
var dayValues71 = {
  narrow: ["Н", "П", "У", "С", "Ч", "П", "С"],
  short: ["нед", "пон", "уто", "сре", "чет", "пет", "суб"],
  abbreviated: ["нед", "пон", "уто", "сре", "чет", "пет", "суб"],
  wide: [
    "недеља",
    "понедељак",
    "уторак",
    "среда",
    "четвртак",
    "петак",
    "субота"
  ]
};
var formattingDayPeriodValues55 = {
  narrow: {
    am: "АМ",
    pm: "ПМ",
    midnight: "поноћ",
    noon: "подне",
    morning: "ујутру",
    afternoon: "поподне",
    evening: "увече",
    night: "ноћу"
  },
  abbreviated: {
    am: "АМ",
    pm: "ПМ",
    midnight: "поноћ",
    noon: "подне",
    morning: "ујутру",
    afternoon: "поподне",
    evening: "увече",
    night: "ноћу"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "поноћ",
    noon: "подне",
    morning: "ујутру",
    afternoon: "после подне",
    evening: "увече",
    night: "ноћу"
  }
};
var dayPeriodValues71 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "поноћ",
    noon: "подне",
    morning: "ујутру",
    afternoon: "поподне",
    evening: "увече",
    night: "ноћу"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "поноћ",
    noon: "подне",
    morning: "ујутру",
    afternoon: "поподне",
    evening: "увече",
    night: "ноћу"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "поноћ",
    noon: "подне",
    morning: "ујутру",
    afternoon: "после подне",
    evening: "увече",
    night: "ноћу"
  }
};
var ordinalNumber71 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize71 = {
  ordinalNumber: ordinalNumber71,
  era: buildLocalizeFn({
    values: eraValues71,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues71,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues71,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues16,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues71,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues71,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues55,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/sr/_lib/match.mjs
var matchOrdinalNumberPattern70 = /^(\d+)\./i;
var parseOrdinalNumberPattern70 = /\d+/i;
var matchEraPatterns70 = {
  narrow: /^(пр\.н\.е\.|АД)/i,
  abbreviated: /^(пр\.\s?Хр\.|по\.\s?Хр\.)/i,
  wide: /^(Пре Христа|пре нове ере|После Христа|нова ера)/i
};
var parseEraPatterns70 = {
  any: [/^пр/i, /^(по|нова)/i]
};
var matchQuarterPatterns70 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?кв\.?/i,
  wide: /^[1234]\. квартал/i
};
var parseQuarterPatterns70 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns70 = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(јан|феб|мар|апр|мај|јун|јул|авг|сеп|окт|нов|дец)/i,
  wide: /^((јануар|јануара)|(фебруар|фебруара)|(март|марта)|(април|априла)|(мја|маја)|(јун|јуна)|(јул|јула)|(август|августа)|(септембар|септембра)|(октобар|октобра)|(новембар|новембра)|(децембар|децембра))/i
};
var parseMonthPatterns70 = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i
  ],
  any: [
    /^ја/i,
    /^ф/i,
    /^мар/i,
    /^ап/i,
    /^мај/i,
    /^јун/i,
    /^јул/i,
    /^авг/i,
    /^с/i,
    /^о/i,
    /^н/i,
    /^д/i
  ]
};
var matchDayPatterns70 = {
  narrow: /^[пусчн]/i,
  short: /^(нед|пон|уто|сре|чет|пет|суб)/i,
  abbreviated: /^(нед|пон|уто|сре|чет|пет|суб)/i,
  wide: /^(недеља|понедељак|уторак|среда|четвртак|петак|субота)/i
};
var parseDayPatterns70 = {
  narrow: [/^п/i, /^у/i, /^с/i, /^ч/i, /^п/i, /^с/i, /^н/i],
  any: [/^нед/i, /^пон/i, /^уто/i, /^сре/i, /^чет/i, /^пет/i, /^суб/i]
};
var matchDayPeriodPatterns70 = {
  any: /^(ам|пм|поноћ|(по)?подне|увече|ноћу|после подне|ујутру)/i
};
var parseDayPeriodPatterns70 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^поно/i,
    noon: /^под/i,
    morning: /ујутру/i,
    afternoon: /(после\s|по)+подне/i,
    evening: /(увече)/i,
    night: /(ноћу)/i
  }
};
var match70 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern70,
    parsePattern: parseOrdinalNumberPattern70,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns70,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns70,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns70,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns70,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns70,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns70,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns70,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns70,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns70,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns70,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/sr.mjs
var sr = {
  code: "sr",
  formatDistance: formatDistance72,
  formatLong: formatLong79,
  formatRelative: formatRelative71,
  localize: localize71,
  match: match70,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/sr-Latn/_lib/formatDistance.mjs
var formatDistanceLocale71 = {
  lessThanXSeconds: {
    one: {
      standalone: "manje od 1 sekunde",
      withPrepositionAgo: "manje od 1 sekunde",
      withPrepositionIn: "manje od 1 sekundu"
    },
    dual: "manje od {{count}} sekunde",
    other: "manje od {{count}} sekundi"
  },
  xSeconds: {
    one: {
      standalone: "1 sekunda",
      withPrepositionAgo: "1 sekunde",
      withPrepositionIn: "1 sekundu"
    },
    dual: "{{count}} sekunde",
    other: "{{count}} sekundi"
  },
  halfAMinute: "pola minute",
  lessThanXMinutes: {
    one: {
      standalone: "manje od 1 minute",
      withPrepositionAgo: "manje od 1 minute",
      withPrepositionIn: "manje od 1 minutu"
    },
    dual: "manje od {{count}} minute",
    other: "manje od {{count}} minuta"
  },
  xMinutes: {
    one: {
      standalone: "1 minuta",
      withPrepositionAgo: "1 minute",
      withPrepositionIn: "1 minutu"
    },
    dual: "{{count}} minute",
    other: "{{count}} minuta"
  },
  aboutXHours: {
    one: {
      standalone: "oko 1 sat",
      withPrepositionAgo: "oko 1 sat",
      withPrepositionIn: "oko 1 sat"
    },
    dual: "oko {{count}} sata",
    other: "oko {{count}} sati"
  },
  xHours: {
    one: {
      standalone: "1 sat",
      withPrepositionAgo: "1 sat",
      withPrepositionIn: "1 sat"
    },
    dual: "{{count}} sata",
    other: "{{count}} sati"
  },
  xDays: {
    one: {
      standalone: "1 dan",
      withPrepositionAgo: "1 dan",
      withPrepositionIn: "1 dan"
    },
    dual: "{{count}} dana",
    other: "{{count}} dana"
  },
  aboutXWeeks: {
    one: {
      standalone: "oko 1 nedelju",
      withPrepositionAgo: "oko 1 nedelju",
      withPrepositionIn: "oko 1 nedelju"
    },
    dual: "oko {{count}} nedelje",
    other: "oko {{count}} nedelje"
  },
  xWeeks: {
    one: {
      standalone: "1 nedelju",
      withPrepositionAgo: "1 nedelju",
      withPrepositionIn: "1 nedelju"
    },
    dual: "{{count}} nedelje",
    other: "{{count}} nedelje"
  },
  aboutXMonths: {
    one: {
      standalone: "oko 1 mesec",
      withPrepositionAgo: "oko 1 mesec",
      withPrepositionIn: "oko 1 mesec"
    },
    dual: "oko {{count}} meseca",
    other: "oko {{count}} meseci"
  },
  xMonths: {
    one: {
      standalone: "1 mesec",
      withPrepositionAgo: "1 mesec",
      withPrepositionIn: "1 mesec"
    },
    dual: "{{count}} meseca",
    other: "{{count}} meseci"
  },
  aboutXYears: {
    one: {
      standalone: "oko 1 godinu",
      withPrepositionAgo: "oko 1 godinu",
      withPrepositionIn: "oko 1 godinu"
    },
    dual: "oko {{count}} godine",
    other: "oko {{count}} godina"
  },
  xYears: {
    one: {
      standalone: "1 godina",
      withPrepositionAgo: "1 godine",
      withPrepositionIn: "1 godinu"
    },
    dual: "{{count}} godine",
    other: "{{count}} godina"
  },
  overXYears: {
    one: {
      standalone: "preko 1 godinu",
      withPrepositionAgo: "preko 1 godinu",
      withPrepositionIn: "preko 1 godinu"
    },
    dual: "preko {{count}} godine",
    other: "preko {{count}} godina"
  },
  almostXYears: {
    one: {
      standalone: "gotovo 1 godinu",
      withPrepositionAgo: "gotovo 1 godinu",
      withPrepositionIn: "gotovo 1 godinu"
    },
    dual: "gotovo {{count}} godine",
    other: "gotovo {{count}} godina"
  }
};
var formatDistance73 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale71[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options2 == null ? void 0 : options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        result = tokenValue.one.withPrepositionIn;
      } else {
        result = tokenValue.one.withPrepositionAgo;
      }
    } else {
      result = tokenValue.one.standalone;
    }
  } else if (count % 10 > 1 && count % 10 < 5 && // if last digit is between 2 and 4
  String(count).substr(-2, 1) !== "1") {
    result = tokenValue.dual.replace("{{count}}", String(count));
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "za " + result;
    } else {
      return "pre " + result;
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/sr-Latn/_lib/formatLong.mjs
var dateFormats80 = {
  full: "EEEE, d. MMMM yyyy.",
  long: "d. MMMM yyyy.",
  medium: "d. MMM yy.",
  short: "dd. MM. yy."
};
var timeFormats80 = {
  full: "HH:mm:ss (zzzz)",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats80 = {
  full: "{{date}} 'u' {{time}}",
  long: "{{date}} 'u' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong80 = {
  date: buildFormatLongFn({
    formats: dateFormats80,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats80,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats80,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/sr-Latn/_lib/formatRelative.mjs
var formatRelativeLocale72 = {
  lastWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'prošle nedelje u' p";
      case 3:
        return "'prošle srede u' p";
      case 6:
        return "'prošle subote u' p";
      default:
        return "'prošli' EEEE 'u' p";
    }
  },
  yesterday: "'juče u' p",
  today: "'danas u' p",
  tomorrow: "'sutra u' p",
  nextWeek: (date2) => {
    switch (date2.getDay()) {
      case 0:
        return "'sledeće nedelje u' p";
      case 3:
        return "'sledeću sredu u' p";
      case 6:
        return "'sledeću subotu u' p";
      default:
        return "'sledeći' EEEE 'u' p";
    }
  },
  other: "P"
};
var formatRelative72 = (token, date2, _baseDate, _options) => {
  const format3 = formatRelativeLocale72[token];
  if (typeof format3 === "function") {
    return format3(date2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/sr-Latn/_lib/localize.mjs
var eraValues72 = {
  narrow: ["pr.n.e.", "AD"],
  abbreviated: ["pr. Hr.", "po. Hr."],
  wide: ["Pre Hrista", "Posle Hrista"]
};
var quarterValues72 = {
  narrow: ["1.", "2.", "3.", "4."],
  abbreviated: ["1. kv.", "2. kv.", "3. kv.", "4. kv."],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
var monthValues72 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "jun",
    "jul",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar"
  ]
};
var formattingMonthValues17 = {
  narrow: [
    "1.",
    "2.",
    "3.",
    "4.",
    "5.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "11.",
    "12."
  ],
  abbreviated: [
    "jan",
    "feb",
    "mar",
    "apr",
    "maj",
    "jun",
    "jul",
    "avg",
    "sep",
    "okt",
    "nov",
    "dec"
  ],
  wide: [
    "januar",
    "februar",
    "mart",
    "april",
    "maj",
    "jun",
    "jul",
    "avgust",
    "septembar",
    "oktobar",
    "novembar",
    "decembar"
  ]
};
var dayValues72 = {
  narrow: ["N", "P", "U", "S", "Č", "P", "S"],
  short: ["ned", "pon", "uto", "sre", "čet", "pet", "sub"],
  abbreviated: ["ned", "pon", "uto", "sre", "čet", "pet", "sub"],
  wide: [
    "nedelja",
    "ponedeljak",
    "utorak",
    "sreda",
    "četvrtak",
    "petak",
    "subota"
  ]
};
var formattingDayPeriodValues56 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveče",
    night: "noću"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveče",
    night: "noću"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "posle podne",
    evening: "uveče",
    night: "noću"
  }
};
var dayPeriodValues72 = {
  narrow: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveče",
    night: "noću"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "popodne",
    evening: "uveče",
    night: "noću"
  },
  wide: {
    am: "AM",
    pm: "PM",
    midnight: "ponoć",
    noon: "podne",
    morning: "ujutru",
    afternoon: "posle podne",
    evening: "uveče",
    night: "noću"
  }
};
var ordinalNumber72 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize72 = {
  ordinalNumber: ordinalNumber72,
  era: buildLocalizeFn({
    values: eraValues72,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues72,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues72,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues17,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues72,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues72,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues56,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/sr-Latn/_lib/match.mjs
var matchOrdinalNumberPattern71 = /^(\d+)\./i;
var parseOrdinalNumberPattern71 = /\d+/i;
var matchEraPatterns71 = {
  narrow: /^(pr\.n\.e\.|AD)/i,
  abbreviated: /^(pr\.\s?Hr\.|po\.\s?Hr\.)/i,
  wide: /^(Pre Hrista|pre nove ere|Posle Hrista|nova era)/i
};
var parseEraPatterns71 = {
  any: [/^pr/i, /^(po|nova)/i]
};
var matchQuarterPatterns71 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]\.\s?kv\.?/i,
  wide: /^[1234]\. kvartal/i
};
var parseQuarterPatterns71 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns71 = {
  narrow: /^(10|11|12|[123456789])\./i,
  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,
  wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(jun|juna)|(jul|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i
};
var parseMonthPatterns71 = {
  narrow: [
    /^1/i,
    /^2/i,
    /^3/i,
    /^4/i,
    /^5/i,
    /^6/i,
    /^7/i,
    /^8/i,
    /^9/i,
    /^10/i,
    /^11/i,
    /^12/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^avg/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns71 = {
  narrow: /^[npusčc]/i,
  short: /^(ned|pon|uto|sre|(čet|cet)|pet|sub)/i,
  abbreviated: /^(ned|pon|uto|sre|(čet|cet)|pet|sub)/i,
  wide: /^(nedelja|ponedeljak|utorak|sreda|(četvrtak|cetvrtak)|petak|subota)/i
};
var parseDayPatterns71 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns71 = {
  any: /^(am|pm|ponoc|ponoć|(po)?podne|uvece|uveče|noću|posle podne|ujutru)/i
};
var parseDayPeriodPatterns71 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^pono/i,
    noon: /^pod/i,
    morning: /jutro/i,
    afternoon: /(posle\s|po)+podne/i,
    evening: /(uvece|uveče)/i,
    night: /(nocu|noću)/i
  }
};
var match71 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern71,
    parsePattern: parseOrdinalNumberPattern71,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns71,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns71,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns71,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns71,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns71,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns71,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns71,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns71,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns71,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns71,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/sr-Latn.mjs
var srLatn = {
  code: "sr-Latn",
  formatDistance: formatDistance73,
  formatLong: formatLong80,
  formatRelative: formatRelative72,
  localize: localize72,
  match: match71,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/sv/_lib/formatDistance.mjs
var formatDistanceLocale72 = {
  lessThanXSeconds: {
    one: "mindre än en sekund",
    other: "mindre än {{count}} sekunder"
  },
  xSeconds: {
    one: "en sekund",
    other: "{{count}} sekunder"
  },
  halfAMinute: "en halv minut",
  lessThanXMinutes: {
    one: "mindre än en minut",
    other: "mindre än {{count}} minuter"
  },
  xMinutes: {
    one: "en minut",
    other: "{{count}} minuter"
  },
  aboutXHours: {
    one: "ungefär en timme",
    other: "ungefär {{count}} timmar"
  },
  xHours: {
    one: "en timme",
    other: "{{count}} timmar"
  },
  xDays: {
    one: "en dag",
    other: "{{count}} dagar"
  },
  aboutXWeeks: {
    one: "ungefär en vecka",
    other: "ungefär {{count}} veckor"
  },
  xWeeks: {
    one: "en vecka",
    other: "{{count}} veckor"
  },
  aboutXMonths: {
    one: "ungefär en månad",
    other: "ungefär {{count}} månader"
  },
  xMonths: {
    one: "en månad",
    other: "{{count}} månader"
  },
  aboutXYears: {
    one: "ungefär ett år",
    other: "ungefär {{count}} år"
  },
  xYears: {
    one: "ett år",
    other: "{{count}} år"
  },
  overXYears: {
    one: "över ett år",
    other: "över {{count}} år"
  },
  almostXYears: {
    one: "nästan ett år",
    other: "nästan {{count}} år"
  }
};
var wordMapping2 = [
  "noll",
  "en",
  "två",
  "tre",
  "fyra",
  "fem",
  "sex",
  "sju",
  "åtta",
  "nio",
  "tio",
  "elva",
  "tolv"
];
var formatDistance74 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale72[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace(
      "{{count}}",
      count < 13 ? wordMapping2[count] : String(count)
    );
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "om " + result;
    } else {
      return result + " sedan";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/sv/_lib/formatLong.mjs
var dateFormats81 = {
  full: "EEEE d MMMM y",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "y-MM-dd"
};
var timeFormats81 = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats81 = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong81 = {
  date: buildFormatLongFn({
    formats: dateFormats81,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats81,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats81,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/sv/_lib/formatRelative.mjs
var formatRelativeLocale73 = {
  lastWeek: "'i' EEEE's kl.' p",
  yesterday: "'igår kl.' p",
  today: "'idag kl.' p",
  tomorrow: "'imorgon kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P"
};
var formatRelative73 = (token, _date, _baseDate, _options) => formatRelativeLocale73[token];

// ../../../node_modules/date-fns/locale/sv/_lib/localize.mjs
var eraValues73 = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["före Kristus", "efter Kristus"]
};
var quarterValues73 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1:a kvartalet", "2:a kvartalet", "3:e kvartalet", "4:e kvartalet"]
};
var monthValues73 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "jan.",
    "feb.",
    "mars",
    "apr.",
    "maj",
    "juni",
    "juli",
    "aug.",
    "sep.",
    "okt.",
    "nov.",
    "dec."
  ],
  wide: [
    "januari",
    "februari",
    "mars",
    "april",
    "maj",
    "juni",
    "juli",
    "augusti",
    "september",
    "oktober",
    "november",
    "december"
  ]
};
var dayValues73 = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["sö", "må", "ti", "on", "to", "fr", "lö"],
  abbreviated: ["sön", "mån", "tis", "ons", "tors", "fre", "lör"],
  wide: ["söndag", "måndag", "tisdag", "onsdag", "torsdag", "fredag", "lördag"]
};
var dayPeriodValues73 = {
  narrow: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "morg.",
    afternoon: "efterm.",
    evening: "kväll",
    night: "natt"
  },
  abbreviated: {
    am: "f.m.",
    pm: "e.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "morgon",
    afternoon: "efterm.",
    evening: "kväll",
    night: "natt"
  },
  wide: {
    am: "förmiddag",
    pm: "eftermiddag",
    midnight: "midnatt",
    noon: "middag",
    morning: "morgon",
    afternoon: "eftermiddag",
    evening: "kväll",
    night: "natt"
  }
};
var formattingDayPeriodValues57 = {
  narrow: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morg.",
    afternoon: "på efterm.",
    evening: "på kvällen",
    night: "på natten"
  },
  abbreviated: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morg.",
    afternoon: "på efterm.",
    evening: "på kvällen",
    night: "på natten"
  },
  wide: {
    am: "fm",
    pm: "em",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morgonen",
    afternoon: "på eftermiddagen",
    evening: "på kvällen",
    night: "på natten"
  }
};
var ordinalNumber73 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
      case 2:
        return number2 + ":a";
    }
  }
  return number2 + ":e";
};
var localize73 = {
  ordinalNumber: ordinalNumber73,
  era: buildLocalizeFn({
    values: eraValues73,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues73,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues73,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues73,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues73,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues57,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/sv/_lib/match.mjs
var matchOrdinalNumberPattern72 = /^(\d+)(:a|:e)?/i;
var parseOrdinalNumberPattern72 = /\d+/i;
var matchEraPatterns72 = {
  narrow: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|f\.? ?v\.? ?t\.?|e\.? ?Kr\.?|v\.? ?t\.?)/i,
  wide: /^(före Kristus|före vår tid|efter Kristus|vår tid)/i
};
var parseEraPatterns72 = {
  any: [/^f/i, /^[ev]/i]
};
var matchQuarterPatterns72 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](:a|:e)? kvartalet/i
};
var parseQuarterPatterns72 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns72 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar[s]?|apr|maj|jun[i]?|jul[i]?|aug|sep|okt|nov|dec)\.?/i,
  wide: /^(januari|februari|mars|april|maj|juni|juli|augusti|september|oktober|november|december)/i
};
var parseMonthPatterns72 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^maj/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns72 = {
  narrow: /^[smtofl]/i,
  short: /^(sö|må|ti|on|to|fr|lö)/i,
  abbreviated: /^(sön|mån|tis|ons|tors|fre|lör)/i,
  wide: /^(söndag|måndag|tisdag|onsdag|torsdag|fredag|lördag)/i
};
var parseDayPatterns72 = {
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
var matchDayPeriodPatterns72 = {
  any: /^([fe]\.?\s?m\.?|midn(att)?|midd(ag)?|(på) (morgonen|eftermiddagen|kvällen|natten))/i
};
var parseDayPeriodPatterns72 = {
  any: {
    am: /^f/i,
    pm: /^e/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgon/i,
    afternoon: /eftermiddag/i,
    evening: /kväll/i,
    night: /natt/i
  }
};
var match72 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern72,
    parsePattern: parseOrdinalNumberPattern72,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns72,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns72,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns72,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns72,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns72,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns72,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns72,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns72,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns72,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns72,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/sv.mjs
var sv = {
  code: "sv",
  formatDistance: formatDistance74,
  formatLong: formatLong81,
  formatRelative: formatRelative73,
  localize: localize73,
  match: match72,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/ta/_lib/formatDistance.mjs
function isPluralType2(val) {
  return val.one !== void 0;
}
var formatDistanceLocale73 = {
  lessThanXSeconds: {
    one: {
      default: "ஒரு வினாடிக்கு குறைவாக",
      in: "ஒரு வினாடிக்குள்",
      ago: "ஒரு வினாடிக்கு முன்பு"
    },
    other: {
      default: "{{count}} வினாடிகளுக்கு குறைவாக",
      in: "{{count}} வினாடிகளுக்குள்",
      ago: "{{count}} வினாடிகளுக்கு முன்பு"
    }
  },
  xSeconds: {
    one: {
      default: "1 வினாடி",
      in: "1 வினாடியில்",
      ago: "1 வினாடி முன்பு"
    },
    other: {
      default: "{{count}} விநாடிகள்",
      in: "{{count}} வினாடிகளில்",
      ago: "{{count}} விநாடிகளுக்கு முன்பு"
    }
  },
  halfAMinute: {
    default: "அரை நிமிடம்",
    in: "அரை நிமிடத்தில்",
    ago: "அரை நிமிடம் முன்பு"
  },
  lessThanXMinutes: {
    one: {
      default: "ஒரு நிமிடத்திற்கும் குறைவாக",
      in: "ஒரு நிமிடத்திற்குள்",
      ago: "ஒரு நிமிடத்திற்கு முன்பு"
    },
    other: {
      default: "{{count}} நிமிடங்களுக்கும் குறைவாக",
      in: "{{count}} நிமிடங்களுக்குள்",
      ago: "{{count}} நிமிடங்களுக்கு முன்பு"
    }
  },
  xMinutes: {
    one: {
      default: "1 நிமிடம்",
      in: "1 நிமிடத்தில்",
      ago: "1 நிமிடம் முன்பு"
    },
    other: {
      default: "{{count}} நிமிடங்கள்",
      in: "{{count}} நிமிடங்களில்",
      ago: "{{count}} நிமிடங்களுக்கு முன்பு"
    }
  },
  aboutXHours: {
    one: {
      default: "சுமார் 1 மணி நேரம்",
      in: "சுமார் 1 மணி நேரத்தில்",
      ago: "சுமார் 1 மணி நேரத்திற்கு முன்பு"
    },
    other: {
      default: "சுமார் {{count}} மணி நேரம்",
      in: "சுமார் {{count}} மணி நேரத்திற்கு முன்பு",
      ago: "சுமார் {{count}} மணி நேரத்தில்"
    }
  },
  xHours: {
    one: {
      default: "1 மணி நேரம்",
      in: "1 மணி நேரத்தில்",
      ago: "1 மணி நேரத்திற்கு முன்பு"
    },
    other: {
      default: "{{count}} மணி நேரம்",
      in: "{{count}} மணி நேரத்தில்",
      ago: "{{count}} மணி நேரத்திற்கு முன்பு"
    }
  },
  xDays: {
    one: {
      default: "1 நாள்",
      in: "1 நாளில்",
      ago: "1 நாள் முன்பு"
    },
    other: {
      default: "{{count}} நாட்கள்",
      in: "{{count}} நாட்களில்",
      ago: "{{count}} நாட்களுக்கு முன்பு"
    }
  },
  aboutXWeeks: {
    one: {
      default: "சுமார் 1 வாரம்",
      in: "சுமார் 1 வாரத்தில்",
      ago: "சுமார் 1 வாரம் முன்பு"
    },
    other: {
      default: "சுமார் {{count}} வாரங்கள்",
      in: "சுமார் {{count}} வாரங்களில்",
      ago: "சுமார் {{count}} வாரங்களுக்கு முன்பு"
    }
  },
  xWeeks: {
    one: {
      default: "1 வாரம்",
      in: "1 வாரத்தில்",
      ago: "1 வாரம் முன்பு"
    },
    other: {
      default: "{{count}} வாரங்கள்",
      in: "{{count}} வாரங்களில்",
      ago: "{{count}} வாரங்களுக்கு முன்பு"
    }
  },
  aboutXMonths: {
    one: {
      default: "சுமார் 1 மாதம்",
      in: "சுமார் 1 மாதத்தில்",
      ago: "சுமார் 1 மாதத்திற்கு முன்பு"
    },
    other: {
      default: "சுமார் {{count}} மாதங்கள்",
      in: "சுமார் {{count}} மாதங்களில்",
      ago: "சுமார் {{count}} மாதங்களுக்கு முன்பு"
    }
  },
  xMonths: {
    one: {
      default: "1 மாதம்",
      in: "1 மாதத்தில்",
      ago: "1 மாதம் முன்பு"
    },
    other: {
      default: "{{count}} மாதங்கள்",
      in: "{{count}} மாதங்களில்",
      ago: "{{count}} மாதங்களுக்கு முன்பு"
    }
  },
  aboutXYears: {
    one: {
      default: "சுமார் 1 வருடம்",
      in: "சுமார் 1 ஆண்டில்",
      ago: "சுமார் 1 வருடம் முன்பு"
    },
    other: {
      default: "சுமார் {{count}} ஆண்டுகள்",
      in: "சுமார் {{count}} ஆண்டுகளில்",
      ago: "சுமார் {{count}} ஆண்டுகளுக்கு முன்பு"
    }
  },
  xYears: {
    one: {
      default: "1 வருடம்",
      in: "1 ஆண்டில்",
      ago: "1 வருடம் முன்பு"
    },
    other: {
      default: "{{count}} ஆண்டுகள்",
      in: "{{count}} ஆண்டுகளில்",
      ago: "{{count}} ஆண்டுகளுக்கு முன்பு"
    }
  },
  overXYears: {
    one: {
      default: "1 வருடத்திற்கு மேல்",
      in: "1 வருடத்திற்கும் மேலாக",
      ago: "1 வருடம் முன்பு"
    },
    other: {
      default: "{{count}} ஆண்டுகளுக்கும் மேலாக",
      in: "{{count}} ஆண்டுகளில்",
      ago: "{{count}} ஆண்டுகளுக்கு முன்பு"
    }
  },
  almostXYears: {
    one: {
      default: "கிட்டத்தட்ட 1 வருடம்",
      in: "கிட்டத்தட்ட 1 ஆண்டில்",
      ago: "கிட்டத்தட்ட 1 வருடம் முன்பு"
    },
    other: {
      default: "கிட்டத்தட்ட {{count}} ஆண்டுகள்",
      in: "கிட்டத்தட்ட {{count}} ஆண்டுகளில்",
      ago: "கிட்டத்தட்ட {{count}} ஆண்டுகளுக்கு முன்பு"
    }
  }
};
var formatDistance75 = (token, count, options2) => {
  const tense = (options2 == null ? void 0 : options2.addSuffix) ? options2.comparison && options2.comparison > 0 ? "in" : "ago" : "default";
  const tokenValue = formatDistanceLocale73[token];
  if (!isPluralType2(tokenValue)) return tokenValue[tense];
  if (count === 1) {
    return tokenValue.one[tense];
  } else {
    return tokenValue.other[tense].replace("{{count}}", String(count));
  }
};

// ../../../node_modules/date-fns/locale/ta/_lib/formatLong.mjs
var dateFormats82 = {
  full: "EEEE, d MMMM, y",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "d/M/yy"
};
var timeFormats82 = {
  full: "a h:mm:ss zzzz",
  long: "a h:mm:ss z",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats82 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong82 = {
  date: buildFormatLongFn({
    formats: dateFormats82,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats82,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats82,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ta/_lib/formatRelative.mjs
var formatRelativeLocale74 = {
  lastWeek: "'கடந்த' eeee p 'மணிக்கு'",
  yesterday: "'நேற்று ' p 'மணிக்கு'",
  today: "'இன்று ' p 'மணிக்கு'",
  tomorrow: "'நாளை ' p 'மணிக்கு'",
  nextWeek: "eeee p 'மணிக்கு'",
  other: "P"
};
var formatRelative74 = (token, _date, _baseDate, _options) => formatRelativeLocale74[token];

// ../../../node_modules/date-fns/locale/ta/_lib/localize.mjs
var eraValues74 = {
  narrow: ["கி.மு.", "கி.பி."],
  abbreviated: ["கி.மு.", "கி.பி."],
  // CLDR #1624, #1626
  wide: ["கிறிஸ்துவுக்கு முன்", "அன்னோ டோமினி"]
  // CLDR #1620, #1622
};
var quarterValues74 = {
  // CLDR #1644 - #1647
  narrow: ["1", "2", "3", "4"],
  // CLDR #1636 - #1639
  abbreviated: ["காலா.1", "காலா.2", "காலா.3", "காலா.4"],
  // CLDR #1628 - #1631
  wide: [
    "ஒன்றாம் காலாண்டு",
    "இரண்டாம் காலாண்டு",
    "மூன்றாம் காலாண்டு",
    "நான்காம் காலாண்டு"
  ]
};
var monthValues74 = {
  // CLDR #700 - #711
  narrow: ["ஜ", "பி", "மா", "ஏ", "மே", "ஜூ", "ஜூ", "ஆ", "செ", "அ", "ந", "டி"],
  // CLDR #1676 - #1687
  abbreviated: [
    "ஜன.",
    "பிப்.",
    "மார்.",
    "ஏப்.",
    "மே",
    "ஜூன்",
    "ஜூலை",
    "ஆக.",
    "செப்.",
    "அக்.",
    "நவ.",
    "டிச."
  ],
  // CLDR #1652 - #1663
  wide: [
    "ஜனவரி",
    // January
    "பிப்ரவரி",
    // February
    "மார்ச்",
    // March
    "ஏப்ரல்",
    // April
    "மே",
    // May
    "ஜூன்",
    // June
    "ஜூலை",
    // July
    "ஆகஸ்ட்",
    // August
    "செப்டம்பர்",
    // September
    "அக்டோபர்",
    // October
    "நவம்பர்",
    // November
    "டிசம்பர்"
    // December
  ]
};
var dayValues74 = {
  // CLDR #1766 - #1772
  narrow: ["ஞா", "தி", "செ", "பு", "வி", "வெ", "ச"],
  // CLDR #1752 - #1758
  short: ["ஞா", "தி", "செ", "பு", "வி", "வெ", "ச"],
  // CLDR #1738 - #1744
  abbreviated: ["ஞாயி.", "திங்.", "செவ்.", "புத.", "வியா.", "வெள்.", "சனி"],
  // CLDR #1724 - #1730
  wide: [
    "ஞாயிறு",
    // Sunday
    "திங்கள்",
    // Monday
    "செவ்வாய்",
    // Tuesday
    "புதன்",
    // Wednesday
    "வியாழன்",
    // Thursday
    "வெள்ளி",
    // Friday
    "சனி"
    // Saturday
  ]
};
var dayPeriodValues74 = {
  narrow: {
    am: "மு.ப",
    pm: "பி.ப",
    midnight: "நள்.",
    noon: "நண்.",
    morning: "கா.",
    afternoon: "மதி.",
    evening: "மா.",
    night: "இர."
  },
  abbreviated: {
    am: "முற்பகல்",
    pm: "பிற்பகல்",
    midnight: "நள்ளிரவு",
    noon: "நண்பகல்",
    morning: "காலை",
    afternoon: "மதியம்",
    evening: "மாலை",
    night: "இரவு"
  },
  wide: {
    am: "முற்பகல்",
    pm: "பிற்பகல்",
    midnight: "நள்ளிரவு",
    noon: "நண்பகல்",
    morning: "காலை",
    afternoon: "மதியம்",
    evening: "மாலை",
    night: "இரவு"
  }
};
var formattingDayPeriodValues58 = {
  narrow: {
    am: "மு.ப",
    pm: "பி.ப",
    midnight: "நள்.",
    noon: "நண்.",
    morning: "கா.",
    afternoon: "மதி.",
    evening: "மா.",
    night: "இர."
  },
  abbreviated: {
    am: "முற்பகல்",
    pm: "பிற்பகல்",
    midnight: "நள்ளிரவு",
    noon: "நண்பகல்",
    morning: "காலை",
    afternoon: "மதியம்",
    evening: "மாலை",
    night: "இரவு"
  },
  wide: {
    am: "முற்பகல்",
    pm: "பிற்பகல்",
    midnight: "நள்ளிரவு",
    noon: "நண்பகல்",
    morning: "காலை",
    afternoon: "மதியம்",
    evening: "மாலை",
    night: "இரவு"
  }
};
var ordinalNumber74 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize74 = {
  ordinalNumber: ordinalNumber74,
  era: buildLocalizeFn({
    values: eraValues74,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues74,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues74,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues74,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues74,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues58,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ta/_lib/match.mjs
var matchOrdinalNumberPattern73 = /^(\d+)(வது)?/i;
var parseOrdinalNumberPattern73 = /\d+/i;
var matchEraPatterns73 = {
  narrow: /^(கி.மு.|கி.பி.)/i,
  abbreviated: /^(கி\.?\s?மு\.?|கி\.?\s?பி\.?)/,
  wide: /^(கிறிஸ்துவுக்கு\sமுன்|அன்னோ\sடோமினி)/i
};
var parseEraPatterns73 = {
  any: [/கி\.?\s?மு\.?/, /கி\.?\s?பி\.?/]
};
var matchQuarterPatterns73 = {
  narrow: /^[1234]/i,
  abbreviated: /^காலா.[1234]/i,
  wide: /^(ஒன்றாம்|இரண்டாம்|மூன்றாம்|நான்காம்) காலாண்டு/i
};
var parseQuarterPatterns73 = {
  narrow: [/1/i, /2/i, /3/i, /4/i],
  any: [
    /(1|காலா.1|ஒன்றாம்)/i,
    /(2|காலா.2|இரண்டாம்)/i,
    /(3|காலா.3|மூன்றாம்)/i,
    /(4|காலா.4|நான்காம்)/i
  ]
};
var matchMonthPatterns73 = {
  narrow: /^(ஜ|பி|மா|ஏ|மே|ஜூ|ஆ|செ|அ|ந|டி)$/i,
  abbreviated: /^(ஜன.|பிப்.|மார்.|ஏப்.|மே|ஜூன்|ஜூலை|ஆக.|செப்.|அக்.|நவ.|டிச.)/i,
  wide: /^(ஜனவரி|பிப்ரவரி|மார்ச்|ஏப்ரல்|மே|ஜூன்|ஜூலை|ஆகஸ்ட்|செப்டம்பர்|அக்டோபர்|நவம்பர்|டிசம்பர்)/i
};
var parseMonthPatterns73 = {
  narrow: [
    /^ஜ$/i,
    /^பி/i,
    /^மா/i,
    /^ஏ/i,
    /^மே/i,
    /^ஜூ/i,
    /^ஜூ/i,
    /^ஆ/i,
    /^செ/i,
    /^அ/i,
    /^ந/i,
    /^டி/i
  ],
  any: [
    /^ஜன/i,
    /^பி/i,
    /^மா/i,
    /^ஏ/i,
    /^மே/i,
    /^ஜூன்/i,
    /^ஜூலை/i,
    /^ஆ/i,
    /^செ/i,
    /^அ/i,
    /^ந/i,
    /^டி/i
  ]
};
var matchDayPatterns73 = {
  narrow: /^(ஞா|தி|செ|பு|வி|வெ|ச)/i,
  short: /^(ஞா|தி|செ|பு|வி|வெ|ச)/i,
  abbreviated: /^(ஞாயி.|திங்.|செவ்.|புத.|வியா.|வெள்.|சனி)/i,
  wide: /^(ஞாயிறு|திங்கள்|செவ்வாய்|புதன்|வியாழன்|வெள்ளி|சனி)/i
};
var parseDayPatterns73 = {
  narrow: [/^ஞா/i, /^தி/i, /^செ/i, /^பு/i, /^வி/i, /^வெ/i, /^ச/i],
  any: [/^ஞா/i, /^தி/i, /^செ/i, /^பு/i, /^வி/i, /^வெ/i, /^ச/i]
};
var matchDayPeriodPatterns73 = {
  narrow: /^(மு.ப|பி.ப|நள்|நண்|காலை|மதியம்|மாலை|இரவு)/i,
  any: /^(மு.ப|பி.ப|முற்பகல்|பிற்பகல்|நள்ளிரவு|நண்பகல்|காலை|மதியம்|மாலை|இரவு)/i
};
var parseDayPeriodPatterns73 = {
  any: {
    am: /^மு/i,
    pm: /^பி/i,
    midnight: /^நள்/i,
    noon: /^நண்/i,
    morning: /காலை/i,
    afternoon: /மதியம்/i,
    evening: /மாலை/i,
    night: /இரவு/i
  }
};
var match73 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern73,
    parsePattern: parseOrdinalNumberPattern73,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns73,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns73,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns73,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns73,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns73,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns73,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns73,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns73,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns73,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns73,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ta.mjs
var ta = {
  code: "ta",
  formatDistance: formatDistance75,
  formatLong: formatLong82,
  formatRelative: formatRelative74,
  localize: localize74,
  match: match73,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/te/_lib/formatDistance.mjs
var formatDistanceLocale74 = {
  lessThanXSeconds: {
    standalone: {
      one: "సెకను కన్నా తక్కువ",
      other: "{{count}} సెకన్ల కన్నా తక్కువ"
    },
    withPreposition: {
      one: "సెకను",
      other: "{{count}} సెకన్ల"
    }
  },
  xSeconds: {
    standalone: {
      one: "ఒక సెకను",
      // CLDR #1314
      other: "{{count}} సెకన్ల"
    },
    withPreposition: {
      one: "ఒక సెకను",
      other: "{{count}} సెకన్ల"
    }
  },
  halfAMinute: {
    standalone: "అర నిమిషం",
    withPreposition: "అర నిమిషం"
  },
  lessThanXMinutes: {
    standalone: {
      one: "ఒక నిమిషం కన్నా తక్కువ",
      other: "{{count}} నిమిషాల కన్నా తక్కువ"
    },
    withPreposition: {
      one: "ఒక నిమిషం",
      other: "{{count}} నిమిషాల"
    }
  },
  xMinutes: {
    standalone: {
      one: "ఒక నిమిషం",
      // CLDR #1311
      other: "{{count}} నిమిషాలు"
    },
    withPreposition: {
      one: "ఒక నిమిషం",
      // CLDR #1311
      other: "{{count}} నిమిషాల"
    }
  },
  aboutXHours: {
    standalone: {
      one: "సుమారు ఒక గంట",
      other: "సుమారు {{count}} గంటలు"
    },
    withPreposition: {
      one: "సుమారు ఒక గంట",
      other: "సుమారు {{count}} గంటల"
    }
  },
  xHours: {
    standalone: {
      one: "ఒక గంట",
      // CLDR #1308
      other: "{{count}} గంటలు"
    },
    withPreposition: {
      one: "ఒక గంట",
      other: "{{count}} గంటల"
    }
  },
  xDays: {
    standalone: {
      one: "ఒక రోజు",
      // CLDR #1292
      other: "{{count}} రోజులు"
    },
    withPreposition: {
      one: "ఒక రోజు",
      other: "{{count}} రోజుల"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "సుమారు ఒక వారం",
      other: "సుమారు {{count}} వారాలు"
    },
    withPreposition: {
      one: "సుమారు ఒక వారం",
      other: "సుమారు {{count}} వారాలల"
    }
  },
  xWeeks: {
    standalone: {
      one: "ఒక వారం",
      other: "{{count}} వారాలు"
    },
    withPreposition: {
      one: "ఒక వారం",
      other: "{{count}} వారాలల"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "సుమారు ఒక నెల",
      other: "సుమారు {{count}} నెలలు"
    },
    withPreposition: {
      one: "సుమారు ఒక నెల",
      other: "సుమారు {{count}} నెలల"
    }
  },
  xMonths: {
    standalone: {
      one: "ఒక నెల",
      // CLDR #1281
      other: "{{count}} నెలలు"
    },
    withPreposition: {
      one: "ఒక నెల",
      other: "{{count}} నెలల"
    }
  },
  aboutXYears: {
    standalone: {
      one: "సుమారు ఒక సంవత్సరం",
      other: "సుమారు {{count}} సంవత్సరాలు"
    },
    withPreposition: {
      one: "సుమారు ఒక సంవత్సరం",
      other: "సుమారు {{count}} సంవత్సరాల"
    }
  },
  xYears: {
    standalone: {
      one: "ఒక సంవత్సరం",
      // CLDR #1275
      other: "{{count}} సంవత్సరాలు"
    },
    withPreposition: {
      one: "ఒక సంవత్సరం",
      other: "{{count}} సంవత్సరాల"
    }
  },
  overXYears: {
    standalone: {
      one: "ఒక సంవత్సరం పైగా",
      other: "{{count}} సంవత్సరాలకు పైగా"
    },
    withPreposition: {
      one: "ఒక సంవత్సరం",
      other: "{{count}} సంవత్సరాల"
    }
  },
  almostXYears: {
    standalone: {
      one: "దాదాపు ఒక సంవత్సరం",
      other: "దాదాపు {{count}} సంవత్సరాలు"
    },
    withPreposition: {
      one: "దాదాపు ఒక సంవత్సరం",
      other: "దాదాపు {{count}} సంవత్సరాల"
    }
  }
};
var formatDistance76 = (token, count, options2) => {
  let result;
  const tokenValue = (options2 == null ? void 0 : options2.addSuffix) ? formatDistanceLocale74[token].withPreposition : formatDistanceLocale74[token].standalone;
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "లో";
    } else {
      return result + " క్రితం";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/te/_lib/formatLong.mjs
var dateFormats83 = {
  full: "d, MMMM y, EEEE",
  long: "d MMMM, y",
  medium: "d MMM, y",
  short: "dd-MM-yy"
};
var timeFormats83 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats83 = {
  full: "{{date}} {{time}}'కి'",
  long: "{{date}} {{time}}'కి'",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong83 = {
  date: buildFormatLongFn({
    formats: dateFormats83,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats83,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats83,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/te/_lib/formatRelative.mjs
var formatRelativeLocale75 = {
  lastWeek: "'గత' eeee p",
  // CLDR #1384
  yesterday: "'నిన్న' p",
  // CLDR #1393
  today: "'ఈ రోజు' p",
  // CLDR #1394
  tomorrow: "'రేపు' p",
  // CLDR #1395
  nextWeek: "'తదుపరి' eeee p",
  // CLDR #1386
  other: "P"
};
var formatRelative75 = (token, _date, _baseDate, _options) => formatRelativeLocale75[token];

// ../../../node_modules/date-fns/locale/te/_lib/localize.mjs
var eraValues75 = {
  narrow: ["క్రీ.పూ.", "క్రీ.శ."],
  abbreviated: ["క్రీ.పూ.", "క్రీ.శ."],
  wide: ["క్రీస్తు పూర్వం", "క్రీస్తుశకం"]
};
var quarterValues75 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["త్రై1", "త్రై2", "త్రై3", "త్రై4"],
  wide: ["1వ త్రైమాసికం", "2వ త్రైమాసికం", "3వ త్రైమాసికం", "4వ త్రైమాసికం"]
};
var monthValues75 = {
  narrow: ["జ", "ఫి", "మా", "ఏ", "మే", "జూ", "జు", "ఆ", "సె", "అ", "న", "డి"],
  abbreviated: [
    "జన",
    "ఫిబ్ర",
    "మార్చి",
    "ఏప్రి",
    "మే",
    "జూన్",
    "జులై",
    "ఆగ",
    "సెప్టెం",
    "అక్టో",
    "నవం",
    "డిసెం"
  ],
  wide: [
    "జనవరి",
    "ఫిబ్రవరి",
    "మార్చి",
    "ఏప్రిల్",
    "మే",
    "జూన్",
    "జులై",
    "ఆగస్టు",
    "సెప్టెంబర్",
    "అక్టోబర్",
    "నవంబర్",
    "డిసెంబర్"
  ]
};
var dayValues75 = {
  narrow: ["ఆ", "సో", "మ", "బు", "గు", "శు", "శ"],
  short: ["ఆది", "సోమ", "మంగళ", "బుధ", "గురు", "శుక్ర", "శని"],
  abbreviated: ["ఆది", "సోమ", "మంగళ", "బుధ", "గురు", "శుక్ర", "శని"],
  wide: [
    "ఆదివారం",
    "సోమవారం",
    "మంగళవారం",
    "బుధవారం",
    "గురువారం",
    "శుక్రవారం",
    "శనివారం"
  ]
};
var dayPeriodValues75 = {
  narrow: {
    am: "పూర్వాహ్నం",
    pm: "అపరాహ్నం",
    midnight: "అర్ధరాత్రి",
    noon: "మిట్టమధ్యాహ్నం",
    morning: "ఉదయం",
    afternoon: "మధ్యాహ్నం",
    evening: "సాయంత్రం",
    night: "రాత్రి"
  },
  abbreviated: {
    am: "పూర్వాహ్నం",
    pm: "అపరాహ్నం",
    midnight: "అర్ధరాత్రి",
    noon: "మిట్టమధ్యాహ్నం",
    morning: "ఉదయం",
    afternoon: "మధ్యాహ్నం",
    evening: "సాయంత్రం",
    night: "రాత్రి"
  },
  wide: {
    am: "పూర్వాహ్నం",
    pm: "అపరాహ్నం",
    midnight: "అర్ధరాత్రి",
    noon: "మిట్టమధ్యాహ్నం",
    morning: "ఉదయం",
    afternoon: "మధ్యాహ్నం",
    evening: "సాయంత్రం",
    night: "రాత్రి"
  }
};
var formattingDayPeriodValues59 = {
  narrow: {
    am: "పూర్వాహ్నం",
    pm: "అపరాహ్నం",
    midnight: "అర్ధరాత్రి",
    noon: "మిట్టమధ్యాహ్నం",
    morning: "ఉదయం",
    afternoon: "మధ్యాహ్నం",
    evening: "సాయంత్రం",
    night: "రాత్రి"
  },
  abbreviated: {
    am: "పూర్వాహ్నం",
    pm: "అపరాహ్నం",
    midnight: "అర్ధరాత్రి",
    noon: "మిట్టమధ్యాహ్నం",
    morning: "ఉదయం",
    afternoon: "మధ్యాహ్నం",
    evening: "సాయంత్రం",
    night: "రాత్రి"
  },
  wide: {
    am: "పూర్వాహ్నం",
    pm: "అపరాహ్నం",
    midnight: "అర్ధరాత్రి",
    noon: "మిట్టమధ్యాహ్నం",
    morning: "ఉదయం",
    afternoon: "మధ్యాహ్నం",
    evening: "సాయంత్రం",
    night: "రాత్రి"
  }
};
var ordinalNumber75 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "వ";
};
var localize75 = {
  ordinalNumber: ordinalNumber75,
  era: buildLocalizeFn({
    values: eraValues75,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues75,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues75,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues75,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues75,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues59,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/te/_lib/match.mjs
var matchOrdinalNumberPattern74 = /^(\d+)(వ)?/i;
var parseOrdinalNumberPattern74 = /\d+/i;
var matchEraPatterns74 = {
  narrow: /^(క్రీ\.పూ\.|క్రీ\.శ\.)/i,
  abbreviated: /^(క్రీ\.?\s?పూ\.?|ప్ర\.?\s?శ\.?\s?పూ\.?|క్రీ\.?\s?శ\.?|సా\.?\s?శ\.?)/i,
  wide: /^(క్రీస్తు పూర్వం|ప్రస్తుత శకానికి పూర్వం|క్రీస్తు శకం|ప్రస్తుత శకం)/i
};
var parseEraPatterns74 = {
  any: [/^(పూ|శ)/i, /^సా/i]
};
var matchQuarterPatterns74 = {
  narrow: /^[1234]/i,
  abbreviated: /^త్రై[1234]/i,
  wide: /^[1234](వ)? త్రైమాసికం/i
};
var parseQuarterPatterns74 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns74 = {
  narrow: /^(జూ|జు|జ|ఫి|మా|ఏ|మే|ఆ|సె|అ|న|డి)/i,
  abbreviated: /^(జన|ఫిబ్ర|మార్చి|ఏప్రి|మే|జూన్|జులై|ఆగ|సెప్|అక్టో|నవ|డిసె)/i,
  wide: /^(జనవరి|ఫిబ్రవరి|మార్చి|ఏప్రిల్|మే|జూన్|జులై|ఆగస్టు|సెప్టెంబర్|అక్టోబర్|నవంబర్|డిసెంబర్)/i
};
var parseMonthPatterns74 = {
  narrow: [
    /^జ/i,
    /^ఫి/i,
    /^మా/i,
    /^ఏ/i,
    /^మే/i,
    /^జూ/i,
    /^జు/i,
    /^ఆ/i,
    /^సె/i,
    /^అ/i,
    /^న/i,
    /^డి/i
  ],
  any: [
    /^జన/i,
    /^ఫి/i,
    /^మా/i,
    /^ఏ/i,
    /^మే/i,
    /^జూన్/i,
    /^జులై/i,
    /^ఆగ/i,
    /^సె/i,
    /^అ/i,
    /^న/i,
    /^డి/i
  ]
};
var matchDayPatterns74 = {
  narrow: /^(ఆ|సో|మ|బు|గు|శు|శ)/i,
  short: /^(ఆది|సోమ|మం|బుధ|గురు|శుక్ర|శని)/i,
  abbreviated: /^(ఆది|సోమ|మం|బుధ|గురు|శుక్ర|శని)/i,
  wide: /^(ఆదివారం|సోమవారం|మంగళవారం|బుధవారం|గురువారం|శుక్రవారం|శనివారం)/i
};
var parseDayPatterns74 = {
  narrow: [/^ఆ/i, /^సో/i, /^మ/i, /^బు/i, /^గు/i, /^శు/i, /^శ/i],
  any: [/^ఆది/i, /^సోమ/i, /^మం/i, /^బుధ/i, /^గురు/i, /^శుక్ర/i, /^శని/i]
};
var matchDayPeriodPatterns74 = {
  narrow: /^(పూర్వాహ్నం|అపరాహ్నం|అర్ధరాత్రి|మిట్టమధ్యాహ్నం|ఉదయం|మధ్యాహ్నం|సాయంత్రం|రాత్రి)/i,
  any: /^(పూర్వాహ్నం|అపరాహ్నం|అర్ధరాత్రి|మిట్టమధ్యాహ్నం|ఉదయం|మధ్యాహ్నం|సాయంత్రం|రాత్రి)/i
};
var parseDayPeriodPatterns74 = {
  any: {
    am: /^పూర్వాహ్నం/i,
    pm: /^అపరాహ్నం/i,
    midnight: /^అర్ధ/i,
    noon: /^మిట్ట/i,
    morning: /ఉదయం/i,
    afternoon: /మధ్యాహ్నం/i,
    evening: /సాయంత్రం/i,
    night: /రాత్రి/i
  }
};
var match74 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern74,
    parsePattern: parseOrdinalNumberPattern74,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns74,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns74,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns74,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns74,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns74,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns74,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns74,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns74,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns74,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns74,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/te.mjs
var te = {
  code: "te",
  formatDistance: formatDistance76,
  formatLong: formatLong83,
  formatRelative: formatRelative75,
  localize: localize75,
  match: match74,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/th/_lib/formatDistance.mjs
var formatDistanceLocale75 = {
  lessThanXSeconds: {
    one: "น้อยกว่า 1 วินาที",
    other: "น้อยกว่า {{count}} วินาที"
  },
  xSeconds: {
    one: "1 วินาที",
    other: "{{count}} วินาที"
  },
  halfAMinute: "ครึ่งนาที",
  lessThanXMinutes: {
    one: "น้อยกว่า 1 นาที",
    other: "น้อยกว่า {{count}} นาที"
  },
  xMinutes: {
    one: "1 นาที",
    other: "{{count}} นาที"
  },
  aboutXHours: {
    one: "ประมาณ 1 ชั่วโมง",
    other: "ประมาณ {{count}} ชั่วโมง"
  },
  xHours: {
    one: "1 ชั่วโมง",
    other: "{{count}} ชั่วโมง"
  },
  xDays: {
    one: "1 วัน",
    other: "{{count}} วัน"
  },
  aboutXWeeks: {
    one: "ประมาณ 1 สัปดาห์",
    other: "ประมาณ {{count}} สัปดาห์"
  },
  xWeeks: {
    one: "1 สัปดาห์",
    other: "{{count}} สัปดาห์"
  },
  aboutXMonths: {
    one: "ประมาณ 1 เดือน",
    other: "ประมาณ {{count}} เดือน"
  },
  xMonths: {
    one: "1 เดือน",
    other: "{{count}} เดือน"
  },
  aboutXYears: {
    one: "ประมาณ 1 ปี",
    other: "ประมาณ {{count}} ปี"
  },
  xYears: {
    one: "1 ปี",
    other: "{{count}} ปี"
  },
  overXYears: {
    one: "มากกว่า 1 ปี",
    other: "มากกว่า {{count}} ปี"
  },
  almostXYears: {
    one: "เกือบ 1 ปี",
    other: "เกือบ {{count}} ปี"
  }
};
var formatDistance77 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale75[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      if (token === "halfAMinute") {
        return "ใน" + result;
      } else {
        return "ใน " + result;
      }
    } else {
      return result + "ที่ผ่านมา";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/th/_lib/formatLong.mjs
var dateFormats84 = {
  full: "วันEEEEที่ do MMMM y",
  long: "do MMMM y",
  medium: "d MMM y",
  short: "dd/MM/yyyy"
};
var timeFormats84 = {
  full: "H:mm:ss น. zzzz",
  long: "H:mm:ss น. z",
  medium: "H:mm:ss น.",
  short: "H:mm น."
};
var dateTimeFormats84 = {
  full: "{{date}} 'เวลา' {{time}}",
  long: "{{date}} 'เวลา' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong84 = {
  date: buildFormatLongFn({
    formats: dateFormats84,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats84,
    defaultWidth: "medium"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats84,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/th/_lib/formatRelative.mjs
var formatRelativeLocale76 = {
  lastWeek: "eeee'ที่แล้วเวลา' p",
  yesterday: "'เมื่อวานนี้เวลา' p",
  today: "'วันนี้เวลา' p",
  tomorrow: "'พรุ่งนี้เวลา' p",
  nextWeek: "eeee 'เวลา' p",
  other: "P"
};
var formatRelative76 = (token, _date, _baseDate, _options) => formatRelativeLocale76[token];

// ../../../node_modules/date-fns/locale/th/_lib/localize.mjs
var eraValues76 = {
  narrow: ["B", "คศ"],
  abbreviated: ["BC", "ค.ศ."],
  wide: ["ปีก่อนคริสตกาล", "คริสต์ศักราช"]
};
var quarterValues76 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["ไตรมาสแรก", "ไตรมาสที่สอง", "ไตรมาสที่สาม", "ไตรมาสที่สี่"]
};
var dayValues76 = {
  narrow: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
  short: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
  abbreviated: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
  wide: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์"]
};
var monthValues76 = {
  narrow: [
    "ม.ค.",
    "ก.พ.",
    "มี.ค.",
    "เม.ย.",
    "พ.ค.",
    "มิ.ย.",
    "ก.ค.",
    "ส.ค.",
    "ก.ย.",
    "ต.ค.",
    "พ.ย.",
    "ธ.ค."
  ],
  abbreviated: [
    "ม.ค.",
    "ก.พ.",
    "มี.ค.",
    "เม.ย.",
    "พ.ค.",
    "มิ.ย.",
    "ก.ค.",
    "ส.ค.",
    "ก.ย.",
    "ต.ค.",
    "พ.ย.",
    "ธ.ค."
  ],
  wide: [
    "มกราคม",
    "กุมภาพันธ์",
    "มีนาคม",
    "เมษายน",
    "พฤษภาคม",
    "มิถุนายน",
    "กรกฎาคม",
    "สิงหาคม",
    "กันยายน",
    "ตุลาคม",
    "พฤศจิกายน",
    "ธันวาคม"
  ]
};
var dayPeriodValues76 = {
  narrow: {
    am: "ก่อนเที่ยง",
    pm: "หลังเที่ยง",
    midnight: "เที่ยงคืน",
    noon: "เที่ยง",
    morning: "เช้า",
    afternoon: "บ่าย",
    evening: "เย็น",
    night: "กลางคืน"
  },
  abbreviated: {
    am: "ก่อนเที่ยง",
    pm: "หลังเที่ยง",
    midnight: "เที่ยงคืน",
    noon: "เที่ยง",
    morning: "เช้า",
    afternoon: "บ่าย",
    evening: "เย็น",
    night: "กลางคืน"
  },
  wide: {
    am: "ก่อนเที่ยง",
    pm: "หลังเที่ยง",
    midnight: "เที่ยงคืน",
    noon: "เที่ยง",
    morning: "เช้า",
    afternoon: "บ่าย",
    evening: "เย็น",
    night: "กลางคืน"
  }
};
var formattingDayPeriodValues60 = {
  narrow: {
    am: "ก่อนเที่ยง",
    pm: "หลังเที่ยง",
    midnight: "เที่ยงคืน",
    noon: "เที่ยง",
    morning: "ตอนเช้า",
    afternoon: "ตอนกลางวัน",
    evening: "ตอนเย็น",
    night: "ตอนกลางคืน"
  },
  abbreviated: {
    am: "ก่อนเที่ยง",
    pm: "หลังเที่ยง",
    midnight: "เที่ยงคืน",
    noon: "เที่ยง",
    morning: "ตอนเช้า",
    afternoon: "ตอนกลางวัน",
    evening: "ตอนเย็น",
    night: "ตอนกลางคืน"
  },
  wide: {
    am: "ก่อนเที่ยง",
    pm: "หลังเที่ยง",
    midnight: "เที่ยงคืน",
    noon: "เที่ยง",
    morning: "ตอนเช้า",
    afternoon: "ตอนกลางวัน",
    evening: "ตอนเย็น",
    night: "ตอนกลางคืน"
  }
};
var ordinalNumber76 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize76 = {
  ordinalNumber: ordinalNumber76,
  era: buildLocalizeFn({
    values: eraValues76,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues76,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues76,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues76,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues76,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues60,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/th/_lib/match.mjs
var matchOrdinalNumberPattern75 = /^\d+/i;
var parseOrdinalNumberPattern75 = /\d+/i;
var matchEraPatterns75 = {
  narrow: /^([bB]|[aA]|คศ)/i,
  abbreviated: /^([bB]\.?\s?[cC]\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?|ค\.?ศ\.?)/i,
  wide: /^(ก่อนคริสตกาล|คริสต์ศักราช|คริสตกาล)/i
};
var parseEraPatterns75 = {
  any: [/^[bB]/i, /^(^[aA]|ค\.?ศ\.?|คริสตกาล|คริสต์ศักราช|)/i]
};
var matchQuarterPatterns75 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^ไตรมาส(ที่)? ?[1234]/i
};
var parseQuarterPatterns75 = {
  any: [/(1|แรก|หนึ่ง)/i, /(2|สอง)/i, /(3|สาม)/i, /(4|สี่)/i]
};
var matchMonthPatterns75 = {
  narrow: /^(ม\.?ค\.?|ก\.?พ\.?|มี\.?ค\.?|เม\.?ย\.?|พ\.?ค\.?|มิ\.?ย\.?|ก\.?ค\.?|ส\.?ค\.?|ก\.?ย\.?|ต\.?ค\.?|พ\.?ย\.?|ธ\.?ค\.?)/i,
  abbreviated: /^(ม\.?ค\.?|ก\.?พ\.?|มี\.?ค\.?|เม\.?ย\.?|พ\.?ค\.?|มิ\.?ย\.?|ก\.?ค\.?|ส\.?ค\.?|ก\.?ย\.?|ต\.?ค\.?|พ\.?ย\.?|ธ\.?ค\.?')/i,
  wide: /^(มกราคม|กุมภาพันธ์|มีนาคม|เมษายน|พฤษภาคม|มิถุนายน|กรกฎาคม|สิงหาคม|กันยายน|ตุลาคม|พฤศจิกายน|ธันวาคม)/i
};
var parseMonthPatterns75 = {
  wide: [
    /^มก/i,
    /^กุม/i,
    /^มี/i,
    /^เม/i,
    /^พฤษ/i,
    /^มิ/i,
    /^กรก/i,
    /^ส/i,
    /^กัน/i,
    /^ต/i,
    /^พฤศ/i,
    /^ธ/i
  ],
  any: [
    /^ม\.?ค\.?/i,
    /^ก\.?พ\.?/i,
    /^มี\.?ค\.?/i,
    /^เม\.?ย\.?/i,
    /^พ\.?ค\.?/i,
    /^มิ\.?ย\.?/i,
    /^ก\.?ค\.?/i,
    /^ส\.?ค\.?/i,
    /^ก\.?ย\.?/i,
    /^ต\.?ค\.?/i,
    /^พ\.?ย\.?/i,
    /^ธ\.?ค\.?/i
  ]
};
var matchDayPatterns75 = {
  narrow: /^(อา\.?|จ\.?|อ\.?|พฤ\.?|พ\.?|ศ\.?|ส\.?)/i,
  short: /^(อา\.?|จ\.?|อ\.?|พฤ\.?|พ\.?|ศ\.?|ส\.?)/i,
  abbreviated: /^(อา\.?|จ\.?|อ\.?|พฤ\.?|พ\.?|ศ\.?|ส\.?)/i,
  wide: /^(อาทิตย์|จันทร์|อังคาร|พุธ|พฤหัสบดี|ศุกร์|เสาร์)/i
};
var parseDayPatterns75 = {
  wide: [/^อา/i, /^จั/i, /^อั/i, /^พุธ/i, /^พฤ/i, /^ศ/i, /^เส/i],
  any: [/^อา/i, /^จ/i, /^อ/i, /^พ(?!ฤ)/i, /^พฤ/i, /^ศ/i, /^ส/i]
};
var matchDayPeriodPatterns75 = {
  any: /^(ก่อนเที่ยง|หลังเที่ยง|เที่ยงคืน|เที่ยง|(ตอน.*?)?.*(เที่ยง|เช้า|บ่าย|เย็น|กลางคืน))/i
};
var parseDayPeriodPatterns75 = {
  any: {
    am: /^ก่อนเที่ยง/i,
    pm: /^หลังเที่ยง/i,
    midnight: /^เที่ยงคืน/i,
    noon: /^เที่ยง/i,
    morning: /เช้า/i,
    afternoon: /บ่าย/i,
    evening: /เย็น/i,
    night: /กลางคืน/i
  }
};
var match75 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern75,
    parsePattern: parseOrdinalNumberPattern75,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns75,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns75,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns75,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns75,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns75,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns75,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns75,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns75,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns75,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns75,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/th.mjs
var th = {
  code: "th",
  formatDistance: formatDistance77,
  formatLong: formatLong84,
  formatRelative: formatRelative76,
  localize: localize76,
  match: match75,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/tr/_lib/formatDistance.mjs
var formatDistanceLocale76 = {
  lessThanXSeconds: {
    one: "bir saniyeden az",
    other: "{{count}} saniyeden az"
  },
  xSeconds: {
    one: "1 saniye",
    other: "{{count}} saniye"
  },
  halfAMinute: "yarım dakika",
  lessThanXMinutes: {
    one: "bir dakikadan az",
    other: "{{count}} dakikadan az"
  },
  xMinutes: {
    one: "1 dakika",
    other: "{{count}} dakika"
  },
  aboutXHours: {
    one: "yaklaşık 1 saat",
    other: "yaklaşık {{count}} saat"
  },
  xHours: {
    one: "1 saat",
    other: "{{count}} saat"
  },
  xDays: {
    one: "1 gün",
    other: "{{count}} gün"
  },
  aboutXWeeks: {
    one: "yaklaşık 1 hafta",
    other: "yaklaşık {{count}} hafta"
  },
  xWeeks: {
    one: "1 hafta",
    other: "{{count}} hafta"
  },
  aboutXMonths: {
    one: "yaklaşık 1 ay",
    other: "yaklaşık {{count}} ay"
  },
  xMonths: {
    one: "1 ay",
    other: "{{count}} ay"
  },
  aboutXYears: {
    one: "yaklaşık 1 yıl",
    other: "yaklaşık {{count}} yıl"
  },
  xYears: {
    one: "1 yıl",
    other: "{{count}} yıl"
  },
  overXYears: {
    one: "1 yıldan fazla",
    other: "{{count}} yıldan fazla"
  },
  almostXYears: {
    one: "neredeyse 1 yıl",
    other: "neredeyse {{count}} yıl"
  }
};
var formatDistance78 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale76[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + " sonra";
    } else {
      return result + " önce";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/tr/_lib/formatLong.mjs
var dateFormats85 = {
  full: "d MMMM y EEEE",
  long: "d MMMM y",
  medium: "d MMM y",
  short: "dd.MM.yyyy"
};
var timeFormats85 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats85 = {
  full: "{{date}} 'saat' {{time}}",
  long: "{{date}} 'saat' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong85 = {
  date: buildFormatLongFn({
    formats: dateFormats85,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats85,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats85,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/tr/_lib/formatRelative.mjs
var formatRelativeLocale77 = {
  lastWeek: "'geçen hafta' eeee 'saat' p",
  yesterday: "'dün saat' p",
  today: "'bugün saat' p",
  tomorrow: "'yarın saat' p",
  nextWeek: "eeee 'saat' p",
  other: "P"
};
var formatRelative77 = (token, _date, _baseDate, _options) => formatRelativeLocale77[token];

// ../../../node_modules/date-fns/locale/tr/_lib/localize.mjs
var eraValues77 = {
  narrow: ["MÖ", "MS"],
  abbreviated: ["MÖ", "MS"],
  wide: ["Milattan Önce", "Milattan Sonra"]
};
var quarterValues77 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1Ç", "2Ç", "3Ç", "4Ç"],
  wide: ["İlk çeyrek", "İkinci Çeyrek", "Üçüncü çeyrek", "Son çeyrek"]
};
var monthValues77 = {
  narrow: ["O", "Ş", "M", "N", "M", "H", "T", "A", "E", "E", "K", "A"],
  abbreviated: [
    "Oca",
    "Şub",
    "Mar",
    "Nis",
    "May",
    "Haz",
    "Tem",
    "Ağu",
    "Eyl",
    "Eki",
    "Kas",
    "Ara"
  ],
  wide: [
    "Ocak",
    "Şubat",
    "Mart",
    "Nisan",
    "Mayıs",
    "Haziran",
    "Temmuz",
    "Ağustos",
    "Eylül",
    "Ekim",
    "Kasım",
    "Aralık"
  ]
};
var dayValues77 = {
  narrow: ["P", "P", "S", "Ç", "P", "C", "C"],
  short: ["Pz", "Pt", "Sa", "Ça", "Pe", "Cu", "Ct"],
  abbreviated: ["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cts"],
  wide: [
    "Pazar",
    "Pazartesi",
    "Salı",
    "Çarşamba",
    "Perşembe",
    "Cuma",
    "Cumartesi"
  ]
};
var dayPeriodValues77 = {
  narrow: {
    am: "öö",
    pm: "ös",
    midnight: "gy",
    noon: "ö",
    morning: "sa",
    afternoon: "ös",
    evening: "ak",
    night: "ge"
  },
  abbreviated: {
    am: "ÖÖ",
    pm: "ÖS",
    midnight: "gece yarısı",
    noon: "öğle",
    morning: "sabah",
    afternoon: "öğleden sonra",
    evening: "akşam",
    night: "gece"
  },
  wide: {
    am: "Ö.Ö.",
    pm: "Ö.S.",
    midnight: "gece yarısı",
    noon: "öğle",
    morning: "sabah",
    afternoon: "öğleden sonra",
    evening: "akşam",
    night: "gece"
  }
};
var formattingDayPeriodValues61 = {
  narrow: {
    am: "öö",
    pm: "ös",
    midnight: "gy",
    noon: "ö",
    morning: "sa",
    afternoon: "ös",
    evening: "ak",
    night: "ge"
  },
  abbreviated: {
    am: "ÖÖ",
    pm: "ÖS",
    midnight: "gece yarısı",
    noon: "öğlen",
    morning: "sabahleyin",
    afternoon: "öğleden sonra",
    evening: "akşamleyin",
    night: "geceleyin"
  },
  wide: {
    am: "ö.ö.",
    pm: "ö.s.",
    midnight: "gece yarısı",
    noon: "öğlen",
    morning: "sabahleyin",
    afternoon: "öğleden sonra",
    evening: "akşamleyin",
    night: "geceleyin"
  }
};
var ordinalNumber77 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
var localize77 = {
  ordinalNumber: ordinalNumber77,
  era: buildLocalizeFn({
    values: eraValues77,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues77,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues77,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues77,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues77,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues61,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/tr/_lib/match.mjs
var matchOrdinalNumberPattern76 = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern76 = /\d+/i;
var matchEraPatterns76 = {
  narrow: /^(mö|ms)/i,
  abbreviated: /^(mö|ms)/i,
  wide: /^(milattan önce|milattan sonra)/i
};
var parseEraPatterns76 = {
  any: [/(^mö|^milattan önce)/i, /(^ms|^milattan sonra)/i]
};
var matchQuarterPatterns76 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]ç/i,
  wide: /^((i|İ)lk|(i|İ)kinci|üçüncü|son) çeyrek/i
};
var parseQuarterPatterns76 = {
  any: [/1/i, /2/i, /3/i, /4/i],
  abbreviated: [/1ç/i, /2ç/i, /3ç/i, /4ç/i],
  wide: [
    /^(i|İ)lk çeyrek/i,
    /(i|İ)kinci çeyrek/i,
    /üçüncü çeyrek/i,
    /son çeyrek/i
  ]
};
var matchMonthPatterns76 = {
  narrow: /^[oşmnhtaek]/i,
  abbreviated: /^(oca|şub|mar|nis|may|haz|tem|ağu|eyl|eki|kas|ara)/i,
  wide: /^(ocak|şubat|mart|nisan|mayıs|haziran|temmuz|ağustos|eylül|ekim|kasım|aralık)/i
};
var parseMonthPatterns76 = {
  narrow: [
    /^o/i,
    /^ş/i,
    /^m/i,
    /^n/i,
    /^m/i,
    /^h/i,
    /^t/i,
    /^a/i,
    /^e/i,
    /^e/i,
    /^k/i,
    /^a/i
  ],
  any: [
    /^o/i,
    /^ş/i,
    /^mar/i,
    /^n/i,
    /^may/i,
    /^h/i,
    /^t/i,
    /^ağ/i,
    /^ey/i,
    /^ek/i,
    /^k/i,
    /^ar/i
  ]
};
var matchDayPatterns76 = {
  narrow: /^[psçc]/i,
  short: /^(pz|pt|sa|ça|pe|cu|ct)/i,
  abbreviated: /^(paz|pzt|sal|çar|per|cum|cts)/i,
  wide: /^(pazar(?!tesi)|pazartesi|salı|çarşamba|perşembe|cuma(?!rtesi)|cumartesi)/i
};
var parseDayPatterns76 = {
  narrow: [/^p/i, /^p/i, /^s/i, /^ç/i, /^p/i, /^c/i, /^c/i],
  any: [/^pz/i, /^pt/i, /^sa/i, /^ça/i, /^pe/i, /^cu/i, /^ct/i],
  wide: [
    /^pazar(?!tesi)/i,
    /^pazartesi/i,
    /^salı/i,
    /^çarşamba/i,
    /^perşembe/i,
    /^cuma(?!rtesi)/i,
    /^cumartesi/i
  ]
};
var matchDayPeriodPatterns76 = {
  narrow: /^(öö|ös|gy|ö|sa|ös|ak|ge)/i,
  any: /^(ö\.?\s?[ös]\.?|öğleden sonra|gece yarısı|öğle|(sabah|öğ|akşam|gece)(leyin))/i
};
var parseDayPeriodPatterns76 = {
  any: {
    am: /^ö\.?ö\.?/i,
    pm: /^ö\.?s\.?/i,
    midnight: /^(gy|gece yarısı)/i,
    noon: /^öğ/i,
    morning: /^sa/i,
    afternoon: /^öğleden sonra/i,
    evening: /^ak/i,
    night: /^ge/i
  }
};
var match76 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern76,
    parsePattern: parseOrdinalNumberPattern76,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns76,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns76,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns76,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns76,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns76,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns76,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns76,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns76,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns76,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns76,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/tr.mjs
var tr = {
  code: "tr",
  formatDistance: formatDistance78,
  formatLong: formatLong85,
  formatRelative: formatRelative77,
  localize: localize77,
  match: match76,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/ug/_lib/formatDistance.mjs
var formatDistanceLocale77 = {
  lessThanXSeconds: {
    one: "بىر سىكۇنت ئىچىدە",
    other: "سىكۇنت ئىچىدە {{count}}"
  },
  xSeconds: {
    one: "بىر سىكۇنت",
    other: "سىكۇنت {{count}}"
  },
  halfAMinute: "يىرىم مىنۇت",
  lessThanXMinutes: {
    one: "بىر مىنۇت ئىچىدە",
    other: "مىنۇت ئىچىدە {{count}}"
  },
  xMinutes: {
    one: "بىر مىنۇت",
    other: "مىنۇت {{count}}"
  },
  aboutXHours: {
    one: "تەخمىنەن بىر سائەت",
    other: "سائەت {{count}} تەخمىنەن"
  },
  xHours: {
    one: "بىر سائەت",
    other: "سائەت {{count}}"
  },
  xDays: {
    one: "بىر كۈن",
    other: "كۈن {{count}}"
  },
  aboutXWeeks: {
    one: "تەخمىنەن بىرھەپتە",
    other: "ھەپتە {{count}} تەخمىنەن"
  },
  xWeeks: {
    one: "بىرھەپتە",
    other: "ھەپتە {{count}}"
  },
  aboutXMonths: {
    one: "تەخمىنەن بىر ئاي",
    other: "ئاي {{count}} تەخمىنەن"
  },
  xMonths: {
    one: "بىر ئاي",
    other: "ئاي {{count}}"
  },
  aboutXYears: {
    one: "تەخمىنەن بىر يىل",
    other: "يىل {{count}} تەخمىنەن"
  },
  xYears: {
    one: "بىر يىل",
    other: "يىل {{count}}"
  },
  overXYears: {
    one: "بىر يىلدىن ئارتۇق",
    other: "يىلدىن ئارتۇق {{count}}"
  },
  almostXYears: {
    one: "ئاساسەن بىر يىل",
    other: "يىل {{count}} ئاساسەن"
  }
};
var formatDistance79 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale77[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result;
    } else {
      return result + " بولدى";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/ug/_lib/formatLong.mjs
var dateFormats86 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats86 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats86 = {
  full: "{{date}} 'دە' {{time}}",
  long: "{{date}} 'دە' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong86 = {
  date: buildFormatLongFn({
    formats: dateFormats86,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats86,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats86,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/ug/_lib/formatRelative.mjs
var formatRelativeLocale78 = {
  lastWeek: "'ئ‍ۆتكەن' eeee 'دە' p",
  yesterday: "'تۈنۈگۈن دە' p",
  today: "'بۈگۈن دە' p",
  tomorrow: "'ئەتە دە' p",
  nextWeek: "eeee 'دە' p",
  other: "P"
};
var formatRelative78 = (token, _date, _baseDate, _options) => formatRelativeLocale78[token];

// ../../../node_modules/date-fns/locale/ug/_lib/localize.mjs
var eraValues78 = {
  narrow: ["ب", "ك"],
  abbreviated: ["ب", "ك"],
  wide: ["مىيلادىدىن بۇرۇن", "مىيلادىدىن كىيىن"]
};
var quarterValues78 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1", "2", "3", "4"],
  wide: ["بىرىنجى چارەك", "ئىككىنجى چارەك", "ئۈچىنجى چارەك", "تۆتىنجى چارەك"]
};
var monthValues78 = {
  narrow: ["ي", "ف", "م", "ا", "م", "ى", "ى", "ا", "س", "ۆ", "ن", "د"],
  abbreviated: [
    "يانۋار",
    "فېۋىرال",
    "مارت",
    "ئاپرىل",
    "ماي",
    "ئىيۇن",
    "ئىيول",
    "ئاۋغۇست",
    "سىنتەبىر",
    "ئۆكتەبىر",
    "نويابىر",
    "دىكابىر"
  ],
  wide: [
    "يانۋار",
    "فېۋىرال",
    "مارت",
    "ئاپرىل",
    "ماي",
    "ئىيۇن",
    "ئىيول",
    "ئاۋغۇست",
    "سىنتەبىر",
    "ئۆكتەبىر",
    "نويابىر",
    "دىكابىر"
  ]
};
var dayValues78 = {
  narrow: ["ي", "د", "س", "چ", "پ", "ج", "ش"],
  short: ["ي", "د", "س", "چ", "پ", "ج", "ش"],
  abbreviated: [
    "يەكشەنبە",
    "دۈشەنبە",
    "سەيشەنبە",
    "چارشەنبە",
    "پەيشەنبە",
    "جۈمە",
    "شەنبە"
  ],
  wide: [
    "يەكشەنبە",
    "دۈشەنبە",
    "سەيشەنبە",
    "چارشەنبە",
    "پەيشەنبە",
    "جۈمە",
    "شەنبە"
  ]
};
var dayPeriodValues78 = {
  narrow: {
    am: "ئە",
    pm: "چ",
    midnight: "ك",
    noon: "چ",
    morning: "ئەتىگەن",
    afternoon: "چۈشتىن كىيىن",
    evening: "ئاخشىم",
    night: "كىچە"
  },
  abbreviated: {
    am: "ئە",
    pm: "چ",
    midnight: "ك",
    noon: "چ",
    morning: "ئەتىگەن",
    afternoon: "چۈشتىن كىيىن",
    evening: "ئاخشىم",
    night: "كىچە"
  },
  wide: {
    am: "ئە",
    pm: "چ",
    midnight: "ك",
    noon: "چ",
    morning: "ئەتىگەن",
    afternoon: "چۈشتىن كىيىن",
    evening: "ئاخشىم",
    night: "كىچە"
  }
};
var formattingDayPeriodValues62 = {
  narrow: {
    am: "ئە",
    pm: "چ",
    midnight: "ك",
    noon: "چ",
    morning: "ئەتىگەندە",
    afternoon: "چۈشتىن كىيىن",
    evening: "ئاخشامدا",
    night: "كىچىدە"
  },
  abbreviated: {
    am: "ئە",
    pm: "چ",
    midnight: "ك",
    noon: "چ",
    morning: "ئەتىگەندە",
    afternoon: "چۈشتىن كىيىن",
    evening: "ئاخشامدا",
    night: "كىچىدە"
  },
  wide: {
    am: "ئە",
    pm: "چ",
    midnight: "ك",
    noon: "چ",
    morning: "ئەتىگەندە",
    afternoon: "چۈشتىن كىيىن",
    evening: "ئاخشامدا",
    night: "كىچىدە"
  }
};
var ordinalNumber78 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize78 = {
  ordinalNumber: ordinalNumber78,
  era: buildLocalizeFn({
    values: eraValues78,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues78,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues78,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues78,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues78,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues62,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/ug/_lib/match.mjs
var matchOrdinalNumberPattern77 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern77 = /\d+/i;
var matchEraPatterns77 = {
  narrow: /^(ب|ك)/i,
  wide: /^(مىيلادىدىن بۇرۇن|مىيلادىدىن كىيىن)/i
};
var parseEraPatterns77 = {
  any: [/^بۇرۇن/i, /^كىيىن/i]
};
var matchQuarterPatterns77 = {
  narrow: /^[1234]/i,
  abbreviated: /^چ[1234]/i,
  wide: /^چارەك [1234]/i
};
var parseQuarterPatterns77 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns77 = {
  // eslint-disable-next-line no-misleading-character-class
  narrow: /^[يفمئامئ‍ئاسۆند]/i,
  abbreviated: /^(يانۋار|فېۋىرال|مارت|ئاپرىل|ماي|ئىيۇن|ئىيول|ئاۋغۇست|سىنتەبىر|ئۆكتەبىر|نويابىر|دىكابىر)/i,
  wide: /^(يانۋار|فېۋىرال|مارت|ئاپرىل|ماي|ئىيۇن|ئىيول|ئاۋغۇست|سىنتەبىر|ئۆكتەبىر|نويابىر|دىكابىر)/i
};
var parseMonthPatterns77 = {
  narrow: [
    /^ي/i,
    /^ف/i,
    /^م/i,
    /^ا/i,
    /^م/i,
    /^ى‍/i,
    /^ى‍/i,
    /^ا‍/i,
    /^س/i,
    /^ۆ/i,
    /^ن/i,
    /^د/i
  ],
  any: [
    /^يان/i,
    /^فېۋ/i,
    /^مار/i,
    /^ئاپ/i,
    /^ماي/i,
    /^ئىيۇن/i,
    /^ئىيول/i,
    /^ئاۋ/i,
    /^سىن/i,
    /^ئۆك/i,
    /^نوي/i,
    /^دىك/i
  ]
};
var matchDayPatterns77 = {
  narrow: /^[دسچپجشي]/i,
  short: /^(يە|دۈ|سە|چا|پە|جۈ|شە)/i,
  abbreviated: /^(يە|دۈ|سە|چا|پە|جۈ|شە)/i,
  wide: /^(يەكشەنبە|دۈشەنبە|سەيشەنبە|چارشەنبە|پەيشەنبە|جۈمە|شەنبە)/i
};
var parseDayPatterns77 = {
  narrow: [/^ي/i, /^د/i, /^س/i, /^چ/i, /^پ/i, /^ج/i, /^ش/i],
  any: [/^ي/i, /^د/i, /^س/i, /^چ/i, /^پ/i, /^ج/i, /^ش/i]
};
var matchDayPeriodPatterns77 = {
  narrow: /^(ئە|چ|ك|چ|(دە|ئەتىگەن) ( ئە‍|چۈشتىن كىيىن|ئاخشىم|كىچە))/i,
  any: /^(ئە|چ|ك|چ|(دە|ئەتىگەن) ( ئە‍|چۈشتىن كىيىن|ئاخشىم|كىچە))/i
};
var parseDayPeriodPatterns77 = {
  any: {
    am: /^ئە/i,
    pm: /^چ/i,
    midnight: /^ك/i,
    noon: /^چ/i,
    morning: /ئەتىگەن/i,
    afternoon: /چۈشتىن كىيىن/i,
    evening: /ئاخشىم/i,
    night: /كىچە/i
  }
};
var match77 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern77,
    parsePattern: parseOrdinalNumberPattern77,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns77,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns77,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns77,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns77,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns77,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns77,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns77,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns77,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns77,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns77,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/ug.mjs
var ug = {
  code: "ug",
  formatDistance: formatDistance79,
  formatLong: formatLong86,
  formatRelative: formatRelative78,
  localize: localize78,
  match: match77,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/uk/_lib/formatDistance.mjs
function declension7(scheme2, count) {
  if (scheme2.one !== void 0 && count === 1) {
    return scheme2.one;
  }
  const rem10 = count % 10;
  const rem100 = count % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme2.singularNominative.replace("{{count}}", String(count));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme2.singularGenitive.replace("{{count}}", String(count));
  } else {
    return scheme2.pluralGenitive.replace("{{count}}", String(count));
  }
}
function buildLocalizeTokenFn5(scheme2) {
  return (count, options2) => {
    if (options2 && options2.addSuffix) {
      if (options2.comparison && options2.comparison > 0) {
        if (scheme2.future) {
          return declension7(scheme2.future, count);
        } else {
          return "за " + declension7(scheme2.regular, count);
        }
      } else {
        if (scheme2.past) {
          return declension7(scheme2.past, count);
        } else {
          return declension7(scheme2.regular, count) + " тому";
        }
      }
    } else {
      return declension7(scheme2.regular, count);
    }
  };
}
var halfAtMinute = (_, options2) => {
  if (options2 && options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "за півхвилини";
    } else {
      return "півхвилини тому";
    }
  }
  return "півхвилини";
};
var formatDistanceLocale78 = {
  lessThanXSeconds: buildLocalizeTokenFn5({
    regular: {
      one: "менше секунди",
      singularNominative: "менше {{count}} секунди",
      singularGenitive: "менше {{count}} секунд",
      pluralGenitive: "менше {{count}} секунд"
    },
    future: {
      one: "менше, ніж за секунду",
      singularNominative: "менше, ніж за {{count}} секунду",
      singularGenitive: "менше, ніж за {{count}} секунди",
      pluralGenitive: "менше, ніж за {{count}} секунд"
    }
  }),
  xSeconds: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "{{count}} секунда",
      singularGenitive: "{{count}} секунди",
      pluralGenitive: "{{count}} секунд"
    },
    past: {
      singularNominative: "{{count}} секунду тому",
      singularGenitive: "{{count}} секунди тому",
      pluralGenitive: "{{count}} секунд тому"
    },
    future: {
      singularNominative: "за {{count}} секунду",
      singularGenitive: "за {{count}} секунди",
      pluralGenitive: "за {{count}} секунд"
    }
  }),
  halfAMinute: halfAtMinute,
  lessThanXMinutes: buildLocalizeTokenFn5({
    regular: {
      one: "менше хвилини",
      singularNominative: "менше {{count}} хвилини",
      singularGenitive: "менше {{count}} хвилин",
      pluralGenitive: "менше {{count}} хвилин"
    },
    future: {
      one: "менше, ніж за хвилину",
      singularNominative: "менше, ніж за {{count}} хвилину",
      singularGenitive: "менше, ніж за {{count}} хвилини",
      pluralGenitive: "менше, ніж за {{count}} хвилин"
    }
  }),
  xMinutes: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "{{count}} хвилина",
      singularGenitive: "{{count}} хвилини",
      pluralGenitive: "{{count}} хвилин"
    },
    past: {
      singularNominative: "{{count}} хвилину тому",
      singularGenitive: "{{count}} хвилини тому",
      pluralGenitive: "{{count}} хвилин тому"
    },
    future: {
      singularNominative: "за {{count}} хвилину",
      singularGenitive: "за {{count}} хвилини",
      pluralGenitive: "за {{count}} хвилин"
    }
  }),
  aboutXHours: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "близько {{count}} години",
      singularGenitive: "близько {{count}} годин",
      pluralGenitive: "близько {{count}} годин"
    },
    future: {
      singularNominative: "приблизно за {{count}} годину",
      singularGenitive: "приблизно за {{count}} години",
      pluralGenitive: "приблизно за {{count}} годин"
    }
  }),
  xHours: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "{{count}} годину",
      singularGenitive: "{{count}} години",
      pluralGenitive: "{{count}} годин"
    }
  }),
  xDays: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "{{count}} день",
      singularGenitive: "{{count}} днi",
      pluralGenitive: "{{count}} днів"
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "близько {{count}} тижня",
      singularGenitive: "близько {{count}} тижнів",
      pluralGenitive: "близько {{count}} тижнів"
    },
    future: {
      singularNominative: "приблизно за {{count}} тиждень",
      singularGenitive: "приблизно за {{count}} тижні",
      pluralGenitive: "приблизно за {{count}} тижнів"
    }
  }),
  xWeeks: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "{{count}} тиждень",
      singularGenitive: "{{count}} тижні",
      pluralGenitive: "{{count}} тижнів"
    }
  }),
  aboutXMonths: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "близько {{count}} місяця",
      singularGenitive: "близько {{count}} місяців",
      pluralGenitive: "близько {{count}} місяців"
    },
    future: {
      singularNominative: "приблизно за {{count}} місяць",
      singularGenitive: "приблизно за {{count}} місяці",
      pluralGenitive: "приблизно за {{count}} місяців"
    }
  }),
  xMonths: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "{{count}} місяць",
      singularGenitive: "{{count}} місяці",
      pluralGenitive: "{{count}} місяців"
    }
  }),
  aboutXYears: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "близько {{count}} року",
      singularGenitive: "близько {{count}} років",
      pluralGenitive: "близько {{count}} років"
    },
    future: {
      singularNominative: "приблизно за {{count}} рік",
      singularGenitive: "приблизно за {{count}} роки",
      pluralGenitive: "приблизно за {{count}} років"
    }
  }),
  xYears: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "{{count}} рік",
      singularGenitive: "{{count}} роки",
      pluralGenitive: "{{count}} років"
    }
  }),
  overXYears: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "більше {{count}} року",
      singularGenitive: "більше {{count}} років",
      pluralGenitive: "більше {{count}} років"
    },
    future: {
      singularNominative: "більше, ніж за {{count}} рік",
      singularGenitive: "більше, ніж за {{count}} роки",
      pluralGenitive: "більше, ніж за {{count}} років"
    }
  }),
  almostXYears: buildLocalizeTokenFn5({
    regular: {
      singularNominative: "майже {{count}} рік",
      singularGenitive: "майже {{count}} роки",
      pluralGenitive: "майже {{count}} років"
    },
    future: {
      singularNominative: "майже за {{count}} рік",
      singularGenitive: "майже за {{count}} роки",
      pluralGenitive: "майже за {{count}} років"
    }
  })
};
var formatDistance80 = (token, count, options2) => {
  options2 = options2 || {};
  return formatDistanceLocale78[token](count, options2);
};

// ../../../node_modules/date-fns/locale/uk/_lib/formatLong.mjs
var dateFormats87 = {
  full: "EEEE, do MMMM y 'р.'",
  long: "do MMMM y 'р.'",
  medium: "d MMM y 'р.'",
  short: "dd.MM.y"
};
var timeFormats87 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats87 = {
  full: "{{date}} 'о' {{time}}",
  long: "{{date}} 'о' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong87 = {
  date: buildFormatLongFn({
    formats: dateFormats87,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats87,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats87,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/uk/_lib/formatRelative.mjs
var accusativeWeekdays8 = [
  "неділю",
  "понеділок",
  "вівторок",
  "середу",
  "четвер",
  "п’ятницю",
  "суботу"
];
function lastWeek9(day) {
  const weekday = accusativeWeekdays8[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'у минулу " + weekday + " о' p";
    case 1:
    case 2:
    case 4:
      return "'у минулий " + weekday + " о' p";
  }
}
function thisWeek9(day) {
  const weekday = accusativeWeekdays8[day];
  return "'у " + weekday + " о' p";
}
function nextWeek9(day) {
  const weekday = accusativeWeekdays8[day];
  switch (day) {
    case 0:
    case 3:
    case 5:
    case 6:
      return "'у наступну " + weekday + " о' p";
    case 1:
    case 2:
    case 4:
      return "'у наступний " + weekday + " о' p";
  }
}
var lastWeekFormat3 = (dirtyDate, baseDate, options2) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options2)) {
    return thisWeek9(day);
  } else {
    return lastWeek9(day);
  }
};
var nextWeekFormat3 = (dirtyDate, baseDate, options2) => {
  const date2 = toDate(dirtyDate);
  const day = date2.getDay();
  if (isSameWeek(date2, baseDate, options2)) {
    return thisWeek9(day);
  } else {
    return nextWeek9(day);
  }
};
var formatRelativeLocale79 = {
  lastWeek: lastWeekFormat3,
  yesterday: "'вчора о' p",
  today: "'сьогодні о' p",
  tomorrow: "'завтра о' p",
  nextWeek: nextWeekFormat3,
  other: "P"
};
var formatRelative79 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale79[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/uk/_lib/localize.mjs
var eraValues79 = {
  narrow: ["до н.е.", "н.е."],
  abbreviated: ["до н. е.", "н. е."],
  wide: ["до нашої ери", "нашої ери"]
};
var quarterValues79 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-й кв.", "2-й кв.", "3-й кв.", "4-й кв."],
  wide: ["1-й квартал", "2-й квартал", "3-й квартал", "4-й квартал"]
};
var monthValues79 = {
  // ДСТУ 3582:2013
  narrow: ["С", "Л", "Б", "К", "Т", "Ч", "Л", "С", "В", "Ж", "Л", "Г"],
  abbreviated: [
    "січ.",
    "лют.",
    "берез.",
    "квіт.",
    "трав.",
    "черв.",
    "лип.",
    "серп.",
    "верес.",
    "жовт.",
    "листоп.",
    "груд."
  ],
  wide: [
    "січень",
    "лютий",
    "березень",
    "квітень",
    "травень",
    "червень",
    "липень",
    "серпень",
    "вересень",
    "жовтень",
    "листопад",
    "грудень"
  ]
};
var formattingMonthValues18 = {
  narrow: ["С", "Л", "Б", "К", "Т", "Ч", "Л", "С", "В", "Ж", "Л", "Г"],
  abbreviated: [
    "січ.",
    "лют.",
    "берез.",
    "квіт.",
    "трав.",
    "черв.",
    "лип.",
    "серп.",
    "верес.",
    "жовт.",
    "листоп.",
    "груд."
  ],
  wide: [
    "січня",
    "лютого",
    "березня",
    "квітня",
    "травня",
    "червня",
    "липня",
    "серпня",
    "вересня",
    "жовтня",
    "листопада",
    "грудня"
  ]
};
var dayValues79 = {
  narrow: ["Н", "П", "В", "С", "Ч", "П", "С"],
  short: ["нд", "пн", "вт", "ср", "чт", "пт", "сб"],
  abbreviated: ["нед", "пон", "вів", "сер", "чтв", "птн", "суб"],
  wide: [
    "неділя",
    "понеділок",
    "вівторок",
    "середа",
    "четвер",
    "п’ятниця",
    "субота"
  ]
};
var dayPeriodValues79 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "півн.",
    noon: "пол.",
    morning: "ранок",
    afternoon: "день",
    evening: "веч.",
    night: "ніч"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "півн.",
    noon: "пол.",
    morning: "ранок",
    afternoon: "день",
    evening: "веч.",
    night: "ніч"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "північ",
    noon: "полудень",
    morning: "ранок",
    afternoon: "день",
    evening: "вечір",
    night: "ніч"
  }
};
var formattingDayPeriodValues63 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "півн.",
    noon: "пол.",
    morning: "ранку",
    afternoon: "дня",
    evening: "веч.",
    night: "ночі"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "півн.",
    noon: "пол.",
    morning: "ранку",
    afternoon: "дня",
    evening: "веч.",
    night: "ночі"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "північ",
    noon: "полудень",
    morning: "ранку",
    afternoon: "дня",
    evening: "веч.",
    night: "ночі"
  }
};
var ordinalNumber79 = (dirtyNumber, options2) => {
  const unit = String(options2 == null ? void 0 : options2.unit);
  const number2 = Number(dirtyNumber);
  let suffix2;
  if (unit === "date") {
    if (number2 === 3 || number2 === 23) {
      suffix2 = "-є";
    } else {
      suffix2 = "-е";
    }
  } else if (unit === "minute" || unit === "second" || unit === "hour") {
    suffix2 = "-а";
  } else {
    suffix2 = "-й";
  }
  return number2 + suffix2;
};
var localize79 = {
  ordinalNumber: ordinalNumber79,
  era: buildLocalizeFn({
    values: eraValues79,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues79,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues79,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues18,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues79,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues79,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues63,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/uk/_lib/match.mjs
var matchOrdinalNumberPattern78 = /^(\d+)(-?(е|й|є|а|я))?/i;
var parseOrdinalNumberPattern78 = /\d+/i;
var matchEraPatterns78 = {
  narrow: /^((до )?н\.?\s?е\.?)/i,
  abbreviated: /^((до )?н\.?\s?е\.?)/i,
  wide: /^(до нашої ери|нашої ери|наша ера)/i
};
var parseEraPatterns78 = {
  any: [/^д/i, /^н/i]
};
var matchQuarterPatterns78 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[иі]?й?)? кв.?/i,
  wide: /^[1234](-?[иі]?й?)? квартал/i
};
var parseQuarterPatterns78 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns78 = {
  narrow: /^[слбктчвжг]/i,
  abbreviated: /^(січ|лют|бер(ез)?|квіт|трав|черв|лип|серп|вер(ес)?|жовт|лис(топ)?|груд)\.?/i,
  wide: /^(січень|січня|лютий|лютого|березень|березня|квітень|квітня|травень|травня|червня|червень|липень|липня|серпень|серпня|вересень|вересня|жовтень|жовтня|листопад[а]?|грудень|грудня)/i
};
var parseMonthPatterns78 = {
  narrow: [
    /^с/i,
    /^л/i,
    /^б/i,
    /^к/i,
    /^т/i,
    /^ч/i,
    /^л/i,
    /^с/i,
    /^в/i,
    /^ж/i,
    /^л/i,
    /^г/i
  ],
  any: [
    /^сі/i,
    /^лю/i,
    /^б/i,
    /^к/i,
    /^т/i,
    /^ч/i,
    /^лип/i,
    /^се/i,
    /^в/i,
    /^ж/i,
    /^лис/i,
    /^г/i
  ]
};
var matchDayPatterns78 = {
  narrow: /^[нпвсч]/i,
  short: /^(нд|пн|вт|ср|чт|пт|сб)\.?/i,
  abbreviated: /^(нед|пон|вів|сер|че?тв|птн?|суб)\.?/i,
  wide: /^(неділ[яі]|понеділ[ок][ка]|вівтор[ок][ка]|серед[аи]|четвер(га)?|п\W*?ятниц[яі]|субот[аи])/i
};
var parseDayPatterns78 = {
  narrow: [/^н/i, /^п/i, /^в/i, /^с/i, /^ч/i, /^п/i, /^с/i],
  any: [/^н/i, /^п[он]/i, /^в/i, /^с[ер]/i, /^ч/i, /^п\W*?[ят]/i, /^с[уб]/i]
};
var matchDayPeriodPatterns78 = {
  narrow: /^([дп]п|півн\.?|пол\.?|ранок|ранку|день|дня|веч\.?|ніч|ночі)/i,
  abbreviated: /^([дп]п|півн\.?|пол\.?|ранок|ранку|день|дня|веч\.?|ніч|ночі)/i,
  wide: /^([дп]п|північ|полудень|ранок|ранку|день|дня|вечір|вечора|ніч|ночі)/i
};
var parseDayPeriodPatterns78 = {
  any: {
    am: /^дп/i,
    pm: /^пп/i,
    midnight: /^півн/i,
    noon: /^пол/i,
    morning: /^р/i,
    afternoon: /^д[ен]/i,
    evening: /^в/i,
    night: /^н/i
  }
};
var match78 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern78,
    parsePattern: parseOrdinalNumberPattern78,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns78,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns78,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns78,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns78,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns78,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns78,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns78,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns78,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns78,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns78,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/uk.mjs
var uk = {
  code: "uk",
  formatDistance: formatDistance80,
  formatLong: formatLong87,
  formatRelative: formatRelative79,
  localize: localize79,
  match: match78,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/uz/_lib/formatDistance.mjs
var formatDistanceLocale79 = {
  lessThanXSeconds: {
    one: "sekunddan kam",
    other: "{{count}} sekunddan kam"
  },
  xSeconds: {
    one: "1 sekund",
    other: "{{count}} sekund"
  },
  halfAMinute: "yarim minut",
  lessThanXMinutes: {
    one: "bir minutdan kam",
    other: "{{count}} minutdan kam"
  },
  xMinutes: {
    one: "1 minut",
    other: "{{count}} minut"
  },
  aboutXHours: {
    one: "tahminan 1 soat",
    other: "tahminan {{count}} soat"
  },
  xHours: {
    one: "1 soat",
    other: "{{count}} soat"
  },
  xDays: {
    one: "1 kun",
    other: "{{count}} kun"
  },
  aboutXWeeks: {
    one: "tahminan 1 hafta",
    other: "tahminan {{count}} hafta"
  },
  xWeeks: {
    one: "1 hafta",
    other: "{{count}} hafta"
  },
  aboutXMonths: {
    one: "tahminan 1 oy",
    other: "tahminan {{count}} oy"
  },
  xMonths: {
    one: "1 oy",
    other: "{{count}} oy"
  },
  aboutXYears: {
    one: "tahminan 1 yil",
    other: "tahminan {{count}} yil"
  },
  xYears: {
    one: "1 yil",
    other: "{{count}} yil"
  },
  overXYears: {
    one: "1 yildan ko'p",
    other: "{{count}} yildan ko'p"
  },
  almostXYears: {
    one: "deyarli 1 yil",
    other: "deyarli {{count}} yil"
  }
};
var formatDistance81 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale79[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + " dan keyin";
    } else {
      return result + " oldin";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/uz/_lib/formatLong.mjs
var dateFormats88 = {
  full: "EEEE, do MMMM, y",
  long: "do MMMM, y",
  medium: "d MMM, y",
  short: "dd/MM/yyyy"
};
var timeFormats88 = {
  full: "h:mm:ss zzzz",
  long: "h:mm:ss z",
  medium: "h:mm:ss",
  short: "h:mm"
};
var dateTimeFormats88 = {
  any: "{{date}}, {{time}}"
};
var formatLong88 = {
  date: buildFormatLongFn({
    formats: dateFormats88,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats88,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats88,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/uz/_lib/formatRelative.mjs
var formatRelativeLocale80 = {
  lastWeek: "'oldingi' eeee p 'da'",
  yesterday: "'kecha' p 'da'",
  today: "'bugun' p 'da'",
  tomorrow: "'ertaga' p 'da'",
  nextWeek: "eeee p 'da'",
  other: "P"
};
var formatRelative80 = (token, _date, _baseDate, _options) => formatRelativeLocale80[token];

// ../../../node_modules/date-fns/locale/uz/_lib/localize.mjs
var eraValues80 = {
  narrow: ["M.A", "M."],
  abbreviated: ["M.A", "M."],
  wide: ["Miloddan Avvalgi", "Milodiy"]
};
var quarterValues80 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["CH.1", "CH.2", "CH.3", "CH.4"],
  wide: ["1-chi chorak", "2-chi chorak", "3-chi chorak", "4-chi chorak"]
};
var monthValues80 = {
  narrow: ["Y", "F", "M", "A", "M", "I", "I", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Yan",
    "Fev",
    "Mar",
    "Apr",
    "May",
    "Iyun",
    "Iyul",
    "Avg",
    "Sen",
    "Okt",
    "Noy",
    "Dek"
  ],
  wide: [
    "Yanvar",
    "Fevral",
    "Mart",
    "Aprel",
    "May",
    "Iyun",
    "Iyul",
    "Avgust",
    "Sentabr",
    "Oktabr",
    "Noyabr",
    "Dekabr"
  ]
};
var dayValues80 = {
  narrow: ["Y", "D", "S", "CH", "P", "J", "SH"],
  short: ["Ya", "Du", "Se", "Cho", "Pa", "Ju", "Sha"],
  abbreviated: ["Yak", "Dush", "Sesh", "Chor", "Pay", "Jum", "Shan"],
  wide: [
    "Yakshanba",
    "Dushanba",
    "Seshanba",
    "Chorshanba",
    "Payshanba",
    "Juma",
    "Shanba"
  ]
};
var dayPeriodValues80 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "y.t",
    noon: "p.",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  }
};
var formattingDayPeriodValues64 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "y.t",
    noon: "p.",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "yarim tun",
    noon: "peshin",
    morning: "ertalab",
    afternoon: "tushdan keyin",
    evening: "kechqurun",
    night: "tun"
  }
};
var ordinalNumber80 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize80 = {
  ordinalNumber: ordinalNumber80,
  era: buildLocalizeFn({
    values: eraValues80,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues80,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues80,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues80,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues80,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues64,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/uz/_lib/match.mjs
var matchOrdinalNumberPattern79 = /^(\d+)(chi)?/i;
var parseOrdinalNumberPattern79 = /\d+/i;
var matchEraPatterns79 = {
  narrow: /^(m\.a|m\.)/i,
  abbreviated: /^(m\.a\.?\s?m\.?)/i,
  wide: /^(miloddan avval|miloddan keyin)/i
};
var parseEraPatterns79 = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns79 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](chi)? chorak/i
};
var parseQuarterPatterns79 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns79 = {
  narrow: /^[yfmasond]/i,
  abbreviated: /^(yan|fev|mar|apr|may|iyun|iyul|avg|sen|okt|noy|dek)/i,
  wide: /^(yanvar|fevral|mart|aprel|may|iyun|iyul|avgust|sentabr|oktabr|noyabr|dekabr)/i
};
var parseMonthPatterns79 = {
  narrow: [
    /^y/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^i/i,
    /^i/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ya/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^iyun/i,
    /^iyul/i,
    /^av/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns79 = {
  narrow: /^[ydschj]/i,
  short: /^(ya|du|se|cho|pa|ju|sha)/i,
  abbreviated: /^(yak|dush|sesh|chor|pay|jum|shan)/i,
  wide: /^(yakshanba|dushanba|seshanba|chorshanba|payshanba|juma|shanba)/i
};
var parseDayPatterns79 = {
  narrow: [/^y/i, /^d/i, /^s/i, /^ch/i, /^p/i, /^j/i, /^sh/i],
  any: [/^ya/i, /^d/i, /^se/i, /^ch/i, /^p/i, /^j/i, /^sh/i]
};
var matchDayPeriodPatterns79 = {
  narrow: /^(a|p|y\.t|p| (ertalab|tushdan keyin|kechqurun|tun))/i,
  any: /^([ap]\.?\s?m\.?|yarim tun|peshin| (ertalab|tushdan keyin|kechqurun|tun))/i
};
var parseDayPeriodPatterns79 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^y\.t/i,
    noon: /^pe/i,
    morning: /ertalab/i,
    afternoon: /tushdan keyin/i,
    evening: /kechqurun/i,
    night: /tun/i
  }
};
var match79 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern79,
    parsePattern: parseOrdinalNumberPattern79,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns79,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns79,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns79,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns79,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns79,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns79,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns79,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns79,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns79,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns79,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/uz.mjs
var uz = {
  code: "uz",
  formatDistance: formatDistance81,
  formatLong: formatLong88,
  formatRelative: formatRelative80,
  localize: localize80,
  match: match79,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/uz-Cyrl/_lib/formatDistance.mjs
var formatDistanceLocale80 = {
  lessThanXSeconds: {
    one: "1 сониядан кам",
    other: "{{count}} сониядан кам"
  },
  xSeconds: {
    one: "1 сония",
    other: "{{count}} сония"
  },
  halfAMinute: "ярим дақиқа",
  lessThanXMinutes: {
    one: "1 дақиқадан кам",
    other: "{{count}} дақиқадан кам"
  },
  xMinutes: {
    one: "1 дақиқа",
    other: "{{count}} дақиқа"
  },
  aboutXHours: {
    one: "тахминан 1 соат",
    other: "тахминан {{count}} соат"
  },
  xHours: {
    one: "1 соат",
    other: "{{count}} соат"
  },
  xDays: {
    one: "1 кун",
    other: "{{count}} кун"
  },
  aboutXWeeks: {
    one: "тахминан 1 хафта",
    other: "тахминан {{count}} хафта"
  },
  xWeeks: {
    one: "1 хафта",
    other: "{{count}} хафта"
  },
  aboutXMonths: {
    one: "тахминан 1 ой",
    other: "тахминан {{count}} ой"
  },
  xMonths: {
    one: "1 ой",
    other: "{{count}} ой"
  },
  aboutXYears: {
    one: "тахминан 1 йил",
    other: "тахминан {{count}} йил"
  },
  xYears: {
    one: "1 йил",
    other: "{{count}} йил"
  },
  overXYears: {
    one: "1 йилдан кўп",
    other: "{{count}} йилдан кўп"
  },
  almostXYears: {
    one: "деярли 1 йил",
    other: "деярли {{count}} йил"
  }
};
var formatDistance82 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale80[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "дан кейин";
    } else {
      return result + " олдин";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/uz-Cyrl/_lib/formatLong.mjs
var dateFormats89 = {
  full: "EEEE, do MMMM, y",
  long: "do MMMM, y",
  medium: "d MMM, y",
  short: "dd/MM/yyyy"
};
var timeFormats89 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats89 = {
  any: "{{date}}, {{time}}"
};
var formatLong89 = {
  date: buildFormatLongFn({
    formats: dateFormats89,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats89,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats89,
    defaultWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/uz-Cyrl/_lib/formatRelative.mjs
var formatRelativeLocale81 = {
  lastWeek: "'ўтган' eeee p 'да'",
  yesterday: "'кеча' p 'да'",
  today: "'бугун' p 'да'",
  tomorrow: "'эртага' p 'да'",
  nextWeek: "eeee p 'да'",
  other: "P"
};
var formatRelative81 = (token, _date, _baseDate, _options) => formatRelativeLocale81[token];

// ../../../node_modules/date-fns/locale/uz-Cyrl/_lib/localize.mjs
var eraValues81 = {
  narrow: ["М.А", "М"],
  abbreviated: ["М.А", "М"],
  wide: ["Милоддан Аввалги", "Милодий"]
};
var quarterValues81 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-чор.", "2-чор.", "3-чор.", "4-чор."],
  wide: ["1-чорак", "2-чорак", "3-чорак", "4-чорак"]
};
var monthValues81 = {
  narrow: ["Я", "Ф", "М", "А", "М", "И", "И", "А", "С", "О", "Н", "Д"],
  abbreviated: [
    "янв",
    "фев",
    "мар",
    "апр",
    "май",
    "июн",
    "июл",
    "авг",
    "сен",
    "окт",
    "ноя",
    "дек"
  ],
  wide: [
    "январ",
    "феврал",
    "март",
    "апрел",
    "май",
    "июн",
    "июл",
    "август",
    "сентабр",
    "октабр",
    "ноябр",
    "декабр"
  ]
};
var dayValues81 = {
  narrow: ["Я", "Д", "С", "Ч", "П", "Ж", "Ш"],
  short: ["як", "ду", "се", "чо", "па", "жу", "ша"],
  abbreviated: ["якш", "душ", "сеш", "чор", "пай", "жум", "шан"],
  wide: [
    "якшанба",
    "душанба",
    "сешанба",
    "чоршанба",
    "пайшанба",
    "жума",
    "шанба"
  ]
};
var dayPeriodValues81 = {
  any: {
    am: "П.О.",
    pm: "П.К.",
    midnight: "ярим тун",
    noon: "пешин",
    morning: "эрталаб",
    afternoon: "пешиндан кейин",
    evening: "кечаси",
    night: "тун"
  }
};
var formattingDayPeriodValues65 = {
  any: {
    am: "П.О.",
    pm: "П.К.",
    midnight: "ярим тун",
    noon: "пешин",
    morning: "эрталаб",
    afternoon: "пешиндан кейин",
    evening: "кечаси",
    night: "тун"
  }
};
var ordinalNumber81 = (dirtyNumber, _options) => {
  return String(dirtyNumber);
};
var localize81 = {
  ordinalNumber: ordinalNumber81,
  era: buildLocalizeFn({
    values: eraValues81,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues81,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues81,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues81,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues81,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues65,
    defaultFormattingWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/uz-Cyrl/_lib/match.mjs
var matchOrdinalNumberPattern80 = /^(\d+)(чи)?/i;
var parseOrdinalNumberPattern80 = /\d+/i;
var matchEraPatterns80 = {
  narrow: /^(м\.а|м\.)/i,
  abbreviated: /^(м\.а|м\.)/i,
  wide: /^(милоддан аввал|милоддан кейин)/i
};
var parseEraPatterns80 = {
  any: [/^м/i, /^а/i]
};
var matchQuarterPatterns80 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]-чор./i,
  wide: /^[1234]-чорак/i
};
var parseQuarterPatterns80 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns80 = {
  narrow: /^[яфмамииасонд]/i,
  abbreviated: /^(янв|фев|мар|апр|май|июн|июл|авг|сен|окт|ноя|дек)/i,
  wide: /^(январ|феврал|март|апрел|май|июн|июл|август|сентабр|октабр|ноябр|декабр)/i
};
var parseMonthPatterns80 = {
  narrow: [
    /^я/i,
    /^ф/i,
    /^м/i,
    /^а/i,
    /^м/i,
    /^и/i,
    /^и/i,
    /^а/i,
    /^с/i,
    /^о/i,
    /^н/i,
    /^д/i
  ],
  any: [
    /^я/i,
    /^ф/i,
    /^мар/i,
    /^ап/i,
    /^май/i,
    /^июн/i,
    /^июл/i,
    /^ав/i,
    /^с/i,
    /^о/i,
    /^н/i,
    /^д/i
  ]
};
var matchDayPatterns80 = {
  narrow: /^[ядсчпжш]/i,
  short: /^(як|ду|се|чо|па|жу|ша)/i,
  abbreviated: /^(якш|душ|сеш|чор|пай|жум|шан)/i,
  wide: /^(якшанба|душанба|сешанба|чоршанба|пайшанба|жума|шанба)/i
};
var parseDayPatterns80 = {
  narrow: [/^я/i, /^д/i, /^с/i, /^ч/i, /^п/i, /^ж/i, /^ш/i],
  any: [/^як/i, /^ду/i, /^се/i, /^чор/i, /^пай/i, /^жу/i, /^шан/i]
};
var matchDayPeriodPatterns80 = {
  any: /^(п\.о\.|п\.к\.|ярим тун|пешиндан кейин|(эрталаб|пешиндан кейин|кечаси|тун))/i
};
var parseDayPeriodPatterns80 = {
  any: {
    am: /^п\.о\./i,
    pm: /^п\.к\./i,
    midnight: /^ярим тун/i,
    noon: /^пешиндан кейин/i,
    morning: /эрталаб/i,
    afternoon: /пешиндан кейин/i,
    evening: /кечаси/i,
    night: /тун/i
  }
};
var match80 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern80,
    parsePattern: parseOrdinalNumberPattern80,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns80,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns80,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns80,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns80,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns80,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns80,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns80,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns80,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns80,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns80,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/uz-Cyrl.mjs
var uzCyrl = {
  code: "uz-Cyrl",
  formatDistance: formatDistance82,
  formatLong: formatLong89,
  formatRelative: formatRelative81,
  localize: localize81,
  match: match80,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/vi/_lib/formatDistance.mjs
var formatDistanceLocale81 = {
  lessThanXSeconds: {
    one: "dưới 1 giây",
    other: "dưới {{count}} giây"
  },
  xSeconds: {
    one: "1 giây",
    other: "{{count}} giây"
  },
  halfAMinute: "nửa phút",
  lessThanXMinutes: {
    one: "dưới 1 phút",
    other: "dưới {{count}} phút"
  },
  xMinutes: {
    one: "1 phút",
    other: "{{count}} phút"
  },
  aboutXHours: {
    one: "khoảng 1 giờ",
    other: "khoảng {{count}} giờ"
  },
  xHours: {
    one: "1 giờ",
    other: "{{count}} giờ"
  },
  xDays: {
    one: "1 ngày",
    other: "{{count}} ngày"
  },
  aboutXWeeks: {
    one: "khoảng 1 tuần",
    other: "khoảng {{count}} tuần"
  },
  xWeeks: {
    one: "1 tuần",
    other: "{{count}} tuần"
  },
  aboutXMonths: {
    one: "khoảng 1 tháng",
    other: "khoảng {{count}} tháng"
  },
  xMonths: {
    one: "1 tháng",
    other: "{{count}} tháng"
  },
  aboutXYears: {
    one: "khoảng 1 năm",
    other: "khoảng {{count}} năm"
  },
  xYears: {
    one: "1 năm",
    other: "{{count}} năm"
  },
  overXYears: {
    one: "hơn 1 năm",
    other: "hơn {{count}} năm"
  },
  almostXYears: {
    one: "gần 1 năm",
    other: "gần {{count}} năm"
  }
};
var formatDistance83 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale81[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + " nữa";
    } else {
      return result + " trước";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/vi/_lib/formatLong.mjs
var dateFormats90 = {
  // thứ Sáu, ngày 25 tháng 08 năm 2017
  full: "EEEE, 'ngày' d MMMM 'năm' y",
  // ngày 25 tháng 08 năm 2017
  long: "'ngày' d MMMM 'năm' y",
  // 25 thg 08 năm 2017
  medium: "d MMM 'năm' y",
  // 25/08/2017
  short: "dd/MM/y"
};
var timeFormats90 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats90 = {
  // thứ Sáu, ngày 25 tháng 08 năm 2017 23:25:59
  full: "{{date}} {{time}}",
  // ngày 25 tháng 08 năm 2017 23:25
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong90 = {
  date: buildFormatLongFn({
    formats: dateFormats90,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats90,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats90,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/vi/_lib/formatRelative.mjs
var formatRelativeLocale82 = {
  lastWeek: "eeee 'tuần trước vào lúc' p",
  yesterday: "'hôm qua vào lúc' p",
  today: "'hôm nay vào lúc' p",
  tomorrow: "'ngày mai vào lúc' p",
  nextWeek: "eeee 'tới vào lúc' p",
  other: "P"
};
var formatRelative82 = (token, _date, _baseDate, _options) => formatRelativeLocale82[token];

// ../../../node_modules/date-fns/locale/vi/_lib/localize.mjs
var eraValues82 = {
  narrow: ["TCN", "SCN"],
  abbreviated: ["trước CN", "sau CN"],
  wide: ["trước Công Nguyên", "sau Công Nguyên"]
};
var quarterValues82 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["Quý 1", "Quý 2", "Quý 3", "Quý 4"]
};
var formattingQuarterValues4 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  // I notice many news outlet use this "quý II/2018"
  wide: ["quý I", "quý II", "quý III", "quý IV"]
};
var monthValues82 = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "Thg 1",
    "Thg 2",
    "Thg 3",
    "Thg 4",
    "Thg 5",
    "Thg 6",
    "Thg 7",
    "Thg 8",
    "Thg 9",
    "Thg 10",
    "Thg 11",
    "Thg 12"
  ],
  wide: [
    "Tháng Một",
    "Tháng Hai",
    "Tháng Ba",
    "Tháng Tư",
    "Tháng Năm",
    "Tháng Sáu",
    "Tháng Bảy",
    "Tháng Tám",
    "Tháng Chín",
    "Tháng Mười",
    "Tháng Mười Một",
    "Tháng Mười Hai"
  ]
};
var formattingMonthValues19 = {
  narrow: [
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "10",
    "11",
    "12"
  ],
  abbreviated: [
    "thg 1",
    "thg 2",
    "thg 3",
    "thg 4",
    "thg 5",
    "thg 6",
    "thg 7",
    "thg 8",
    "thg 9",
    "thg 10",
    "thg 11",
    "thg 12"
  ],
  wide: [
    "tháng 01",
    "tháng 02",
    "tháng 03",
    "tháng 04",
    "tháng 05",
    "tháng 06",
    "tháng 07",
    "tháng 08",
    "tháng 09",
    "tháng 10",
    "tháng 11",
    "tháng 12"
  ]
};
var dayValues82 = {
  narrow: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
  short: ["CN", "Th 2", "Th 3", "Th 4", "Th 5", "Th 6", "Th 7"],
  abbreviated: ["CN", "Thứ 2", "Thứ 3", "Thứ 4", "Thứ 5", "Thứ 6", "Thứ 7"],
  wide: [
    "Chủ Nhật",
    "Thứ Hai",
    "Thứ Ba",
    "Thứ Tư",
    "Thứ Năm",
    "Thứ Sáu",
    "Thứ Bảy"
  ]
};
var dayPeriodValues82 = {
  // narrow date period is extremely rare in Vietnamese
  // I used abbreviated form for noon, morning and afternoon
  // which are regconizable by Vietnamese, others cannot be any shorter
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "nửa đêm",
    noon: "tr",
    morning: "sg",
    afternoon: "ch",
    evening: "tối",
    night: "đêm"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "nửa đêm",
    noon: "trưa",
    morning: "sáng",
    afternoon: "chiều",
    evening: "tối",
    night: "đêm"
  },
  wide: {
    am: "SA",
    pm: "CH",
    midnight: "nửa đêm",
    noon: "trưa",
    morning: "sáng",
    afternoon: "chiều",
    evening: "tối",
    night: "đêm"
  }
};
var formattingDayPeriodValues66 = {
  narrow: {
    am: "am",
    pm: "pm",
    midnight: "nửa đêm",
    noon: "tr",
    morning: "sg",
    afternoon: "ch",
    evening: "tối",
    night: "đêm"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "nửa đêm",
    noon: "trưa",
    morning: "sáng",
    afternoon: "chiều",
    evening: "tối",
    night: "đêm"
  },
  wide: {
    am: "SA",
    pm: "CH",
    midnight: "nửa đêm",
    noon: "giữa trưa",
    morning: "vào buổi sáng",
    afternoon: "vào buổi chiều",
    evening: "vào buổi tối",
    night: "vào ban đêm"
  }
};
var ordinalNumber82 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  const unit = options2 == null ? void 0 : options2.unit;
  if (unit === "quarter") {
    switch (number2) {
      case 1:
        return "I";
      case 2:
        return "II";
      case 3:
        return "III";
      case 4:
        return "IV";
    }
  } else if (unit === "day") {
    switch (number2) {
      case 1:
        return "thứ 2";
      // meaning 2nd day but it's the first day of the week :D
      case 2:
        return "thứ 3";
      // meaning 3rd day
      case 3:
        return "thứ 4";
      // meaning 4th day and so on
      case 4:
        return "thứ 5";
      case 5:
        return "thứ 6";
      case 6:
        return "thứ 7";
      case 7:
        return "chủ nhật";
    }
  } else if (unit === "week") {
    if (number2 === 1) {
      return "thứ nhất";
    } else {
      return "thứ " + number2;
    }
  } else if (unit === "dayOfYear") {
    if (number2 === 1) {
      return "đầu tiên";
    } else {
      return "thứ " + number2;
    }
  }
  return String(number2);
};
var localize82 = {
  ordinalNumber: ordinalNumber82,
  era: buildLocalizeFn({
    values: eraValues82,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues82,
    defaultWidth: "wide",
    formattingValues: formattingQuarterValues4,
    defaultFormattingWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues82,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues19,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues82,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues82,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues66,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/vi/_lib/match.mjs
var matchOrdinalNumberPattern81 = /^(\d+)/i;
var parseOrdinalNumberPattern81 = /\d+/i;
var matchEraPatterns81 = {
  narrow: /^(tcn|scn)/i,
  abbreviated: /^(trước CN|sau CN)/i,
  wide: /^(trước Công Nguyên|sau Công Nguyên)/i
};
var parseEraPatterns81 = {
  any: [/^t/i, /^s/i]
};
var matchQuarterPatterns81 = {
  narrow: /^([1234]|i{1,3}v?)/i,
  abbreviated: /^q([1234]|i{1,3}v?)/i,
  wide: /^quý ([1234]|i{1,3}v?)/i
};
var parseQuarterPatterns81 = {
  any: [/(1|i)$/i, /(2|ii)$/i, /(3|iii)$/i, /(4|iv)$/i]
};
var matchMonthPatterns81 = {
  // month number may contain leading 0, 'thg' prefix may have space, underscore or empty before number
  // note the order of '1' since it is a sub-string of '10', so must be lower priority
  narrow: /^(0?[2-9]|10|11|12|0?1)/i,
  // note the order of 'thg 1' since it is sub-string of 'thg 10', so must be lower priority
  abbreviated: /^thg[ _]?(0?[1-9](?!\d)|10|11|12)/i,
  // note the order of 'Mười' since it is sub-string of Mười Một, so must be lower priority
  wide: /^tháng ?(Một|Hai|Ba|Tư|Năm|Sáu|Bảy|Tám|Chín|Mười|Mười ?Một|Mười ?Hai|0?[1-9](?!\d)|10|11|12)/i
};
var parseMonthPatterns81 = {
  narrow: [
    /0?1$/i,
    /0?2/i,
    /3/,
    /4/,
    /5/,
    /6/,
    /7/,
    /8/,
    /9/,
    /10/,
    /11/,
    /12/
  ],
  abbreviated: [
    /^thg[ _]?0?1(?!\d)/i,
    /^thg[ _]?0?2/i,
    /^thg[ _]?0?3/i,
    /^thg[ _]?0?4/i,
    /^thg[ _]?0?5/i,
    /^thg[ _]?0?6/i,
    /^thg[ _]?0?7/i,
    /^thg[ _]?0?8/i,
    /^thg[ _]?0?9/i,
    /^thg[ _]?10/i,
    /^thg[ _]?11/i,
    /^thg[ _]?12/i
  ],
  wide: [
    /^tháng ?(Một|0?1(?!\d))/i,
    /^tháng ?(Hai|0?2)/i,
    /^tháng ?(Ba|0?3)/i,
    /^tháng ?(Tư|0?4)/i,
    /^tháng ?(Năm|0?5)/i,
    /^tháng ?(Sáu|0?6)/i,
    /^tháng ?(Bảy|0?7)/i,
    /^tháng ?(Tám|0?8)/i,
    /^tháng ?(Chín|0?9)/i,
    /^tháng ?(Mười|10)/i,
    /^tháng ?(Mười ?Một|11)/i,
    /^tháng ?(Mười ?Hai|12)/i
  ]
};
var matchDayPatterns81 = {
  narrow: /^(CN|T2|T3|T4|T5|T6|T7)/i,
  short: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
  abbreviated: /^(CN|Th ?2|Th ?3|Th ?4|Th ?5|Th ?6|Th ?7)/i,
  wide: /^(Chủ ?Nhật|Chúa ?Nhật|thứ ?Hai|thứ ?Ba|thứ ?Tư|thứ ?Năm|thứ ?Sáu|thứ ?Bảy)/i
};
var parseDayPatterns81 = {
  narrow: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  short: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  abbreviated: [/CN/i, /2/i, /3/i, /4/i, /5/i, /6/i, /7/i],
  wide: [/(Chủ|Chúa) ?Nhật/i, /Hai/i, /Ba/i, /Tư/i, /Năm/i, /Sáu/i, /Bảy/i]
};
var matchDayPeriodPatterns81 = {
  narrow: /^(a|p|nửa đêm|trưa|(giờ) (sáng|chiều|tối|đêm))/i,
  abbreviated: /^(am|pm|nửa đêm|trưa|(giờ) (sáng|chiều|tối|đêm))/i,
  wide: /^(ch[^i]*|sa|nửa đêm|trưa|(giờ) (sáng|chiều|tối|đêm))/i
};
var parseDayPeriodPatterns81 = {
  any: {
    am: /^(a|sa)/i,
    pm: /^(p|ch[^i]*)/i,
    midnight: /nửa đêm/i,
    noon: /trưa/i,
    morning: /sáng/i,
    afternoon: /chiều/i,
    evening: /tối/i,
    night: /^đêm/i
  }
};
var match81 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern81,
    parsePattern: parseOrdinalNumberPattern81,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns81,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns81,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns81,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns81,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns81,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns81,
    defaultParseWidth: "wide"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns81,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns81,
    defaultParseWidth: "wide"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns81,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns81,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/vi.mjs
var vi = {
  code: "vi",
  formatDistance: formatDistance83,
  formatLong: formatLong90,
  formatRelative: formatRelative82,
  localize: localize82,
  match: match81,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/zh-CN/_lib/formatDistance.mjs
var formatDistanceLocale82 = {
  lessThanXSeconds: {
    one: "不到 1 秒",
    other: "不到 {{count}} 秒"
  },
  xSeconds: {
    one: "1 秒",
    other: "{{count}} 秒"
  },
  halfAMinute: "半分钟",
  lessThanXMinutes: {
    one: "不到 1 分钟",
    other: "不到 {{count}} 分钟"
  },
  xMinutes: {
    one: "1 分钟",
    other: "{{count}} 分钟"
  },
  xHours: {
    one: "1 小时",
    other: "{{count}} 小时"
  },
  aboutXHours: {
    one: "大约 1 小时",
    other: "大约 {{count}} 小时"
  },
  xDays: {
    one: "1 天",
    other: "{{count}} 天"
  },
  aboutXWeeks: {
    one: "大约 1 个星期",
    other: "大约 {{count}} 个星期"
  },
  xWeeks: {
    one: "1 个星期",
    other: "{{count}} 个星期"
  },
  aboutXMonths: {
    one: "大约 1 个月",
    other: "大约 {{count}} 个月"
  },
  xMonths: {
    one: "1 个月",
    other: "{{count}} 个月"
  },
  aboutXYears: {
    one: "大约 1 年",
    other: "大约 {{count}} 年"
  },
  xYears: {
    one: "1 年",
    other: "{{count}} 年"
  },
  overXYears: {
    one: "超过 1 年",
    other: "超过 {{count}} 年"
  },
  almostXYears: {
    one: "将近 1 年",
    other: "将近 {{count}} 年"
  }
};
var formatDistance84 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale82[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "内";
    } else {
      return result + "前";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/zh-CN/_lib/formatLong.mjs
var dateFormats91 = {
  full: "y'年'M'月'd'日' EEEE",
  long: "y'年'M'月'd'日'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
var timeFormats91 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats91 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong91 = {
  date: buildFormatLongFn({
    formats: dateFormats91,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats91,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats91,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/zh-CN/_lib/formatRelative.mjs
function checkWeek(date2, baseDate, options2) {
  const baseFormat = "eeee p";
  if (isSameWeek(date2, baseDate, options2)) {
    return baseFormat;
  } else if (date2.getTime() > baseDate.getTime()) {
    return "'下个'" + baseFormat;
  }
  return "'上个'" + baseFormat;
}
var formatRelativeLocale83 = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'昨天' p",
  today: "'今天' p",
  tomorrow: "'明天' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: "PP p"
};
var formatRelative83 = (token, date2, baseDate, options2) => {
  const format3 = formatRelativeLocale83[token];
  if (typeof format3 === "function") {
    return format3(date2, baseDate, options2);
  }
  return format3;
};

// ../../../node_modules/date-fns/locale/zh-CN/_lib/localize.mjs
var eraValues83 = {
  narrow: ["前", "公元"],
  abbreviated: ["前", "公元"],
  wide: ["公元前", "公元"]
};
var quarterValues83 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["第一季", "第二季", "第三季", "第四季"],
  wide: ["第一季度", "第二季度", "第三季度", "第四季度"]
};
var monthValues83 = {
  narrow: [
    "一",
    "二",
    "三",
    "四",
    "五",
    "六",
    "七",
    "八",
    "九",
    "十",
    "十一",
    "十二"
  ],
  abbreviated: [
    "1月",
    "2月",
    "3月",
    "4月",
    "5月",
    "6月",
    "7月",
    "8月",
    "9月",
    "10月",
    "11月",
    "12月"
  ],
  wide: [
    "一月",
    "二月",
    "三月",
    "四月",
    "五月",
    "六月",
    "七月",
    "八月",
    "九月",
    "十月",
    "十一月",
    "十二月"
  ]
};
var dayValues83 = {
  narrow: ["日", "一", "二", "三", "四", "五", "六"],
  short: ["日", "一", "二", "三", "四", "五", "六"],
  abbreviated: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
  wide: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
};
var dayPeriodValues83 = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "凌晨",
    noon: "午",
    morning: "早",
    afternoon: "下午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  }
};
var formattingDayPeriodValues67 = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "凌晨",
    noon: "午",
    morning: "早",
    afternoon: "下午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  }
};
var ordinalNumber83 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  switch (options2 == null ? void 0 : options2.unit) {
    case "date":
      return number2.toString() + "日";
    case "hour":
      return number2.toString() + "时";
    case "minute":
      return number2.toString() + "分";
    case "second":
      return number2.toString() + "秒";
    default:
      return "第 " + number2.toString();
  }
};
var localize83 = {
  ordinalNumber: ordinalNumber83,
  era: buildLocalizeFn({
    values: eraValues83,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues83,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues83,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues83,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues83,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues67,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/zh-CN/_lib/match.mjs
var matchOrdinalNumberPattern82 = /^(第\s*)?\d+(日|时|分|秒)?/i;
var parseOrdinalNumberPattern82 = /\d+/i;
var matchEraPatterns82 = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
var parseEraPatterns82 = {
  any: [/^(前)/i, /^(公元)/i]
};
var matchQuarterPatterns82 = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻钟/i
};
var parseQuarterPatterns82 = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
var matchMonthPatterns82 = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
var parseMonthPatterns82 = {
  narrow: [
    /^一/i,
    /^二/i,
    /^三/i,
    /^四/i,
    /^五/i,
    /^六/i,
    /^七/i,
    /^八/i,
    /^九/i,
    /^十(?!(一|二))/i,
    /^十一/i,
    /^十二/i
  ],
  any: [
    /^一|1/i,
    /^二|2/i,
    /^三|3/i,
    /^四|4/i,
    /^五|5/i,
    /^六|6/i,
    /^七|7/i,
    /^八|8/i,
    /^九|9/i,
    /^十(?!(一|二))|10/i,
    /^十一|11/i,
    /^十二|12/i
  ]
};
var matchDayPatterns82 = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^周[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
var parseDayPatterns82 = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
var matchDayPeriodPatterns82 = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i
};
var parseDayPeriodPatterns82 = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
var match82 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern82,
    parsePattern: parseOrdinalNumberPattern82,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns82,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns82,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns82,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns82,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns82,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns82,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns82,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns82,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns82,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns82,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/zh-CN.mjs
var zhCN = {
  code: "zh-CN",
  formatDistance: formatDistance84,
  formatLong: formatLong91,
  formatRelative: formatRelative83,
  localize: localize83,
  match: match82,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/date-fns/locale/zh-HK/_lib/formatDistance.mjs
var formatDistanceLocale83 = {
  lessThanXSeconds: {
    one: "少於 1 秒",
    other: "少於 {{count}} 秒"
  },
  xSeconds: {
    one: "1 秒",
    other: "{{count}} 秒"
  },
  halfAMinute: "半分鐘",
  lessThanXMinutes: {
    one: "少於 1 分鐘",
    other: "少於 {{count}} 分鐘"
  },
  xMinutes: {
    one: "1 分鐘",
    other: "{{count}} 分鐘"
  },
  xHours: {
    one: "1 小時",
    other: "{{count}} 小時"
  },
  aboutXHours: {
    one: "大約 1 小時",
    other: "大約 {{count}} 小時"
  },
  xDays: {
    one: "1 天",
    other: "{{count}} 天"
  },
  aboutXWeeks: {
    one: "大約 1 個星期",
    other: "大約 {{count}} 個星期"
  },
  xWeeks: {
    one: "1 個星期",
    other: "{{count}} 個星期"
  },
  aboutXMonths: {
    one: "大約 1 個月",
    other: "大約 {{count}} 個月"
  },
  xMonths: {
    one: "1 個月",
    other: "{{count}} 個月"
  },
  aboutXYears: {
    one: "大約 1 年",
    other: "大約 {{count}} 年"
  },
  xYears: {
    one: "1 年",
    other: "{{count}} 年"
  },
  overXYears: {
    one: "超過 1 年",
    other: "超過 {{count}} 年"
  },
  almostXYears: {
    one: "將近 1 年",
    other: "將近 {{count}} 年"
  }
};
var formatDistance85 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale83[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "內";
    } else {
      return result + "前";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/zh-HK/_lib/formatLong.mjs
var dateFormats92 = {
  full: "y'年'M'月'd'日' EEEE",
  long: "y'年'M'月'd'日'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
var timeFormats92 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats92 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong92 = {
  date: buildFormatLongFn({
    formats: dateFormats92,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats92,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats92,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/zh-HK/_lib/formatRelative.mjs
var formatRelativeLocale84 = {
  lastWeek: "'上個'eeee p",
  yesterday: "'昨天' p",
  today: "'今天' p",
  tomorrow: "'明天' p",
  nextWeek: "'下個'eeee p",
  other: "P"
};
var formatRelative84 = (token, _date, _baseDate, _options) => formatRelativeLocale84[token];

// ../../../node_modules/date-fns/locale/zh-HK/_lib/localize.mjs
var eraValues84 = {
  narrow: ["前", "公元"],
  abbreviated: ["前", "公元"],
  wide: ["公元前", "公元"]
};
var quarterValues84 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["第一季", "第二季", "第三季", "第四季"],
  wide: ["第一季度", "第二季度", "第三季度", "第四季度"]
};
var monthValues84 = {
  narrow: [
    "一",
    "二",
    "三",
    "四",
    "五",
    "六",
    "七",
    "八",
    "九",
    "十",
    "十一",
    "十二"
  ],
  abbreviated: [
    "1月",
    "2月",
    "3月",
    "4月",
    "5月",
    "6月",
    "7月",
    "8月",
    "9月",
    "10月",
    "11月",
    "12月"
  ],
  wide: [
    "一月",
    "二月",
    "三月",
    "四月",
    "五月",
    "六月",
    "七月",
    "八月",
    "九月",
    "十月",
    "十一月",
    "十二月"
  ]
};
var dayValues84 = {
  narrow: ["日", "一", "二", "三", "四", "五", "六"],
  short: ["日", "一", "二", "三", "四", "五", "六"],
  abbreviated: ["週日", "週一", "週二", "週三", "週四", "週五", "週六"],
  wide: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
};
var dayPeriodValues84 = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "午夜",
    noon: "晌",
    morning: "早",
    afternoon: "午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "午夜",
    noon: "中午",
    morning: "上午",
    afternoon: "下午",
    evening: "晚上",
    night: "夜晚"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "午夜",
    noon: "中午",
    morning: "上午",
    afternoon: "下午",
    evening: "晚上",
    night: "夜晚"
  }
};
var formattingDayPeriodValues68 = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "午夜",
    noon: "晌",
    morning: "早",
    afternoon: "午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "午夜",
    noon: "中午",
    morning: "上午",
    afternoon: "下午",
    evening: "晚上",
    night: "夜晚"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "午夜",
    noon: "中午",
    morning: "上午",
    afternoon: "下午",
    evening: "晚上",
    night: "夜晚"
  }
};
var ordinalNumber84 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  switch (options2 == null ? void 0 : options2.unit) {
    case "date":
      return number2 + "日";
    case "hour":
      return number2 + "時";
    case "minute":
      return number2 + "分";
    case "second":
      return number2 + "秒";
    default:
      return "第 " + number2;
  }
};
var localize84 = {
  ordinalNumber: ordinalNumber84,
  era: buildLocalizeFn({
    values: eraValues84,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues84,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues84,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues84,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues84,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues68,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/zh-HK/_lib/match.mjs
var matchOrdinalNumberPattern83 = /^(第\s*)?\d+(日|時|分|秒)?/i;
var parseOrdinalNumberPattern83 = /\d+/i;
var matchEraPatterns83 = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
var parseEraPatterns83 = {
  any: [/^(前)/i, /^(公元)/i]
};
var matchQuarterPatterns83 = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]季/i,
  wide: /^第[一二三四]季度/i
};
var parseQuarterPatterns83 = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
var matchMonthPatterns83 = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
var parseMonthPatterns83 = {
  narrow: [
    /^一/i,
    /^二/i,
    /^三/i,
    /^四/i,
    /^五/i,
    /^六/i,
    /^七/i,
    /^八/i,
    /^九/i,
    /^十(?!(一|二))/i,
    /^十一/i,
    /^十二/i
  ],
  any: [
    /^一|1/i,
    /^二|2/i,
    /^三|3/i,
    /^四|4/i,
    /^五|5/i,
    /^六|6/i,
    /^七|7/i,
    /^八|8/i,
    /^九|9/i,
    /^十(?!(一|二))|10/i,
    /^十一|11/i,
    /^十二|12/i
  ]
};
var matchDayPatterns83 = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^週[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
var parseDayPatterns83 = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
var matchDayPeriodPatterns83 = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨)/i
};
var parseDayPeriodPatterns83 = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
var match83 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern83,
    parsePattern: parseOrdinalNumberPattern83,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns83,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns83,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns83,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns83,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns83,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns83,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns83,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns83,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns83,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns83,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/zh-HK.mjs
var zhHK = {
  code: "zh-HK",
  formatDistance: formatDistance85,
  formatLong: formatLong92,
  formatRelative: formatRelative84,
  localize: localize84,
  match: match83,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// ../../../node_modules/date-fns/locale/zh-TW/_lib/formatDistance.mjs
var formatDistanceLocale84 = {
  lessThanXSeconds: {
    one: "少於 1 秒",
    other: "少於 {{count}} 秒"
  },
  xSeconds: {
    one: "1 秒",
    other: "{{count}} 秒"
  },
  halfAMinute: "半分鐘",
  lessThanXMinutes: {
    one: "少於 1 分鐘",
    other: "少於 {{count}} 分鐘"
  },
  xMinutes: {
    one: "1 分鐘",
    other: "{{count}} 分鐘"
  },
  xHours: {
    one: "1 小時",
    other: "{{count}} 小時"
  },
  aboutXHours: {
    one: "大約 1 小時",
    other: "大約 {{count}} 小時"
  },
  xDays: {
    one: "1 天",
    other: "{{count}} 天"
  },
  aboutXWeeks: {
    one: "大約 1 個星期",
    other: "大約 {{count}} 個星期"
  },
  xWeeks: {
    one: "1 個星期",
    other: "{{count}} 個星期"
  },
  aboutXMonths: {
    one: "大約 1 個月",
    other: "大約 {{count}} 個月"
  },
  xMonths: {
    one: "1 個月",
    other: "{{count}} 個月"
  },
  aboutXYears: {
    one: "大約 1 年",
    other: "大約 {{count}} 年"
  },
  xYears: {
    one: "1 年",
    other: "{{count}} 年"
  },
  overXYears: {
    one: "超過 1 年",
    other: "超過 {{count}} 年"
  },
  almostXYears: {
    one: "將近 1 年",
    other: "將近 {{count}} 年"
  }
};
var formatDistance86 = (token, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale84[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return result + "內";
    } else {
      return result + "前";
    }
  }
  return result;
};

// ../../../node_modules/date-fns/locale/zh-TW/_lib/formatLong.mjs
var dateFormats93 = {
  full: "y'年'M'月'd'日' EEEE",
  long: "y'年'M'月'd'日'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
var timeFormats93 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats93 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong93 = {
  date: buildFormatLongFn({
    formats: dateFormats93,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats93,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats93,
    defaultWidth: "full"
  })
};

// ../../../node_modules/date-fns/locale/zh-TW/_lib/formatRelative.mjs
var formatRelativeLocale85 = {
  lastWeek: "'上個'eeee p",
  yesterday: "'昨天' p",
  today: "'今天' p",
  tomorrow: "'明天' p",
  nextWeek: "'下個'eeee p",
  other: "P"
};
var formatRelative85 = (token, _date, _baseDate, _options) => formatRelativeLocale85[token];

// ../../../node_modules/date-fns/locale/zh-TW/_lib/localize.mjs
var eraValues85 = {
  narrow: ["前", "公元"],
  abbreviated: ["前", "公元"],
  wide: ["公元前", "公元"]
};
var quarterValues85 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["第一刻", "第二刻", "第三刻", "第四刻"],
  wide: ["第一刻鐘", "第二刻鐘", "第三刻鐘", "第四刻鐘"]
};
var monthValues85 = {
  narrow: [
    "一",
    "二",
    "三",
    "四",
    "五",
    "六",
    "七",
    "八",
    "九",
    "十",
    "十一",
    "十二"
  ],
  abbreviated: [
    "1月",
    "2月",
    "3月",
    "4月",
    "5月",
    "6月",
    "7月",
    "8月",
    "9月",
    "10月",
    "11月",
    "12月"
  ],
  wide: [
    "一月",
    "二月",
    "三月",
    "四月",
    "五月",
    "六月",
    "七月",
    "八月",
    "九月",
    "十月",
    "十一月",
    "十二月"
  ]
};
var dayValues85 = {
  narrow: ["日", "一", "二", "三", "四", "五", "六"],
  short: ["日", "一", "二", "三", "四", "五", "六"],
  abbreviated: ["週日", "週一", "週二", "週三", "週四", "週五", "週六"],
  wide: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
};
var dayPeriodValues85 = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "凌晨",
    noon: "午",
    morning: "早",
    afternoon: "下午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜間"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜間"
  }
};
var formattingDayPeriodValues69 = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "凌晨",
    noon: "午",
    morning: "早",
    afternoon: "下午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜間"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜間"
  }
};
var ordinalNumber85 = (dirtyNumber, options2) => {
  const number2 = Number(dirtyNumber);
  switch (options2 == null ? void 0 : options2.unit) {
    case "date":
      return number2 + "日";
    case "hour":
      return number2 + "時";
    case "minute":
      return number2 + "分";
    case "second":
      return number2 + "秒";
    default:
      return "第 " + number2;
  }
};
var localize85 = {
  ordinalNumber: ordinalNumber85,
  era: buildLocalizeFn({
    values: eraValues85,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues85,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues85,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues85,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues85,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues69,
    defaultFormattingWidth: "wide"
  })
};

// ../../../node_modules/date-fns/locale/zh-TW/_lib/match.mjs
var matchOrdinalNumberPattern84 = /^(第\s*)?\d+(日|時|分|秒)?/i;
var parseOrdinalNumberPattern84 = /\d+/i;
var matchEraPatterns84 = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
var parseEraPatterns84 = {
  any: [/^(前)/i, /^(公元)/i]
};
var matchQuarterPatterns84 = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻鐘/i
};
var parseQuarterPatterns84 = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
var matchMonthPatterns84 = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
var parseMonthPatterns84 = {
  narrow: [
    /^一/i,
    /^二/i,
    /^三/i,
    /^四/i,
    /^五/i,
    /^六/i,
    /^七/i,
    /^八/i,
    /^九/i,
    /^十(?!(一|二))/i,
    /^十一/i,
    /^十二/i
  ],
  any: [
    /^一|1/i,
    /^二|2/i,
    /^三|3/i,
    /^四|4/i,
    /^五|5/i,
    /^六|6/i,
    /^七|7/i,
    /^八|8/i,
    /^九|9/i,
    /^十(?!(一|二))|10/i,
    /^十一|11/i,
    /^十二|12/i
  ]
};
var matchDayPatterns84 = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^週[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
var parseDayPatterns84 = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
var matchDayPeriodPatterns84 = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨)/i
};
var parseDayPeriodPatterns84 = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
var match84 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern84,
    parsePattern: parseOrdinalNumberPattern84,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns84,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns84,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns84,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns84,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns84,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns84,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns84,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns84,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns84,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns84,
    defaultParseWidth: "any"
  })
};

// ../../../node_modules/date-fns/locale/zh-TW.mjs
var zhTW = {
  code: "zh-TW",
  formatDistance: formatDistance86,
  formatLong: formatLong93,
  formatRelative: formatRelative85,
  localize: localize85,
  match: match84,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// ../../../node_modules/react-use-measure/dist/index.js
var import_react3 = __toESM(require_react());
function g(n2, t2) {
  let o2;
  return (...i2) => {
    window.clearTimeout(o2), o2 = window.setTimeout(() => n2(...i2), t2);
  };
}
function j({ debounce: n2, scroll: t2, polyfill: o2, offsetSize: i2 } = { debounce: 0, scroll: false, offsetSize: false }) {
  const a2 = o2 || (typeof window == "undefined" ? class {
  } : window.ResizeObserver);
  if (!a2) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [c5, h2] = (0, import_react3.useState)({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), e2 = (0, import_react3.useRef)({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: c5, orientationHandler: null }), d = n2 ? typeof n2 == "number" ? n2 : n2.scroll : null, f = n2 ? typeof n2 == "number" ? n2 : n2.resize : null, w = (0, import_react3.useRef)(false);
  (0, import_react3.useEffect)(() => (w.current = true, () => void (w.current = false)));
  const [z, m, s2] = (0, import_react3.useMemo)(() => {
    const r2 = () => {
      if (!e2.current.element) return;
      const { left: y, top: C, width: H, height: O, bottom: S, right: x, x: B, y: R } = e2.current.element.getBoundingClientRect(), l2 = { left: y, top: C, width: H, height: O, bottom: S, right: x, x: B, y: R };
      e2.current.element instanceof HTMLElement && i2 && (l2.height = e2.current.element.offsetHeight, l2.width = e2.current.element.offsetWidth), Object.freeze(l2), w.current && !D(e2.current.lastBounds, l2) && h2(e2.current.lastBounds = l2);
    };
    return [r2, f ? g(r2, f) : r2, d ? g(r2, d) : r2];
  }, [h2, i2, d, f]);
  function v() {
    e2.current.scrollContainers && (e2.current.scrollContainers.forEach((r2) => r2.removeEventListener("scroll", s2, true)), e2.current.scrollContainers = null), e2.current.resizeObserver && (e2.current.resizeObserver.disconnect(), e2.current.resizeObserver = null), e2.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", e2.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", e2.current.orientationHandler));
  }
  function b2() {
    e2.current.element && (e2.current.resizeObserver = new a2(s2), e2.current.resizeObserver.observe(e2.current.element), t2 && e2.current.scrollContainers && e2.current.scrollContainers.forEach((r2) => r2.addEventListener("scroll", s2, { capture: true, passive: true })), e2.current.orientationHandler = () => {
      s2();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", e2.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", e2.current.orientationHandler));
  }
  const L = (r2) => {
    !r2 || r2 === e2.current.element || (v(), e2.current.element = r2, e2.current.scrollContainers = E(r2), b2());
  };
  return X(s2, !!t2), W(m), (0, import_react3.useEffect)(() => {
    v(), b2();
  }, [t2, s2, m]), (0, import_react3.useEffect)(() => v, []), [L, c5, z];
}
function W(n2) {
  (0, import_react3.useEffect)(() => {
    const t2 = n2;
    return window.addEventListener("resize", t2), () => void window.removeEventListener("resize", t2);
  }, [n2]);
}
function X(n2, t2) {
  (0, import_react3.useEffect)(() => {
    if (t2) {
      const o2 = n2;
      return window.addEventListener("scroll", o2, { capture: true, passive: true }), () => void window.removeEventListener("scroll", o2, true);
    }
  }, [n2, t2]);
}
function E(n2) {
  const t2 = [];
  if (!n2 || n2 === document.body) return t2;
  const { overflow: o2, overflowX: i2, overflowY: a2 } = window.getComputedStyle(n2);
  return [o2, i2, a2].some((c5) => c5 === "auto" || c5 === "scroll") && t2.push(n2), [...t2, ...E(n2.parentElement)];
}
var k = ["x", "y", "top", "bottom", "left", "right", "width", "height"];
var D = (n2, t2) => k.every((o2) => n2[o2] === t2[o2]);

// ../../../node_modules/nanoclone/src/index.js
var map;
try {
  map = Map;
} catch (_) {
}
var set;
try {
  set = Set;
} catch (_) {
}
function baseClone(src, circulars, clones) {
  if (!src || typeof src !== "object" || typeof src === "function") {
    return src;
  }
  if (src.nodeType && "cloneNode" in src) {
    return src.cloneNode(true);
  }
  if (src instanceof Date) {
    return new Date(src.getTime());
  }
  if (src instanceof RegExp) {
    return new RegExp(src);
  }
  if (Array.isArray(src)) {
    return src.map(clone2);
  }
  if (map && src instanceof map) {
    return new Map(Array.from(src.entries()));
  }
  if (set && src instanceof set) {
    return new Set(Array.from(src.values()));
  }
  if (src instanceof Object) {
    circulars.push(src);
    var obj = Object.create(src);
    clones.push(obj);
    for (var key in src) {
      var idx = circulars.findIndex(function(i2) {
        return i2 === src[key];
      });
      obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);
    }
    return obj;
  }
  return src;
}
function clone2(src) {
  return baseClone(src, [], []);
}

// ../../../node_modules/yup/es/util/printValue.js
var toString2 = Object.prototype.toString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
var symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val) return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false) return "" + val;
  const typeOf2 = typeof val;
  if (typeOf2 === "number") return printNumber(val);
  if (typeOf2 === "string") return quoteStrings ? `"${val}"` : val;
  if (typeOf2 === "function") return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf2 === "symbol") return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString2.call(val).slice(8, -1);
  if (tag === "Date") return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error) return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp") return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null) return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null) return result2;
    return value2;
  }, 2);
}

// ../../../node_modules/yup/es/locale.js
var mixed = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path,
    type,
    value,
    originalValue
  }) => {
    let isCast = originalValue != null && originalValue !== value;
    let msg = `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".");
    if (value === null) {
      msg += `
 If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
    }
    return msg;
  },
  defined: "${path} must be defined"
};
var string = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
var number = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
var date = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
var boolean = {
  isValue: "${path} field must be ${value}"
};
var object = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
};
var array = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
var locale_default = Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean
});

// ../../../node_modules/yup/es/Condition.js
var import_has = __toESM(require_has());

// ../../../node_modules/yup/es/util/isSchema.js
var isSchema = (obj) => obj && obj.__isYupSchema__;
var isSchema_default = isSchema;

// ../../../node_modules/yup/es/Condition.js
var Condition = class {
  constructor(refs, options2) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    if (typeof options2 === "function") {
      this.fn = options2;
      return;
    }
    if (!(0, import_has.default)(options2, "is")) throw new TypeError("`is:` is required for `when()` conditions");
    if (!options2.then && !options2.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is: is3,
      then,
      otherwise
    } = options2;
    let check = typeof is3 === "function" ? is3 : (...values) => values.every((value) => value === is3);
    this.fn = function(...args) {
      let options3 = args.pop();
      let schema2 = args.pop();
      let branch = check(...args) ? then : otherwise;
      if (!branch) return void 0;
      if (typeof branch === "function") return branch(schema2);
      return schema2.concat(branch.resolve(options3));
    };
  }
  resolve(base2, options2) {
    let values = this.refs.map((ref2) => ref2.getValue(options2 == null ? void 0 : options2.value, options2 == null ? void 0 : options2.parent, options2 == null ? void 0 : options2.context));
    let schema2 = this.fn.apply(base2, values.concat(base2, options2));
    if (schema2 === void 0 || schema2 === base2) return base2;
    if (!isSchema_default(schema2)) throw new TypeError("conditions must return a schema object");
    return schema2.resolve(options2);
  }
};
var Condition_default = Condition;

// ../../../node_modules/yup/es/util/toArray.js
function toArray(value) {
  return value == null ? [] : [].concat(value);
}

// ../../../node_modules/yup/es/ValidationError.js
function _extends6() {
  _extends6 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}
var strReg = /\$\{\s*(\w+)\s*\}/g;
var ValidationError = class _ValidationError extends Error {
  static formatError(message2, params) {
    const path = params.label || params.path || "this";
    if (path !== params.path) params = _extends6({}, params, {
      path
    });
    if (typeof message2 === "string") return message2.replace(strReg, (_, key) => printValue(params[key]));
    if (typeof message2 === "function") return message2(params);
    return message2;
  }
  static isError(err) {
    return err && err.name === "ValidationError";
  }
  constructor(errorOrErrors, value, field, type) {
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.errors = void 0;
    this.params = void 0;
    this.inner = void 0;
    this.name = "ValidationError";
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    toArray(errorOrErrors).forEach((err) => {
      if (_ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        this.inner = this.inner.concat(err.inner.length ? err.inner : err);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
    if (Error.captureStackTrace) Error.captureStackTrace(this, _ValidationError);
  }
};

// ../../../node_modules/yup/es/util/runTests.js
var once = (cb) => {
  let fired = false;
  return (...args) => {
    if (fired) return;
    fired = true;
    cb(...args);
  };
};
function runTests(options2, cb) {
  let {
    endEarly,
    tests,
    args,
    value,
    errors,
    sort,
    path
  } = options2;
  let callback = once(cb);
  let count = tests.length;
  const nestedErrors = [];
  errors = errors ? errors : [];
  if (!count) return errors.length ? callback(new ValidationError(errors, value, path)) : callback(null, value);
  for (let i2 = 0; i2 < tests.length; i2++) {
    const test = tests[i2];
    test(args, function finishTestRun(err) {
      if (err) {
        if (!ValidationError.isError(err)) {
          return callback(err, value);
        }
        if (endEarly) {
          err.value = value;
          return callback(err, value);
        }
        nestedErrors.push(err);
      }
      if (--count <= 0) {
        if (nestedErrors.length) {
          if (sort) nestedErrors.sort(sort);
          if (errors.length) nestedErrors.push(...errors);
          errors = nestedErrors;
        }
        if (errors.length) {
          callback(new ValidationError(errors, value, path), value);
          return;
        }
        callback(null, value);
      }
    });
  }
}

// ../../../node_modules/yup/es/util/createValidation.js
var import_mapValues = __toESM(require_mapValues());

// ../../../node_modules/yup/es/Reference.js
var import_property_expr = __toESM(require_property_expr());
var prefixes = {
  context: "$",
  value: "."
};
var Reference = class {
  constructor(key, options2 = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== "string") throw new TypeError("ref must be a string, got: " + key);
    this.key = key.trim();
    if (key === "") throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix3 = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
    this.path = this.key.slice(prefix3.length);
    this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
    this.map = options2.map;
  }
  getValue(value, parent, context) {
    let result = this.isContext ? context : this.isValue ? value : parent;
    if (this.getter) result = this.getter(result || {});
    if (this.map) result = this.map(result);
    return result;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options2) {
    return this.getValue(value, options2 == null ? void 0 : options2.parent, options2 == null ? void 0 : options2.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
};
Reference.prototype.__isYupRef = true;

// ../../../node_modules/yup/es/util/createValidation.js
function _extends7() {
  _extends7 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends7.apply(this, arguments);
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function createValidation(config) {
  function validate(_ref, cb) {
    let {
      value,
      path = "",
      label,
      options: options2,
      originalValue,
      sync
    } = _ref, rest = _objectWithoutPropertiesLoose3(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);
    const {
      name,
      test,
      params,
      message: message2
    } = config;
    let {
      parent,
      context
    } = options2;
    function resolve(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError(overrides = {}) {
      const nextParams = (0, import_mapValues.default)(_extends7({
        value,
        originalValue,
        label,
        path: overrides.path || path
      }, params, overrides.params), resolve);
      const error2 = new ValidationError(ValidationError.formatError(overrides.message || message2, nextParams), value, nextParams.path, overrides.type || name);
      error2.params = nextParams;
      return error2;
    }
    let ctx = _extends7({
      path,
      parent,
      type: name,
      createError,
      resolve,
      options: options2,
      originalValue
    }, rest);
    if (!sync) {
      try {
        Promise.resolve(test.call(ctx, value, ctx)).then((validOrError) => {
          if (ValidationError.isError(validOrError)) cb(validOrError);
          else if (!validOrError) cb(createError());
          else cb(null, validOrError);
        }).catch(cb);
      } catch (err) {
        cb(err);
      }
      return;
    }
    let result;
    try {
      var _ref2;
      result = test.call(ctx, value, ctx);
      if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === "function") {
        throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
      }
    } catch (err) {
      cb(err);
      return;
    }
    if (ValidationError.isError(result)) cb(result);
    else if (!result) cb(createError());
    else cb(null, result);
  }
  validate.OPTIONS = config;
  return validate;
}

// ../../../node_modules/yup/es/util/reach.js
var import_property_expr2 = __toESM(require_property_expr());
var trim = (part) => part.substr(0, part.length - 1).substr(1);
function getIn2(schema2, path, value, context = value) {
  let parent, lastPart, lastPartDebug;
  if (!path) return {
    parent,
    parentPath: path,
    schema: schema2
  };
  (0, import_property_expr2.forEach)(path, (_part, isBracket, isArray2) => {
    let part = isBracket ? trim(_part) : _part;
    schema2 = schema2.resolve({
      context,
      parent,
      value
    });
    if (schema2.innerType) {
      let idx = isArray2 ? parseInt(part, 10) : 0;
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema2 = schema2.innerType;
    }
    if (!isArray2) {
      if (!schema2.fields || !schema2.fields[part]) throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema2._type}")`);
      parent = value;
      value = value && value[part];
      schema2 = schema2.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema: schema2,
    parent,
    parentPath: lastPart
  };
}

// ../../../node_modules/yup/es/util/ReferenceSet.js
var ReferenceSet = class _ReferenceSet {
  constructor() {
    this.list = void 0;
    this.refs = void 0;
    this.list = /* @__PURE__ */ new Set();
    this.refs = /* @__PURE__ */ new Map();
  }
  get size() {
    return this.list.size + this.refs.size;
  }
  describe() {
    const description = [];
    for (const item of this.list) description.push(item);
    for (const [, ref2] of this.refs) description.push(ref2.describe());
    return description;
  }
  toArray() {
    return Array.from(this.list).concat(Array.from(this.refs.values()));
  }
  resolveAll(resolve) {
    return this.toArray().reduce((acc, e2) => acc.concat(Reference.isRef(e2) ? resolve(e2) : e2), []);
  }
  add(value) {
    Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
  }
  delete(value) {
    Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
  }
  clone() {
    const next = new _ReferenceSet();
    next.list = new Set(this.list);
    next.refs = new Map(this.refs);
    return next;
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.list.forEach((value) => next.add(value));
    newItems.refs.forEach((value) => next.add(value));
    removeItems.list.forEach((value) => next.delete(value));
    removeItems.refs.forEach((value) => next.delete(value));
    return next;
  }
};

// ../../../node_modules/yup/es/schema.js
function _extends8() {
  _extends8 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends8.apply(this, arguments);
}
var BaseSchema = class {
  constructor(options2) {
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this._typeError = void 0;
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = /* @__PURE__ */ Object.create(null);
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = (options2 == null ? void 0 : options2.type) || "mixed";
    this.spec = _extends8({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      nullable: false,
      presence: "optional"
    }, options2 == null ? void 0 : options2.spec);
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  _typeCheck(_value) {
    return true;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec) Object.assign(this.spec, spec);
      return this;
    }
    const next = Object.create(Object.getPrototypeOf(this));
    next.type = this.type;
    next._typeError = this._typeError;
    next._whitelistError = this._whitelistError;
    next._blacklistError = this._blacklistError;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.exclusiveTests = _extends8({}, this.exclusiveTests);
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone2(_extends8({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0) return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  // withContext<TContext extends AnyObject>(): BaseSchema<
  //   TCast,
  //   TContext,
  //   TOutput
  // > {
  //   return this as any;
  // }
  withMutation(fn2) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn2(this);
    this._mutate = before;
    return result;
  }
  concat(schema2) {
    if (!schema2 || schema2 === this) return this;
    if (schema2.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema2.type}`);
    let base2 = this;
    let combined = schema2.clone();
    const mergedSpec = _extends8({}, base2.spec, combined.spec);
    combined.spec = mergedSpec;
    combined._typeError || (combined._typeError = base2._typeError);
    combined._whitelistError || (combined._whitelistError = base2._whitelistError);
    combined._blacklistError || (combined._blacklistError = base2._blacklistError);
    combined._whitelist = base2._whitelist.merge(schema2._whitelist, schema2._blacklist);
    combined._blacklist = base2._blacklist.merge(schema2._blacklist, schema2._whitelist);
    combined.tests = base2.tests;
    combined.exclusiveTests = base2.exclusiveTests;
    combined.withMutation((next) => {
      schema2.tests.forEach((fn2) => {
        next.test(fn2.OPTIONS);
      });
    });
    combined.transforms = [...base2.transforms, ...combined.transforms];
    return combined;
  }
  isType(v) {
    if (this.spec.nullable && v === null) return true;
    return this._typeCheck(v);
  }
  resolve(options2) {
    let schema2 = this;
    if (schema2.conditions.length) {
      let conditions = schema2.conditions;
      schema2 = schema2.clone();
      schema2.conditions = [];
      schema2 = conditions.reduce((schema3, condition) => condition.resolve(schema3, options2), schema2);
      schema2 = schema2.resolve(options2);
    }
    return schema2;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {*=} options.parent
   * @param {*=} options.context
   */
  cast(value, options2 = {}) {
    let resolvedSchema = this.resolve(_extends8({
      value
    }, options2));
    let result = resolvedSchema._cast(value, options2);
    if (value !== void 0 && options2.assert !== false && resolvedSchema.isType(result) !== true) {
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options2.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema._type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
    }
    return result;
  }
  _cast(rawValue, _options) {
    let value = rawValue === void 0 ? rawValue : this.transforms.reduce((value2, fn2) => fn2.call(this, value2, rawValue, this), rawValue);
    if (value === void 0) {
      value = this.getDefault();
    }
    return value;
  }
  _validate(_value, options2 = {}, cb) {
    let {
      sync,
      path,
      from: from2 = [],
      originalValue = _value,
      strict = this.spec.strict,
      abortEarly = this.spec.abortEarly
    } = options2;
    let value = _value;
    if (!strict) {
      value = this._cast(value, _extends8({
        assert: false
      }, options2));
    }
    let args = {
      value,
      path,
      options: options2,
      originalValue,
      schema: this,
      label: this.spec.label,
      sync,
      from: from2
    };
    let initialTests = [];
    if (this._typeError) initialTests.push(this._typeError);
    let finalTests = [];
    if (this._whitelistError) finalTests.push(this._whitelistError);
    if (this._blacklistError) finalTests.push(this._blacklistError);
    runTests({
      args,
      value,
      path,
      sync,
      tests: initialTests,
      endEarly: abortEarly
    }, (err) => {
      if (err) return void cb(err, value);
      runTests({
        tests: this.tests.concat(finalTests),
        args,
        path,
        sync,
        value,
        endEarly: abortEarly
      }, cb);
    });
  }
  validate(value, options2, maybeCb) {
    let schema2 = this.resolve(_extends8({}, options2, {
      value
    }));
    return typeof maybeCb === "function" ? schema2._validate(value, options2, maybeCb) : new Promise((resolve, reject) => schema2._validate(value, options2, (err, value2) => {
      if (err) reject(err);
      else resolve(value2);
    }));
  }
  validateSync(value, options2) {
    let schema2 = this.resolve(_extends8({}, options2, {
      value
    }));
    let result;
    schema2._validate(value, _extends8({}, options2, {
      sync: true
    }), (err, value2) => {
      if (err) throw err;
      result = value2;
    });
    return result;
  }
  isValid(value, options2) {
    return this.validate(value, options2).then(() => true, (err) => {
      if (ValidationError.isError(err)) return false;
      throw err;
    });
  }
  isValidSync(value, options2) {
    try {
      this.validateSync(value, options2);
      return true;
    } catch (err) {
      if (ValidationError.isError(err)) return false;
      throw err;
    }
  }
  _getDefault() {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === "function" ? defaultValue.call(this) : clone2(defaultValue);
  }
  getDefault(options2) {
    let schema2 = this.resolve(options2 || {});
    return schema2._getDefault();
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def
    });
    return next;
  }
  strict(isStrict = true) {
    let next = this.clone();
    next.spec.strict = isStrict;
    return next;
  }
  _isPresent(value) {
    return value != null;
  }
  defined(message2 = mixed.defined) {
    return this.test({
      message: message2,
      name: "defined",
      exclusive: true,
      test(value) {
        return value !== void 0;
      }
    });
  }
  required(message2 = mixed.required) {
    return this.clone({
      presence: "required"
    }).withMutation((s2) => s2.test({
      message: message2,
      name: "required",
      exclusive: true,
      test(value) {
        return this.schema._isPresent(value);
      }
    }));
  }
  notRequired() {
    let next = this.clone({
      presence: "optional"
    });
    next.tests = next.tests.filter((test) => test.OPTIONS.name !== "required");
    return next;
  }
  nullable(isNullable = true) {
    let next = this.clone({
      nullable: isNullable !== false
    });
    return next;
  }
  transform(fn2) {
    let next = this.clone();
    next.transforms.push(fn2);
    return next;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === "function") {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === void 0) opts.message = mixed.default;
    if (typeof opts.test !== "function") throw new TypeError("`test` is a required parameters");
    let next = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    }
    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter((fn2) => {
      if (fn2.OPTIONS.name === opts.name) {
        if (isExclusive) return false;
        if (fn2.OPTIONS.test === validate.OPTIONS.test) return false;
      }
      return true;
    });
    next.tests.push(validate);
    return next;
  }
  when(keys2, options2) {
    if (!Array.isArray(keys2) && typeof keys2 !== "string") {
      options2 = keys2;
      keys2 = ".";
    }
    let next = this.clone();
    let deps = toArray(keys2).map((key) => new Reference(key));
    deps.forEach((dep) => {
      if (dep.isSibling) next.deps.push(dep.key);
    });
    next.conditions.push(new Condition_default(deps, options2));
    return next;
  }
  typeError(message2) {
    let next = this.clone();
    next._typeError = createValidation({
      message: message2,
      name: "typeError",
      test(value) {
        if (value !== void 0 && !this.schema.isType(value)) return this.createError({
          params: {
            type: this.schema._type
          }
        });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message2 = mixed.oneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next._whitelistError = createValidation({
      message: message2,
      name: "oneOf",
      test(value) {
        if (value === void 0) return true;
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: valids.toArray().join(", "),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message2 = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next._blacklistError = createValidation({
      message: message2,
      name: "notOneOf",
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value)) return this.createError({
          params: {
            values: invalids.toArray().join(", "),
            resolved
          }
        });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }
  describe() {
    const next = this.clone();
    const {
      label,
      meta
    } = next.spec;
    const description = {
      meta,
      label,
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.map((fn2) => ({
        name: fn2.OPTIONS.name,
        params: fn2.OPTIONS.params
      })).filter((n2, idx, list) => list.findIndex((c5) => c5.name === n2.name) === idx)
    };
    return description;
  }
};
BaseSchema.prototype.__isYupSchema__ = true;
for (const method of ["validate", "validateSync"]) BaseSchema.prototype[`${method}At`] = function(path, value, options2 = {}) {
  const {
    parent,
    parentPath,
    schema: schema2
  } = getIn2(this, path, value, options2.context);
  return schema2[method](parent && parent[parentPath], _extends8({}, options2, {
    parent,
    path
  }));
};
for (const alias of ["equals", "is"]) BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;
for (const alias of ["not", "nope"]) BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;
BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;

// ../../../node_modules/yup/es/mixed.js
var Mixed = BaseSchema;
function create() {
  return new Mixed();
}
create.prototype = Mixed.prototype;

// ../../../node_modules/yup/es/util/isAbsent.js
var isAbsent = (value) => value == null;
var isAbsent_default = isAbsent;

// ../../../node_modules/yup/es/boolean.js
function create2() {
  return new BooleanSchema();
}
var BooleanSchema = class extends BaseSchema {
  constructor() {
    super({
      type: "boolean"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (!this.isType(value)) {
          if (/^(true|1)$/i.test(String(value))) return true;
          if (/^(false|0)$/i.test(String(value))) return false;
        }
        return value;
      });
    });
  }
  _typeCheck(v) {
    if (v instanceof Boolean) v = v.valueOf();
    return typeof v === "boolean";
  }
  isTrue(message2 = boolean.isValue) {
    return this.test({
      message: message2,
      name: "is-value",
      exclusive: true,
      params: {
        value: "true"
      },
      test(value) {
        return isAbsent_default(value) || value === true;
      }
    });
  }
  isFalse(message2 = boolean.isValue) {
    return this.test({
      message: message2,
      name: "is-value",
      exclusive: true,
      params: {
        value: "false"
      },
      test(value) {
        return isAbsent_default(value) || value === false;
      }
    });
  }
};
create2.prototype = BooleanSchema.prototype;

// ../../../node_modules/yup/es/string.js
var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
var isTrimmed = (value) => isAbsent_default(value) || value === value.trim();
var objStringTag = {}.toString();
function create3() {
  return new StringSchema();
}
var StringSchema = class extends BaseSchema {
  constructor() {
    super({
      type: "string"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (this.isType(value)) return value;
        if (Array.isArray(value)) return value;
        const strValue = value != null && value.toString ? value.toString() : value;
        if (strValue === objStringTag) return value;
        return strValue;
      });
    });
  }
  _typeCheck(value) {
    if (value instanceof String) value = value.valueOf();
    return typeof value === "string";
  }
  _isPresent(value) {
    return super._isPresent(value) && !!value.length;
  }
  length(length, message2 = string.length) {
    return this.test({
      message: message2,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      test(value) {
        return isAbsent_default(value) || value.length === this.resolve(length);
      }
    });
  }
  min(min3, message2 = string.min) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min3
      },
      test(value) {
        return isAbsent_default(value) || value.length >= this.resolve(min3);
      }
    });
  }
  max(max3, message2 = string.max) {
    return this.test({
      name: "max",
      exclusive: true,
      message: message2,
      params: {
        max: max3
      },
      test(value) {
        return isAbsent_default(value) || value.length <= this.resolve(max3);
      }
    });
  }
  matches(regex, options2) {
    let excludeEmptyString = false;
    let message2;
    let name;
    if (options2) {
      if (typeof options2 === "object") {
        ({
          excludeEmptyString = false,
          message: message2,
          name
        } = options2);
      } else {
        message2 = options2;
      }
    }
    return this.test({
      name: name || "matches",
      message: message2 || string.matches,
      params: {
        regex
      },
      test: (value) => isAbsent_default(value) || value === "" && excludeEmptyString || value.search(regex) !== -1
    });
  }
  email(message2 = string.email) {
    return this.matches(rEmail, {
      name: "email",
      message: message2,
      excludeEmptyString: true
    });
  }
  url(message2 = string.url) {
    return this.matches(rUrl, {
      name: "url",
      message: message2,
      excludeEmptyString: true
    });
  }
  uuid(message2 = string.uuid) {
    return this.matches(rUUID, {
      name: "uuid",
      message: message2,
      excludeEmptyString: false
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((val) => val === null ? "" : val);
  }
  trim(message2 = string.trim) {
    return this.transform((val) => val != null ? val.trim() : val).test({
      message: message2,
      name: "trim",
      test: isTrimmed
    });
  }
  lowercase(message2 = string.lowercase) {
    return this.transform((value) => !isAbsent_default(value) ? value.toLowerCase() : value).test({
      message: message2,
      name: "string_case",
      exclusive: true,
      test: (value) => isAbsent_default(value) || value === value.toLowerCase()
    });
  }
  uppercase(message2 = string.uppercase) {
    return this.transform((value) => !isAbsent_default(value) ? value.toUpperCase() : value).test({
      message: message2,
      name: "string_case",
      exclusive: true,
      test: (value) => isAbsent_default(value) || value === value.toUpperCase()
    });
  }
};
create3.prototype = StringSchema.prototype;

// ../../../node_modules/yup/es/number.js
var isNaN2 = (value) => value != +value;
function create4() {
  return new NumberSchema();
}
var NumberSchema = class extends BaseSchema {
  constructor() {
    super({
      type: "number"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        let parsed = value;
        if (typeof parsed === "string") {
          parsed = parsed.replace(/\s/g, "");
          if (parsed === "") return NaN;
          parsed = +parsed;
        }
        if (this.isType(parsed)) return parsed;
        return parseFloat(parsed);
      });
    });
  }
  _typeCheck(value) {
    if (value instanceof Number) value = value.valueOf();
    return typeof value === "number" && !isNaN2(value);
  }
  min(min3, message2 = number.min) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min3
      },
      test(value) {
        return isAbsent_default(value) || value >= this.resolve(min3);
      }
    });
  }
  max(max3, message2 = number.max) {
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max3
      },
      test(value) {
        return isAbsent_default(value) || value <= this.resolve(max3);
      }
    });
  }
  lessThan(less, message2 = number.lessThan) {
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        less
      },
      test(value) {
        return isAbsent_default(value) || value < this.resolve(less);
      }
    });
  }
  moreThan(more, message2 = number.moreThan) {
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        more
      },
      test(value) {
        return isAbsent_default(value) || value > this.resolve(more);
      }
    });
  }
  positive(msg = number.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number.negative) {
    return this.lessThan(0, msg);
  }
  integer(message2 = number.integer) {
    return this.test({
      name: "integer",
      message: message2,
      test: (val) => isAbsent_default(val) || Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform((value) => !isAbsent_default(value) ? value | 0 : value);
  }
  round(method) {
    var _method;
    let avail = ["ceil", "floor", "round", "trunc"];
    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
    if (method === "trunc") return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError("Only valid options for round() are: " + avail.join(", "));
    return this.transform((value) => !isAbsent_default(value) ? Math[method](value) : value);
  }
};
create4.prototype = NumberSchema.prototype;

// ../../../node_modules/yup/es/util/isodate.js
var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
function parseIsoDate(date2) {
  var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
  if (struct = isoReg.exec(date2)) {
    for (var i2 = 0, k2; k2 = numericKeys[i2]; ++i2) struct[k2] = +struct[k2] || 0;
    struct[2] = (+struct[2] || 1) - 1;
    struct[3] = +struct[3] || 1;
    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
    if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === "")) timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
    else {
      if (struct[8] !== "Z" && struct[9] !== void 0) {
        minutesOffset = struct[10] * 60 + struct[11];
        if (struct[9] === "+") minutesOffset = 0 - minutesOffset;
      }
      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
    }
  } else timestamp = Date.parse ? Date.parse(date2) : NaN;
  return timestamp;
}

// ../../../node_modules/yup/es/date.js
var invalidDate = /* @__PURE__ */ new Date("");
var isDate2 = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
function create5() {
  return new DateSchema();
}
var DateSchema = class extends BaseSchema {
  constructor() {
    super({
      type: "date"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (this.isType(value)) return value;
        value = parseIsoDate(value);
        return !isNaN(value) ? new Date(value) : invalidDate;
      });
    });
  }
  _typeCheck(v) {
    return isDate2(v) && !isNaN(v.getTime());
  }
  prepareParam(ref2, name) {
    let param;
    if (!Reference.isRef(ref2)) {
      let cast = this.cast(ref2);
      if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast;
    } else {
      param = ref2;
    }
    return param;
  }
  min(min3, message2 = date.min) {
    let limit = this.prepareParam(min3, "min");
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min3
      },
      test(value) {
        return isAbsent_default(value) || value >= this.resolve(limit);
      }
    });
  }
  max(max3, message2 = date.max) {
    let limit = this.prepareParam(max3, "max");
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max3
      },
      test(value) {
        return isAbsent_default(value) || value <= this.resolve(limit);
      }
    });
  }
};
DateSchema.INVALID_DATE = invalidDate;
create5.prototype = DateSchema.prototype;
create5.INVALID_DATE = invalidDate;

// ../../../node_modules/yup/es/object.js
var import_has3 = __toESM(require_has());
var import_snakeCase = __toESM(require_snakeCase());
var import_camelCase = __toESM(require_camelCase());
var import_mapKeys = __toESM(require_mapKeys());
var import_mapValues2 = __toESM(require_mapValues());
var import_property_expr4 = __toESM(require_property_expr());

// ../../../node_modules/yup/es/util/sortFields.js
var import_has2 = __toESM(require_has());
var import_toposort = __toESM(require_toposort());
var import_property_expr3 = __toESM(require_property_expr());
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = /* @__PURE__ */ new Set();
  let excludes = new Set(excludedEdges.map(([a2, b2]) => `${a2}-${b2}`));
  function addNode2(depPath, key) {
    let node = (0, import_property_expr3.split)(depPath)[0];
    nodes.add(node);
    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
  }
  for (const key in fields) if ((0, import_has2.default)(fields, key)) {
    let value = fields[key];
    nodes.add(key);
    if (Reference.isRef(value) && value.isSibling) addNode2(value.path, key);
    else if (isSchema_default(value) && "deps" in value) value.deps.forEach((path) => addNode2(path, key));
  }
  return import_toposort.default.array(Array.from(nodes), edges).reverse();
}

// ../../../node_modules/yup/es/util/sortByKeyOrder.js
function findIndex2(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys2) {
  return (a2, b2) => {
    return findIndex2(keys2, a2) - findIndex2(keys2, b2);
  };
}

// ../../../node_modules/yup/es/object.js
function _extends9() {
  _extends9 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends9.apply(this, arguments);
}
var isObject3 = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
var defaultSort = sortByKeyOrder([]);
var ObjectSchema = class extends BaseSchema {
  constructor(spec) {
    super({
      type: "object"
    });
    this.fields = /* @__PURE__ */ Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      this.transform(function coerce(value) {
        if (typeof value === "string") {
          try {
            value = JSON.parse(value);
          } catch (err) {
            value = null;
          }
        }
        if (this.isType(value)) return value;
        return null;
      });
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _typeCheck(value) {
    return isObject3(value) || typeof value === "function";
  }
  _cast(_value, options2 = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options2);
    if (value === void 0) return this.getDefault();
    if (!this._typeCheck(value)) return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options2.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = this._nodes.concat(Object.keys(value).filter((v) => this._nodes.indexOf(v) === -1));
    let intermediateValue = {};
    let innerOptions = _extends9({}, options2, {
      parent: intermediateValue,
      __validating: options2.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = (0, import_has3.default)(value, prop);
      if (field) {
        let fieldValue;
        let inputValue = value[prop];
        innerOptions.path = (options2.path ? `${options2.path}.` : "") + prop;
        field = field.resolve({
          value: inputValue,
          context: options2.context,
          parent: intermediateValue
        });
        let fieldSpec = "spec" in field ? field.spec : void 0;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec == null ? void 0 : fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options2.__validating || !strict ? (
          // TODO: use _cast, this is double resolving
          field.cast(value[prop], innerOptions)
        ) : value[prop];
        if (fieldValue !== void 0) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, opts = {}, callback) {
    let errors = [];
    let {
      sync,
      from: from2 = [],
      originalValue = _value,
      abortEarly = this.spec.abortEarly,
      recursive = this.spec.recursive
    } = opts;
    from2 = [{
      schema: this,
      value: originalValue
    }, ...from2];
    opts.__validating = true;
    opts.originalValue = originalValue;
    opts.from = from2;
    super._validate(_value, opts, (err, value) => {
      if (err) {
        if (!ValidationError.isError(err) || abortEarly) {
          return void callback(err, value);
        }
        errors.push(err);
      }
      if (!recursive || !isObject3(value)) {
        callback(errors[0] || null, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = this._nodes.map((key) => (_, cb) => {
        let path = key.indexOf(".") === -1 ? (opts.path ? `${opts.path}.` : "") + key : `${opts.path || ""}["${key}"]`;
        let field = this.fields[key];
        if (field && "validate" in field) {
          field.validate(value[key], _extends9({}, opts, {
            // @ts-ignore
            path,
            from: from2,
            // inner fields are always strict:
            // 1. this isn't strict so the casting will also have cast inner values
            // 2. this is strict in which case the nested values weren't cast either
            strict: true,
            parent: value,
            originalValue: originalValue[key]
          }), cb);
          return;
        }
        cb(null);
      });
      runTests({
        sync,
        tests,
        value,
        errors,
        endEarly: abortEarly,
        sort: this._sortErrors,
        path: opts.path
      }, callback);
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = _extends9({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema2) {
    let next = super.concat(schema2);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      if (target === void 0) {
        nextFields[field] = schemaOrRef;
      } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
        nextFields[field] = schemaOrRef.concat(target);
      }
    }
    return next.withMutation(() => next.shape(nextFields, this._excludedEdges));
  }
  getDefaultFromShape() {
    let dft = {};
    this._nodes.forEach((key) => {
      const field = this.fields[key];
      dft[key] = "default" in field ? field.getDefault() : void 0;
    });
    return dft;
  }
  _getDefault() {
    if ("default" in this.spec) {
      return super._getDefault();
    }
    if (!this._nodes.length) {
      return void 0;
    }
    return this.getDefaultFromShape();
  }
  shape(additions, excludes = []) {
    let next = this.clone();
    let fields = Object.assign(next.fields, additions);
    next.fields = fields;
    next._sortErrors = sortByKeyOrder(Object.keys(fields));
    if (excludes.length) {
      if (!Array.isArray(excludes[0])) excludes = [excludes];
      next._excludedEdges = [...next._excludedEdges, ...excludes];
    }
    next._nodes = sortFields(fields, next._excludedEdges);
    return next;
  }
  pick(keys2) {
    const picked = {};
    for (const key of keys2) {
      if (this.fields[key]) picked[key] = this.fields[key];
    }
    return this.clone().withMutation((next) => {
      next.fields = {};
      return next.shape(picked);
    });
  }
  omit(keys2) {
    const next = this.clone();
    const fields = next.fields;
    next.fields = {};
    for (const key of keys2) {
      delete fields[key];
    }
    return next.withMutation(() => next.shape(fields));
  }
  from(from2, to, alias) {
    let fromGetter = (0, import_property_expr4.getter)(from2, true);
    return this.transform((obj) => {
      if (obj == null) return obj;
      let newObj = obj;
      if ((0, import_has3.default)(obj, from2)) {
        newObj = _extends9({}, obj);
        if (!alias) delete newObj[from2];
        newObj[to] = fromGetter(obj);
      }
      return newObj;
    });
  }
  noUnknown(noAllow = true, message2 = object.noUnknown) {
    if (typeof noAllow === "string") {
      message2 = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: "noUnknown",
      exclusive: true,
      message: message2,
      test(value) {
        if (value == null) return true;
        const unknownKeys = unknown(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(", ")
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message2 = object.noUnknown) {
    return this.noUnknown(!allow, message2);
  }
  transformKeys(fn2) {
    return this.transform((obj) => obj && (0, import_mapKeys.default)(obj, (_, key) => fn2(key)));
  }
  camelCase() {
    return this.transformKeys(import_camelCase.default);
  }
  snakeCase() {
    return this.transformKeys(import_snakeCase.default);
  }
  constantCase() {
    return this.transformKeys((key) => (0, import_snakeCase.default)(key).toUpperCase());
  }
  describe() {
    let base2 = super.describe();
    base2.fields = (0, import_mapValues2.default)(this.fields, (value) => value.describe());
    return base2;
  }
};
function create6(spec) {
  return new ObjectSchema(spec);
}
create6.prototype = ObjectSchema.prototype;

// ../../../node_modules/yup/es/array.js
function _extends10() {
  _extends10 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends10.apply(this, arguments);
}
function create7(type) {
  return new ArraySchema(type);
}
var ArraySchema = class extends BaseSchema {
  constructor(type) {
    super({
      type: "array"
    });
    this.innerType = void 0;
    this.innerType = type;
    this.withMutation(() => {
      this.transform(function(values) {
        if (typeof values === "string") try {
          values = JSON.parse(values);
        } catch (err) {
          values = null;
        }
        return this.isType(values) ? values : null;
      });
    });
  }
  _typeCheck(v) {
    return Array.isArray(v);
  }
  get _subType() {
    return this.innerType;
  }
  _cast(_value, _opts) {
    const value = super._cast(_value, _opts);
    if (!this._typeCheck(value) || !this.innerType) return value;
    let isChanged = false;
    const castArray = value.map((v, idx) => {
      const castElement = this.innerType.cast(v, _extends10({}, _opts, {
        path: `${_opts.path || ""}[${idx}]`
      }));
      if (castElement !== v) {
        isChanged = true;
      }
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options2 = {}, callback) {
    var _options$abortEarly, _options$recursive;
    let errors = [];
    let sync = options2.sync;
    let path = options2.path;
    let innerType = this.innerType;
    let endEarly = (_options$abortEarly = options2.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
    let recursive = (_options$recursive = options2.recursive) != null ? _options$recursive : this.spec.recursive;
    let originalValue = options2.originalValue != null ? options2.originalValue : _value;
    super._validate(_value, options2, (err, value) => {
      if (err) {
        if (!ValidationError.isError(err) || endEarly) {
          return void callback(err, value);
        }
        errors.push(err);
      }
      if (!recursive || !innerType || !this._typeCheck(value)) {
        callback(errors[0] || null, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = new Array(value.length);
      for (let idx = 0; idx < value.length; idx++) {
        let item = value[idx];
        let path2 = `${options2.path || ""}[${idx}]`;
        let innerOptions = _extends10({}, options2, {
          path: path2,
          strict: true,
          parent: value,
          index: idx,
          originalValue: originalValue[idx]
        });
        tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);
      }
      runTests({
        sync,
        path,
        value,
        errors,
        endEarly,
        tests
      }, callback);
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.innerType = this.innerType;
    return next;
  }
  concat(schema2) {
    let next = super.concat(schema2);
    next.innerType = this.innerType;
    if (schema2.innerType) next.innerType = next.innerType ? (
      // @ts-expect-error Lazy doesn't have concat()
      next.innerType.concat(schema2.innerType)
    ) : schema2.innerType;
    return next;
  }
  of(schema2) {
    let next = this.clone();
    if (!isSchema_default(schema2)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema2));
    next.innerType = schema2;
    return next;
  }
  length(length, message2 = array.length) {
    return this.test({
      message: message2,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      test(value) {
        return isAbsent_default(value) || value.length === this.resolve(length);
      }
    });
  }
  min(min3, message2) {
    message2 = message2 || array.min;
    return this.test({
      message: message2,
      name: "min",
      exclusive: true,
      params: {
        min: min3
      },
      // FIXME(ts): Array<typeof T>
      test(value) {
        return isAbsent_default(value) || value.length >= this.resolve(min3);
      }
    });
  }
  max(max3, message2) {
    message2 = message2 || array.max;
    return this.test({
      message: message2,
      name: "max",
      exclusive: true,
      params: {
        max: max3
      },
      test(value) {
        return isAbsent_default(value) || value.length <= this.resolve(max3);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((val, original) => {
      if (this._typeCheck(val)) return val;
      return original == null ? [] : [].concat(original);
    });
  }
  compact(rejector) {
    let reject = !rejector ? (v) => !!v : (v, i2, a2) => !rejector(v, i2, a2);
    return this.transform((values) => values != null ? values.filter(reject) : values);
  }
  describe() {
    let base2 = super.describe();
    if (this.innerType) base2.innerType = this.innerType.describe();
    return base2;
  }
  nullable(isNullable = true) {
    return super.nullable(isNullable);
  }
  defined() {
    return super.defined();
  }
  required(msg) {
    return super.required(msg);
  }
};
create7.prototype = ArraySchema.prototype;

// ../../../node_modules/yup/es/index.js
function addMethod(schemaType, name, fn2) {
  if (!schemaType || !isSchema_default(schemaType.prototype)) throw new TypeError("You must provide a yup schema constructor function");
  if (typeof name !== "string") throw new TypeError("A Method name must be provided");
  if (typeof fn2 !== "function") throw new TypeError("Method function must be provided");
  schemaType.prototype[name] = fn2;
}

// ../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized2(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}

// ../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}

// ../../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose2(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
}

// ../../../node_modules/react-window/node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first2, second) {
  if (first2 === second) {
    return true;
  }
  if (safeIsNaN(first2) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual4) {
  if (isEqual4 === void 0) {
    isEqual4 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual4(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var memoize_one_esm_default = memoizeOne;

// ../../../node_modules/react-window/dist/index.esm.js
var import_react4 = __toESM(require_react());
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now = hasNativePerformanceNow ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  var start3 = now();
  function tick() {
    if (now() - start3 >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }
  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}
var size = -1;
function getScrollbarSize(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (size === -1 || recalculate) {
    var div2 = document.createElement("div");
    var style3 = div2.style;
    style3.width = "50px";
    style3.height = "50px";
    style3.overflow = "scroll";
    document.body.appendChild(div2);
    size = div2.offsetWidth - div2.clientWidth;
    document.body.removeChild(div2);
  }
  return size;
}
var cachedRTLResult = null;
function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement("div");
    var outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    var innerDiv = document.createElement("div");
    var innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
var IS_SCROLLING_DEBOUNCE_INTERVAL = 150;
var defaultItemKey = function defaultItemKey2(_ref) {
  var columnIndex = _ref.columnIndex, data = _ref.data, rowIndex = _ref.rowIndex;
  return rowIndex + ":" + columnIndex;
};
var devWarningsOverscanCount = null;
var devWarningsOverscanRowsColumnsCount = null;
var devWarningsTagName = null;
if (true) {
  if (typeof window !== "undefined" && typeof window.WeakSet !== "undefined") {
    devWarningsOverscanCount = /* @__PURE__ */ new WeakSet();
    devWarningsOverscanRowsColumnsCount = /* @__PURE__ */ new WeakSet();
    devWarningsTagName = /* @__PURE__ */ new WeakSet();
  }
}
function createGridComponent(_ref2) {
  var _class;
  var getColumnOffset3 = _ref2.getColumnOffset, getColumnStartIndexForOffset3 = _ref2.getColumnStartIndexForOffset, getColumnStopIndexForStartIndex3 = _ref2.getColumnStopIndexForStartIndex, getColumnWidth3 = _ref2.getColumnWidth, getEstimatedTotalHeight4 = _ref2.getEstimatedTotalHeight, getEstimatedTotalWidth4 = _ref2.getEstimatedTotalWidth, getOffsetForColumnAndAlignment3 = _ref2.getOffsetForColumnAndAlignment, getOffsetForRowAndAlignment3 = _ref2.getOffsetForRowAndAlignment, getRowHeight4 = _ref2.getRowHeight, getRowOffset3 = _ref2.getRowOffset, getRowStartIndexForOffset3 = _ref2.getRowStartIndexForOffset, getRowStopIndexForStartIndex3 = _ref2.getRowStopIndexForStartIndex, initInstanceProps5 = _ref2.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange, validateProps6 = _ref2.validateProps;
  return _class = function(_PureComponent) {
    _inheritsLoose2(Grid, _PureComponent);
    function Grid(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps5(_this.props, _assertThisInitialized2(_this));
      _this._resetIsScrollingTimeoutId = null;
      _this._outerRef = void 0;
      _this.state = {
        instance: _assertThisInitialized2(_this),
        isScrolling: false,
        horizontalScrollDirection: "forward",
        scrollLeft: typeof _this.props.initialScrollLeft === "number" ? _this.props.initialScrollLeft : 0,
        scrollTop: typeof _this.props.initialScrollTop === "number" ? _this.props.initialScrollTop : 0,
        scrollUpdateWasRequested: false,
        verticalScrollDirection: "forward"
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = memoize_one_esm_default(function(overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {
        return _this.props.onItemsRendered({
          overscanColumnStartIndex,
          overscanColumnStopIndex,
          overscanRowStartIndex,
          overscanRowStopIndex,
          visibleColumnStartIndex,
          visibleColumnStopIndex,
          visibleRowStartIndex,
          visibleRowStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = memoize_one_esm_default(function(scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          horizontalScrollDirection,
          scrollLeft,
          scrollTop,
          verticalScrollDirection,
          scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;
      _this._getItemStyle = function(rowIndex, columnIndex) {
        var _this$props = _this.props, columnWidth = _this$props.columnWidth, direction2 = _this$props.direction, rowHeight = _this$props.rowHeight;
        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction2, shouldResetStyleCacheOnItemSizeChange && rowHeight);
        var key = rowIndex + ":" + columnIndex;
        var style3;
        if (itemStyleCache.hasOwnProperty(key)) {
          style3 = itemStyleCache[key];
        } else {
          var _offset = getColumnOffset3(_this.props, columnIndex, _this._instanceProps);
          var isRtl = direction2 === "rtl";
          itemStyleCache[key] = style3 = {
            position: "absolute",
            left: isRtl ? void 0 : _offset,
            right: isRtl ? _offset : void 0,
            top: getRowOffset3(_this.props, rowIndex, _this._instanceProps),
            height: getRowHeight4(_this.props, rowIndex, _this._instanceProps),
            width: getColumnWidth3(_this.props, columnIndex, _this._instanceProps)
          };
        }
        return style3;
      };
      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = memoize_one_esm_default(function(_, __, ___) {
        return {};
      });
      _this._onScroll = function(event) {
        var _event$currentTarget = event.currentTarget, clientHeight = _event$currentTarget.clientHeight, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollTop = _event$currentTarget.scrollTop, scrollHeight = _event$currentTarget.scrollHeight, scrollWidth = _event$currentTarget.scrollWidth;
        _this.setState(function(prevState) {
          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {
            return null;
          }
          var direction2 = _this.props.direction;
          var calculatedScrollLeft = scrollLeft;
          if (direction2 === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                calculatedScrollLeft = -scrollLeft;
                break;
              case "positive-descending":
                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));
          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? "forward" : "backward",
            scrollLeft: calculatedScrollLeft,
            scrollTop: calculatedScrollTop,
            verticalScrollDirection: prevState.scrollTop < scrollTop ? "forward" : "backward",
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._outerRefSetter = function(ref2) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref2;
        if (typeof outerRef === "function") {
          outerRef(ref2);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref2;
        }
      };
      _this._resetIsScrollingDebounced = function() {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }
        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);
      };
      _this._resetIsScrolling = function() {
        _this._resetIsScrollingTimeoutId = null;
        _this.setState({
          isScrolling: false
        }, function() {
          _this._getItemStyleCache(-1);
        });
      };
      return _this;
    }
    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps(nextProps, prevState);
      validateProps6(nextProps);
      return null;
    };
    var _proto = Grid.prototype;
    _proto.scrollTo = function scrollTo(_ref3) {
      var scrollLeft = _ref3.scrollLeft, scrollTop = _ref3.scrollTop;
      if (scrollLeft !== void 0) {
        scrollLeft = Math.max(0, scrollLeft);
      }
      if (scrollTop !== void 0) {
        scrollTop = Math.max(0, scrollTop);
      }
      this.setState(function(prevState) {
        if (scrollLeft === void 0) {
          scrollLeft = prevState.scrollLeft;
        }
        if (scrollTop === void 0) {
          scrollTop = prevState.scrollTop;
        }
        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {
          return null;
        }
        return {
          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? "forward" : "backward",
          scrollLeft,
          scrollTop,
          scrollUpdateWasRequested: true,
          verticalScrollDirection: prevState.scrollTop < scrollTop ? "forward" : "backward"
        };
      }, this._resetIsScrollingDebounced);
    };
    _proto.scrollToItem = function scrollToItem(_ref4) {
      var _ref4$align = _ref4.align, align = _ref4$align === void 0 ? "auto" : _ref4$align, columnIndex = _ref4.columnIndex, rowIndex = _ref4.rowIndex;
      var _this$props2 = this.props, columnCount = _this$props2.columnCount, height = _this$props2.height, rowCount = _this$props2.rowCount, width = _this$props2.width;
      var _this$state = this.state, scrollLeft = _this$state.scrollLeft, scrollTop = _this$state.scrollTop;
      var scrollbarSize = getScrollbarSize();
      if (columnIndex !== void 0) {
        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));
      }
      if (rowIndex !== void 0) {
        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));
      }
      var estimatedTotalHeight = getEstimatedTotalHeight4(this.props, this._instanceProps);
      var estimatedTotalWidth = getEstimatedTotalWidth4(this.props, this._instanceProps);
      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;
      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;
      this.scrollTo({
        scrollLeft: columnIndex !== void 0 ? getOffsetForColumnAndAlignment3(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,
        scrollTop: rowIndex !== void 0 ? getOffsetForRowAndAlignment3(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop
      });
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props, initialScrollLeft = _this$props3.initialScrollLeft, initialScrollTop = _this$props3.initialScrollTop;
      if (this._outerRef != null) {
        var outerRef = this._outerRef;
        if (typeof initialScrollLeft === "number") {
          outerRef.scrollLeft = initialScrollLeft;
        }
        if (typeof initialScrollTop === "number") {
          outerRef.scrollTop = initialScrollTop;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      var direction2 = this.props.direction;
      var _this$state2 = this.state, scrollLeft = _this$state2.scrollLeft, scrollTop = _this$state2.scrollTop, scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction2 === "rtl") {
          switch (getRTLOffsetType()) {
            case "negative":
              outerRef.scrollLeft = -scrollLeft;
              break;
            case "positive-ascending":
              outerRef.scrollLeft = scrollLeft;
              break;
            default:
              var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;
              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;
              break;
          }
        } else {
          outerRef.scrollLeft = Math.max(0, scrollLeft);
        }
        outerRef.scrollTop = Math.max(0, scrollTop);
      }
      this._callPropsCallbacks();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };
    _proto.render = function render2() {
      var _this$props4 = this.props, children = _this$props4.children, className = _this$props4.className, columnCount = _this$props4.columnCount, direction2 = _this$props4.direction, height = _this$props4.height, innerRef = _this$props4.innerRef, innerElementType2 = _this$props4.innerElementType, innerTagName = _this$props4.innerTagName, itemData = _this$props4.itemData, _this$props4$itemKey = _this$props4.itemKey, itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey, outerElementType = _this$props4.outerElementType, outerTagName = _this$props4.outerTagName, rowCount = _this$props4.rowCount, style3 = _this$props4.style, useIsScrolling = _this$props4.useIsScrolling, width = _this$props4.width;
      var isScrolling = this.state.isScrolling;
      var _this$_getHorizontalR = this._getHorizontalRangeToRender(), columnStartIndex = _this$_getHorizontalR[0], columnStopIndex = _this$_getHorizontalR[1];
      var _this$_getVerticalRan = this._getVerticalRangeToRender(), rowStartIndex = _this$_getVerticalRan[0], rowStopIndex = _this$_getVerticalRan[1];
      var items2 = [];
      if (columnCount > 0 && rowCount) {
        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {
          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {
            items2.push((0, import_react4.createElement)(children, {
              columnIndex: _columnIndex,
              data: itemData,
              isScrolling: useIsScrolling ? isScrolling : void 0,
              key: itemKey({
                columnIndex: _columnIndex,
                data: itemData,
                rowIndex: _rowIndex
              }),
              rowIndex: _rowIndex,
              style: this._getItemStyle(_rowIndex, _columnIndex)
            }));
          }
        }
      }
      var estimatedTotalHeight = getEstimatedTotalHeight4(this.props, this._instanceProps);
      var estimatedTotalWidth = getEstimatedTotalWidth4(this.props, this._instanceProps);
      return (0, import_react4.createElement)(outerElementType || outerTagName || "div", {
        className,
        onScroll: this._onScroll,
        ref: this._outerRefSetter,
        style: _extends({
          position: "relative",
          height,
          width,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction: direction2
        }, style3)
      }, (0, import_react4.createElement)(innerElementType2 || innerTagName || "div", {
        children: items2,
        ref: innerRef,
        style: {
          height: estimatedTotalHeight,
          pointerEvents: isScrolling ? "none" : void 0,
          width: estimatedTotalWidth
        }
      }));
    };
    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      var _this$props5 = this.props, columnCount = _this$props5.columnCount, onItemsRendered = _this$props5.onItemsRendered, onScroll = _this$props5.onScroll, rowCount = _this$props5.rowCount;
      if (typeof onItemsRendered === "function") {
        if (columnCount > 0 && rowCount > 0) {
          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(), _overscanColumnStartIndex = _this$_getHorizontalR2[0], _overscanColumnStopIndex = _this$_getHorizontalR2[1], _visibleColumnStartIndex = _this$_getHorizontalR2[2], _visibleColumnStopIndex = _this$_getHorizontalR2[3];
          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(), _overscanRowStartIndex = _this$_getVerticalRan2[0], _overscanRowStopIndex = _this$_getVerticalRan2[1], _visibleRowStartIndex = _this$_getVerticalRan2[2], _visibleRowStopIndex = _this$_getVerticalRan2[3];
          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);
        }
      }
      if (typeof onScroll === "function") {
        var _this$state3 = this.state, _horizontalScrollDirection = _this$state3.horizontalScrollDirection, _scrollLeft = _this$state3.scrollLeft, _scrollTop = _this$state3.scrollTop, _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested, _verticalScrollDirection = _this$state3.verticalScrollDirection;
        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);
      }
    };
    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {
      var _this$props6 = this.props, columnCount = _this$props6.columnCount, overscanColumnCount = _this$props6.overscanColumnCount, overscanColumnsCount = _this$props6.overscanColumnsCount, overscanCount = _this$props6.overscanCount, rowCount = _this$props6.rowCount;
      var _this$state4 = this.state, horizontalScrollDirection = _this$state4.horizontalScrollDirection, isScrolling = _this$state4.isScrolling, scrollLeft = _this$state4.scrollLeft;
      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;
      if (columnCount === 0 || rowCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getColumnStartIndexForOffset3(this.props, scrollLeft, this._instanceProps);
      var stopIndex = getColumnStopIndexForStartIndex3(this.props, startIndex, scrollLeft, this._instanceProps);
      var overscanBackward = !isScrolling || horizontalScrollDirection === "backward" ? Math.max(1, overscanCountResolved) : 1;
      var overscanForward = !isScrolling || horizontalScrollDirection === "forward" ? Math.max(1, overscanCountResolved) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };
    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {
      var _this$props7 = this.props, columnCount = _this$props7.columnCount, overscanCount = _this$props7.overscanCount, overscanRowCount = _this$props7.overscanRowCount, overscanRowsCount = _this$props7.overscanRowsCount, rowCount = _this$props7.rowCount;
      var _this$state5 = this.state, isScrolling = _this$state5.isScrolling, verticalScrollDirection = _this$state5.verticalScrollDirection, scrollTop = _this$state5.scrollTop;
      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;
      if (columnCount === 0 || rowCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getRowStartIndexForOffset3(this.props, scrollTop, this._instanceProps);
      var stopIndex = getRowStopIndexForStartIndex3(this.props, startIndex, scrollTop, this._instanceProps);
      var overscanBackward = !isScrolling || verticalScrollDirection === "backward" ? Math.max(1, overscanCountResolved) : 1;
      var overscanForward = !isScrolling || verticalScrollDirection === "forward" ? Math.max(1, overscanCountResolved) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };
    return Grid;
  }(import_react4.PureComponent), _class.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    useIsScrolling: false
  }, _class;
}
var validateSharedProps = function validateSharedProps2(_ref5, _ref6) {
  var children = _ref5.children, direction2 = _ref5.direction, height = _ref5.height, innerTagName = _ref5.innerTagName, outerTagName = _ref5.outerTagName, overscanColumnsCount = _ref5.overscanColumnsCount, overscanCount = _ref5.overscanCount, overscanRowsCount = _ref5.overscanRowsCount, width = _ref5.width;
  var instance = _ref6.instance;
  if (true) {
    if (typeof overscanCount === "number") {
      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {
        devWarningsOverscanCount.add(instance);
        console.warn("The overscanCount prop has been deprecated. Please use the overscanColumnCount and overscanRowCount props instead.");
      }
    }
    if (typeof overscanColumnsCount === "number" || typeof overscanRowsCount === "number") {
      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {
        devWarningsOverscanRowsColumnsCount.add(instance);
        console.warn("The overscanColumnsCount and overscanRowsCount props have been deprecated. Please use the overscanColumnCount and overscanRowCount props instead.");
      }
    }
    if (innerTagName != null || outerTagName != null) {
      if (devWarningsTagName && !devWarningsTagName.has(instance)) {
        devWarningsTagName.add(instance);
        console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead.");
      }
    }
    if (children == null) {
      throw Error('An invalid "children" prop has been specified. Value should be a React component. ' + ('"' + (children === null ? "null" : typeof children) + '" was specified.'));
    }
    switch (direction2) {
      case "ltr":
      case "rtl":
        break;
      default:
        throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". ' + ('"' + direction2 + '" was specified.'));
    }
    if (typeof width !== "number") {
      throw Error('An invalid "width" prop has been specified. Grids must specify a number for width. ' + ('"' + (width === null ? "null" : typeof width) + '" was specified.'));
    }
    if (typeof height !== "number") {
      throw Error('An invalid "height" prop has been specified. Grids must specify a number for height. ' + ('"' + (height === null ? "null" : typeof height) + '" was specified.'));
    }
  }
};
var DEFAULT_ESTIMATED_ITEM_SIZE = 50;
var getEstimatedTotalHeight = function getEstimatedTotalHeight2(_ref, _ref2) {
  var rowCount = _ref.rowCount;
  var rowMetadataMap = _ref2.rowMetadataMap, estimatedRowHeight = _ref2.estimatedRowHeight, lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;
  var totalSizeOfMeasuredRows = 0;
  if (lastMeasuredRowIndex >= rowCount) {
    lastMeasuredRowIndex = rowCount - 1;
  }
  if (lastMeasuredRowIndex >= 0) {
    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];
    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;
  }
  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;
  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;
};
var getEstimatedTotalWidth = function getEstimatedTotalWidth2(_ref3, _ref4) {
  var columnCount = _ref3.columnCount;
  var columnMetadataMap = _ref4.columnMetadataMap, estimatedColumnWidth = _ref4.estimatedColumnWidth, lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;
  var totalSizeOfMeasuredRows = 0;
  if (lastMeasuredColumnIndex >= columnCount) {
    lastMeasuredColumnIndex = columnCount - 1;
  }
  if (lastMeasuredColumnIndex >= 0) {
    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];
    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;
  }
  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;
  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;
};
var getItemMetadata = function getItemMetadata2(itemType, props, index2, instanceProps) {
  var itemMetadataMap, itemSize, lastMeasuredIndex;
  if (itemType === "column") {
    itemMetadataMap = instanceProps.columnMetadataMap;
    itemSize = props.columnWidth;
    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;
  } else {
    itemMetadataMap = instanceProps.rowMetadataMap;
    itemSize = props.rowHeight;
    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;
  }
  if (index2 > lastMeasuredIndex) {
    var offset4 = 0;
    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset4 = itemMetadata.offset + itemMetadata.size;
    }
    for (var i2 = lastMeasuredIndex + 1; i2 <= index2; i2++) {
      var size2 = itemSize(i2);
      itemMetadataMap[i2] = {
        offset: offset4,
        size: size2
      };
      offset4 += size2;
    }
    if (itemType === "column") {
      instanceProps.lastMeasuredColumnIndex = index2;
    } else {
      instanceProps.lastMeasuredRowIndex = index2;
    }
  }
  return itemMetadataMap[index2];
};
var findNearestItem = function findNearestItem2(itemType, props, instanceProps, offset4) {
  var itemMetadataMap, lastMeasuredIndex;
  if (itemType === "column") {
    itemMetadataMap = instanceProps.columnMetadataMap;
    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;
  } else {
    itemMetadataMap = instanceProps.rowMetadataMap;
    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;
  }
  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;
  if (lastMeasuredItemOffset >= offset4) {
    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset4);
  } else {
    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset4);
  }
};
var findNearestItemBinarySearch = function findNearestItemBinarySearch2(itemType, props, instanceProps, high, low, offset4) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;
    if (currentOffset === offset4) {
      return middle;
    } else if (currentOffset < offset4) {
      low = middle + 1;
    } else if (currentOffset > offset4) {
      high = middle - 1;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
var findNearestItemExponentialSearch = function findNearestItemExponentialSearch2(itemType, props, instanceProps, index2, offset4) {
  var itemCount = itemType === "column" ? props.columnCount : props.rowCount;
  var interval = 1;
  while (index2 < itemCount && getItemMetadata(itemType, props, index2, instanceProps).offset < offset4) {
    index2 += interval;
    interval *= 2;
  }
  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index2, itemCount - 1), Math.floor(index2 / 2), offset4);
};
var getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment2(itemType, props, index2, align, scrollOffset, instanceProps, scrollbarSize) {
  var size2 = itemType === "column" ? props.width : props.height;
  var itemMetadata = getItemMetadata(itemType, props, index2, instanceProps);
  var estimatedTotalSize = itemType === "column" ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);
  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, itemMetadata.offset));
  var minOffset = Math.max(0, itemMetadata.offset - size2 + scrollbarSize + itemMetadata.size);
  if (align === "smart") {
    if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
      align = "auto";
    } else {
      align = "center";
    }
  }
  switch (align) {
    case "start":
      return maxOffset;
    case "end":
      return minOffset;
    case "center":
      return Math.round(minOffset + (maxOffset - minOffset) / 2);
    case "auto":
    default:
      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
        return scrollOffset;
      } else if (minOffset > maxOffset) {
        return minOffset;
      } else if (scrollOffset < minOffset) {
        return minOffset;
      } else {
        return maxOffset;
      }
  }
};
var VariableSizeGrid = createGridComponent({
  getColumnOffset: function getColumnOffset(props, index2, instanceProps) {
    return getItemMetadata("column", props, index2, instanceProps).offset;
  },
  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {
    return findNearestItem("column", props, instanceProps, scrollLeft);
  },
  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {
    var columnCount = props.columnCount, width = props.width;
    var itemMetadata = getItemMetadata("column", props, startIndex, instanceProps);
    var maxOffset = scrollLeft + width;
    var offset4 = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;
    while (stopIndex < columnCount - 1 && offset4 < maxOffset) {
      stopIndex++;
      offset4 += getItemMetadata("column", props, stopIndex, instanceProps).size;
    }
    return stopIndex;
  },
  getColumnWidth: function getColumnWidth(props, index2, instanceProps) {
    return instanceProps.columnMetadataMap[index2].size;
  },
  getEstimatedTotalHeight,
  getEstimatedTotalWidth,
  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index2, align, scrollOffset, instanceProps, scrollbarSize) {
    return getOffsetForIndexAndAlignment("column", props, index2, align, scrollOffset, instanceProps, scrollbarSize);
  },
  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index2, align, scrollOffset, instanceProps, scrollbarSize) {
    return getOffsetForIndexAndAlignment("row", props, index2, align, scrollOffset, instanceProps, scrollbarSize);
  },
  getRowOffset: function getRowOffset(props, index2, instanceProps) {
    return getItemMetadata("row", props, index2, instanceProps).offset;
  },
  getRowHeight: function getRowHeight(props, index2, instanceProps) {
    return instanceProps.rowMetadataMap[index2].size;
  },
  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {
    return findNearestItem("row", props, instanceProps, scrollTop);
  },
  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {
    var rowCount = props.rowCount, height = props.height;
    var itemMetadata = getItemMetadata("row", props, startIndex, instanceProps);
    var maxOffset = scrollTop + height;
    var offset4 = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;
    while (stopIndex < rowCount - 1 && offset4 < maxOffset) {
      stopIndex++;
      offset4 += getItemMetadata("row", props, stopIndex, instanceProps).size;
    }
    return stopIndex;
  },
  initInstanceProps: function initInstanceProps(props, instance) {
    var _ref5 = props, estimatedColumnWidth = _ref5.estimatedColumnWidth, estimatedRowHeight = _ref5.estimatedRowHeight;
    var instanceProps = {
      columnMetadataMap: {},
      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,
      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,
      lastMeasuredColumnIndex: -1,
      lastMeasuredRowIndex: -1,
      rowMetadataMap: {}
    };
    instance.resetAfterColumnIndex = function(columnIndex, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }
      instance.resetAfterIndices({
        columnIndex,
        shouldForceUpdate
      });
    };
    instance.resetAfterRowIndex = function(rowIndex, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }
      instance.resetAfterIndices({
        rowIndex,
        shouldForceUpdate
      });
    };
    instance.resetAfterIndices = function(_ref6) {
      var columnIndex = _ref6.columnIndex, rowIndex = _ref6.rowIndex, _ref6$shouldForceUpda = _ref6.shouldForceUpdate, shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;
      if (typeof columnIndex === "number") {
        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);
      }
      if (typeof rowIndex === "number") {
        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);
      }
      instance._getItemStyleCache(-1);
      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };
    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps(_ref7) {
    var columnWidth = _ref7.columnWidth, rowHeight = _ref7.rowHeight;
    if (true) {
      if (typeof columnWidth !== "function") {
        throw Error('An invalid "columnWidth" prop has been specified. Value should be a function. ' + ('"' + (columnWidth === null ? "null" : typeof columnWidth) + '" was specified.'));
      } else if (typeof rowHeight !== "function") {
        throw Error('An invalid "rowHeight" prop has been specified. Value should be a function. ' + ('"' + (rowHeight === null ? "null" : typeof rowHeight) + '" was specified.'));
      }
    }
  }
});
var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
var defaultItemKey$1 = function defaultItemKey3(index2, data) {
  return index2;
};
var devWarningsDirection = null;
var devWarningsTagName$1 = null;
if (true) {
  if (typeof window !== "undefined" && typeof window.WeakSet !== "undefined") {
    devWarningsDirection = /* @__PURE__ */ new WeakSet();
    devWarningsTagName$1 = /* @__PURE__ */ new WeakSet();
  }
}
function createListComponent(_ref) {
  var _class;
  var getItemOffset3 = _ref.getItemOffset, getEstimatedTotalSize4 = _ref.getEstimatedTotalSize, getItemSize3 = _ref.getItemSize, getOffsetForIndexAndAlignment5 = _ref.getOffsetForIndexAndAlignment, getStartIndexForOffset3 = _ref.getStartIndexForOffset, getStopIndexForStartIndex3 = _ref.getStopIndexForStartIndex, initInstanceProps5 = _ref.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange, validateProps6 = _ref.validateProps;
  return _class = function(_PureComponent) {
    _inheritsLoose2(List, _PureComponent);
    function List(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps5(_this.props, _assertThisInitialized2(_this));
      _this._outerRef = void 0;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: _assertThisInitialized2(_this),
        isScrolling: false,
        scrollDirection: "forward",
        scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = memoize_one_esm_default(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex,
          overscanStopIndex,
          visibleStartIndex,
          visibleStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = memoize_one_esm_default(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection,
          scrollOffset,
          scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;
      _this._getItemStyle = function(index2) {
        var _this$props = _this.props, direction2 = _this$props.direction, itemSize = _this$props.itemSize, layout = _this$props.layout;
        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction2);
        var style3;
        if (itemStyleCache.hasOwnProperty(index2)) {
          style3 = itemStyleCache[index2];
        } else {
          var _offset = getItemOffset3(_this.props, index2, _this._instanceProps);
          var size2 = getItemSize3(_this.props, index2, _this._instanceProps);
          var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
          var isRtl = direction2 === "rtl";
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index2] = style3 = {
            position: "absolute",
            left: isRtl ? void 0 : offsetHorizontal,
            right: isRtl ? offsetHorizontal : void 0,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size2 : "100%",
            width: isHorizontal ? size2 : "100%"
          };
        }
        return style3;
      };
      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = memoize_one_esm_default(function(_, __, ___) {
        return {};
      });
      _this._onScrollHorizontal = function(event) {
        var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollLeft) {
            return null;
          }
          var direction2 = _this.props.direction;
          var scrollOffset = scrollLeft;
          if (direction2 === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                scrollOffset = -scrollLeft;
                break;
              case "positive-descending":
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._onScrollVertical = function(event) {
        var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop = _event$currentTarget2.scrollTop;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollTop) {
            return null;
          }
          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._outerRefSetter = function(ref2) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref2;
        if (typeof outerRef === "function") {
          outerRef(ref2);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref2;
        }
      };
      _this._resetIsScrollingDebounced = function() {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }
        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };
      _this._resetIsScrolling = function() {
        _this._resetIsScrollingTimeoutId = null;
        _this.setState({
          isScrolling: false
        }, function() {
          _this._getItemStyleCache(-1, null);
        });
      };
      return _this;
    }
    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps6(nextProps);
      return null;
    };
    var _proto = List.prototype;
    _proto.scrollTo = function scrollTo(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function(prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }
        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
          scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };
    _proto.scrollToItem = function scrollToItem(index2, align) {
      if (align === void 0) {
        align = "auto";
      }
      var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout = _this$props2.layout;
      var scrollOffset = this.state.scrollOffset;
      index2 = Math.max(0, Math.min(index2, itemCount - 1));
      var scrollbarSize = 0;
      if (this._outerRef) {
        var outerRef = this._outerRef;
        if (layout === "vertical") {
          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
        } else {
          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
        }
      }
      this.scrollTo(getOffsetForIndexAndAlignment5(this.props, index2, align, scrollOffset, this._instanceProps, scrollbarSize));
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props, direction2 = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout = _this$props3.layout;
      if (typeof initialScrollOffset === "number" && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction2 === "horizontal" || layout === "horizontal") {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props4 = this.props, direction2 = _this$props4.direction, layout = _this$props4.layout;
      var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction2 === "horizontal" || layout === "horizontal") {
          if (direction2 === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                outerRef.scrollLeft = -scrollOffset;
                break;
              case "positive-ascending":
                outerRef.scrollLeft = scrollOffset;
                break;
              default:
                var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };
    _proto.render = function render2() {
      var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction2 = _this$props5.direction, height = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType2 = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey, layout = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style3 = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width = _this$props5.width;
      var isScrolling = this.state.isScrolling;
      var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
      var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];
      var items2 = [];
      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items2.push((0, import_react4.createElement)(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : void 0,
            style: this._getItemStyle(_index)
          }));
        }
      }
      var estimatedTotalSize = getEstimatedTotalSize4(this.props, this._instanceProps);
      return (0, import_react4.createElement)(outerElementType || outerTagName || "div", {
        className,
        onScroll,
        ref: this._outerRefSetter,
        style: _extends({
          position: "relative",
          height,
          width,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction: direction2
        }, style3)
      }, (0, import_react4.createElement)(innerElementType2 || innerTagName || "div", {
        children: items2,
        ref: innerRef,
        style: {
          height: isHorizontal ? "100%" : estimatedTotalSize,
          pointerEvents: isScrolling ? "none" : void 0,
          width: isHorizontal ? estimatedTotalSize : "100%"
        }
      }));
    };
    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === "function") {
        var itemCount = this.props.itemCount;
        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];
          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }
      if (typeof this.props.onScroll === "function") {
        var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    };
    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;
      var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;
      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getStartIndexForOffset3(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex3(this.props, startIndex, scrollOffset, this._instanceProps);
      var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };
    return List;
  }(import_react4.PureComponent), _class.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: false
  }, _class;
}
var validateSharedProps$1 = function validateSharedProps3(_ref2, _ref3) {
  var children = _ref2.children, direction2 = _ref2.direction, height = _ref2.height, layout = _ref2.layout, innerTagName = _ref2.innerTagName, outerTagName = _ref2.outerTagName, width = _ref2.width;
  var instance = _ref3.instance;
  if (true) {
    if (innerTagName != null || outerTagName != null) {
      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {
        devWarningsTagName$1.add(instance);
        console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead.");
      }
    }
    var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
    switch (direction2) {
      case "horizontal":
      case "vertical":
        if (devWarningsDirection && !devWarningsDirection.has(instance)) {
          devWarningsDirection.add(instance);
          console.warn('The direction prop should be either "ltr" (default) or "rtl". Please use the layout prop to specify "vertical" (default) or "horizontal" orientation.');
        }
        break;
      case "ltr":
      case "rtl":
        break;
      default:
        throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". ' + ('"' + direction2 + '" was specified.'));
    }
    switch (layout) {
      case "horizontal":
      case "vertical":
        break;
      default:
        throw Error('An invalid "layout" prop has been specified. Value should be either "horizontal" or "vertical". ' + ('"' + layout + '" was specified.'));
    }
    if (children == null) {
      throw Error('An invalid "children" prop has been specified. Value should be a React component. ' + ('"' + (children === null ? "null" : typeof children) + '" was specified.'));
    }
    if (isHorizontal && typeof width !== "number") {
      throw Error('An invalid "width" prop has been specified. Horizontal lists must specify a number for width. ' + ('"' + (width === null ? "null" : typeof width) + '" was specified.'));
    } else if (!isHorizontal && typeof height !== "number") {
      throw Error('An invalid "height" prop has been specified. Vertical lists must specify a number for height. ' + ('"' + (height === null ? "null" : typeof height) + '" was specified.'));
    }
  }
};
var DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;
var getItemMetadata$1 = function getItemMetadata3(props, index2, instanceProps) {
  var _ref = props, itemSize = _ref.itemSize;
  var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  if (index2 > lastMeasuredIndex) {
    var offset4 = 0;
    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset4 = itemMetadata.offset + itemMetadata.size;
    }
    for (var i2 = lastMeasuredIndex + 1; i2 <= index2; i2++) {
      var size2 = itemSize(i2);
      itemMetadataMap[i2] = {
        offset: offset4,
        size: size2
      };
      offset4 += size2;
    }
    instanceProps.lastMeasuredIndex = index2;
  }
  return itemMetadataMap[index2];
};
var findNearestItem$1 = function findNearestItem3(props, instanceProps, offset4) {
  var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;
  if (lastMeasuredItemOffset >= offset4) {
    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset4);
  } else {
    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset4);
  }
};
var findNearestItemBinarySearch$1 = function findNearestItemBinarySearch3(props, instanceProps, high, low, offset4) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;
    if (currentOffset === offset4) {
      return middle;
    } else if (currentOffset < offset4) {
      low = middle + 1;
    } else if (currentOffset > offset4) {
      high = middle - 1;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
var findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch3(props, instanceProps, index2, offset4) {
  var itemCount = props.itemCount;
  var interval = 1;
  while (index2 < itemCount && getItemMetadata$1(props, index2, instanceProps).offset < offset4) {
    index2 += interval;
    interval *= 2;
  }
  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index2, itemCount - 1), Math.floor(index2 / 2), offset4);
};
var getEstimatedTotalSize = function getEstimatedTotalSize2(_ref2, _ref3) {
  var itemCount = _ref2.itemCount;
  var itemMetadataMap = _ref3.itemMetadataMap, estimatedItemSize = _ref3.estimatedItemSize, lastMeasuredIndex = _ref3.lastMeasuredIndex;
  var totalSizeOfMeasuredItems = 0;
  if (lastMeasuredIndex >= itemCount) {
    lastMeasuredIndex = itemCount - 1;
  }
  if (lastMeasuredIndex >= 0) {
    var itemMetadata = itemMetadataMap[lastMeasuredIndex];
    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;
  }
  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};
var VariableSizeList = createListComponent({
  getItemOffset: function getItemOffset(props, index2, instanceProps) {
    return getItemMetadata$1(props, index2, instanceProps).offset;
  },
  getItemSize: function getItemSize(props, index2, instanceProps) {
    return instanceProps.itemMetadataMap[index2].size;
  },
  getEstimatedTotalSize,
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment3(props, index2, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction2 = props.direction, height = props.height, layout = props.layout, width = props.width;
    var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, index2, instanceProps);
    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);
    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, itemMetadata.offset));
    var minOffset = Math.max(0, itemMetadata.offset - size2 + itemMetadata.size + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        return Math.round(minOffset + (maxOffset - minOffset) / 2);
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(props, offset4, instanceProps) {
    return findNearestItem$1(props, instanceProps, offset4);
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {
    var direction2 = props.direction, height = props.height, itemCount = props.itemCount, layout = props.layout, width = props.width;
    var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);
    var maxOffset = scrollOffset + size2;
    var offset4 = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;
    while (stopIndex < itemCount - 1 && offset4 < maxOffset) {
      stopIndex++;
      offset4 += getItemMetadata$1(props, stopIndex, instanceProps).size;
    }
    return stopIndex;
  },
  initInstanceProps: function initInstanceProps2(props, instance) {
    var _ref4 = props, estimatedItemSize = _ref4.estimatedItemSize;
    var instanceProps = {
      itemMetadataMap: {},
      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,
      lastMeasuredIndex: -1
    };
    instance.resetAfterIndex = function(index2, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }
      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index2 - 1);
      instance._getItemStyleCache(-1);
      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };
    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps2(_ref5) {
    var itemSize = _ref5.itemSize;
    if (true) {
      if (typeof itemSize !== "function") {
        throw Error('An invalid "itemSize" prop has been specified. Value should be a function. ' + ('"' + (itemSize === null ? "null" : typeof itemSize) + '" was specified.'));
      }
    }
  }
});
var FixedSizeGrid = createGridComponent({
  getColumnOffset: function getColumnOffset2(_ref, index2) {
    var columnWidth = _ref.columnWidth;
    return index2 * columnWidth;
  },
  getColumnWidth: function getColumnWidth2(_ref2, index2) {
    var columnWidth = _ref2.columnWidth;
    return columnWidth;
  },
  getRowOffset: function getRowOffset2(_ref3, index2) {
    var rowHeight = _ref3.rowHeight;
    return index2 * rowHeight;
  },
  getRowHeight: function getRowHeight2(_ref4, index2) {
    var rowHeight = _ref4.rowHeight;
    return rowHeight;
  },
  getEstimatedTotalHeight: function getEstimatedTotalHeight3(_ref5) {
    var rowCount = _ref5.rowCount, rowHeight = _ref5.rowHeight;
    return rowHeight * rowCount;
  },
  getEstimatedTotalWidth: function getEstimatedTotalWidth3(_ref6) {
    var columnCount = _ref6.columnCount, columnWidth = _ref6.columnWidth;
    return columnWidth * columnCount;
  },
  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment2(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {
    var columnCount = _ref7.columnCount, columnWidth = _ref7.columnWidth, width = _ref7.width;
    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);
    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);
    if (align === "smart") {
      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(width / 2)) {
          return 0;
        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
          return lastColumnOffset;
        } else {
          return middleOffset;
        }
      case "auto":
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment2(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {
    var rowHeight = _ref8.rowHeight, height = _ref8.height, rowCount = _ref8.rowCount;
    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);
    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);
    if (align === "smart") {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(height / 2)) {
          return 0;
        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
          return lastRowOffset;
        } else {
          return middleOffset;
        }
      case "auto":
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getColumnStartIndexForOffset: function getColumnStartIndexForOffset2(_ref9, scrollLeft) {
    var columnWidth = _ref9.columnWidth, columnCount = _ref9.columnCount;
    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));
  },
  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex2(_ref10, startIndex, scrollLeft) {
    var columnWidth = _ref10.columnWidth, columnCount = _ref10.columnCount, width = _ref10.width;
    var left2 = startIndex * columnWidth;
    var numVisibleColumns = Math.ceil((width + scrollLeft - left2) / columnWidth);
    return Math.max(0, Math.min(
      columnCount - 1,
      startIndex + numVisibleColumns - 1
      // -1 is because stop index is inclusive
    ));
  },
  getRowStartIndexForOffset: function getRowStartIndexForOffset2(_ref11, scrollTop) {
    var rowHeight = _ref11.rowHeight, rowCount = _ref11.rowCount;
    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));
  },
  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex2(_ref12, startIndex, scrollTop) {
    var rowHeight = _ref12.rowHeight, rowCount = _ref12.rowCount, height = _ref12.height;
    var top2 = startIndex * rowHeight;
    var numVisibleRows = Math.ceil((height + scrollTop - top2) / rowHeight);
    return Math.max(0, Math.min(
      rowCount - 1,
      startIndex + numVisibleRows - 1
      // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps3(props) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps3(_ref13) {
    var columnWidth = _ref13.columnWidth, rowHeight = _ref13.rowHeight;
    if (true) {
      if (typeof columnWidth !== "number") {
        throw Error('An invalid "columnWidth" prop has been specified. Value should be a number. ' + ('"' + (columnWidth === null ? "null" : typeof columnWidth) + '" was specified.'));
      }
      if (typeof rowHeight !== "number") {
        throw Error('An invalid "rowHeight" prop has been specified. Value should be a number. ' + ('"' + (rowHeight === null ? "null" : typeof rowHeight) + '" was specified.'));
      }
    }
  }
});
var FixedSizeList = createListComponent({
  getItemOffset: function getItemOffset2(_ref, index2) {
    var itemSize = _ref.itemSize;
    return index2 * itemSize;
  },
  getItemSize: function getItemSize2(_ref2, index2) {
    var itemSize = _ref2.itemSize;
    return itemSize;
  },
  getEstimatedTotalSize: function getEstimatedTotalSize3(_ref3) {
    var itemCount = _ref3.itemCount, itemSize = _ref3.itemSize;
    return itemSize * itemCount;
  },
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment4(_ref4, index2, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction2 = _ref4.direction, height = _ref4.height, itemCount = _ref4.itemCount, itemSize = _ref4.itemSize, layout = _ref4.layout, width = _ref4.width;
    var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width : height;
    var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
    var maxOffset = Math.min(lastItemOffset, index2 * itemSize);
    var minOffset = Math.max(0, index2 * itemSize - size2 + itemSize + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center": {
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size2 / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getStartIndexForOffset: function getStartIndexForOffset2(_ref5, offset4) {
    var itemCount = _ref5.itemCount, itemSize = _ref5.itemSize;
    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset4 / itemSize)));
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex2(_ref6, startIndex, scrollOffset) {
    var direction2 = _ref6.direction, height = _ref6.height, itemCount = _ref6.itemCount, itemSize = _ref6.itemSize, layout = _ref6.layout, width = _ref6.width;
    var isHorizontal = direction2 === "horizontal" || layout === "horizontal";
    var offset4 = startIndex * itemSize;
    var size2 = isHorizontal ? width : height;
    var numVisibleItems = Math.ceil((size2 + scrollOffset - offset4) / itemSize);
    return Math.max(0, Math.min(
      itemCount - 1,
      startIndex + numVisibleItems - 1
      // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps4(props) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps4(_ref7) {
    var itemSize = _ref7.itemSize;
    if (true) {
      if (typeof itemSize !== "number") {
        throw Error('An invalid "itemSize" prop has been specified. Value should be a number. ' + ('"' + (itemSize === null ? "null" : typeof itemSize) + '" was specified.'));
      }
    }
  }
});

// ../../../node_modules/@hello-pangea/dnd/dist/dnd.esm.js
var import_react6 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// ../../../node_modules/redux/dist/redux.mjs
var $$observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${randomString()}`,
  REPLACE: `@@redux/REPLACE${randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate3(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate3(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer2, preloadedState, enhancer) {
  if (typeof reducer2 !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer2)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore)(reducer2, preloadedState);
  }
  let currentReducer = reducer2;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key) => {
        nextListeners.set(key, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(false ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners2 = currentListeners = nextListeners;
    listeners2.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function bindActionCreator(actionCreator, dispatch) {
  return function(...args) {
    return dispatch(actionCreator.apply(this, args));
  };
}
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(false ? formatProdErrorMessage(16) : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
  }
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore22) => (reducer2, preloadedState) => {
    const store = createStore22(reducer2, preloadedState);
    let dispatch = () => {
      throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}

// ../../../node_modules/react-redux/dist/react-redux.mjs
var React4 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var IS_REACT_19 = React4.version.startsWith("19");
var REACT_ELEMENT_TYPE = Symbol.for(
  IS_REACT_19 ? "react.transitional.element" : "react.element"
);
var REACT_PORTAL_TYPE = Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = Symbol.for(
  "react.suspense_list"
);
var REACT_MEMO_TYPE = Symbol.for("react.memo");
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = Symbol.for(
  "react.client.reference"
);
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function isValidElementType(type) {
  return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;
}
function typeOf(object2) {
  if (typeof object2 === "object" && object2 !== null) {
    const { $$typeof } = object2;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        switch (object2 = object2.type, object2) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return object2;
          default:
            switch (object2 = object2 && object2.$$typeof, object2) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
                return object2;
              case REACT_CONSUMER_TYPE:
                return object2;
              default:
                return $$typeof;
            }
        }
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }
}
function isContextConsumer(object2) {
  return IS_REACT_19 ? typeOf(object2) === REACT_CONSUMER_TYPE : typeOf(object2) === REACT_CONTEXT_TYPE;
}
function isMemo(object2) {
  return typeOf(object2) === REACT_MEMO_TYPE;
}
function warning3(message2) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message2);
  }
  try {
    throw new Error(message2);
  } catch (e2) {
  }
}
function verify(selector, methodName) {
  if (!selector) {
    throw new Error(`Unexpected value for ${methodName} in connect.`);
  } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
    if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
      warning3(
        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`
      );
    }
  }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps2, mergeProps) {
  verify(mapStateToProps, "mapStateToProps");
  verify(mapDispatchToProps2, "mapDispatchToProps");
  verify(mergeProps, "mergeProps");
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, {
  areStatesEqual,
  areOwnPropsEqual,
  areStatePropsEqual
}) {
  let hasRunAtLeastOnce = false;
  let state;
  let ownProps;
  let stateProps;
  let dispatchProps;
  let mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(
      nextState,
      state,
      nextOwnProps,
      ownProps
    );
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps,
  initMergeProps,
  ...options2
}) {
  const mapStateToProps = initMapStateToProps(dispatch, options2);
  const mapDispatchToProps2 = initMapDispatchToProps(dispatch, options2);
  const mergeProps = initMergeProps(dispatch, options2);
  if (true) {
    verifySubselectors(mapStateToProps, mapDispatchToProps2, mergeProps);
  }
  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, options2);
}
function bindActionCreators2(actionCreators, dispatch) {
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));
    }
  }
  return boundActionCreators;
}
function isPlainObject2(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  const proto = Object.getPrototypeOf(obj);
  if (proto === null) return true;
  let baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
function verifyPlainObject(value, displayName, methodName) {
  if (!isPlainObject2(value)) {
    warning3(
      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`
    );
  }
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch) {
    const constant = getConstant(dispatch);
    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      let props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      if (true)
        verifyPlainObject(props, displayName, methodName);
      return props;
    };
    return proxy;
  };
}
function createInvalidArgFactory(arg, name) {
  return (dispatch, options2) => {
    throw new Error(
      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options2.wrappedComponentName}.`
    );
  };
}
function mapDispatchToPropsFactory(mapDispatchToProps2) {
  return mapDispatchToProps2 && typeof mapDispatchToProps2 === "object" ? wrapMapToPropsConstant(
    (dispatch) => (
      // @ts-ignore
      bindActionCreators2(mapDispatchToProps2, dispatch)
    )
  ) : !mapDispatchToProps2 ? wrapMapToPropsConstant((dispatch) => ({
    dispatch
  })) : typeof mapDispatchToProps2 === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps2, "mapDispatchToProps")
  ) : createInvalidArgFactory(mapDispatchToProps2, "mapDispatchToProps");
}
function mapStateToPropsFactory(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps, "mapStateToProps")
  ) : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return { ...ownProps, ...stateProps, ...dispatchProps };
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {
    let hasRunOnce = false;
    let mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (true)
          verifyPlainObject(mergedProps, displayName, "mergeProps");
      }
      return mergedProps;
    };
  };
}
function mergePropsFactory(mergeProps) {
  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
}
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first2 = null;
  let last = null;
  return {
    clear() {
      first2 = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first2;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners2 = [];
      let listener = first2;
      while (listener) {
        listeners2.push(listener);
        listener = listener.next;
      }
      return listeners2;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first2 = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first2 === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first2 = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners2 = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners2.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners2.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners2 = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners2.clear();
      listeners2 = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners2
  };
  return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React4.useLayoutEffect : React4.useEffect;
var useIsomorphicLayoutEffect2 = getUseIsomorphicLayoutEffect();
function is2(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function shallowEqual(objA, objB) {
  if (is2(objA, objB)) return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;
  for (let i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is2(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
function getStatics(component) {
  if (isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      const inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent);
      }
    }
    let keys2 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
    }
    const targetStatics = getStatics(targetComponent);
    const sourceStatics = getStatics(sourceComponent);
    for (let i2 = 0; i2 < keys2.length; ++i2) {
      const key = keys2[i2];
      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var ContextKey = Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!React4.createContext) return {};
  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
  let realContext = contextMap.get(React4.createContext);
  if (!realContext) {
    realContext = React4.createContext(
      null
    );
    if (true) {
      realContext.displayName = "ReactRedux";
    }
    contextMap.set(React4.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = getContext();
var NO_SUBSCRIPTION_ARRAY = [null, null];
var stringifyComponent = (Comp) => {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect2(() => effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
  if (!shouldHandleStateChanges) return () => {
  };
  let didUnsubscribe = false;
  let lastThrownError = null;
  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      return;
    }
    const latestStoreState = store.getState();
    let newChildProps, error2;
    try {
      newChildProps = childPropsSelector(
        latestStoreState,
        lastWrapperProps.current
      );
    } catch (e2) {
      error2 = e2;
      lastThrownError = e2;
    }
    if (!error2) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      additionalSubscribeListener();
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
function strictEqual(a2, b2) {
  return a2 === b2;
}
var hasWarnedAboutDeprecatedPureOption = false;
function connect(mapStateToProps, mapDispatchToProps2, mergeProps, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure,
  areStatesEqual = strictEqual,
  areOwnPropsEqual = shallowEqual,
  areStatePropsEqual = shallowEqual,
  areMergedPropsEqual = shallowEqual,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef: forwardRef8 = false,
  // the context consumer to use
  context = ReactReduxContext
} = {}) {
  if (true) {
    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {
      hasWarnedAboutDeprecatedPureOption = true;
      warning3(
        'The `pure` option has been removed. `connect` is now always a "pure/memoized" component'
      );
    }
  }
  const Context = context;
  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps2);
  const initMergeProps = mergePropsFactory(mergeProps);
  const shouldHandleStateChanges = Boolean(mapStateToProps);
  const wrapWithConnect = (WrappedComponent) => {
    if (true) {
      const isValid2 = isValidElementType(WrappedComponent);
      if (!isValid2)
        throw new Error(
          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(
            WrappedComponent
          )}`
        );
    }
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    const displayName = `Connect(${wrappedComponentName})`;
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] = React4.useMemo(() => {
        const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]);
      const ContextToUse = React4.useMemo(() => {
        let ResultContext = Context;
        if (propsContext == null ? void 0 : propsContext.Consumer) {
          if (true) {
            const isValid2 = isContextConsumer(
              // @ts-ignore
              React4.createElement(propsContext.Consumer, null)
            );
            if (!isValid2) {
              throw new Error(
                "You must pass a valid React context consumer as `props.context`"
              );
            }
            ResultContext = propsContext;
          }
        }
        return ResultContext;
      }, [propsContext, Context]);
      const contextValue = React4.useContext(ContextToUse);
      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      if (!didStoreComeFromProps && !didStoreComeFromContext) {
        throw new Error(
          `Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`
        );
      }
      const store = didStoreComeFromProps ? props.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
      const childPropsSelector = React4.useMemo(() => {
        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
      }, [store]);
      const [subscription, notifyNestedSubs] = React4.useMemo(() => {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
        const subscription2 = createSubscription(
          store,
          didStoreComeFromProps ? void 0 : contextValue.subscription
        );
        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]);
      const overriddenContextValue = React4.useMemo(() => {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return {
          ...contextValue,
          subscription
        };
      }, [didStoreComeFromProps, contextValue, subscription]);
      const lastChildProps = React4.useRef(void 0);
      const lastWrapperProps = React4.useRef(wrapperProps);
      const childPropsFromStoreUpdate = React4.useRef(void 0);
      const renderIsScheduled = React4.useRef(false);
      const isMounted = React4.useRef(false);
      const latestSubscriptionCallbackError = React4.useRef(
        void 0
      );
      useIsomorphicLayoutEffect2(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector = React4.useMemo(() => {
        const selector = () => {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store.getState(), wrapperProps);
        };
        return selector;
      }, [store, wrapperProps]);
      const subscribeForReact = React4.useMemo(() => {
        const subscribe = (reactListener) => {
          if (!subscription) {
            return () => {
            };
          }
          return subscribeUpdates(
            shouldHandleStateChanges,
            store,
            subscription,
            // @ts-ignore
            childPropsSelector,
            lastWrapperProps,
            lastChildProps,
            renderIsScheduled,
            isMounted,
            childPropsFromStoreUpdate,
            notifyNestedSubs,
            reactListener
          );
        };
        return subscribe;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
        lastWrapperProps,
        lastChildProps,
        renderIsScheduled,
        wrapperProps,
        childPropsFromStoreUpdate,
        notifyNestedSubs
      ]);
      let actualChildProps;
      try {
        actualChildProps = React4.useSyncExternalStore(
          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
          subscribeForReact,
          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
          actualChildPropsSelector,
          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
        );
      } catch (err) {
        if (latestSubscriptionCallbackError.current) {
          ;
          err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
        }
        throw err;
      }
      useIsomorphicLayoutEffect2(() => {
        latestSubscriptionCallbackError.current = void 0;
        childPropsFromStoreUpdate.current = void 0;
        lastChildProps.current = actualChildProps;
      });
      const renderedWrappedComponent = React4.useMemo(() => {
        return (
          // @ts-ignore
          React4.createElement(
            WrappedComponent,
            {
              ...actualChildProps,
              ref: reactReduxForwardedRef
            }
          )
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      const renderedChild = React4.useMemo(() => {
        if (shouldHandleStateChanges) {
          return React4.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = React4.memo(ConnectFunction);
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef8) {
      const _forwarded = React4.forwardRef(
        function forwardConnectRef(props, ref2) {
          return React4.createElement(Connect, { ...props, reactReduxForwardedRef: ref2 });
        }
      );
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoistNonReactStatics(forwarded, WrappedComponent);
    }
    return hoistNonReactStatics(Connect, WrappedComponent);
  };
  return wrapWithConnect;
}
var connect_default = connect;
function Provider(providerProps) {
  const { children, context, serverState, store } = providerProps;
  const contextValue = React4.useMemo(() => {
    const subscription = createSubscription(store);
    const baseContextValue = {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    if (false) {
      return baseContextValue;
    } else {
      const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
      return Object.assign(baseContextValue, {
        stabilityCheck,
        identityFunctionCheck
      });
    }
  }, [store, serverState]);
  const previousState = React4.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect2(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return React4.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = React4.useContext(context);
    if (!contextValue) {
      throw new Error(
        "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
      );
    }
    return contextValue;
  };
}
var useReduxContext = createReduxContextHook();
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context)
  );
  const useStore2 = () => {
    const { store } = useReduxContext2();
    return store;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store = useStore2();
    return store.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = createDispatchHook();
var refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  const useSelector2 = (selector, equalityFnOrOptions = {}) => {
    const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
    if (true) {
      if (!selector) {
        throw new Error(`You must pass a selector to useSelector`);
      }
      if (typeof selector !== "function") {
        throw new Error(`You must pass a function as a selector to useSelector`);
      }
      if (typeof equalityFn !== "function") {
        throw new Error(
          `You must pass a function as an equality function to useSelector`
        );
      }
    }
    const reduxContext = useReduxContext2();
    const { store, subscription, getServerState } = reduxContext;
    const firstRun = React4.useRef(true);
    const wrappedSelector = React4.useCallback(
      {
        [selector.name](state) {
          const selected = selector(state);
          if (true) {
            const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
            const { identityFunctionCheck, stabilityCheck } = reduxContext;
            const {
              identityFunctionCheck: finalIdentityFunctionCheck,
              stabilityCheck: finalStabilityCheck
            } = {
              stabilityCheck,
              identityFunctionCheck,
              ...devModeChecks
            };
            if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
              const toCompare = selector(state);
              if (!equalityFn(selected, toCompare)) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ;
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                  {
                    state,
                    selected,
                    selected2: toCompare,
                    stack
                  }
                );
              }
            }
            if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
              if (selected === state) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ;
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                  { stack }
                );
              }
            }
            if (firstRun.current) firstRun.current = false;
          }
          return selected;
        }
      }[selector.name],
      [selector]
    );
    const selectedState = (0, import_with_selector.useSyncExternalStoreWithSelector)(
      subscription.addNestedSub,
      store.getState,
      getServerState || store.getState,
      wrappedSelector,
      equalityFn
    );
    React4.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
var useSelector = createSelectorHook();

// ../../../node_modules/use-memo-one/dist/use-memo-one.esm.js
var import_react5 = __toESM(require_react());
function areInputsEqual2(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (newInputs[i2] !== lastInputs[i2]) {
      return false;
    }
  }
  return true;
}
function useMemoOne(getResult, inputs) {
  var initial = (0, import_react5.useState)(function() {
    return {
      inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = (0, import_react5.useRef)(true);
  var committed = (0, import_react5.useRef)(initial);
  var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual2(inputs, committed.current.inputs));
  var cache = useCache ? committed.current : {
    inputs,
    result: getResult()
  };
  (0, import_react5.useEffect)(function() {
    isFirstRun.current = false;
    committed.current = cache;
  }, [cache]);
  return cache.result;
}
function useCallbackOne(callback, inputs) {
  return useMemoOne(function() {
    return callback;
  }, inputs);
}
var useMemo6 = useMemoOne;
var useCallback6 = useCallbackOne;

// ../../../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant2(condition, message2) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message2 === "function" ? message2() : message2;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// ../../../node_modules/css-box-model/dist/css-box-model.esm.js
var getRect = function getRect2(_ref) {
  var top2 = _ref.top, right2 = _ref.right, bottom2 = _ref.bottom, left2 = _ref.left;
  var width = right2 - left2;
  var height = bottom2 - top2;
  var rect = {
    top: top2,
    right: right2,
    bottom: bottom2,
    left: left2,
    width,
    height,
    x: left2,
    y: top2,
    center: {
      x: (right2 + left2) / 2,
      y: (bottom2 + top2) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var shift = function shift2(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? noSpacing : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border,
    padding
  };
};
var parse3 = function parse4(raw) {
  var value = raw.slice(0, -2);
  var suffix2 = raw.slice(-2);
  if (suffix2 !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? true ? invariant2(false, "Could not parse value [raw: " + raw + ", without suffix: " + value + "]") : invariant2(false) : void 0;
  return result;
};
var getWindowScroll = function getWindowScroll2() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
var offset = function offset2(original, change) {
  var borderBox = original.borderBox, border = original.border, margin = original.margin, padding = original.padding;
  var shifted = shift(borderBox, change);
  return createBox({
    borderBox: shifted,
    border,
    margin,
    padding
  });
};
var withScroll = function withScroll2(original, scroll2) {
  if (scroll2 === void 0) {
    scroll2 = getWindowScroll();
  }
  return offset(original, scroll2);
};
var calculateBox = function calculateBox2(borderBox, styles2) {
  var margin = {
    top: parse3(styles2.marginTop),
    right: parse3(styles2.marginRight),
    bottom: parse3(styles2.marginBottom),
    left: parse3(styles2.marginLeft)
  };
  var padding = {
    top: parse3(styles2.paddingTop),
    right: parse3(styles2.paddingRight),
    bottom: parse3(styles2.paddingBottom),
    left: parse3(styles2.paddingLeft)
  };
  var border = {
    top: parse3(styles2.borderTopWidth),
    right: parse3(styles2.borderRightWidth),
    bottom: parse3(styles2.borderBottomWidth),
    left: parse3(styles2.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border
  });
};
var getBox = function getBox2(el2) {
  var borderBox = el2.getBoundingClientRect();
  var styles2 = window.getComputedStyle(el2);
  return calculateBox(borderBox, styles2);
};

// ../../../node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN2 = Number.isNaN || function ponyfill2(value) {
  return typeof value === "number" && value !== value;
};
function isEqual2(first2, second) {
  if (first2 === second) {
    return true;
  }
  if (safeIsNaN2(first2) && safeIsNaN2(second)) {
    return true;
  }
  return false;
}
function areInputsEqual3(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual2(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne2(resultFn, isEqual4) {
  if (isEqual4 === void 0) {
    isEqual4 = areInputsEqual3;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache && cache.lastThis === this && isEqual4(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}

// ../../../node_modules/raf-schd/dist/raf-schd.esm.js
var rafSchd = function rafSchd2(fn2) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn2.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
var raf_schd_esm_default = rafSchd;

// ../../../node_modules/@hello-pangea/dnd/dist/dnd.esm.js
var isProduction$1 = false;
var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;
var clean$2 = (value) => value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
var getDevMessage = (message2) => clean$2(`
  %c@hello-pangea/dnd

  %c${clean$2(message2)}

  %c👷‍ This is a development only message. It will be removed in production builds.
`);
var getFormattedMessage = (message2) => [getDevMessage(message2), "color: #00C584; font-size: 1.2em; font-weight: bold;", "line-height: 1.5", "color: #723874;"];
var isDisabledFlag = "__@hello-pangea/dnd-disable-dev-warnings";
function log(type, message2) {
  if (isProduction$1) {
    return;
  }
  if (typeof window !== "undefined" && window[isDisabledFlag]) {
    return;
  }
  console[type](...getFormattedMessage(message2));
}
var warning4 = log.bind(null, "warn");
var error = log.bind(null, "error");
function noop$2() {
}
function getOptions(shared2, fromBinding) {
  return {
    ...shared2,
    ...fromBinding
  };
}
function bindEvents(el2, bindings, sharedOptions) {
  const unbindings = bindings.map((binding) => {
    const options2 = getOptions(sharedOptions, binding.options);
    el2.addEventListener(binding.eventName, binding.fn, options2);
    return function unbind() {
      el2.removeEventListener(binding.eventName, binding.fn, options2);
    };
  });
  return function unbindAll() {
    unbindings.forEach((unbind) => {
      unbind();
    });
  };
}
var isProduction2 = false;
var prefix$1 = "Invariant failed";
var RbdInvariant = class extends Error {
};
RbdInvariant.prototype.toString = function toString3() {
  return this.message;
};
function invariant3(condition, message2) {
  if (isProduction2) {
    throw new RbdInvariant(prefix$1);
  } else {
    throw new RbdInvariant(`${prefix$1}: ${message2 || ""}`);
  }
}
var ErrorBoundary = class extends import_react6.default.Component {
  constructor(...args) {
    super(...args);
    this.callbacks = null;
    this.unbind = noop$2;
    this.onWindowError = (event) => {
      const callbacks = this.getCallbacks();
      if (callbacks.isDragging()) {
        callbacks.tryAbort();
        true ? warning4(`
        An error was caught by our window 'error' event listener while a drag was occurring.
        The active drag has been aborted.
      `) : void 0;
      }
      const err = event.error;
      if (err instanceof RbdInvariant) {
        event.preventDefault();
        if (true) {
          error(err.message);
        }
      }
    };
    this.getCallbacks = () => {
      if (!this.callbacks) {
        throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");
      }
      return this.callbacks;
    };
    this.setCallbacks = (callbacks) => {
      this.callbacks = callbacks;
    };
  }
  componentDidMount() {
    this.unbind = bindEvents(window, [{
      eventName: "error",
      fn: this.onWindowError
    }]);
  }
  componentDidCatch(err) {
    if (err instanceof RbdInvariant) {
      if (true) {
        error(err.message);
      }
      this.setState({});
      return;
    }
    throw err;
  }
  componentWillUnmount() {
    this.unbind();
  }
  render() {
    return this.props.children(this.setCallbacks);
  }
};
var dragHandleUsageInstructions = `
  Press space bar to start a drag.
  When dragging you can use the arrow keys to move the item around and escape to cancel.
  Some screen readers may require you to be in focus mode or to use your pass through key
`;
var position = (index2) => index2 + 1;
var onDragStart = (start3) => `
  You have lifted an item in position ${position(start3.source.index)}
`;
var withLocation = (source, destination) => {
  const isInHomeList = source.droppableId === destination.droppableId;
  const startPosition = position(source.index);
  const endPosition = position(destination.index);
  if (isInHomeList) {
    return `
      You have moved the item from position ${startPosition}
      to position ${endPosition}
    `;
  }
  return `
    You have moved the item from position ${startPosition}
    in list ${source.droppableId}
    to list ${destination.droppableId}
    in position ${endPosition}
  `;
};
var withCombine = (id2, source, combine2) => {
  const inHomeList = source.droppableId === combine2.droppableId;
  if (inHomeList) {
    return `
      The item ${id2}
      has been combined with ${combine2.draggableId}`;
  }
  return `
      The item ${id2}
      in list ${source.droppableId}
      has been combined with ${combine2.draggableId}
      in list ${combine2.droppableId}
    `;
};
var onDragUpdate = (update2) => {
  const location = update2.destination;
  if (location) {
    return withLocation(update2.source, location);
  }
  const combine2 = update2.combine;
  if (combine2) {
    return withCombine(update2.draggableId, update2.source, combine2);
  }
  return "You are over an area that cannot be dropped on";
};
var returnedToStart = (source) => `
  The item has returned to its starting position
  of ${position(source.index)}
`;
var onDragEnd = (result) => {
  if (result.reason === "CANCEL") {
    return `
      Movement cancelled.
      ${returnedToStart(result.source)}
    `;
  }
  const location = result.destination;
  const combine2 = result.combine;
  if (location) {
    return `
      You have dropped the item.
      ${withLocation(result.source, location)}
    `;
  }
  if (combine2) {
    return `
      You have dropped the item.
      ${withCombine(result.draggableId, result.source, combine2)}
    `;
  }
  return `
    The item has been dropped while not over a drop area.
    ${returnedToStart(result.source)}
  `;
};
var preset = {
  dragHandleUsageInstructions,
  onDragStart,
  onDragUpdate,
  onDragEnd
};
var origin = {
  x: 0,
  y: 0
};
var add2 = (point1, point2) => ({
  x: point1.x + point2.x,
  y: point1.y + point2.y
});
var subtract = (point1, point2) => ({
  x: point1.x - point2.x,
  y: point1.y - point2.y
});
var isEqual$1 = (point1, point2) => point1.x === point2.x && point1.y === point2.y;
var negate = (point) => ({
  x: point.x !== 0 ? -point.x : 0,
  y: point.y !== 0 ? -point.y : 0
});
var patch = (line, value, otherValue = 0) => {
  if (line === "x") {
    return {
      x: value,
      y: otherValue
    };
  }
  return {
    x: otherValue,
    y: value
  };
};
var distance = (point1, point2) => Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);
var closest$1 = (target, points) => Math.min(...points.map((point) => distance(target, point)));
var apply = (fn2) => (point) => ({
  x: fn2(point.x),
  y: fn2(point.y)
});
var executeClip = (frame, subject) => {
  const result = getRect({
    top: Math.max(subject.top, frame.top),
    right: Math.min(subject.right, frame.right),
    bottom: Math.min(subject.bottom, frame.bottom),
    left: Math.max(subject.left, frame.left)
  });
  if (result.width <= 0 || result.height <= 0) {
    return null;
  }
  return result;
};
var offsetByPosition = (spacing, point) => ({
  top: spacing.top + point.y,
  left: spacing.left + point.x,
  bottom: spacing.bottom + point.y,
  right: spacing.right + point.x
});
var getCorners = (spacing) => [{
  x: spacing.left,
  y: spacing.top
}, {
  x: spacing.right,
  y: spacing.top
}, {
  x: spacing.left,
  y: spacing.bottom
}, {
  x: spacing.right,
  y: spacing.bottom
}];
var noSpacing2 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var scroll$1 = (target, frame) => {
  if (!frame) {
    return target;
  }
  return offsetByPosition(target, frame.scroll.diff.displacement);
};
var increase = (target, axis, withPlaceholder) => {
  if (withPlaceholder && withPlaceholder.increasedBy) {
    return {
      ...target,
      [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]
    };
  }
  return target;
};
var clip = (target, frame) => {
  if (frame && frame.shouldClipSubject) {
    return executeClip(frame.pageMarginBox, target);
  }
  return getRect(target);
};
var getSubject = ({
  page,
  withPlaceholder,
  axis,
  frame
}) => {
  const scrolled = scroll$1(page.marginBox, frame);
  const increased = increase(scrolled, axis, withPlaceholder);
  const clipped = clip(increased, frame);
  return {
    page,
    withPlaceholder,
    active: clipped
  };
};
var scrollDroppable = (droppable2, newScroll) => {
  !droppable2.frame ? true ? invariant3() : invariant3() : void 0;
  const scrollable = droppable2.frame;
  const scrollDiff = subtract(newScroll, scrollable.scroll.initial);
  const scrollDisplacement = negate(scrollDiff);
  const frame = {
    ...scrollable,
    scroll: {
      initial: scrollable.scroll.initial,
      current: newScroll,
      diff: {
        value: scrollDiff,
        displacement: scrollDisplacement
      },
      max: scrollable.scroll.max
    }
  };
  const subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: droppable2.subject.withPlaceholder,
    axis: droppable2.axis,
    frame
  });
  const result = {
    ...droppable2,
    frame,
    subject
  };
  return result;
};
var toDroppableMap = memoizeOne2((droppables) => droppables.reduce((previous, current) => {
  previous[current.descriptor.id] = current;
  return previous;
}, {}));
var toDraggableMap = memoizeOne2((draggables) => draggables.reduce((previous, current) => {
  previous[current.descriptor.id] = current;
  return previous;
}, {}));
var toDroppableList = memoizeOne2((droppables) => Object.values(droppables));
var toDraggableList = memoizeOne2((draggables) => Object.values(draggables));
var getDraggablesInsideDroppable = memoizeOne2((droppableId, draggables) => {
  const result = toDraggableList(draggables).filter((draggable2) => droppableId === draggable2.descriptor.droppableId).sort((a2, b2) => a2.descriptor.index - b2.descriptor.index);
  return result;
});
function tryGetDestination(impact) {
  if (impact.at && impact.at.type === "REORDER") {
    return impact.at.destination;
  }
  return null;
}
function tryGetCombine(impact) {
  if (impact.at && impact.at.type === "COMBINE") {
    return impact.at.combine;
  }
  return null;
}
var removeDraggableFromList = memoizeOne2((remove, list) => list.filter((item) => item.descriptor.id !== remove.descriptor.id));
var moveToNextCombine = ({
  isMovingForward,
  draggable: draggable2,
  destination,
  insideDestination,
  previousImpact
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const location = tryGetDestination(previousImpact);
  if (!location) {
    return null;
  }
  function getImpact(target) {
    const at = {
      type: "COMBINE",
      combine: {
        draggableId: target,
        droppableId: destination.descriptor.id
      }
    };
    return {
      ...previousImpact,
      at
    };
  }
  const all = previousImpact.displaced.all;
  const closestId = all.length ? all[0] : null;
  if (isMovingForward) {
    return closestId ? getImpact(closestId) : null;
  }
  const withoutDraggable = removeDraggableFromList(draggable2, insideDestination);
  if (!closestId) {
    if (!withoutDraggable.length) {
      return null;
    }
    const last = withoutDraggable[withoutDraggable.length - 1];
    return getImpact(last.descriptor.id);
  }
  const indexOfClosest = withoutDraggable.findIndex((d) => d.descriptor.id === closestId);
  !(indexOfClosest !== -1) ? true ? invariant3(false, "Could not find displaced item in set") : invariant3() : void 0;
  const proposedIndex = indexOfClosest - 1;
  if (proposedIndex < 0) {
    return null;
  }
  const before = withoutDraggable[proposedIndex];
  return getImpact(before.descriptor.id);
};
var isHomeOf = (draggable2, destination) => draggable2.descriptor.droppableId === destination.descriptor.id;
var noDisplacedBy = {
  point: origin,
  value: 0
};
var emptyGroups = {
  invisible: {},
  visible: {},
  all: []
};
var noImpact = {
  displaced: emptyGroups,
  displacedBy: noDisplacedBy,
  at: null
};
var isWithin = (lowerBound, upperBound) => (value) => lowerBound <= value && value <= upperBound;
var isPartiallyVisibleThroughFrame = (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    if (isContained) {
      return true;
    }
    const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
    const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
    const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
    if (isPartiallyContained) {
      return true;
    }
    const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
    const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
    const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
    if (isTargetBiggerThanFrame) {
      return true;
    }
    const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
    return isTargetBiggerOnOneAxis;
  };
};
var isTotallyVisibleThroughFrame = (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    return isContained;
  };
};
var vertical = {
  direction: "vertical",
  line: "y",
  crossAxisLine: "x",
  start: "top",
  end: "bottom",
  size: "height",
  crossAxisStart: "left",
  crossAxisEnd: "right",
  crossAxisSize: "width"
};
var horizontal = {
  direction: "horizontal",
  line: "x",
  crossAxisLine: "y",
  start: "left",
  end: "right",
  size: "width",
  crossAxisStart: "top",
  crossAxisEnd: "bottom",
  crossAxisSize: "height"
};
var isTotallyVisibleThroughFrameOnAxis = (axis) => (frame) => {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return (subject) => {
    if (axis === vertical) {
      return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
    }
    return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
  };
};
var getDroppableDisplaced = (target, destination) => {
  const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
  return offsetByPosition(target, displacement);
};
var isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn) => {
  if (!destination.subject.active) {
    return false;
  }
  return isVisibleThroughFrameFn(destination.subject.active)(target);
};
var isVisibleInViewport = (target, viewport2, isVisibleThroughFrameFn) => isVisibleThroughFrameFn(viewport2)(target);
var isVisible$1 = ({
  target: toBeDisplaced,
  destination,
  viewport: viewport2,
  withDroppableDisplacement: withDroppableDisplacement2,
  isVisibleThroughFrameFn
}) => {
  const displacedTarget = withDroppableDisplacement2 ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport2, isVisibleThroughFrameFn);
};
var isPartiallyVisible = (args) => isVisible$1({
  ...args,
  isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
});
var isTotallyVisible = (args) => isVisible$1({
  ...args,
  isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
});
var isTotallyVisibleOnAxis = (args) => isVisible$1({
  ...args,
  isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
});
var getShouldAnimate = (id2, last, forceShouldAnimate) => {
  if (typeof forceShouldAnimate === "boolean") {
    return forceShouldAnimate;
  }
  if (!last) {
    return true;
  }
  const {
    invisible,
    visible
  } = last;
  if (invisible[id2]) {
    return false;
  }
  const previous = visible[id2];
  return previous ? previous.shouldAnimate : true;
};
function getTarget(draggable2, displacedBy) {
  const marginBox = draggable2.page.marginBox;
  const expandBy = {
    top: displacedBy.point.y,
    right: 0,
    bottom: 0,
    left: displacedBy.point.x
  };
  return getRect(expand(marginBox, expandBy));
}
function getDisplacementGroups({
  afterDragging,
  destination,
  displacedBy,
  viewport: viewport2,
  forceShouldAnimate,
  last
}) {
  return afterDragging.reduce(function process2(groups, draggable2) {
    const target = getTarget(draggable2, displacedBy);
    const id2 = draggable2.descriptor.id;
    groups.all.push(id2);
    const isVisible2 = isPartiallyVisible({
      target,
      destination,
      viewport: viewport2,
      withDroppableDisplacement: true
    });
    if (!isVisible2) {
      groups.invisible[draggable2.descriptor.id] = true;
      return groups;
    }
    const shouldAnimate = getShouldAnimate(id2, last, forceShouldAnimate);
    const displacement = {
      draggableId: id2,
      shouldAnimate
    };
    groups.visible[id2] = displacement;
    return groups;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}
function getIndexOfLastItem(draggables, options2) {
  if (!draggables.length) {
    return 0;
  }
  const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
  return options2.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
}
function goAtEnd({
  insideDestination,
  inHomeList,
  displacedBy,
  destination
}) {
  const newIndex = getIndexOfLastItem(insideDestination, {
    inHomeList
  });
  return {
    displaced: emptyGroups,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: newIndex
      }
    }
  };
}
function calculateReorderImpact({
  draggable: draggable2,
  insideDestination,
  destination,
  viewport: viewport2,
  displacedBy,
  last,
  index: index2,
  forceShouldAnimate
}) {
  const inHomeList = isHomeOf(draggable2, destination);
  if (index2 == null) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  const match85 = insideDestination.find((item) => item.descriptor.index === index2);
  if (!match85) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const sliceFrom = insideDestination.indexOf(match85);
  const impacted = withoutDragging.slice(sliceFrom);
  const displaced = getDisplacementGroups({
    afterDragging: impacted,
    destination,
    displacedBy,
    last,
    viewport: viewport2.frame,
    forceShouldAnimate
  });
  return {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: index2
      }
    }
  };
}
function didStartAfterCritical(draggableId, afterCritical) {
  return Boolean(afterCritical.effected[draggableId]);
}
var fromCombine = ({
  isMovingForward,
  destination,
  draggables,
  combine: combine2,
  afterCritical
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const combineId = combine2.draggableId;
  const combineWith = draggables[combineId];
  const combineWithIndex = combineWith.descriptor.index;
  const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
  if (didCombineWithStartAfterCritical) {
    if (isMovingForward) {
      return combineWithIndex;
    }
    return combineWithIndex - 1;
  }
  if (isMovingForward) {
    return combineWithIndex + 1;
  }
  return combineWithIndex;
};
var fromReorder = ({
  isMovingForward,
  isInHomeList,
  insideDestination,
  location
}) => {
  if (!insideDestination.length) {
    return null;
  }
  const currentIndex = location.index;
  const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
  const firstIndex = insideDestination[0].descriptor.index;
  const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
  const upperBound = isInHomeList ? lastIndex : lastIndex + 1;
  if (proposedIndex < firstIndex) {
    return null;
  }
  if (proposedIndex > upperBound) {
    return null;
  }
  return proposedIndex;
};
var moveToNextIndex = ({
  isMovingForward,
  isInHomeList,
  draggable: draggable2,
  draggables,
  destination,
  insideDestination,
  previousImpact,
  viewport: viewport2,
  afterCritical
}) => {
  const wasAt = previousImpact.at;
  !wasAt ? true ? invariant3(false, "Cannot move in direction without previous impact location") : invariant3() : void 0;
  if (wasAt.type === "REORDER") {
    const newIndex2 = fromReorder({
      isMovingForward,
      isInHomeList,
      location: wasAt.destination,
      insideDestination
    });
    if (newIndex2 == null) {
      return null;
    }
    return calculateReorderImpact({
      draggable: draggable2,
      insideDestination,
      destination,
      viewport: viewport2,
      last: previousImpact.displaced,
      displacedBy: previousImpact.displacedBy,
      index: newIndex2
    });
  }
  const newIndex = fromCombine({
    isMovingForward,
    destination,
    displaced: previousImpact.displaced,
    draggables,
    combine: wasAt.combine,
    afterCritical
  });
  if (newIndex == null) {
    return null;
  }
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    last: previousImpact.displaced,
    displacedBy: previousImpact.displacedBy,
    index: newIndex
  });
};
var getCombinedItemDisplacement = ({
  displaced,
  afterCritical,
  combineWith,
  displacedBy
}) => {
  const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
  if (didStartAfterCritical(combineWith, afterCritical)) {
    return isDisplaced ? origin : negate(displacedBy.point);
  }
  return isDisplaced ? displacedBy.point : origin;
};
var whenCombining = ({
  afterCritical,
  impact,
  draggables
}) => {
  const combine2 = tryGetCombine(impact);
  !combine2 ? true ? invariant3() : invariant3() : void 0;
  const combineWith = combine2.draggableId;
  const center = draggables[combineWith].page.borderBox.center;
  const displaceBy = getCombinedItemDisplacement({
    displaced: impact.displaced,
    afterCritical,
    combineWith,
    displacedBy: impact.displacedBy
  });
  return add2(center, displaceBy);
};
var distanceFromStartToBorderBoxCenter = (axis, box) => box.margin[axis.start] + box.borderBox[axis.size] / 2;
var distanceFromEndToBorderBoxCenter = (axis, box) => box.margin[axis.end] + box.borderBox[axis.size] / 2;
var getCrossAxisBorderBoxCenter = (axis, target, isMoving) => target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
var goAfter = ({
  axis,
  moveRelativeTo,
  isMoving
}) => patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
var goBefore = ({
  axis,
  moveRelativeTo,
  isMoving
}) => patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
var goIntoStart = ({
  axis,
  moveInto,
  isMoving
}) => patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
var whenReordering = ({
  impact,
  draggable: draggable2,
  draggables,
  droppable: droppable2,
  afterCritical
}) => {
  const insideDestination = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  const draggablePage = draggable2.page;
  const axis = droppable2.axis;
  if (!insideDestination.length) {
    return goIntoStart({
      axis,
      moveInto: droppable2.page,
      isMoving: draggablePage
    });
  }
  const {
    displaced,
    displacedBy
  } = impact;
  const closestAfter = displaced.all[0];
  if (closestAfter) {
    const closest2 = draggables[closestAfter];
    if (didStartAfterCritical(closestAfter, afterCritical)) {
      return goBefore({
        axis,
        moveRelativeTo: closest2.page,
        isMoving: draggablePage
      });
    }
    const withDisplacement = offset(closest2.page, displacedBy.point);
    return goBefore({
      axis,
      moveRelativeTo: withDisplacement,
      isMoving: draggablePage
    });
  }
  const last = insideDestination[insideDestination.length - 1];
  if (last.descriptor.id === draggable2.descriptor.id) {
    return draggablePage.borderBox.center;
  }
  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
    const page = offset(last.page, negate(afterCritical.displacedBy.point));
    return goAfter({
      axis,
      moveRelativeTo: page,
      isMoving: draggablePage
    });
  }
  return goAfter({
    axis,
    moveRelativeTo: last.page,
    isMoving: draggablePage
  });
};
var withDroppableDisplacement = (droppable2, point) => {
  const frame = droppable2.frame;
  if (!frame) {
    return point;
  }
  return add2(point, frame.scroll.diff.displacement);
};
var getResultWithoutDroppableDisplacement = ({
  impact,
  draggable: draggable2,
  droppable: droppable2,
  draggables,
  afterCritical
}) => {
  const original = draggable2.page.borderBox.center;
  const at = impact.at;
  if (!droppable2) {
    return original;
  }
  if (!at) {
    return original;
  }
  if (at.type === "REORDER") {
    return whenReordering({
      impact,
      draggable: draggable2,
      draggables,
      droppable: droppable2,
      afterCritical
    });
  }
  return whenCombining({
    impact,
    draggables,
    afterCritical
  });
};
var getPageBorderBoxCenterFromImpact = (args) => {
  const withoutDisplacement = getResultWithoutDroppableDisplacement(args);
  const droppable2 = args.droppable;
  const withDisplacement = droppable2 ? withDroppableDisplacement(droppable2, withoutDisplacement) : withoutDisplacement;
  return withDisplacement;
};
var scrollViewport = (viewport2, newScroll) => {
  const diff = subtract(newScroll, viewport2.scroll.initial);
  const displacement = negate(diff);
  const frame = getRect({
    top: newScroll.y,
    bottom: newScroll.y + viewport2.frame.height,
    left: newScroll.x,
    right: newScroll.x + viewport2.frame.width
  });
  const updated = {
    frame,
    scroll: {
      initial: viewport2.scroll.initial,
      max: viewport2.scroll.max,
      current: newScroll,
      diff: {
        value: diff,
        displacement
      }
    }
  };
  return updated;
};
function getDraggables$1(ids, draggables) {
  return ids.map((id2) => draggables[id2]);
}
function tryGetVisible(id2, groups) {
  for (let i2 = 0; i2 < groups.length; i2++) {
    const displacement = groups[i2].visible[id2];
    if (displacement) {
      return displacement;
    }
  }
  return null;
}
var speculativelyIncrease = ({
  impact,
  viewport: viewport2,
  destination,
  draggables,
  maxScrollChange
}) => {
  const scrolledViewport = scrollViewport(viewport2, add2(viewport2.scroll.current, maxScrollChange));
  const scrolledDroppable = destination.frame ? scrollDroppable(destination, add2(destination.frame.scroll.current, maxScrollChange)) : destination;
  const last = impact.displaced;
  const withViewportScroll = getDisplacementGroups({
    afterDragging: getDraggables$1(last.all, draggables),
    destination,
    displacedBy: impact.displacedBy,
    viewport: scrolledViewport.frame,
    last,
    forceShouldAnimate: false
  });
  const withDroppableScroll2 = getDisplacementGroups({
    afterDragging: getDraggables$1(last.all, draggables),
    destination: scrolledDroppable,
    displacedBy: impact.displacedBy,
    viewport: viewport2.frame,
    last,
    forceShouldAnimate: false
  });
  const invisible = {};
  const visible = {};
  const groups = [last, withViewportScroll, withDroppableScroll2];
  last.all.forEach((id2) => {
    const displacement = tryGetVisible(id2, groups);
    if (displacement) {
      visible[id2] = displacement;
      return;
    }
    invisible[id2] = true;
  });
  const newImpact = {
    ...impact,
    displaced: {
      all: last.all,
      invisible,
      visible
    }
  };
  return newImpact;
};
var withViewportDisplacement = (viewport2, point) => add2(viewport2.scroll.diff.displacement, point);
var getClientFromPageBorderBoxCenter = ({
  pageBorderBoxCenter,
  draggable: draggable2,
  viewport: viewport2
}) => {
  const withoutPageScrollChange = withViewportDisplacement(viewport2, pageBorderBoxCenter);
  const offset4 = subtract(withoutPageScrollChange, draggable2.page.borderBox.center);
  return add2(draggable2.client.borderBox.center, offset4);
};
var isTotallyVisibleInNewLocation = ({
  draggable: draggable2,
  destination,
  newPageBorderBoxCenter,
  viewport: viewport2,
  withDroppableDisplacement: withDroppableDisplacement2,
  onlyOnMainAxis = false
}) => {
  const changeNeeded = subtract(newPageBorderBoxCenter, draggable2.page.borderBox.center);
  const shifted = offsetByPosition(draggable2.page.borderBox, changeNeeded);
  const args = {
    target: shifted,
    destination,
    withDroppableDisplacement: withDroppableDisplacement2,
    viewport: viewport2
  };
  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
};
var moveToNextPlace = ({
  isMovingForward,
  draggable: draggable2,
  destination,
  draggables,
  previousImpact,
  viewport: viewport2,
  previousPageBorderBoxCenter,
  previousClientSelection,
  afterCritical
}) => {
  if (!destination.isEnabled) {
    return null;
  }
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const isInHomeList = isHomeOf(draggable2, destination);
  const impact = moveToNextCombine({
    isMovingForward,
    draggable: draggable2,
    destination,
    insideDestination,
    previousImpact
  }) || moveToNextIndex({
    isMovingForward,
    isInHomeList,
    draggable: draggable2,
    draggables,
    destination,
    insideDestination,
    previousImpact,
    viewport: viewport2,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
    draggable: draggable2,
    destination,
    newPageBorderBoxCenter: pageBorderBoxCenter,
    viewport: viewport2.frame,
    withDroppableDisplacement: false,
    onlyOnMainAxis: true
  });
  if (isVisibleInNewLocation) {
    const clientSelection = getClientFromPageBorderBoxCenter({
      pageBorderBoxCenter,
      draggable: draggable2,
      viewport: viewport2
    });
    return {
      clientSelection,
      impact,
      scrollJumpRequest: null
    };
  }
  const distance2 = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
  const cautious = speculativelyIncrease({
    impact,
    viewport: viewport2,
    destination,
    draggables,
    maxScrollChange: distance2
  });
  return {
    clientSelection: previousClientSelection,
    impact: cautious,
    scrollJumpRequest: distance2
  };
};
var getKnownActive = (droppable2) => {
  const rect = droppable2.subject.active;
  !rect ? true ? invariant3(false, "Cannot get clipped area from droppable") : invariant3() : void 0;
  return rect;
};
var getBestCrossAxisDroppable = ({
  isMovingForward,
  pageBorderBoxCenter,
  source,
  droppables,
  viewport: viewport2
}) => {
  const active = source.subject.active;
  if (!active) {
    return null;
  }
  const axis = source.axis;
  const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
  const candidates = toDroppableList(droppables).filter((droppable2) => droppable2 !== source).filter((droppable2) => droppable2.isEnabled).filter((droppable2) => Boolean(droppable2.subject.active)).filter((droppable2) => isPartiallyVisibleThroughFrame(viewport2.frame)(getKnownActive(droppable2))).filter((droppable2) => {
    const activeOfTarget = getKnownActive(droppable2);
    if (isMovingForward) {
      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
    }
    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
  }).filter((droppable2) => {
    const activeOfTarget = getKnownActive(droppable2);
    const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
  }).sort((a2, b2) => {
    const first2 = getKnownActive(a2)[axis.crossAxisStart];
    const second = getKnownActive(b2)[axis.crossAxisStart];
    if (isMovingForward) {
      return first2 - second;
    }
    return second - first2;
  }).filter((droppable2, index2, array2) => getKnownActive(droppable2)[axis.crossAxisStart] === getKnownActive(array2[0])[axis.crossAxisStart]);
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0];
  }
  const contains2 = candidates.filter((droppable2) => {
    const isWithinDroppable = isWithin(getKnownActive(droppable2)[axis.start], getKnownActive(droppable2)[axis.end]);
    return isWithinDroppable(pageBorderBoxCenter[axis.line]);
  });
  if (contains2.length === 1) {
    return contains2[0];
  }
  if (contains2.length > 1) {
    return contains2.sort((a2, b2) => getKnownActive(a2)[axis.start] - getKnownActive(b2)[axis.start])[0];
  }
  return candidates.sort((a2, b2) => {
    const first2 = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a2)));
    const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b2)));
    if (first2 !== second) {
      return first2 - second;
    }
    return getKnownActive(a2)[axis.start] - getKnownActive(b2)[axis.start];
  })[0];
};
var getCurrentPageBorderBoxCenter = (draggable2, afterCritical) => {
  const original = draggable2.page.borderBox.center;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
};
var getCurrentPageBorderBox = (draggable2, afterCritical) => {
  const original = draggable2.page.borderBox;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
};
var getClosestDraggable = ({
  pageBorderBoxCenter,
  viewport: viewport2,
  destination,
  insideDestination,
  afterCritical
}) => {
  const sorted = insideDestination.filter((draggable2) => isTotallyVisible({
    target: getCurrentPageBorderBox(draggable2, afterCritical),
    destination,
    viewport: viewport2.frame,
    withDroppableDisplacement: true
  })).sort((a2, b2) => {
    const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a2, afterCritical)));
    const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b2, afterCritical)));
    if (distanceToA < distanceToB) {
      return -1;
    }
    if (distanceToB < distanceToA) {
      return 1;
    }
    return a2.descriptor.index - b2.descriptor.index;
  });
  return sorted[0] || null;
};
var getDisplacedBy = memoizeOne2(function getDisplacedBy2(axis, displaceBy) {
  const displacement = displaceBy[axis.line];
  return {
    value: displacement,
    point: patch(axis.line, displacement)
  };
});
var getRequiredGrowthForPlaceholder = (droppable2, placeholderSize, draggables) => {
  const axis = droppable2.axis;
  if (droppable2.descriptor.mode === "virtual") {
    return patch(axis.line, placeholderSize[axis.line]);
  }
  const availableSpace = droppable2.subject.page.contentBox[axis.size];
  const insideDroppable = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  const spaceUsed = insideDroppable.reduce((sum, dimension) => sum + dimension.client.marginBox[axis.size], 0);
  const requiredSpace = spaceUsed + placeholderSize[axis.line];
  const needsToGrowBy = requiredSpace - availableSpace;
  if (needsToGrowBy <= 0) {
    return null;
  }
  return patch(axis.line, needsToGrowBy);
};
var withMaxScroll = (frame, max3) => ({
  ...frame,
  scroll: {
    ...frame.scroll,
    max: max3
  }
});
var addPlaceholder = (droppable2, draggable2, draggables) => {
  const frame = droppable2.frame;
  !!isHomeOf(draggable2, droppable2) ? true ? invariant3(false, "Should not add placeholder space to home list") : invariant3() : void 0;
  !!droppable2.subject.withPlaceholder ? true ? invariant3(false, "Cannot add placeholder size to a subject when it already has one") : invariant3() : void 0;
  const placeholderSize = getDisplacedBy(droppable2.axis, draggable2.displaceBy).point;
  const requiredGrowth = getRequiredGrowthForPlaceholder(droppable2, placeholderSize, draggables);
  const added = {
    placeholderSize,
    increasedBy: requiredGrowth,
    oldFrameMaxScroll: droppable2.frame ? droppable2.frame.scroll.max : null
  };
  if (!frame) {
    const subject2 = getSubject({
      page: droppable2.subject.page,
      withPlaceholder: added,
      axis: droppable2.axis,
      frame: droppable2.frame
    });
    return {
      ...droppable2,
      subject: subject2
    };
  }
  const maxScroll = requiredGrowth ? add2(frame.scroll.max, requiredGrowth) : frame.scroll.max;
  const newFrame = withMaxScroll(frame, maxScroll);
  const subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: added,
    axis: droppable2.axis,
    frame: newFrame
  });
  return {
    ...droppable2,
    subject,
    frame: newFrame
  };
};
var removePlaceholder = (droppable2) => {
  const added = droppable2.subject.withPlaceholder;
  !added ? true ? invariant3(false, "Cannot remove placeholder form subject when there was none") : invariant3() : void 0;
  const frame = droppable2.frame;
  if (!frame) {
    const subject2 = getSubject({
      page: droppable2.subject.page,
      axis: droppable2.axis,
      frame: null,
      withPlaceholder: null
    });
    return {
      ...droppable2,
      subject: subject2
    };
  }
  const oldMaxScroll = added.oldFrameMaxScroll;
  !oldMaxScroll ? true ? invariant3(false, "Expected droppable with frame to have old max frame scroll when removing placeholder") : invariant3() : void 0;
  const newFrame = withMaxScroll(frame, oldMaxScroll);
  const subject = getSubject({
    page: droppable2.subject.page,
    axis: droppable2.axis,
    frame: newFrame,
    withPlaceholder: null
  });
  return {
    ...droppable2,
    subject,
    frame: newFrame
  };
};
var moveToNewDroppable = ({
  previousPageBorderBoxCenter,
  moveRelativeTo,
  insideDestination,
  draggable: draggable2,
  draggables,
  destination,
  viewport: viewport2,
  afterCritical
}) => {
  if (!moveRelativeTo) {
    if (insideDestination.length) {
      return null;
    }
    const proposed = {
      displaced: emptyGroups,
      displacedBy: noDisplacedBy,
      at: {
        type: "REORDER",
        destination: {
          droppableId: destination.descriptor.id,
          index: 0
        }
      }
    };
    const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
      impact: proposed,
      draggable: draggable2,
      droppable: destination,
      draggables,
      afterCritical
    });
    const withPlaceholder = isHomeOf(draggable2, destination) ? destination : addPlaceholder(destination, draggable2, draggables);
    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({
      draggable: draggable2,
      destination: withPlaceholder,
      newPageBorderBoxCenter: proposedPageBorderBoxCenter,
      viewport: viewport2.frame,
      withDroppableDisplacement: false,
      onlyOnMainAxis: true
    });
    return isVisibleInNewLocation ? proposed : null;
  }
  const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
  const proposedIndex = (() => {
    const relativeTo = moveRelativeTo.descriptor.index;
    if (moveRelativeTo.descriptor.id === draggable2.descriptor.id) {
      return relativeTo;
    }
    if (isGoingBeforeTarget) {
      return relativeTo;
    }
    return relativeTo + 1;
  })();
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    displacedBy,
    last: emptyGroups,
    index: proposedIndex
  });
};
var moveCrossAxis = ({
  isMovingForward,
  previousPageBorderBoxCenter,
  draggable: draggable2,
  isOver,
  draggables,
  droppables,
  viewport: viewport2,
  afterCritical
}) => {
  const destination = getBestCrossAxisDroppable({
    isMovingForward,
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    source: isOver,
    droppables,
    viewport: viewport2
  });
  if (!destination) {
    return null;
  }
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const moveRelativeTo = getClosestDraggable({
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    viewport: viewport2,
    destination,
    insideDestination,
    afterCritical
  });
  const impact = moveToNewDroppable({
    previousPageBorderBoxCenter,
    destination,
    draggable: draggable2,
    draggables,
    moveRelativeTo,
    insideDestination,
    viewport: viewport2,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  const clientSelection = getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport: viewport2
  });
  return {
    clientSelection,
    impact,
    scrollJumpRequest: null
  };
};
var whatIsDraggedOver = (impact) => {
  const at = impact.at;
  if (!at) {
    return null;
  }
  if (at.type === "REORDER") {
    return at.destination.droppableId;
  }
  return at.combine.droppableId;
};
var getDroppableOver$1 = (impact, droppables) => {
  const id2 = whatIsDraggedOver(impact);
  return id2 ? droppables[id2] : null;
};
var moveInDirection = ({
  state,
  type
}) => {
  const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);
  const isMainAxisMovementAllowed = Boolean(isActuallyOver);
  const home2 = state.dimensions.droppables[state.critical.droppable.id];
  const isOver = isActuallyOver || home2;
  const direction2 = isOver.axis.direction;
  const isMovingOnMainAxis = direction2 === "vertical" && (type === "MOVE_UP" || type === "MOVE_DOWN") || direction2 === "horizontal" && (type === "MOVE_LEFT" || type === "MOVE_RIGHT");
  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
    return null;
  }
  const isMovingForward = type === "MOVE_DOWN" || type === "MOVE_RIGHT";
  const draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
  const {
    draggables,
    droppables
  } = state.dimensions;
  return isMovingOnMainAxis ? moveToNextPlace({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    destination: isOver,
    draggables,
    viewport: state.viewport,
    previousClientSelection: state.current.client.selection,
    previousImpact: state.impact,
    afterCritical: state.afterCritical
  }) : moveCrossAxis({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    isOver,
    draggables,
    droppables,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
};
function isMovementAllowed(state) {
  return state.phase === "DRAGGING" || state.phase === "COLLECTING";
}
function isPositionInFrame(frame) {
  const isWithinVertical = isWithin(frame.top, frame.bottom);
  const isWithinHorizontal = isWithin(frame.left, frame.right);
  return function run3(point) {
    return isWithinVertical(point.y) && isWithinHorizontal(point.x);
  };
}
function getHasOverlap(first2, second) {
  return first2.left < second.right && first2.right > second.left && first2.top < second.bottom && first2.bottom > second.top;
}
function getFurthestAway({
  pageBorderBox,
  draggable: draggable2,
  candidates
}) {
  const startCenter = draggable2.page.borderBox.center;
  const sorted = candidates.map((candidate) => {
    const axis = candidate.axis;
    const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
    return {
      id: candidate.descriptor.id,
      distance: distance(startCenter, target)
    };
  }).sort((a2, b2) => b2.distance - a2.distance);
  return sorted[0] ? sorted[0].id : null;
}
function getDroppableOver({
  pageBorderBox,
  draggable: draggable2,
  droppables
}) {
  const candidates = toDroppableList(droppables).filter((item) => {
    if (!item.isEnabled) {
      return false;
    }
    const active = item.subject.active;
    if (!active) {
      return false;
    }
    if (!getHasOverlap(pageBorderBox, active)) {
      return false;
    }
    if (isPositionInFrame(active)(pageBorderBox.center)) {
      return true;
    }
    const axis = item.axis;
    const childCenter = active.center[axis.crossAxisLine];
    const crossAxisStart = pageBorderBox[axis.crossAxisStart];
    const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
    const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
    const isStartContained = isContained(crossAxisStart);
    const isEndContained = isContained(crossAxisEnd);
    if (!isStartContained && !isEndContained) {
      return true;
    }
    if (isStartContained) {
      return crossAxisStart < childCenter;
    }
    return crossAxisEnd > childCenter;
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0].descriptor.id;
  }
  return getFurthestAway({
    pageBorderBox,
    draggable: draggable2,
    candidates
  });
}
var offsetRectByPosition = (rect, point) => getRect(offsetByPosition(rect, point));
var withDroppableScroll = (droppable2, area) => {
  const frame = droppable2.frame;
  if (!frame) {
    return area;
  }
  return offsetRectByPosition(area, frame.scroll.diff.value);
};
function getIsDisplaced({
  displaced,
  id: id2
}) {
  return Boolean(displaced.visible[id2] || displaced.invisible[id2]);
}
function atIndex({
  draggable: draggable2,
  closest: closest2,
  inHomeList
}) {
  if (!closest2) {
    return null;
  }
  if (!inHomeList) {
    return closest2.descriptor.index;
  }
  if (closest2.descriptor.index > draggable2.descriptor.index) {
    return closest2.descriptor.index - 1;
  }
  return closest2.descriptor.index;
}
var getReorderImpact = ({
  pageBorderBoxWithDroppableScroll: targetRect,
  draggable: draggable2,
  destination,
  insideDestination,
  last,
  viewport: viewport2,
  afterCritical
}) => {
  const axis = destination.axis;
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  const displacement = displacedBy.value;
  const targetStart = targetRect[axis.start];
  const targetEnd = targetRect[axis.end];
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const closest2 = withoutDragging.find((child) => {
    const id2 = child.descriptor.id;
    const childCenter = child.page.borderBox.center[axis.line];
    const didStartAfterCritical$1 = didStartAfterCritical(id2, afterCritical);
    const isDisplaced = getIsDisplaced({
      displaced: last,
      id: id2
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd <= childCenter;
      }
      return targetStart < childCenter - displacement;
    }
    if (isDisplaced) {
      return targetEnd <= childCenter + displacement;
    }
    return targetStart < childCenter;
  }) || null;
  const newIndex = atIndex({
    draggable: draggable2,
    closest: closest2,
    inHomeList: isHomeOf(draggable2, destination)
  });
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    last,
    displacedBy,
    index: newIndex
  });
};
var combineThresholdDivisor = 4;
var getCombineImpact = ({
  draggable: draggable2,
  pageBorderBoxWithDroppableScroll: targetRect,
  previousImpact,
  destination,
  insideDestination,
  afterCritical
}) => {
  if (!destination.isCombineEnabled) {
    return null;
  }
  const axis = destination.axis;
  const displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  const displacement = displacedBy.value;
  const targetStart = targetRect[axis.start];
  const targetEnd = targetRect[axis.end];
  const withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  const combineWith = withoutDragging.find((child) => {
    const id2 = child.descriptor.id;
    const childRect = child.page.borderBox;
    const childSize = childRect[axis.size];
    const threshold = childSize / combineThresholdDivisor;
    const didStartAfterCritical$1 = didStartAfterCritical(id2, afterCritical);
    const isDisplaced = getIsDisplaced({
      displaced: previousImpact.displaced,
      id: id2
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
      }
      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
    }
    if (isDisplaced) {
      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
    }
    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
  });
  if (!combineWith) {
    return null;
  }
  const impact = {
    displacedBy,
    displaced: previousImpact.displaced,
    at: {
      type: "COMBINE",
      combine: {
        draggableId: combineWith.descriptor.id,
        droppableId: destination.descriptor.id
      }
    }
  };
  return impact;
};
var getDragImpact = ({
  pageOffset,
  draggable: draggable2,
  draggables,
  droppables,
  previousImpact,
  viewport: viewport2,
  afterCritical
}) => {
  const pageBorderBox = offsetRectByPosition(draggable2.page.borderBox, pageOffset);
  const destinationId = getDroppableOver({
    pageBorderBox,
    draggable: draggable2,
    droppables
  });
  if (!destinationId) {
    return noImpact;
  }
  const destination = droppables[destinationId];
  const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
  return getCombineImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    previousImpact,
    destination,
    insideDestination,
    afterCritical
  }) || getReorderImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    destination,
    insideDestination,
    last: previousImpact.displaced,
    viewport: viewport2,
    afterCritical
  });
};
var patchDroppableMap = (droppables, updated) => ({
  ...droppables,
  [updated.descriptor.id]: updated
});
var clearUnusedPlaceholder = ({
  previousImpact,
  impact,
  droppables
}) => {
  const last = whatIsDraggedOver(previousImpact);
  const now2 = whatIsDraggedOver(impact);
  if (!last) {
    return droppables;
  }
  if (last === now2) {
    return droppables;
  }
  const lastDroppable = droppables[last];
  if (!lastDroppable.subject.withPlaceholder) {
    return droppables;
  }
  const updated = removePlaceholder(lastDroppable);
  return patchDroppableMap(droppables, updated);
};
var recomputePlaceholders = ({
  draggable: draggable2,
  draggables,
  droppables,
  previousImpact,
  impact
}) => {
  const cleaned = clearUnusedPlaceholder({
    previousImpact,
    impact,
    droppables
  });
  const isOver = whatIsDraggedOver(impact);
  if (!isOver) {
    return cleaned;
  }
  const droppable2 = droppables[isOver];
  if (isHomeOf(draggable2, droppable2)) {
    return cleaned;
  }
  if (droppable2.subject.withPlaceholder) {
    return cleaned;
  }
  const patched = addPlaceholder(droppable2, draggable2, draggables);
  return patchDroppableMap(cleaned, patched);
};
var update = ({
  state,
  clientSelection: forcedClientSelection,
  dimensions: forcedDimensions,
  viewport: forcedViewport,
  impact: forcedImpact,
  scrollJumpRequest
}) => {
  const viewport2 = forcedViewport || state.viewport;
  const dimensions = forcedDimensions || state.dimensions;
  const clientSelection = forcedClientSelection || state.current.client.selection;
  const offset4 = subtract(clientSelection, state.initial.client.selection);
  const client = {
    offset: offset4,
    selection: clientSelection,
    borderBoxCenter: add2(state.initial.client.borderBoxCenter, offset4)
  };
  const page = {
    selection: add2(client.selection, viewport2.scroll.current),
    borderBoxCenter: add2(client.borderBoxCenter, viewport2.scroll.current),
    offset: add2(client.offset, viewport2.scroll.diff.value)
  };
  const current = {
    client,
    page
  };
  if (state.phase === "COLLECTING") {
    return {
      ...state,
      dimensions,
      viewport: viewport2,
      current
    };
  }
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const newImpact = forcedImpact || getDragImpact({
    pageOffset: page.offset,
    draggable: draggable2,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: state.impact,
    viewport: viewport2,
    afterCritical: state.afterCritical
  });
  const withUpdatedPlaceholders = recomputePlaceholders({
    draggable: draggable2,
    impact: newImpact,
    previousImpact: state.impact,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables
  });
  const result = {
    ...state,
    current,
    dimensions: {
      draggables: dimensions.draggables,
      droppables: withUpdatedPlaceholders
    },
    impact: newImpact,
    viewport: viewport2,
    scrollJumpRequest: scrollJumpRequest || null,
    forceShouldAnimate: scrollJumpRequest ? false : null
  };
  return result;
};
function getDraggables(ids, draggables) {
  return ids.map((id2) => draggables[id2]);
}
var recompute = ({
  impact,
  viewport: viewport2,
  draggables,
  destination,
  forceShouldAnimate
}) => {
  const last = impact.displaced;
  const afterDragging = getDraggables(last.all, draggables);
  const displaced = getDisplacementGroups({
    afterDragging,
    destination,
    displacedBy: impact.displacedBy,
    viewport: viewport2.frame,
    forceShouldAnimate,
    last
  });
  return {
    ...impact,
    displaced
  };
};
var getClientBorderBoxCenter = ({
  impact,
  draggable: draggable2,
  droppable: droppable2,
  draggables,
  viewport: viewport2,
  afterCritical
}) => {
  const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    draggables,
    droppable: droppable2,
    afterCritical
  });
  return getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport: viewport2
  });
};
var refreshSnap = ({
  state,
  dimensions: forcedDimensions,
  viewport: forcedViewport
}) => {
  !(state.movementMode === "SNAP") ? true ? invariant3() : invariant3() : void 0;
  const needsVisibilityCheck = state.impact;
  const viewport2 = forcedViewport || state.viewport;
  const dimensions = forcedDimensions || state.dimensions;
  const {
    draggables,
    droppables
  } = dimensions;
  const draggable2 = draggables[state.critical.draggable.id];
  const isOver = whatIsDraggedOver(needsVisibilityCheck);
  !isOver ? true ? invariant3(false, "Must be over a destination in SNAP movement mode") : invariant3() : void 0;
  const destination = droppables[isOver];
  const impact = recompute({
    impact: needsVisibilityCheck,
    viewport: viewport2,
    destination,
    draggables
  });
  const clientSelection = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    viewport: viewport2,
    afterCritical: state.afterCritical
  });
  return update({
    impact,
    clientSelection,
    state,
    dimensions,
    viewport: viewport2
  });
};
var getHomeLocation = (descriptor) => ({
  index: descriptor.index,
  droppableId: descriptor.droppableId
});
var getLiftEffect = ({
  draggable: draggable2,
  home: home2,
  draggables,
  viewport: viewport2
}) => {
  const displacedBy = getDisplacedBy(home2.axis, draggable2.displaceBy);
  const insideHome = getDraggablesInsideDroppable(home2.descriptor.id, draggables);
  const rawIndex = insideHome.indexOf(draggable2);
  !(rawIndex !== -1) ? true ? invariant3(false, "Expected draggable to be inside home list") : invariant3() : void 0;
  const afterDragging = insideHome.slice(rawIndex + 1);
  const effected = afterDragging.reduce((previous, item) => {
    previous[item.descriptor.id] = true;
    return previous;
  }, {});
  const afterCritical = {
    inVirtualList: home2.descriptor.mode === "virtual",
    displacedBy,
    effected
  };
  const displaced = getDisplacementGroups({
    afterDragging,
    destination: home2,
    displacedBy,
    last: null,
    viewport: viewport2.frame,
    forceShouldAnimate: false
  });
  const impact = {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: getHomeLocation(draggable2.descriptor)
    }
  };
  return {
    impact,
    afterCritical
  };
};
var patchDimensionMap = (dimensions, updated) => ({
  draggables: dimensions.draggables,
  droppables: patchDroppableMap(dimensions.droppables, updated)
});
var start = (key) => {
  if (true) {
    {
      return;
    }
  }
};
var finish = (key) => {
  if (true) {
    {
      return;
    }
  }
};
var offsetDraggable = ({
  draggable: draggable2,
  offset: offset$1,
  initialWindowScroll
}) => {
  const client = offset(draggable2.client, offset$1);
  const page = withScroll(client, initialWindowScroll);
  const moved = {
    ...draggable2,
    placeholder: {
      ...draggable2.placeholder,
      client
    },
    client,
    page
  };
  return moved;
};
var getFrame = (droppable2) => {
  const frame = droppable2.frame;
  !frame ? true ? invariant3(false, "Expected Droppable to have a frame") : invariant3() : void 0;
  return frame;
};
var adjustAdditionsForScrollChanges = ({
  additions,
  updatedDroppables,
  viewport: viewport2
}) => {
  const windowScrollChange = viewport2.scroll.diff.value;
  return additions.map((draggable2) => {
    const droppableId = draggable2.descriptor.droppableId;
    const modified = updatedDroppables[droppableId];
    const frame = getFrame(modified);
    const droppableScrollChange = frame.scroll.diff.value;
    const totalChange = add2(windowScrollChange, droppableScrollChange);
    const moved = offsetDraggable({
      draggable: draggable2,
      offset: totalChange,
      initialWindowScroll: viewport2.scroll.initial
    });
    return moved;
  });
};
var timingsKey = "Processing dynamic changes";
var publishWhileDraggingInVirtual = ({
  state,
  published
}) => {
  start();
  const withScrollChange = published.modified.map((update2) => {
    const existing = state.dimensions.droppables[update2.droppableId];
    const scrolled = scrollDroppable(existing, update2.scroll);
    return scrolled;
  });
  const droppables = {
    ...state.dimensions.droppables,
    ...toDroppableMap(withScrollChange)
  };
  const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
    additions: published.additions,
    updatedDroppables: droppables,
    viewport: state.viewport
  }));
  const draggables = {
    ...state.dimensions.draggables,
    ...updatedAdditions
  };
  published.removals.forEach((id2) => {
    delete draggables[id2];
  });
  const dimensions = {
    droppables,
    draggables
  };
  const wasOverId = whatIsDraggedOver(state.impact);
  const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const home2 = dimensions.droppables[state.critical.droppable.id];
  const {
    impact: onLiftImpact,
    afterCritical
  } = getLiftEffect({
    draggable: draggable2,
    home: home2,
    draggables,
    viewport: state.viewport
  });
  const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
  const impact = getDragImpact({
    pageOffset: state.current.page.offset,
    draggable: dimensions.draggables[state.critical.draggable.id],
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact,
    viewport: state.viewport,
    afterCritical
  });
  finish(timingsKey);
  const draggingState = {
    ...state,
    phase: "DRAGGING",
    impact,
    onLiftImpact,
    dimensions,
    afterCritical,
    forceShouldAnimate: false
  };
  if (state.phase === "COLLECTING") {
    return draggingState;
  }
  const dropPending2 = {
    ...draggingState,
    phase: "DROP_PENDING",
    reason: state.reason,
    isWaiting: false
  };
  return dropPending2;
};
var isSnapping = (state) => state.movementMode === "SNAP";
var postDroppableChange = (state, updated, isEnabledChanging) => {
  const dimensions = patchDimensionMap(state.dimensions, updated);
  if (!isSnapping(state) || isEnabledChanging) {
    return update({
      state,
      dimensions
    });
  }
  return refreshSnap({
    state,
    dimensions
  });
};
function removeScrollJumpRequest(state) {
  if (state.isDragging && state.movementMode === "SNAP") {
    return {
      ...state,
      scrollJumpRequest: null
    };
  }
  return state;
}
var idle$2 = {
  phase: "IDLE",
  completed: null,
  shouldFlush: false
};
var reducer = (state = idle$2, action) => {
  if (action.type === "FLUSH") {
    return {
      ...idle$2,
      shouldFlush: true
    };
  }
  if (action.type === "INITIAL_PUBLISH") {
    !(state.phase === "IDLE") ? true ? invariant3(false, "INITIAL_PUBLISH must come after a IDLE phase") : invariant3() : void 0;
    const {
      critical,
      clientSelection,
      viewport: viewport2,
      dimensions,
      movementMode
    } = action.payload;
    const draggable2 = dimensions.draggables[critical.draggable.id];
    const home2 = dimensions.droppables[critical.droppable.id];
    const client = {
      selection: clientSelection,
      borderBoxCenter: draggable2.client.borderBox.center,
      offset: origin
    };
    const initial = {
      client,
      page: {
        selection: add2(client.selection, viewport2.scroll.initial),
        borderBoxCenter: add2(client.selection, viewport2.scroll.initial),
        offset: add2(client.selection, viewport2.scroll.diff.value)
      }
    };
    const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item) => !item.isFixedOnPage);
    const {
      impact,
      afterCritical
    } = getLiftEffect({
      draggable: draggable2,
      home: home2,
      draggables: dimensions.draggables,
      viewport: viewport2
    });
    const result = {
      phase: "DRAGGING",
      isDragging: true,
      critical,
      movementMode,
      dimensions,
      initial,
      current: initial,
      isWindowScrollAllowed,
      impact,
      afterCritical,
      onLiftImpact: impact,
      viewport: viewport2,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
    return result;
  }
  if (action.type === "COLLECTION_STARTING") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? true ? invariant3(false, `Collection cannot start from phase ${state.phase}`) : invariant3() : void 0;
    const result = {
      ...state,
      phase: "COLLECTING"
    };
    return result;
  }
  if (action.type === "PUBLISH_WHILE_DRAGGING") {
    !(state.phase === "COLLECTING" || state.phase === "DROP_PENDING") ? true ? invariant3(false, `Unexpected ${action.type} received in phase ${state.phase}`) : invariant3() : void 0;
    return publishWhileDraggingInVirtual({
      state,
      published: action.payload
    });
  }
  if (action.type === "MOVE") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant3(false, `${action.type} not permitted in phase ${state.phase}`) : invariant3() : void 0;
    const {
      client: clientSelection
    } = action.payload;
    if (isEqual$1(clientSelection, state.current.client.selection)) {
      return state;
    }
    return update({
      state,
      clientSelection,
      impact: isSnapping(state) ? state.impact : null
    });
  }
  if (action.type === "UPDATE_DROPPABLE_SCROLL") {
    if (state.phase === "DROP_PENDING") {
      return removeScrollJumpRequest(state);
    }
    if (state.phase === "COLLECTING") {
      return removeScrollJumpRequest(state);
    }
    !isMovementAllowed(state) ? true ? invariant3(false, `${action.type} not permitted in phase ${state.phase}`) : invariant3() : void 0;
    const {
      id: id2,
      newScroll
    } = action.payload;
    const target = state.dimensions.droppables[id2];
    if (!target) {
      return state;
    }
    const scrolled = scrollDroppable(target, newScroll);
    return postDroppableChange(state, scrolled, false);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant3(false, `Attempting to move in an unsupported phase ${state.phase}`) : invariant3() : void 0;
    const {
      id: id2,
      isEnabled
    } = action.payload;
    const target = state.dimensions.droppables[id2];
    !target ? true ? invariant3(false, `Cannot find Droppable[id: ${id2}] to toggle its enabled state`) : invariant3() : void 0;
    !(target.isEnabled !== isEnabled) ? true ? invariant3(false, `Trying to set droppable isEnabled to ${String(isEnabled)}
      but it is already ${String(target.isEnabled)}`) : invariant3() : void 0;
    const updated = {
      ...target,
      isEnabled
    };
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_COMBINE_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant3(false, `Attempting to move in an unsupported phase ${state.phase}`) : invariant3() : void 0;
    const {
      id: id2,
      isCombineEnabled
    } = action.payload;
    const target = state.dimensions.droppables[id2];
    !target ? true ? invariant3(false, `Cannot find Droppable[id: ${id2}] to toggle its isCombineEnabled state`) : invariant3() : void 0;
    !(target.isCombineEnabled !== isCombineEnabled) ? true ? invariant3(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}
      but it is already ${String(target.isCombineEnabled)}`) : invariant3() : void 0;
    const updated = {
      ...target,
      isCombineEnabled
    };
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "MOVE_BY_WINDOW_SCROLL") {
    if (state.phase === "DROP_PENDING" || state.phase === "DROP_ANIMATING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant3(false, `Cannot move by window in phase ${state.phase}`) : invariant3() : void 0;
    !state.isWindowScrollAllowed ? true ? invariant3(false, "Window scrolling is currently not supported for fixed lists") : invariant3() : void 0;
    const newScroll = action.payload.newScroll;
    if (isEqual$1(state.viewport.scroll.current, newScroll)) {
      return removeScrollJumpRequest(state);
    }
    const viewport2 = scrollViewport(state.viewport, newScroll);
    if (isSnapping(state)) {
      return refreshSnap({
        state,
        viewport: viewport2
      });
    }
    return update({
      state,
      viewport: viewport2
    });
  }
  if (action.type === "UPDATE_VIEWPORT_MAX_SCROLL") {
    if (!isMovementAllowed(state)) {
      return state;
    }
    const maxScroll = action.payload.maxScroll;
    if (isEqual$1(maxScroll, state.viewport.scroll.max)) {
      return state;
    }
    const withMaxScroll2 = {
      ...state.viewport,
      scroll: {
        ...state.viewport.scroll,
        max: maxScroll
      }
    };
    return {
      ...state,
      viewport: withMaxScroll2
    };
  }
  if (action.type === "MOVE_UP" || action.type === "MOVE_DOWN" || action.type === "MOVE_LEFT" || action.type === "MOVE_RIGHT") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? true ? invariant3(false, `${action.type} received while not in DRAGGING phase`) : invariant3() : void 0;
    const result = moveInDirection({
      state,
      type: action.type
    });
    if (!result) {
      return state;
    }
    return update({
      state,
      impact: result.impact,
      clientSelection: result.clientSelection,
      scrollJumpRequest: result.scrollJumpRequest
    });
  }
  if (action.type === "DROP_PENDING") {
    const reason = action.payload.reason;
    !(state.phase === "COLLECTING") ? true ? invariant3(false, "Can only move into the DROP_PENDING phase from the COLLECTING phase") : invariant3() : void 0;
    const newState = {
      ...state,
      phase: "DROP_PENDING",
      isWaiting: true,
      reason
    };
    return newState;
  }
  if (action.type === "DROP_ANIMATE") {
    const {
      completed,
      dropDuration,
      newHomeClientOffset
    } = action.payload;
    !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? true ? invariant3(false, `Cannot animate drop from phase ${state.phase}`) : invariant3() : void 0;
    const result = {
      phase: "DROP_ANIMATING",
      completed,
      dropDuration,
      newHomeClientOffset,
      dimensions: state.dimensions
    };
    return result;
  }
  if (action.type === "DROP_COMPLETE") {
    const {
      completed
    } = action.payload;
    return {
      phase: "IDLE",
      completed,
      shouldFlush: false
    };
  }
  return state;
};
function guard(action, predicate) {
  return action instanceof Object && "type" in action && action.type === predicate;
}
var beforeInitialCapture = (args) => ({
  type: "BEFORE_INITIAL_CAPTURE",
  payload: args
});
var lift$1 = (args) => ({
  type: "LIFT",
  payload: args
});
var initialPublish = (args) => ({
  type: "INITIAL_PUBLISH",
  payload: args
});
var publishWhileDragging = (args) => ({
  type: "PUBLISH_WHILE_DRAGGING",
  payload: args
});
var collectionStarting = () => ({
  type: "COLLECTION_STARTING",
  payload: null
});
var updateDroppableScroll = (args) => ({
  type: "UPDATE_DROPPABLE_SCROLL",
  payload: args
});
var updateDroppableIsEnabled = (args) => ({
  type: "UPDATE_DROPPABLE_IS_ENABLED",
  payload: args
});
var updateDroppableIsCombineEnabled = (args) => ({
  type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED",
  payload: args
});
var move = (args) => ({
  type: "MOVE",
  payload: args
});
var moveByWindowScroll = (args) => ({
  type: "MOVE_BY_WINDOW_SCROLL",
  payload: args
});
var updateViewportMaxScroll = (args) => ({
  type: "UPDATE_VIEWPORT_MAX_SCROLL",
  payload: args
});
var moveUp = () => ({
  type: "MOVE_UP",
  payload: null
});
var moveDown = () => ({
  type: "MOVE_DOWN",
  payload: null
});
var moveRight = () => ({
  type: "MOVE_RIGHT",
  payload: null
});
var moveLeft = () => ({
  type: "MOVE_LEFT",
  payload: null
});
var flush = () => ({
  type: "FLUSH",
  payload: null
});
var animateDrop = (args) => ({
  type: "DROP_ANIMATE",
  payload: args
});
var completeDrop = (args) => ({
  type: "DROP_COMPLETE",
  payload: args
});
var drop = (args) => ({
  type: "DROP",
  payload: args
});
var dropPending = (args) => ({
  type: "DROP_PENDING",
  payload: args
});
var dropAnimationFinished = () => ({
  type: "DROP_ANIMATION_FINISHED",
  payload: null
});
function checkIndexes(insideDestination) {
  if (insideDestination.length <= 1) {
    return;
  }
  const indexes = insideDestination.map((d) => d.descriptor.index);
  const errors = {};
  for (let i2 = 1; i2 < indexes.length; i2++) {
    const current = indexes[i2];
    const previous = indexes[i2 - 1];
    if (current !== previous + 1) {
      errors[current] = true;
    }
  }
  if (!Object.keys(errors).length) {
    return;
  }
  const formatted = indexes.map((index2) => {
    const hasError = Boolean(errors[index2]);
    return hasError ? `[🔥${index2}]` : `${index2}`;
  }).join(", ");
  true ? warning4(`
    Detected non-consecutive <Draggable /> indexes.

    (This can cause unexpected bugs)

    ${formatted}
  `) : void 0;
}
function validateDimensions(critical, dimensions) {
  if (true) {
    const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);
    checkIndexes(insideDestination);
  }
}
var lift = (marshal) => ({
  getState,
  dispatch
}) => (next) => (action) => {
  if (!guard(action, "LIFT")) {
    next(action);
    return;
  }
  const {
    id: id2,
    clientSelection,
    movementMode
  } = action.payload;
  const initial = getState();
  if (initial.phase === "DROP_ANIMATING") {
    dispatch(completeDrop({
      completed: initial.completed
    }));
  }
  !(getState().phase === "IDLE") ? true ? invariant3(false, "Unexpected phase to start a drag") : invariant3() : void 0;
  dispatch(flush());
  dispatch(beforeInitialCapture({
    draggableId: id2,
    movementMode
  }));
  const scrollOptions = {
    shouldPublishImmediately: movementMode === "SNAP"
  };
  const request = {
    draggableId: id2,
    scrollOptions
  };
  const {
    critical,
    dimensions,
    viewport: viewport2
  } = marshal.startPublishing(request);
  validateDimensions(critical, dimensions);
  dispatch(initialPublish({
    critical,
    dimensions,
    clientSelection,
    movementMode,
    viewport: viewport2
  }));
};
var style = (marshal) => () => (next) => (action) => {
  if (guard(action, "INITIAL_PUBLISH")) {
    marshal.dragging();
  }
  if (guard(action, "DROP_ANIMATE")) {
    marshal.dropping(action.payload.completed.result.reason);
  }
  if (guard(action, "FLUSH") || guard(action, "DROP_COMPLETE")) {
    marshal.resting();
  }
  next(action);
};
var curves = {
  outOfTheWay: "cubic-bezier(0.2, 0, 0, 1)",
  drop: "cubic-bezier(.2,1,.1,1)"
};
var combine = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
};
var timings = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
};
var outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;
var transitions = {
  fluid: `opacity ${outOfTheWayTiming}`,
  snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,
  drop: (duration) => {
    const timing = `${duration}s ${curves.drop}`;
    return `transform ${timing}, opacity ${timing}`;
  },
  outOfTheWay: `transform ${outOfTheWayTiming}`,
  placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`
};
var moveTo = (offset4) => isEqual$1(offset4, origin) ? void 0 : `translate(${offset4.x}px, ${offset4.y}px)`;
var transforms = {
  moveTo,
  drop: (offset4, isCombining) => {
    const translate2 = moveTo(offset4);
    if (!translate2) {
      return void 0;
    }
    if (!isCombining) {
      return translate2;
    }
    return `${translate2} scale(${combine.scale.drop})`;
  }
};
var {
  minDropTime,
  maxDropTime
} = timings;
var dropTimeRange = maxDropTime - minDropTime;
var maxDropTimeAtDistance = 1500;
var cancelDropModifier = 0.6;
var getDropDuration = ({
  current,
  destination,
  reason
}) => {
  const distance$1 = distance(current, destination);
  if (distance$1 <= 0) {
    return minDropTime;
  }
  if (distance$1 >= maxDropTimeAtDistance) {
    return maxDropTime;
  }
  const percentage = distance$1 / maxDropTimeAtDistance;
  const duration = minDropTime + dropTimeRange * percentage;
  const withDuration = reason === "CANCEL" ? duration * cancelDropModifier : duration;
  return Number(withDuration.toFixed(2));
};
var getNewHomeClientOffset = ({
  impact,
  draggable: draggable2,
  dimensions,
  viewport: viewport2,
  afterCritical
}) => {
  const {
    draggables,
    droppables
  } = dimensions;
  const droppableId = whatIsDraggedOver(impact);
  const destination = droppableId ? droppables[droppableId] : null;
  const home2 = droppables[draggable2.descriptor.droppableId];
  const newClientCenter = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    draggables,
    afterCritical,
    droppable: destination || home2,
    viewport: viewport2
  });
  const offset4 = subtract(newClientCenter, draggable2.client.borderBox.center);
  return offset4;
};
var getDropImpact = ({
  draggables,
  reason,
  lastImpact,
  home: home2,
  viewport: viewport2,
  onLiftImpact
}) => {
  if (!lastImpact.at || reason !== "DROP") {
    const recomputedHomeImpact = recompute({
      draggables,
      impact: onLiftImpact,
      destination: home2,
      viewport: viewport2,
      forceShouldAnimate: true
    });
    return {
      impact: recomputedHomeImpact,
      didDropInsideDroppable: false
    };
  }
  if (lastImpact.at.type === "REORDER") {
    return {
      impact: lastImpact,
      didDropInsideDroppable: true
    };
  }
  const withoutMovement = {
    ...lastImpact,
    displaced: emptyGroups
  };
  return {
    impact: withoutMovement,
    didDropInsideDroppable: true
  };
};
var dropMiddleware = ({
  getState,
  dispatch
}) => (next) => (action) => {
  if (!guard(action, "DROP")) {
    next(action);
    return;
  }
  const state = getState();
  const reason = action.payload.reason;
  if (state.phase === "COLLECTING") {
    dispatch(dropPending({
      reason
    }));
    return;
  }
  if (state.phase === "IDLE") {
    return;
  }
  const isWaitingForDrop = state.phase === "DROP_PENDING" && state.isWaiting;
  !!isWaitingForDrop ? true ? invariant3(false, "A DROP action occurred while DROP_PENDING and still waiting") : invariant3() : void 0;
  !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? true ? invariant3(false, `Cannot drop in phase: ${state.phase}`) : invariant3() : void 0;
  const critical = state.critical;
  const dimensions = state.dimensions;
  const draggable2 = dimensions.draggables[state.critical.draggable.id];
  const {
    impact,
    didDropInsideDroppable
  } = getDropImpact({
    reason,
    lastImpact: state.impact,
    afterCritical: state.afterCritical,
    onLiftImpact: state.onLiftImpact,
    home: state.dimensions.droppables[state.critical.droppable.id],
    viewport: state.viewport,
    draggables: state.dimensions.draggables
  });
  const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
  const combine2 = didDropInsideDroppable ? tryGetCombine(impact) : null;
  const source = {
    index: critical.draggable.index,
    droppableId: critical.droppable.id
  };
  const result = {
    draggableId: draggable2.descriptor.id,
    type: draggable2.descriptor.type,
    source,
    reason,
    mode: state.movementMode,
    destination,
    combine: combine2
  };
  const newHomeClientOffset = getNewHomeClientOffset({
    impact,
    draggable: draggable2,
    dimensions,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
  const completed = {
    critical: state.critical,
    afterCritical: state.afterCritical,
    result,
    impact
  };
  const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
  if (!isAnimationRequired) {
    dispatch(completeDrop({
      completed
    }));
    return;
  }
  const dropDuration = getDropDuration({
    current: state.current.client.offset,
    destination: newHomeClientOffset,
    reason
  });
  const args = {
    newHomeClientOffset,
    dropDuration,
    completed
  };
  dispatch(animateDrop(args));
};
var getWindowScroll3 = () => ({
  x: window.pageXOffset,
  y: window.pageYOffset
});
function getWindowScrollBinding(update2) {
  return {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: (event) => {
      if (event.target !== window && event.target !== window.document) {
        return;
      }
      update2();
    }
  };
}
function getScrollListener({
  onWindowScroll
}) {
  function updateScroll() {
    onWindowScroll(getWindowScroll3());
  }
  const scheduled = raf_schd_esm_default(updateScroll);
  const binding = getWindowScrollBinding(scheduled);
  let unbind = noop$2;
  function isActive3() {
    return unbind !== noop$2;
  }
  function start3() {
    !!isActive3() ? true ? invariant3(false, "Cannot start scroll listener when already active") : invariant3() : void 0;
    unbind = bindEvents(window, [binding]);
  }
  function stop() {
    !isActive3() ? true ? invariant3(false, "Cannot stop scroll listener when not active") : invariant3() : void 0;
    scheduled.cancel();
    unbind();
    unbind = noop$2;
  }
  return {
    start: start3,
    stop,
    isActive: isActive3
  };
}
var shouldStop$1 = (action) => guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATE") || guard(action, "FLUSH");
var scrollListener = (store) => {
  const listener = getScrollListener({
    onWindowScroll: (newScroll) => {
      store.dispatch(moveByWindowScroll({
        newScroll
      }));
    }
  });
  return (next) => (action) => {
    if (!listener.isActive() && guard(action, "INITIAL_PUBLISH")) {
      listener.start();
    }
    if (listener.isActive() && shouldStop$1(action)) {
      listener.stop();
    }
    next(action);
  };
};
var getExpiringAnnounce = (announce) => {
  let wasCalled = false;
  let isExpired = false;
  const timeoutId = setTimeout(() => {
    isExpired = true;
  });
  const result = (message2) => {
    if (wasCalled) {
      true ? warning4("Announcement already made. Not making a second announcement") : void 0;
      return;
    }
    if (isExpired) {
      true ? warning4(`
        Announcements cannot be made asynchronously.
        Default message has already been announced.
      `) : void 0;
      return;
    }
    wasCalled = true;
    announce(message2);
    clearTimeout(timeoutId);
  };
  result.wasCalled = () => wasCalled;
  return result;
};
var getAsyncMarshal = () => {
  const entries = [];
  const execute2 = (timerId) => {
    const index2 = entries.findIndex((item) => item.timerId === timerId);
    !(index2 !== -1) ? true ? invariant3(false, "Could not find timer") : invariant3() : void 0;
    const [entry] = entries.splice(index2, 1);
    entry.callback();
  };
  const add3 = (fn2) => {
    const timerId = setTimeout(() => execute2(timerId));
    const entry = {
      timerId,
      callback: fn2
    };
    entries.push(entry);
  };
  const flush2 = () => {
    if (!entries.length) {
      return;
    }
    const shallow = [...entries];
    entries.length = 0;
    shallow.forEach((entry) => {
      clearTimeout(entry.timerId);
      entry.callback();
    });
  };
  return {
    add: add3,
    flush: flush2
  };
};
var areLocationsEqual = (first2, second) => {
  if (first2 == null && second == null) {
    return true;
  }
  if (first2 == null || second == null) {
    return false;
  }
  return first2.droppableId === second.droppableId && first2.index === second.index;
};
var isCombineEqual = (first2, second) => {
  if (first2 == null && second == null) {
    return true;
  }
  if (first2 == null || second == null) {
    return false;
  }
  return first2.draggableId === second.draggableId && first2.droppableId === second.droppableId;
};
var isCriticalEqual = (first2, second) => {
  if (first2 === second) {
    return true;
  }
  const isDraggableEqual = first2.draggable.id === second.draggable.id && first2.draggable.droppableId === second.draggable.droppableId && first2.draggable.type === second.draggable.type && first2.draggable.index === second.draggable.index;
  const isDroppableEqual = first2.droppable.id === second.droppable.id && first2.droppable.type === second.droppable.type;
  return isDraggableEqual && isDroppableEqual;
};
var withTimings = (key, fn2) => {
  start();
  fn2();
  finish();
};
var getDragStart = (critical, mode) => ({
  draggableId: critical.draggable.id,
  type: critical.droppable.type,
  source: {
    droppableId: critical.droppable.id,
    index: critical.draggable.index
  },
  mode
});
function execute(responder, data, announce, getDefaultMessage) {
  if (!responder) {
    announce(getDefaultMessage(data));
    return;
  }
  const willExpire = getExpiringAnnounce(announce);
  const provided = {
    announce: willExpire
  };
  responder(data, provided);
  if (!willExpire.wasCalled()) {
    announce(getDefaultMessage(data));
  }
}
var getPublisher = (getResponders, announce) => {
  const asyncMarshal = getAsyncMarshal();
  let dragging = null;
  const beforeCapture = (draggableId, mode) => {
    !!dragging ? true ? invariant3(false, "Cannot fire onBeforeCapture as a drag start has already been published") : invariant3() : void 0;
    withTimings("onBeforeCapture", () => {
      const fn2 = getResponders().onBeforeCapture;
      if (fn2) {
        const before = {
          draggableId,
          mode
        };
        fn2(before);
      }
    });
  };
  const beforeStart = (critical, mode) => {
    !!dragging ? true ? invariant3(false, "Cannot fire onBeforeDragStart as a drag start has already been published") : invariant3() : void 0;
    withTimings("onBeforeDragStart", () => {
      const fn2 = getResponders().onBeforeDragStart;
      if (fn2) {
        fn2(getDragStart(critical, mode));
      }
    });
  };
  const start3 = (critical, mode) => {
    !!dragging ? true ? invariant3(false, "Cannot fire onBeforeDragStart as a drag start has already been published") : invariant3() : void 0;
    const data = getDragStart(critical, mode);
    dragging = {
      mode,
      lastCritical: critical,
      lastLocation: data.source,
      lastCombine: null
    };
    asyncMarshal.add(() => {
      withTimings("onDragStart", () => execute(getResponders().onDragStart, data, announce, preset.onDragStart));
    });
  };
  const update2 = (critical, impact) => {
    const location = tryGetDestination(impact);
    const combine2 = tryGetCombine(impact);
    !dragging ? true ? invariant3(false, "Cannot fire onDragMove when onDragStart has not been called") : invariant3() : void 0;
    const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
    if (hasCriticalChanged) {
      dragging.lastCritical = critical;
    }
    const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);
    if (hasLocationChanged) {
      dragging.lastLocation = location;
    }
    const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine2);
    if (hasGroupingChanged) {
      dragging.lastCombine = combine2;
    }
    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
      return;
    }
    const data = {
      ...getDragStart(critical, dragging.mode),
      combine: combine2,
      destination: location
    };
    asyncMarshal.add(() => {
      withTimings("onDragUpdate", () => execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate));
    });
  };
  const flush2 = () => {
    !dragging ? true ? invariant3(false, "Can only flush responders while dragging") : invariant3() : void 0;
    asyncMarshal.flush();
  };
  const drop2 = (result) => {
    !dragging ? true ? invariant3(false, "Cannot fire onDragEnd when there is no matching onDragStart") : invariant3() : void 0;
    dragging = null;
    withTimings("onDragEnd", () => execute(getResponders().onDragEnd, result, announce, preset.onDragEnd));
  };
  const abort = () => {
    if (!dragging) {
      return;
    }
    const result = {
      ...getDragStart(dragging.lastCritical, dragging.mode),
      combine: null,
      destination: null,
      reason: "CANCEL"
    };
    drop2(result);
  };
  return {
    beforeCapture,
    beforeStart,
    start: start3,
    update: update2,
    flush: flush2,
    drop: drop2,
    abort
  };
};
var responders = (getResponders, announce) => {
  const publisher = getPublisher(getResponders, announce);
  return (store) => (next) => (action) => {
    if (guard(action, "BEFORE_INITIAL_CAPTURE")) {
      publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
      return;
    }
    if (guard(action, "INITIAL_PUBLISH")) {
      const critical = action.payload.critical;
      publisher.beforeStart(critical, action.payload.movementMode);
      next(action);
      publisher.start(critical, action.payload.movementMode);
      return;
    }
    if (guard(action, "DROP_COMPLETE")) {
      const result = action.payload.completed.result;
      publisher.flush();
      next(action);
      publisher.drop(result);
      return;
    }
    next(action);
    if (guard(action, "FLUSH")) {
      publisher.abort();
      return;
    }
    const state = store.getState();
    if (state.phase === "DRAGGING") {
      publisher.update(state.critical, state.impact);
    }
  };
};
var dropAnimationFinishMiddleware = (store) => (next) => (action) => {
  if (!guard(action, "DROP_ANIMATION_FINISHED")) {
    next(action);
    return;
  }
  const state = store.getState();
  !(state.phase === "DROP_ANIMATING") ? true ? invariant3(false, "Cannot finish a drop animating when no drop is occurring") : invariant3() : void 0;
  store.dispatch(completeDrop({
    completed: state.completed
  }));
};
var dropAnimationFlushOnScrollMiddleware = (store) => {
  let unbind = null;
  let frameId = null;
  function clear() {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }
    if (unbind) {
      unbind();
      unbind = null;
    }
  }
  return (next) => (action) => {
    if (guard(action, "FLUSH") || guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATION_FINISHED")) {
      clear();
    }
    next(action);
    if (!guard(action, "DROP_ANIMATE")) {
      return;
    }
    const binding = {
      eventName: "scroll",
      options: {
        capture: true,
        passive: false,
        once: true
      },
      fn: function flushDropAnimation() {
        const state = store.getState();
        if (state.phase === "DROP_ANIMATING") {
          store.dispatch(dropAnimationFinished());
        }
      }
    };
    frameId = requestAnimationFrame(() => {
      frameId = null;
      unbind = bindEvents(window, [binding]);
    });
  };
};
var dimensionMarshalStopper = (marshal) => () => (next) => (action) => {
  if (guard(action, "DROP_COMPLETE") || guard(action, "FLUSH") || guard(action, "DROP_ANIMATE")) {
    marshal.stopPublishing();
  }
  next(action);
};
var focus = (marshal) => {
  let isWatching = false;
  return () => (next) => (action) => {
    if (guard(action, "INITIAL_PUBLISH")) {
      isWatching = true;
      marshal.tryRecordFocus(action.payload.critical.draggable.id);
      next(action);
      marshal.tryRestoreFocusRecorded();
      return;
    }
    next(action);
    if (!isWatching) {
      return;
    }
    if (guard(action, "FLUSH")) {
      isWatching = false;
      marshal.tryRestoreFocusRecorded();
      return;
    }
    if (guard(action, "DROP_COMPLETE")) {
      isWatching = false;
      const result = action.payload.completed.result;
      if (result.combine) {
        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
      }
      marshal.tryRestoreFocusRecorded();
    }
  };
};
var shouldStop = (action) => guard(action, "DROP_COMPLETE") || guard(action, "DROP_ANIMATE") || guard(action, "FLUSH");
var autoScroll = (autoScroller) => (store) => (next) => (action) => {
  if (shouldStop(action)) {
    autoScroller.stop();
    next(action);
    return;
  }
  if (guard(action, "INITIAL_PUBLISH")) {
    next(action);
    const state = store.getState();
    !(state.phase === "DRAGGING") ? true ? invariant3(false, "Expected phase to be DRAGGING after INITIAL_PUBLISH") : invariant3() : void 0;
    autoScroller.start(state);
    return;
  }
  next(action);
  autoScroller.scroll(store.getState());
};
var pendingDrop = (store) => (next) => (action) => {
  next(action);
  if (!guard(action, "PUBLISH_WHILE_DRAGGING")) {
    return;
  }
  const postActionState = store.getState();
  if (postActionState.phase !== "DROP_PENDING") {
    return;
  }
  if (postActionState.isWaiting) {
    return;
  }
  store.dispatch(drop({
    reason: postActionState.reason
  }));
};
var composeEnhancers = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
  name: "@hello-pangea/dnd"
}) : compose;
var createStore2 = ({
  dimensionMarshal,
  focusMarshal,
  styleMarshal,
  getResponders,
  announce,
  autoScroller
}) => createStore(reducer, composeEnhancers(applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), dropMiddleware, dropAnimationFinishMiddleware, dropAnimationFlushOnScrollMiddleware, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));
var clean$1 = () => ({
  additions: {},
  removals: {},
  modified: {}
});
function createPublisher({
  registry,
  callbacks
}) {
  let staging = clean$1();
  let frameId = null;
  const collect = () => {
    if (frameId) {
      return;
    }
    callbacks.collectionStarting();
    frameId = requestAnimationFrame(() => {
      frameId = null;
      start();
      const {
        additions,
        removals,
        modified
      } = staging;
      const added = Object.keys(additions).map((id2) => registry.draggable.getById(id2).getDimension(origin)).sort((a2, b2) => a2.descriptor.index - b2.descriptor.index);
      const updated = Object.keys(modified).map((id2) => {
        const entry = registry.droppable.getById(id2);
        const scroll2 = entry.callbacks.getScrollWhileDragging();
        return {
          droppableId: id2,
          scroll: scroll2
        };
      });
      const result = {
        additions: added,
        removals: Object.keys(removals),
        modified: updated
      };
      staging = clean$1();
      finish();
      callbacks.publish(result);
    });
  };
  const add3 = (entry) => {
    const id2 = entry.descriptor.id;
    staging.additions[id2] = entry;
    staging.modified[entry.descriptor.droppableId] = true;
    if (staging.removals[id2]) {
      delete staging.removals[id2];
    }
    collect();
  };
  const remove = (entry) => {
    const descriptor = entry.descriptor;
    staging.removals[descriptor.id] = true;
    staging.modified[descriptor.droppableId] = true;
    if (staging.additions[descriptor.id]) {
      delete staging.additions[descriptor.id];
    }
    collect();
  };
  const stop = () => {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
    staging = clean$1();
  };
  return {
    add: add3,
    remove,
    stop
  };
}
var getMaxScroll = ({
  scrollHeight,
  scrollWidth,
  height,
  width
}) => {
  const maxScroll = subtract({
    x: scrollWidth,
    y: scrollHeight
  }, {
    x: width,
    y: height
  });
  const adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
};
var getDocumentElement = () => {
  const doc3 = document.documentElement;
  !doc3 ? true ? invariant3(false, "Cannot find document.documentElement") : invariant3() : void 0;
  return doc3;
};
var getMaxWindowScroll = () => {
  const doc3 = getDocumentElement();
  const maxScroll = getMaxScroll({
    scrollHeight: doc3.scrollHeight,
    scrollWidth: doc3.scrollWidth,
    width: doc3.clientWidth,
    height: doc3.clientHeight
  });
  return maxScroll;
};
var getViewport = () => {
  const scroll2 = getWindowScroll3();
  const maxScroll = getMaxWindowScroll();
  const top2 = scroll2.y;
  const left2 = scroll2.x;
  const doc3 = getDocumentElement();
  const width = doc3.clientWidth;
  const height = doc3.clientHeight;
  const right2 = left2 + width;
  const bottom2 = top2 + height;
  const frame = getRect({
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2
  });
  const viewport2 = {
    frame,
    scroll: {
      initial: scroll2,
      current: scroll2,
      max: maxScroll,
      diff: {
        value: origin,
        displacement: origin
      }
    }
  };
  return viewport2;
};
var getInitialPublish = ({
  critical,
  scrollOptions,
  registry
}) => {
  start();
  const viewport2 = getViewport();
  const windowScroll = viewport2.scroll.current;
  const home2 = critical.droppable;
  const droppables = registry.droppable.getAllByType(home2.type).map((entry) => entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));
  const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry) => entry.getDimension(windowScroll));
  const dimensions = {
    draggables: toDraggableMap(draggables),
    droppables: toDroppableMap(droppables)
  };
  finish();
  const result = {
    dimensions,
    critical,
    viewport: viewport2
  };
  return result;
};
function shouldPublishUpdate(registry, dragging, entry) {
  if (entry.descriptor.id === dragging.id) {
    return false;
  }
  if (entry.descriptor.type !== dragging.type) {
    return false;
  }
  const home2 = registry.droppable.getById(entry.descriptor.droppableId);
  if (home2.descriptor.mode !== "virtual") {
    true ? warning4(`
      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]
      while a drag is occurring. This is only supported for virtual lists.

      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md
    `) : void 0;
    return false;
  }
  return true;
}
var createDimensionMarshal = (registry, callbacks) => {
  let collection = null;
  const publisher = createPublisher({
    callbacks: {
      publish: callbacks.publishWhileDragging,
      collectionStarting: callbacks.collectionStarting
    },
    registry
  });
  const updateDroppableIsEnabled2 = (id2, isEnabled) => {
    !registry.droppable.exists(id2) ? true ? invariant3(false, `Cannot update is enabled flag of Droppable ${id2} as it is not registered`) : invariant3() : void 0;
    if (!collection) {
      return;
    }
    callbacks.updateDroppableIsEnabled({
      id: id2,
      isEnabled
    });
  };
  const updateDroppableIsCombineEnabled2 = (id2, isCombineEnabled) => {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id2) ? true ? invariant3(false, `Cannot update isCombineEnabled flag of Droppable ${id2} as it is not registered`) : invariant3() : void 0;
    callbacks.updateDroppableIsCombineEnabled({
      id: id2,
      isCombineEnabled
    });
  };
  const updateDroppableScroll2 = (id2, newScroll) => {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id2) ? true ? invariant3(false, `Cannot update the scroll on Droppable ${id2} as it is not registered`) : invariant3() : void 0;
    callbacks.updateDroppableScroll({
      id: id2,
      newScroll
    });
  };
  const scrollDroppable2 = (id2, change) => {
    if (!collection) {
      return;
    }
    registry.droppable.getById(id2).callbacks.scroll(change);
  };
  const stopPublishing = () => {
    if (!collection) {
      return;
    }
    publisher.stop();
    const home2 = collection.critical.droppable;
    registry.droppable.getAllByType(home2.type).forEach((entry) => entry.callbacks.dragStopped());
    collection.unsubscribe();
    collection = null;
  };
  const subscriber = (event) => {
    !collection ? true ? invariant3(false, "Should only be subscribed when a collection is occurring") : invariant3() : void 0;
    const dragging = collection.critical.draggable;
    if (event.type === "ADDITION") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.add(event.value);
      }
    }
    if (event.type === "REMOVAL") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.remove(event.value);
      }
    }
  };
  const startPublishing = (request) => {
    !!collection ? true ? invariant3(false, "Cannot start capturing critical dimensions as there is already a collection") : invariant3() : void 0;
    const entry = registry.draggable.getById(request.draggableId);
    const home2 = registry.droppable.getById(entry.descriptor.droppableId);
    const critical = {
      draggable: entry.descriptor,
      droppable: home2.descriptor
    };
    const unsubscribe = registry.subscribe(subscriber);
    collection = {
      critical,
      unsubscribe
    };
    return getInitialPublish({
      critical,
      registry,
      scrollOptions: request.scrollOptions
    });
  };
  const marshal = {
    updateDroppableIsEnabled: updateDroppableIsEnabled2,
    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled2,
    scrollDroppable: scrollDroppable2,
    updateDroppableScroll: updateDroppableScroll2,
    startPublishing,
    stopPublishing
  };
  return marshal;
};
var canStartDrag = (state, id2) => {
  if (state.phase === "IDLE") {
    return true;
  }
  if (state.phase !== "DROP_ANIMATING") {
    return false;
  }
  if (state.completed.result.draggableId === id2) {
    return false;
  }
  return state.completed.result.reason === "DROP";
};
var scrollWindow = (change) => {
  window.scrollBy(change.x, change.y);
};
var getScrollableDroppables = memoizeOne2((droppables) => toDroppableList(droppables).filter((droppable2) => {
  if (!droppable2.isEnabled) {
    return false;
  }
  if (!droppable2.frame) {
    return false;
  }
  return true;
}));
var getScrollableDroppableOver = (target, droppables) => {
  const maybe = getScrollableDroppables(droppables).find((droppable2) => {
    !droppable2.frame ? true ? invariant3(false, "Invalid result") : invariant3() : void 0;
    return isPositionInFrame(droppable2.frame.pageMarginBox)(target);
  }) || null;
  return maybe;
};
var getBestScrollableDroppable = ({
  center,
  destination,
  droppables
}) => {
  if (destination) {
    const dimension2 = droppables[destination];
    if (!dimension2.frame) {
      return null;
    }
    return dimension2;
  }
  const dimension = getScrollableDroppableOver(center, droppables);
  return dimension;
};
var defaultAutoScrollerOptions = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: (percentage) => percentage ** 2,
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  },
  disabled: false
};
var getDistanceThresholds = (container, axis, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;
  const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;
  const thresholds = {
    startScrollingFrom,
    maxScrollValueAt
  };
  return thresholds;
};
var getPercentage = ({
  startOfRange,
  endOfRange,
  current
}) => {
  const range = endOfRange - startOfRange;
  if (range === 0) {
    true ? warning4(`
      Detected distance range of 0 in the fluid auto scroller
      This is unexpected and would cause a divide by 0 issue.
      Not allowing an auto scroll
    `) : void 0;
    return 0;
  }
  const currentInRange = current - startOfRange;
  const percentage = currentInRange / range;
  return percentage;
};
var minScroll = 1;
var getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = () => defaultAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  if (distanceToEdge > thresholds.startScrollingFrom) {
    return 0;
  }
  if (distanceToEdge <= thresholds.maxScrollValueAt) {
    return autoScrollerOptions.maxPixelScroll;
  }
  if (distanceToEdge === thresholds.startScrollingFrom) {
    return minScroll;
  }
  const percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds.maxScrollValueAt,
    endOfRange: thresholds.startScrollingFrom,
    current: distanceToEdge
  });
  const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  const scroll2 = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll2);
};
var dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions) => {
  const autoScrollerOptions = getAutoScrollerOptions();
  const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;
  const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;
  const startOfRange = dragStartTime;
  const endOfRange = stopAt;
  const now2 = Date.now();
  const runTime = now2 - startOfRange;
  if (runTime >= stopAt) {
    return proposedScroll;
  }
  if (runTime < accelerateAt) {
    return minScroll;
  }
  const betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange,
    current: runTime
  });
  const scroll2 = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll2);
};
var getValue = ({
  distanceToEdge,
  thresholds,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const scroll2 = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);
  if (scroll2 === 0) {
    return 0;
  }
  if (!shouldUseTimeDampening) {
    return scroll2;
  }
  return Math.max(dampenValueByTime(scroll2, dragStartTime, getAutoScrollerOptions), minScroll);
};
var getScrollOnAxis = ({
  container,
  distanceToEdges,
  dragStartTime,
  axis,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);
  const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
  if (isCloserToEnd) {
    return getValue({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds,
      dragStartTime,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
  }
  return -1 * getValue({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds,
    dragStartTime,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
};
var adjustForSizeLimits = ({
  container,
  subject,
  proposedScroll
}) => {
  const isTooBigVertically = subject.height > container.height;
  const isTooBigHorizontally = subject.width > container.width;
  if (!isTooBigHorizontally && !isTooBigVertically) {
    return proposedScroll;
  }
  if (isTooBigHorizontally && isTooBigVertically) {
    return null;
  }
  return {
    x: isTooBigHorizontally ? 0 : proposedScroll.x,
    y: isTooBigVertically ? 0 : proposedScroll.y
  };
};
var clean = apply((value) => value === 0 ? 0 : value);
var getScroll$1 = ({
  dragStartTime,
  container,
  subject,
  center,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const distanceToEdges = {
    top: center.y - container.top,
    right: container.right - center.x,
    bottom: container.bottom - center.y,
    left: center.x - container.left
  };
  const y = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: vertical,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  const x = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  const required2 = clean({
    x,
    y
  });
  if (isEqual$1(required2, origin)) {
    return null;
  }
  const limited = adjustForSizeLimits({
    container,
    subject,
    proposedScroll: required2
  });
  if (!limited) {
    return null;
  }
  return isEqual$1(limited, origin) ? null : limited;
};
var smallestSigned = apply((value) => {
  if (value === 0) {
    return 0;
  }
  return value > 0 ? 1 : -1;
});
var getOverlap = /* @__PURE__ */ (() => {
  const getRemainder = (target, max3) => {
    if (target < 0) {
      return target;
    }
    if (target > max3) {
      return target - max3;
    }
    return 0;
  };
  return ({
    current,
    max: max3,
    change
  }) => {
    const targetScroll = add2(current, change);
    const overlap = {
      x: getRemainder(targetScroll.x, max3.x),
      y: getRemainder(targetScroll.y, max3.y)
    };
    if (isEqual$1(overlap, origin)) {
      return null;
    }
    return overlap;
  };
})();
var canPartiallyScroll = ({
  max: rawMax,
  current,
  change
}) => {
  const max3 = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  const smallestChange = smallestSigned(change);
  const overlap = getOverlap({
    max: max3,
    current,
    change: smallestChange
  });
  if (!overlap) {
    return true;
  }
  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }
  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }
  return false;
};
var canScrollWindow = (viewport2, change) => canPartiallyScroll({
  current: viewport2.scroll.current,
  max: viewport2.scroll.max,
  change
});
var getWindowOverlap = (viewport2, change) => {
  if (!canScrollWindow(viewport2, change)) {
    return null;
  }
  const max3 = viewport2.scroll.max;
  const current = viewport2.scroll.current;
  return getOverlap({
    current,
    max: max3,
    change
  });
};
var canScrollDroppable = (droppable2, change) => {
  const frame = droppable2.frame;
  if (!frame) {
    return false;
  }
  return canPartiallyScroll({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getDroppableOverlap = (droppable2, change) => {
  const frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  if (!canScrollDroppable(droppable2, change)) {
    return null;
  }
  return getOverlap({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getWindowScrollChange = ({
  viewport: viewport2,
  subject,
  center,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const scroll2 = getScroll$1({
    dragStartTime,
    container: viewport2.frame,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  return scroll2 && canScrollWindow(viewport2, scroll2) ? scroll2 : null;
};
var getDroppableScrollChange = ({
  droppable: droppable2,
  subject,
  center,
  dragStartTime,
  shouldUseTimeDampening,
  getAutoScrollerOptions
}) => {
  const frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  const scroll2 = getScroll$1({
    dragStartTime,
    container: frame.pageMarginBox,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  return scroll2 && canScrollDroppable(droppable2, scroll2) ? scroll2 : null;
};
var scroll = ({
  state,
  dragStartTime,
  shouldUseTimeDampening,
  scrollWindow: scrollWindow2,
  scrollDroppable: scrollDroppable2,
  getAutoScrollerOptions
}) => {
  const center = state.current.page.borderBoxCenter;
  const draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  const subject = draggable2.page.marginBox;
  if (state.isWindowScrollAllowed) {
    const viewport2 = state.viewport;
    const change2 = getWindowScrollChange({
      dragStartTime,
      viewport: viewport2,
      subject,
      center,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
    if (change2) {
      scrollWindow2(change2);
      return;
    }
  }
  const droppable2 = getBestScrollableDroppable({
    center,
    destination: whatIsDraggedOver(state.impact),
    droppables: state.dimensions.droppables
  });
  if (!droppable2) {
    return;
  }
  const change = getDroppableScrollChange({
    dragStartTime,
    droppable: droppable2,
    subject,
    center,
    shouldUseTimeDampening,
    getAutoScrollerOptions
  });
  if (change) {
    scrollDroppable2(droppable2.descriptor.id, change);
  }
};
var createFluidScroller = ({
  scrollWindow: scrollWindow2,
  scrollDroppable: scrollDroppable2,
  getAutoScrollerOptions = () => defaultAutoScrollerOptions
}) => {
  const scheduleWindowScroll = raf_schd_esm_default(scrollWindow2);
  const scheduleDroppableScroll = raf_schd_esm_default(scrollDroppable2);
  let dragging = null;
  const tryScroll = (state) => {
    !dragging ? true ? invariant3(false, "Cannot fluid scroll if not dragging") : invariant3() : void 0;
    const {
      shouldUseTimeDampening,
      dragStartTime
    } = dragging;
    scroll({
      state,
      scrollWindow: scheduleWindowScroll,
      scrollDroppable: scheduleDroppableScroll,
      dragStartTime,
      shouldUseTimeDampening,
      getAutoScrollerOptions
    });
  };
  const start$1 = (state) => {
    start();
    !!dragging ? true ? invariant3(false, "Cannot start auto scrolling when already started") : invariant3() : void 0;
    const dragStartTime = Date.now();
    let wasScrollNeeded = false;
    const fakeScrollCallback = () => {
      wasScrollNeeded = true;
    };
    scroll({
      state,
      dragStartTime: 0,
      shouldUseTimeDampening: false,
      scrollWindow: fakeScrollCallback,
      scrollDroppable: fakeScrollCallback,
      getAutoScrollerOptions
    });
    dragging = {
      dragStartTime,
      shouldUseTimeDampening: wasScrollNeeded
    };
    finish();
    if (wasScrollNeeded) {
      tryScroll(state);
    }
  };
  const stop = () => {
    if (!dragging) {
      return;
    }
    scheduleWindowScroll.cancel();
    scheduleDroppableScroll.cancel();
    dragging = null;
  };
  return {
    start: start$1,
    stop,
    scroll: tryScroll
  };
};
var createJumpScroller = ({
  move: move2,
  scrollDroppable: scrollDroppable2,
  scrollWindow: scrollWindow2
}) => {
  const moveByOffset = (state, offset4) => {
    const client = add2(state.current.client.selection, offset4);
    move2({
      client
    });
  };
  const scrollDroppableAsMuchAsItCan = (droppable2, change) => {
    if (!canScrollDroppable(droppable2, change)) {
      return change;
    }
    const overlap = getDroppableOverlap(droppable2, change);
    if (!overlap) {
      scrollDroppable2(droppable2.descriptor.id, change);
      return null;
    }
    const whatTheDroppableCanScroll = subtract(change, overlap);
    scrollDroppable2(droppable2.descriptor.id, whatTheDroppableCanScroll);
    const remainder = subtract(change, whatTheDroppableCanScroll);
    return remainder;
  };
  const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport2, change) => {
    if (!isWindowScrollAllowed) {
      return change;
    }
    if (!canScrollWindow(viewport2, change)) {
      return change;
    }
    const overlap = getWindowOverlap(viewport2, change);
    if (!overlap) {
      scrollWindow2(change);
      return null;
    }
    const whatTheWindowCanScroll = subtract(change, overlap);
    scrollWindow2(whatTheWindowCanScroll);
    const remainder = subtract(change, whatTheWindowCanScroll);
    return remainder;
  };
  const jumpScroller = (state) => {
    const request = state.scrollJumpRequest;
    if (!request) {
      return;
    }
    const destination = whatIsDraggedOver(state.impact);
    !destination ? true ? invariant3(false, "Cannot perform a jump scroll when there is no destination") : invariant3() : void 0;
    const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
    if (!droppableRemainder) {
      return;
    }
    const viewport2 = state.viewport;
    const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport2, droppableRemainder);
    if (!windowRemainder) {
      return;
    }
    moveByOffset(state, windowRemainder);
  };
  return jumpScroller;
};
var createAutoScroller = ({
  scrollDroppable: scrollDroppable2,
  scrollWindow: scrollWindow2,
  move: move2,
  getAutoScrollerOptions
}) => {
  const fluidScroller = createFluidScroller({
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2,
    getAutoScrollerOptions
  });
  const jumpScroll = createJumpScroller({
    move: move2,
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  const scroll2 = (state) => {
    const autoScrollerOptions = getAutoScrollerOptions();
    if (autoScrollerOptions.disabled || state.phase !== "DRAGGING") {
      return;
    }
    if (state.movementMode === "FLUID") {
      fluidScroller.scroll(state);
      return;
    }
    if (!state.scrollJumpRequest) {
      return;
    }
    jumpScroll(state);
  };
  const scroller = {
    scroll: scroll2,
    start: fluidScroller.start,
    stop: fluidScroller.stop
  };
  return scroller;
};
var prefix2 = "data-rfd";
var dragHandle = (() => {
  const base2 = `${prefix2}-drag-handle`;
  return {
    base: base2,
    draggableId: `${base2}-draggable-id`,
    contextId: `${base2}-context-id`
  };
})();
var draggable = (() => {
  const base2 = `${prefix2}-draggable`;
  return {
    base: base2,
    contextId: `${base2}-context-id`,
    id: `${base2}-id`
  };
})();
var droppable = (() => {
  const base2 = `${prefix2}-droppable`;
  return {
    base: base2,
    contextId: `${base2}-context-id`,
    id: `${base2}-id`
  };
})();
var scrollContainer = {
  contextId: `${prefix2}-scroll-container-context-id`
};
var makeGetSelector = (context) => (attribute) => `[${attribute}="${context}"]`;
var getStyles = (rules, property) => rules.map((rule) => {
  const value = rule.styles[property];
  if (!value) {
    return "";
  }
  return `${rule.selector} { ${value} }`;
}).join(" ");
var noPointerEvents = "pointer-events: none;";
var getStyles$1 = (contextId) => {
  const getSelector2 = makeGetSelector(contextId);
  const dragHandle$1 = (() => {
    const grabCursor = `
      cursor: -webkit-grab;
      cursor: grab;
    `;
    return {
      selector: getSelector2(dragHandle.contextId),
      styles: {
        always: `
          -webkit-touch-callout: none;
          -webkit-tap-highlight-color: rgba(0,0,0,0);
          touch-action: manipulation;
        `,
        resting: grabCursor,
        dragging: noPointerEvents,
        dropAnimating: grabCursor
      }
    };
  })();
  const draggable$1 = (() => {
    const transition = `
      transition: ${transitions.outOfTheWay};
    `;
    return {
      selector: getSelector2(draggable.contextId),
      styles: {
        dragging: transition,
        dropAnimating: transition,
        userCancel: transition
      }
    };
  })();
  const droppable$1 = {
    selector: getSelector2(droppable.contextId),
    styles: {
      always: `overflow-anchor: none;`
    }
  };
  const body = {
    selector: "body",
    styles: {
      dragging: `
        cursor: grabbing;
        cursor: -webkit-grabbing;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        overflow-anchor: none;
      `
    }
  };
  const rules = [draggable$1, dragHandle$1, droppable$1, body];
  return {
    always: getStyles(rules, "always"),
    resting: getStyles(rules, "resting"),
    dragging: getStyles(rules, "dragging"),
    dropAnimating: getStyles(rules, "dropAnimating"),
    userCancel: getStyles(rules, "userCancel")
  };
};
var useIsomorphicLayoutEffect3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react6.useLayoutEffect : import_react6.useEffect;
var getHead = () => {
  const head = document.querySelector("head");
  !head ? true ? invariant3(false, "Cannot find the head to append a style to") : invariant3() : void 0;
  return head;
};
var createStyleEl = (nonce) => {
  const el2 = document.createElement("style");
  if (nonce) {
    el2.setAttribute("nonce", nonce);
  }
  el2.type = "text/css";
  return el2;
};
function useStyleMarshal(contextId, nonce) {
  const styles2 = useMemo6(() => getStyles$1(contextId), [contextId]);
  const alwaysRef = (0, import_react6.useRef)(null);
  const dynamicRef = (0, import_react6.useRef)(null);
  const setDynamicStyle = useCallback6(memoizeOne2((proposed) => {
    const el2 = dynamicRef.current;
    !el2 ? true ? invariant3(false, "Cannot set dynamic style element if it is not set") : invariant3() : void 0;
    el2.textContent = proposed;
  }), []);
  const setAlwaysStyle = useCallback6((proposed) => {
    const el2 = alwaysRef.current;
    !el2 ? true ? invariant3(false, "Cannot set dynamic style element if it is not set") : invariant3() : void 0;
    el2.textContent = proposed;
  }, []);
  useIsomorphicLayoutEffect3(() => {
    !(!alwaysRef.current && !dynamicRef.current) ? true ? invariant3(false, "style elements already mounted") : invariant3() : void 0;
    const always = createStyleEl(nonce);
    const dynamic = createStyleEl(nonce);
    alwaysRef.current = always;
    dynamicRef.current = dynamic;
    always.setAttribute(`${prefix2}-always`, contextId);
    dynamic.setAttribute(`${prefix2}-dynamic`, contextId);
    getHead().appendChild(always);
    getHead().appendChild(dynamic);
    setAlwaysStyle(styles2.always);
    setDynamicStyle(styles2.resting);
    return () => {
      const remove = (ref2) => {
        const current = ref2.current;
        !current ? true ? invariant3(false, "Cannot unmount ref as it is not set") : invariant3() : void 0;
        getHead().removeChild(current);
        ref2.current = null;
      };
      remove(alwaysRef);
      remove(dynamicRef);
    };
  }, [nonce, setAlwaysStyle, setDynamicStyle, styles2.always, styles2.resting, contextId]);
  const dragging = useCallback6(() => setDynamicStyle(styles2.dragging), [setDynamicStyle, styles2.dragging]);
  const dropping = useCallback6((reason) => {
    if (reason === "DROP") {
      setDynamicStyle(styles2.dropAnimating);
      return;
    }
    setDynamicStyle(styles2.userCancel);
  }, [setDynamicStyle, styles2.dropAnimating, styles2.userCancel]);
  const resting = useCallback6(() => {
    if (!dynamicRef.current) {
      return;
    }
    setDynamicStyle(styles2.resting);
  }, [setDynamicStyle, styles2.resting]);
  const marshal = useMemo6(() => ({
    dragging,
    dropping,
    resting
  }), [dragging, dropping, resting]);
  return marshal;
}
function querySelectorAll(parentNode2, selector) {
  return Array.from(parentNode2.querySelectorAll(selector));
}
var getWindowFromEl = (el2) => {
  if (el2 && el2.ownerDocument && el2.ownerDocument.defaultView) {
    return el2.ownerDocument.defaultView;
  }
  return window;
};
function isHtmlElement2(el2) {
  return el2 instanceof getWindowFromEl(el2).HTMLElement;
}
function findDragHandle(contextId, draggableId) {
  const selector = `[${dragHandle.contextId}="${contextId}"]`;
  const possible = querySelectorAll(document, selector);
  if (!possible.length) {
    true ? warning4(`Unable to find any drag handles in the context "${contextId}"`) : void 0;
    return null;
  }
  const handle = possible.find((el2) => {
    return el2.getAttribute(dragHandle.draggableId) === draggableId;
  });
  if (!handle) {
    true ? warning4(`Unable to find drag handle with id "${draggableId}" as no handle with a matching id was found`) : void 0;
    return null;
  }
  if (!isHtmlElement2(handle)) {
    true ? warning4("drag handle needs to be a HTMLElement") : void 0;
    return null;
  }
  return handle;
}
function useFocusMarshal(contextId) {
  const entriesRef = (0, import_react6.useRef)({});
  const recordRef = (0, import_react6.useRef)(null);
  const restoreFocusFrameRef = (0, import_react6.useRef)(null);
  const isMountedRef = (0, import_react6.useRef)(false);
  const register2 = useCallback6(function register3(id2, focus3) {
    const entry = {
      id: id2,
      focus: focus3
    };
    entriesRef.current[id2] = entry;
    return function unregister() {
      const entries = entriesRef.current;
      const current = entries[id2];
      if (current !== entry) {
        delete entries[id2];
      }
    };
  }, []);
  const tryGiveFocus = useCallback6(function tryGiveFocus2(tryGiveFocusTo) {
    const handle = findDragHandle(contextId, tryGiveFocusTo);
    if (handle && handle !== document.activeElement) {
      handle.focus();
    }
  }, [contextId]);
  const tryShiftRecord = useCallback6(function tryShiftRecord2(previous, redirectTo) {
    if (recordRef.current === previous) {
      recordRef.current = redirectTo;
    }
  }, []);
  const tryRestoreFocusRecorded = useCallback6(function tryRestoreFocusRecorded2() {
    if (restoreFocusFrameRef.current) {
      return;
    }
    if (!isMountedRef.current) {
      return;
    }
    restoreFocusFrameRef.current = requestAnimationFrame(() => {
      restoreFocusFrameRef.current = null;
      const record = recordRef.current;
      if (record) {
        tryGiveFocus(record);
      }
    });
  }, [tryGiveFocus]);
  const tryRecordFocus = useCallback6(function tryRecordFocus2(id2) {
    recordRef.current = null;
    const focused = document.activeElement;
    if (!focused) {
      return;
    }
    if (focused.getAttribute(dragHandle.draggableId) !== id2) {
      return;
    }
    recordRef.current = id2;
  }, []);
  useIsomorphicLayoutEffect3(() => {
    isMountedRef.current = true;
    return function clearFrameOnUnmount() {
      isMountedRef.current = false;
      const frameId = restoreFocusFrameRef.current;
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, []);
  const marshal = useMemo6(() => ({
    register: register2,
    tryRecordFocus,
    tryRestoreFocusRecorded,
    tryShiftRecord
  }), [register2, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
  return marshal;
}
function createRegistry() {
  const entries = {
    draggables: {},
    droppables: {}
  };
  const subscribers = [];
  function subscribe(cb) {
    subscribers.push(cb);
    return function unsubscribe() {
      const index2 = subscribers.indexOf(cb);
      if (index2 === -1) {
        return;
      }
      subscribers.splice(index2, 1);
    };
  }
  function notify(event) {
    if (subscribers.length) {
      subscribers.forEach((cb) => cb(event));
    }
  }
  function findDraggableById(id2) {
    return entries.draggables[id2] || null;
  }
  function getDraggableById(id2) {
    const entry = findDraggableById(id2);
    !entry ? true ? invariant3(false, `Cannot find draggable entry with id [${id2}]`) : invariant3() : void 0;
    return entry;
  }
  const draggableAPI = {
    register: (entry) => {
      entries.draggables[entry.descriptor.id] = entry;
      notify({
        type: "ADDITION",
        value: entry
      });
    },
    update: (entry, last) => {
      const current = entries.draggables[last.descriptor.id];
      if (!current) {
        return;
      }
      if (current.uniqueId !== entry.uniqueId) {
        return;
      }
      delete entries.draggables[last.descriptor.id];
      entries.draggables[entry.descriptor.id] = entry;
    },
    unregister: (entry) => {
      const draggableId = entry.descriptor.id;
      const current = findDraggableById(draggableId);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.draggables[draggableId];
      if (entries.droppables[entry.descriptor.droppableId]) {
        notify({
          type: "REMOVAL",
          value: entry
        });
      }
    },
    getById: getDraggableById,
    findById: findDraggableById,
    exists: (id2) => Boolean(findDraggableById(id2)),
    getAllByType: (type) => Object.values(entries.draggables).filter((entry) => entry.descriptor.type === type)
  };
  function findDroppableById(id2) {
    return entries.droppables[id2] || null;
  }
  function getDroppableById(id2) {
    const entry = findDroppableById(id2);
    !entry ? true ? invariant3(false, `Cannot find droppable entry with id [${id2}]`) : invariant3() : void 0;
    return entry;
  }
  const droppableAPI = {
    register: (entry) => {
      entries.droppables[entry.descriptor.id] = entry;
    },
    unregister: (entry) => {
      const current = findDroppableById(entry.descriptor.id);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.droppables[entry.descriptor.id];
    },
    getById: getDroppableById,
    findById: findDroppableById,
    exists: (id2) => Boolean(findDroppableById(id2)),
    getAllByType: (type) => Object.values(entries.droppables).filter((entry) => entry.descriptor.type === type)
  };
  function clean3() {
    entries.draggables = {};
    entries.droppables = {};
    subscribers.length = 0;
  }
  return {
    draggable: draggableAPI,
    droppable: droppableAPI,
    subscribe,
    clean: clean3
  };
}
function useRegistry() {
  const registry = useMemo6(createRegistry, []);
  (0, import_react6.useEffect)(() => {
    return function unmount() {
      registry.clean();
    };
  }, [registry]);
  return registry;
}
var StoreContext = import_react6.default.createContext(null);
var getBodyElement = () => {
  const body = document.body;
  !body ? true ? invariant3(false, "Cannot find document.body") : invariant3() : void 0;
  return body;
};
var visuallyHidden = {
  position: "absolute",
  width: "1px",
  height: "1px",
  margin: "-1px",
  border: "0",
  padding: "0",
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(100%)"
};
var getId = (contextId) => `rfd-announcement-${contextId}`;
function useAnnouncer(contextId) {
  const id2 = useMemo6(() => getId(contextId), [contextId]);
  const ref2 = (0, import_react6.useRef)(null);
  (0, import_react6.useEffect)(function setup() {
    const el2 = document.createElement("div");
    ref2.current = el2;
    el2.id = id2;
    el2.setAttribute("aria-live", "assertive");
    el2.setAttribute("aria-atomic", "true");
    _extends(el2.style, visuallyHidden);
    getBodyElement().appendChild(el2);
    return function cleanup() {
      setTimeout(function remove() {
        const body = getBodyElement();
        if (body.contains(el2)) {
          body.removeChild(el2);
        }
        if (el2 === ref2.current) {
          ref2.current = null;
        }
      });
    };
  }, [id2]);
  const announce = useCallback6((message2) => {
    const el2 = ref2.current;
    if (el2) {
      el2.textContent = message2;
      return;
    }
    true ? warning4(`
      A screen reader message was trying to be announced but it was unable to do so.
      This can occur if you unmount your <DragDropContext /> in your onDragEnd.
      Consider calling provided.announce() before the unmount so that the instruction will
      not be lost for users relying on a screen reader.

      Message not passed to screen reader:

      "${message2}"
    `) : void 0;
  }, []);
  return announce;
}
var defaults2 = {
  separator: "::"
};
function useUniqueId(prefix3, options2 = defaults2) {
  const id2 = import_react6.default.useId();
  return useMemo6(() => `${prefix3}${options2.separator}${id2}`, [options2.separator, prefix3, id2]);
}
function getElementId({
  contextId,
  uniqueId
}) {
  return `rfd-hidden-text-${contextId}-${uniqueId}`;
}
function useHiddenTextElement({
  contextId,
  text
}) {
  const uniqueId = useUniqueId("hidden-text", {
    separator: "-"
  });
  const id2 = useMemo6(() => getElementId({
    contextId,
    uniqueId
  }), [uniqueId, contextId]);
  (0, import_react6.useEffect)(function mount() {
    const el2 = document.createElement("div");
    el2.id = id2;
    el2.textContent = text;
    el2.style.display = "none";
    getBodyElement().appendChild(el2);
    return function unmount() {
      const body = getBodyElement();
      if (body.contains(el2)) {
        body.removeChild(el2);
      }
    };
  }, [id2, text]);
  return id2;
}
var AppContext = import_react6.default.createContext(null);
var peerDependencies = {
  react: "^18.0.0",
  "react-dom": "^18.0.0"
};
var semver = /(\d+)\.(\d+)\.(\d+)/;
var getVersion = (value) => {
  const result = semver.exec(value);
  !(result != null) ? true ? invariant3(false, `Unable to parse React version ${value}`) : invariant3() : void 0;
  const major = Number(result[1]);
  const minor = Number(result[2]);
  const patch2 = Number(result[3]);
  return {
    major,
    minor,
    patch: patch2,
    raw: value
  };
};
var isSatisfied = (expected, actual) => {
  if (actual.major > expected.major) {
    return true;
  }
  if (actual.major < expected.major) {
    return false;
  }
  if (actual.minor > expected.minor) {
    return true;
  }
  if (actual.minor < expected.minor) {
    return false;
  }
  return actual.patch >= expected.patch;
};
var checkReactVersion = (peerDepValue, actualValue) => {
  const peerDep = getVersion(peerDepValue);
  const actual = getVersion(actualValue);
  if (isSatisfied(peerDep, actual)) {
    return;
  }
  true ? warning4(`
    React version: [${actual.raw}]
    does not satisfy expected peer dependency version: [${peerDep.raw}]

    This can result in run time bugs, and even fatal crashes
  `) : void 0;
};
var suffix = `
  We expect a html5 doctype: <!doctype html>
  This is to ensure consistent browser layout and measurement

  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md
`;
var checkDoctype = (doc3) => {
  const doctype = doc3.doctype;
  if (!doctype) {
    true ? warning4(`
      No <!doctype html> found.

      ${suffix}
    `) : void 0;
    return;
  }
  if (doctype.name.toLowerCase() !== "html") {
    true ? warning4(`
      Unexpected <!doctype> found: (${doctype.name})

      ${suffix}
    `) : void 0;
  }
  if (doctype.publicId !== "") {
    true ? warning4(`
      Unexpected <!doctype> publicId found: (${doctype.publicId})
      A html5 doctype does not have a publicId

      ${suffix}
    `) : void 0;
  }
};
function useDev(useHook) {
  if (true) {
    useHook();
  }
}
function useDevSetupWarning(fn2, inputs) {
  useDev(() => {
    (0, import_react6.useEffect)(() => {
      try {
        fn2();
      } catch (e2) {
        error(`
          A setup problem was encountered.

          > ${e2.message}
        `);
      }
    }, inputs);
  });
}
function useStartupValidation() {
  useDevSetupWarning(() => {
    checkReactVersion(peerDependencies.react, import_react6.default.version);
    checkDoctype(document);
  }, []);
}
function usePrevious(current) {
  const ref2 = (0, import_react6.useRef)(current);
  (0, import_react6.useEffect)(() => {
    ref2.current = current;
  });
  return ref2;
}
function create10() {
  let lock = null;
  function isClaimed() {
    return Boolean(lock);
  }
  function isActive3(value) {
    return value === lock;
  }
  function claim(abandon) {
    !!lock ? true ? invariant3(false, "Cannot claim lock as it is already claimed") : invariant3() : void 0;
    const newLock = {
      abandon
    };
    lock = newLock;
    return newLock;
  }
  function release() {
    !lock ? true ? invariant3(false, "Cannot release lock when there is no lock") : invariant3() : void 0;
    lock = null;
  }
  function tryAbandon() {
    if (lock) {
      lock.abandon();
      release();
    }
  }
  return {
    isClaimed,
    isActive: isActive3,
    claim,
    release,
    tryAbandon
  };
}
function isDragging(state) {
  if (state.phase === "IDLE" || state.phase === "DROP_ANIMATING") {
    return false;
  }
  return state.isDragging;
}
var tab = 9;
var enter = 13;
var escape = 27;
var space = 32;
var pageUp = 33;
var pageDown = 34;
var end = 35;
var home = 36;
var arrowLeft = 37;
var arrowUp = 38;
var arrowRight = 39;
var arrowDown = 40;
var preventedKeys = {
  [enter]: true,
  [tab]: true
};
var preventStandardKeyEvents = (event) => {
  if (preventedKeys[event.keyCode]) {
    event.preventDefault();
  }
};
var supportedEventName = (() => {
  const base2 = "visibilitychange";
  if (typeof document === "undefined") {
    return base2;
  }
  const candidates = [base2, `ms${base2}`, `webkit${base2}`, `moz${base2}`, `o${base2}`];
  const supported = candidates.find((eventName) => `on${eventName}` in document);
  return supported || base2;
})();
var primaryButton = 0;
var sloppyClickThreshold = 5;
function isSloppyClickThresholdExceeded(original, current) {
  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
}
var idle$1 = {
  type: "IDLE"
};
function getCaptureBindings({
  cancel,
  completed,
  getPhase,
  setPhase
}) {
  return [{
    eventName: "mousemove",
    fn: (event) => {
      const {
        button,
        clientX,
        clientY
      } = event;
      if (button !== primaryButton) {
        return;
      }
      const point = {
        x: clientX,
        y: clientY
      };
      const phase = getPhase();
      if (phase.type === "DRAGGING") {
        event.preventDefault();
        phase.actions.move(point);
        return;
      }
      !(phase.type === "PENDING") ? true ? invariant3(false, "Cannot be IDLE") : invariant3() : void 0;
      const pending = phase.point;
      if (!isSloppyClickThresholdExceeded(pending, point)) {
        return;
      }
      event.preventDefault();
      const actions = phase.actions.fluidLift(point);
      setPhase({
        type: "DRAGGING",
        actions
      });
    }
  }, {
    eventName: "mouseup",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "mousedown",
    fn: (event) => {
      if (getPhase().type === "DRAGGING") {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: "keydown",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type === "PENDING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: () => {
      if (getPhase().type === "PENDING") {
        cancel();
      }
    }
  }, {
    eventName: "webkitmouseforcedown",
    fn: (event) => {
      const phase = getPhase();
      !(phase.type !== "IDLE") ? true ? invariant3(false, "Unexpected phase") : invariant3() : void 0;
      if (phase.actions.shouldRespectForcePress()) {
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useMouseSensor(api) {
  const phaseRef = (0, import_react6.useRef)(idle$1);
  const unbindEventsRef = (0, import_react6.useRef)(noop$2);
  const startCaptureBinding = useMemo6(() => ({
    eventName: "mousedown",
    fn: function onMouseDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.button !== primaryButton) {
        return;
      }
      if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const actions = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!actions) {
        return;
      }
      event.preventDefault();
      const point = {
        x: event.clientX,
        y: event.clientY
      };
      unbindEventsRef.current();
      startPendingDrag(actions, point);
    }
  }), [api]);
  const preventForcePressBinding = useMemo6(() => ({
    eventName: "webkitmouseforcewillbegin",
    fn: (event) => {
      if (event.defaultPrevented) {
        return;
      }
      const id2 = api.findClosestDraggableId(event);
      if (!id2) {
        return;
      }
      const options2 = api.findOptionsForDraggable(id2);
      if (!options2) {
        return;
      }
      if (options2.shouldRespectForcePress) {
        return;
      }
      if (!api.canGetLock(id2)) {
        return;
      }
      event.preventDefault();
    }
  }), [api]);
  const listenForCapture = useCallback6(function listenForCapture2() {
    const options2 = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options2);
  }, [preventForcePressBinding, startCaptureBinding]);
  const stop = useCallback6(() => {
    const current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    phaseRef.current = idle$1;
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture]);
  const cancel = useCallback6(() => {
    const phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  const bindCapturingEvents = useCallback6(function bindCapturingEvents2() {
    const options2 = {
      capture: true,
      passive: false
    };
    const bindings = getCaptureBindings({
      cancel,
      completed: stop,
      getPhase: () => phaseRef.current,
      setPhase: (phase) => {
        phaseRef.current = phase;
      }
    });
    unbindEventsRef.current = bindEvents(window, bindings, options2);
  }, [cancel, stop]);
  const startPendingDrag = useCallback6(function startPendingDrag2(actions, point) {
    !(phaseRef.current.type === "IDLE") ? true ? invariant3(false, "Expected to move from IDLE to PENDING drag") : invariant3() : void 0;
    phaseRef.current = {
      type: "PENDING",
      point,
      actions
    };
    bindCapturingEvents();
  }, [bindCapturingEvents]);
  useIsomorphicLayoutEffect3(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
function noop$1() {
}
var scrollJumpKeys = {
  [pageDown]: true,
  [pageUp]: true,
  [home]: true,
  [end]: true
};
function getDraggingBindings(actions, stop) {
  function cancel() {
    stop();
    actions.cancel();
  }
  function drop2() {
    stop();
    actions.drop();
  }
  return [{
    eventName: "keydown",
    fn: (event) => {
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      if (event.keyCode === space) {
        event.preventDefault();
        drop2();
        return;
      }
      if (event.keyCode === arrowDown) {
        event.preventDefault();
        actions.moveDown();
        return;
      }
      if (event.keyCode === arrowUp) {
        event.preventDefault();
        actions.moveUp();
        return;
      }
      if (event.keyCode === arrowRight) {
        event.preventDefault();
        actions.moveRight();
        return;
      }
      if (event.keyCode === arrowLeft) {
        event.preventDefault();
        actions.moveLeft();
        return;
      }
      if (scrollJumpKeys[event.keyCode]) {
        event.preventDefault();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "mousedown",
    fn: cancel
  }, {
    eventName: "mouseup",
    fn: cancel
  }, {
    eventName: "click",
    fn: cancel
  }, {
    eventName: "touchstart",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "wheel",
    fn: cancel,
    options: {
      passive: true
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useKeyboardSensor(api) {
  const unbindEventsRef = (0, import_react6.useRef)(noop$1);
  const startCaptureBinding = useMemo6(() => ({
    eventName: "keydown",
    fn: function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.keyCode !== space) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const preDrag = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!preDrag) {
        return;
      }
      event.preventDefault();
      let isCapturing = true;
      const actions = preDrag.snapLift();
      unbindEventsRef.current();
      function stop() {
        !isCapturing ? true ? invariant3(false, "Cannot stop capturing a keyboard drag when not capturing") : invariant3() : void 0;
        isCapturing = false;
        unbindEventsRef.current();
        listenForCapture();
      }
      unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
        capture: true,
        passive: false
      });
    }
  }), [api]);
  const listenForCapture = useCallback6(function tryStartCapture() {
    const options2 = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options2);
  }, [startCaptureBinding]);
  useIsomorphicLayoutEffect3(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var idle = {
  type: "IDLE"
};
var timeForLongPress = 120;
var forcePressThreshold = 0.15;
function getWindowBindings({
  cancel,
  getPhase
}) {
  return [{
    eventName: "orientationchange",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "contextmenu",
    fn: (event) => {
      event.preventDefault();
    }
  }, {
    eventName: "keydown",
    fn: (event) => {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function getHandleBindings({
  cancel,
  completed,
  getPhase
}) {
  return [{
    eventName: "touchmove",
    options: {
      capture: false
    },
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      phase.hasMoved = true;
      const {
        clientX,
        clientY
      } = event.touches[0];
      const point = {
        x: clientX,
        y: clientY
      };
      event.preventDefault();
      phase.actions.move(point);
    }
  }, {
    eventName: "touchend",
    fn: (event) => {
      const phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "touchcancel",
    fn: (event) => {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      cancel();
    }
  }, {
    eventName: "touchforcechange",
    fn: (event) => {
      const phase = getPhase();
      !(phase.type !== "IDLE") ? true ? invariant3() : invariant3() : void 0;
      const touch = event.touches[0];
      if (!touch) {
        return;
      }
      const isForcePress = touch.force >= forcePressThreshold;
      if (!isForcePress) {
        return;
      }
      const shouldRespect = phase.actions.shouldRespectForcePress();
      if (phase.type === "PENDING") {
        if (shouldRespect) {
          cancel();
        }
        return;
      }
      if (shouldRespect) {
        if (phase.hasMoved) {
          event.preventDefault();
          return;
        }
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useTouchSensor(api) {
  const phaseRef = (0, import_react6.useRef)(idle);
  const unbindEventsRef = (0, import_react6.useRef)(noop$2);
  const getPhase = useCallback6(function getPhase2() {
    return phaseRef.current;
  }, []);
  const setPhase = useCallback6(function setPhase2(phase) {
    phaseRef.current = phase;
  }, []);
  const startCaptureBinding = useMemo6(() => ({
    eventName: "touchstart",
    fn: function onTouchStart(event) {
      if (event.defaultPrevented) {
        return;
      }
      const draggableId = api.findClosestDraggableId(event);
      if (!draggableId) {
        return;
      }
      const actions = api.tryGetLock(draggableId, stop, {
        sourceEvent: event
      });
      if (!actions) {
        return;
      }
      const touch = event.touches[0];
      const {
        clientX,
        clientY
      } = touch;
      const point = {
        x: clientX,
        y: clientY
      };
      unbindEventsRef.current();
      startPendingDrag(actions, point);
    }
  }), [api]);
  const listenForCapture = useCallback6(function listenForCapture2() {
    const options2 = {
      capture: true,
      passive: false
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options2);
  }, [startCaptureBinding]);
  const stop = useCallback6(() => {
    const current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    if (current.type === "PENDING") {
      clearTimeout(current.longPressTimerId);
    }
    setPhase(idle);
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture, setPhase]);
  const cancel = useCallback6(() => {
    const phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  const bindCapturingEvents = useCallback6(function bindCapturingEvents2() {
    const options2 = {
      capture: true,
      passive: false
    };
    const args = {
      cancel,
      completed: stop,
      getPhase
    };
    const unbindTarget = bindEvents(window, getHandleBindings(args), options2);
    const unbindWindow = bindEvents(window, getWindowBindings(args), options2);
    unbindEventsRef.current = function unbindAll() {
      unbindTarget();
      unbindWindow();
    };
  }, [cancel, getPhase, stop]);
  const startDragging = useCallback6(function startDragging2() {
    const phase = getPhase();
    !(phase.type === "PENDING") ? true ? invariant3(false, `Cannot start dragging from phase ${phase.type}`) : invariant3() : void 0;
    const actions = phase.actions.fluidLift(phase.point);
    setPhase({
      type: "DRAGGING",
      actions,
      hasMoved: false
    });
  }, [getPhase, setPhase]);
  const startPendingDrag = useCallback6(function startPendingDrag2(actions, point) {
    !(getPhase().type === "IDLE") ? true ? invariant3(false, "Expected to move from IDLE to PENDING drag") : invariant3() : void 0;
    const longPressTimerId = setTimeout(startDragging, timeForLongPress);
    setPhase({
      type: "PENDING",
      point,
      actions,
      longPressTimerId
    });
    bindCapturingEvents();
  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
  useIsomorphicLayoutEffect3(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
      const phase = getPhase();
      if (phase.type === "PENDING") {
        clearTimeout(phase.longPressTimerId);
        setPhase(idle);
      }
    };
  }, [getPhase, listenForCapture, setPhase]);
  useIsomorphicLayoutEffect3(function webkitHack() {
    const unbind = bindEvents(window, [{
      eventName: "touchmove",
      fn: () => {
      },
      options: {
        capture: false,
        passive: false
      }
    }]);
    return unbind;
  }, []);
}
function useValidateSensorHooks(sensorHooks) {
  useDev(() => {
    const previousRef = usePrevious(sensorHooks);
    useDevSetupWarning(() => {
      !(previousRef.current.length === sensorHooks.length) ? true ? invariant3(false, "Cannot change the amount of sensor hooks after mounting") : invariant3(false) : void 0;
    });
  });
}
var interactiveTagNames = ["input", "button", "textarea", "select", "option", "optgroup", "video", "audio"];
function isAnInteractiveElement(parent, current) {
  if (current == null) {
    return false;
  }
  const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());
  if (hasAnInteractiveTag) {
    return true;
  }
  const attribute = current.getAttribute("contenteditable");
  if (attribute === "true" || attribute === "") {
    return true;
  }
  if (current === parent) {
    return false;
  }
  return isAnInteractiveElement(parent, current.parentElement);
}
function isEventInInteractiveElement(draggable2, event) {
  const target = event.target;
  if (!isHtmlElement2(target)) {
    return false;
  }
  return isAnInteractiveElement(draggable2, target);
}
var getBorderBoxCenterPosition = (el2) => getRect(el2.getBoundingClientRect()).center;
function isElement(el2) {
  return el2 instanceof getWindowFromEl(el2).Element;
}
var supportedMatchesName = (() => {
  const base2 = "matches";
  if (typeof document === "undefined") {
    return base2;
  }
  const candidates = [base2, "msMatchesSelector", "webkitMatchesSelector"];
  const value = candidates.find((name) => name in Element.prototype);
  return value || base2;
})();
function closestPonyfill(el2, selector) {
  if (el2 == null) {
    return null;
  }
  if (el2[supportedMatchesName](selector)) {
    return el2;
  }
  return closestPonyfill(el2.parentElement, selector);
}
function closest(el2, selector) {
  if (el2.closest) {
    return el2.closest(selector);
  }
  return closestPonyfill(el2, selector);
}
function getSelector(contextId) {
  return `[${dragHandle.contextId}="${contextId}"]`;
}
function findClosestDragHandleFromEvent(contextId, event) {
  const target = event.target;
  if (!isElement(target)) {
    true ? warning4("event.target must be a Element") : void 0;
    return null;
  }
  const selector = getSelector(contextId);
  const handle = closest(target, selector);
  if (!handle) {
    return null;
  }
  if (!isHtmlElement2(handle)) {
    true ? warning4("drag handle must be a HTMLElement") : void 0;
    return null;
  }
  return handle;
}
function tryGetClosestDraggableIdFromEvent(contextId, event) {
  const handle = findClosestDragHandleFromEvent(contextId, event);
  if (!handle) {
    return null;
  }
  return handle.getAttribute(dragHandle.draggableId);
}
function findDraggable(contextId, draggableId) {
  const selector = `[${draggable.contextId}="${contextId}"]`;
  const possible = querySelectorAll(document, selector);
  const draggable$1 = possible.find((el2) => {
    return el2.getAttribute(draggable.id) === draggableId;
  });
  if (!draggable$1) {
    return null;
  }
  if (!isHtmlElement2(draggable$1)) {
    true ? warning4("Draggable element is not a HTMLElement") : void 0;
    return null;
  }
  return draggable$1;
}
function preventDefault(event) {
  event.preventDefault();
}
function isActive({
  expected,
  phase,
  isLockActive,
  shouldWarn
}) {
  if (!isLockActive()) {
    if (shouldWarn) {
      true ? warning4(`
        Cannot perform action.
        The sensor no longer has an action lock.

        Tips:

        - Throw away your action handlers when forceStop() is called
        - Check actions.isActive() if you really need to
      `) : void 0;
    }
    return false;
  }
  if (expected !== phase) {
    if (shouldWarn) {
      true ? warning4(`
        Cannot perform action.
        The actions you used belong to an outdated phase

        Current phase: ${expected}
        You called an action from outdated phase: ${phase}

        Tips:

        - Do not use preDragActions actions after calling preDragActions.lift()
      `) : void 0;
    }
    return false;
  }
  return true;
}
function canStart({
  lockAPI,
  store,
  registry,
  draggableId
}) {
  if (lockAPI.isClaimed()) {
    return false;
  }
  const entry = registry.draggable.findById(draggableId);
  if (!entry) {
    true ? warning4(`Unable to find draggable with id: ${draggableId}`) : void 0;
    return false;
  }
  if (!entry.options.isEnabled) {
    return false;
  }
  if (!canStartDrag(store.getState(), draggableId)) {
    return false;
  }
  return true;
}
function tryStart({
  lockAPI,
  contextId,
  store,
  registry,
  draggableId,
  forceSensorStop,
  sourceEvent
}) {
  const shouldStart = canStart({
    lockAPI,
    store,
    registry,
    draggableId
  });
  if (!shouldStart) {
    return null;
  }
  const entry = registry.draggable.getById(draggableId);
  const el2 = findDraggable(contextId, entry.descriptor.id);
  if (!el2) {
    true ? warning4(`Unable to find draggable element with id: ${draggableId}`) : void 0;
    return null;
  }
  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el2, sourceEvent)) {
    return null;
  }
  const lock = lockAPI.claim(forceSensorStop || noop$2);
  let phase = "PRE_DRAG";
  function getShouldRespectForcePress() {
    return entry.options.shouldRespectForcePress;
  }
  function isLockActive() {
    return lockAPI.isActive(lock);
  }
  function tryDispatch(expected, getAction) {
    if (isActive({
      expected,
      phase,
      isLockActive,
      shouldWarn: true
    })) {
      store.dispatch(getAction());
    }
  }
  const tryDispatchWhenDragging = tryDispatch.bind(null, "DRAGGING");
  function lift5(args) {
    function completed() {
      lockAPI.release();
      phase = "COMPLETED";
    }
    if (phase !== "PRE_DRAG") {
      completed();
      true ? invariant3(false, `Cannot lift in phase ${phase}`) : invariant3();
    }
    store.dispatch(lift$1(args.liftActionArgs));
    phase = "DRAGGING";
    function finish2(reason, options2 = {
      shouldBlockNextClick: false
    }) {
      args.cleanup();
      if (options2.shouldBlockNextClick) {
        const unbind = bindEvents(window, [{
          eventName: "click",
          fn: preventDefault,
          options: {
            once: true,
            passive: false,
            capture: true
          }
        }]);
        setTimeout(unbind);
      }
      completed();
      store.dispatch(drop({
        reason
      }));
    }
    return {
      isActive: () => isActive({
        expected: "DRAGGING",
        phase,
        isLockActive,
        shouldWarn: false
      }),
      shouldRespectForcePress: getShouldRespectForcePress,
      drop: (options2) => finish2("DROP", options2),
      cancel: (options2) => finish2("CANCEL", options2),
      ...args.actions
    };
  }
  function fluidLift(clientSelection) {
    const move$1 = raf_schd_esm_default((client) => {
      tryDispatchWhenDragging(() => move({
        client
      }));
    });
    const api = lift5({
      liftActionArgs: {
        id: draggableId,
        clientSelection,
        movementMode: "FLUID"
      },
      cleanup: () => move$1.cancel(),
      actions: {
        move: move$1
      }
    });
    return {
      ...api,
      move: move$1
    };
  }
  function snapLift() {
    const actions = {
      moveUp: () => tryDispatchWhenDragging(moveUp),
      moveRight: () => tryDispatchWhenDragging(moveRight),
      moveDown: () => tryDispatchWhenDragging(moveDown),
      moveLeft: () => tryDispatchWhenDragging(moveLeft)
    };
    return lift5({
      liftActionArgs: {
        id: draggableId,
        clientSelection: getBorderBoxCenterPosition(el2),
        movementMode: "SNAP"
      },
      cleanup: noop$2,
      actions
    });
  }
  function abortPreDrag() {
    const shouldRelease = isActive({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: true
    });
    if (shouldRelease) {
      lockAPI.release();
    }
  }
  const preDrag = {
    isActive: () => isActive({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: false
    }),
    shouldRespectForcePress: getShouldRespectForcePress,
    fluidLift,
    snapLift,
    abort: abortPreDrag
  };
  return preDrag;
}
var defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
function useSensorMarshal({
  contextId,
  store,
  registry,
  customSensors,
  enableDefaultSensors
}) {
  const useSensors = [...enableDefaultSensors ? defaultSensors : [], ...customSensors || []];
  const lockAPI = (0, import_react6.useState)(() => create10())[0];
  const tryAbandonLock = useCallback6(function tryAbandonLock2(previous, current) {
    if (isDragging(previous) && !isDragging(current)) {
      lockAPI.tryAbandon();
    }
  }, [lockAPI]);
  useIsomorphicLayoutEffect3(function listenToStore() {
    let previous = store.getState();
    const unsubscribe = store.subscribe(() => {
      const current = store.getState();
      tryAbandonLock(previous, current);
      previous = current;
    });
    return unsubscribe;
  }, [lockAPI, store, tryAbandonLock]);
  useIsomorphicLayoutEffect3(() => {
    return lockAPI.tryAbandon;
  }, [lockAPI.tryAbandon]);
  const canGetLock = useCallback6((draggableId) => {
    return canStart({
      lockAPI,
      registry,
      store,
      draggableId
    });
  }, [lockAPI, registry, store]);
  const tryGetLock = useCallback6((draggableId, forceStop, options2) => tryStart({
    lockAPI,
    registry,
    contextId,
    store,
    draggableId,
    forceSensorStop: forceStop || null,
    sourceEvent: options2 && options2.sourceEvent ? options2.sourceEvent : null
  }), [contextId, lockAPI, registry, store]);
  const findClosestDraggableId = useCallback6((event) => tryGetClosestDraggableIdFromEvent(contextId, event), [contextId]);
  const findOptionsForDraggable = useCallback6((id2) => {
    const entry = registry.draggable.findById(id2);
    return entry ? entry.options : null;
  }, [registry.draggable]);
  const tryReleaseLock = useCallback6(function tryReleaseLock2() {
    if (!lockAPI.isClaimed()) {
      return;
    }
    lockAPI.tryAbandon();
    if (store.getState().phase !== "IDLE") {
      store.dispatch(flush());
    }
  }, [lockAPI, store]);
  const isLockClaimed = useCallback6(() => lockAPI.isClaimed(), [lockAPI]);
  const api = useMemo6(() => ({
    canGetLock,
    tryGetLock,
    findClosestDraggableId,
    findOptionsForDraggable,
    tryReleaseLock,
    isLockClaimed
  }), [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
  useValidateSensorHooks(useSensors);
  for (let i2 = 0; i2 < useSensors.length; i2++) {
    useSensors[i2](api);
  }
}
var createResponders = (props) => ({
  onBeforeCapture: (t2) => {
    const onBeforeCapureCallback = () => {
      if (props.onBeforeCapture) {
        props.onBeforeCapture(t2);
      }
    };
    (0, import_react_dom2.flushSync)(onBeforeCapureCallback);
  },
  onBeforeDragStart: props.onBeforeDragStart,
  onDragStart: props.onDragStart,
  onDragEnd: props.onDragEnd,
  onDragUpdate: props.onDragUpdate
});
var createAutoScrollerOptions = (props) => ({
  ...defaultAutoScrollerOptions,
  ...props.autoScrollerOptions,
  durationDampening: {
    ...defaultAutoScrollerOptions.durationDampening,
    ...props.autoScrollerOptions
  }
});
function getStore(lazyRef) {
  !lazyRef.current ? true ? invariant3(false, "Could not find store from lazy ref") : invariant3() : void 0;
  return lazyRef.current;
}
function App(props) {
  const {
    contextId,
    setCallbacks,
    sensors,
    nonce,
    dragHandleUsageInstructions: dragHandleUsageInstructions2
  } = props;
  const lazyStoreRef = (0, import_react6.useRef)(null);
  useStartupValidation();
  const lastPropsRef = usePrevious(props);
  const getResponders = useCallback6(() => {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);
  const getAutoScrollerOptions = useCallback6(() => {
    return createAutoScrollerOptions(lastPropsRef.current);
  }, [lastPropsRef]);
  const announce = useAnnouncer(contextId);
  const dragHandleUsageInstructionsId = useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions2
  });
  const styleMarshal = useStyleMarshal(contextId, nonce);
  const lazyDispatch = useCallback6((action) => {
    getStore(lazyStoreRef).dispatch(action);
  }, []);
  const marshalCallbacks = useMemo6(() => bindActionCreators({
    publishWhileDragging,
    updateDroppableScroll,
    updateDroppableIsEnabled,
    updateDroppableIsCombineEnabled,
    collectionStarting
  }, lazyDispatch), [lazyDispatch]);
  const registry = useRegistry();
  const dimensionMarshal = useMemo6(() => {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);
  const autoScroller = useMemo6(() => createAutoScroller({
    scrollWindow,
    scrollDroppable: dimensionMarshal.scrollDroppable,
    getAutoScrollerOptions,
    ...bindActionCreators({
      move
    }, lazyDispatch)
  }), [dimensionMarshal.scrollDroppable, lazyDispatch, getAutoScrollerOptions]);
  const focusMarshal = useFocusMarshal(contextId);
  const store = useMemo6(() => createStore2({
    announce,
    autoScroller,
    dimensionMarshal,
    focusMarshal,
    getResponders,
    styleMarshal
  }), [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
  if (true) {
    if (lazyStoreRef.current && lazyStoreRef.current !== store) {
      true ? warning4("unexpected store change") : void 0;
    }
  }
  lazyStoreRef.current = store;
  const tryResetStore = useCallback6(() => {
    const current = getStore(lazyStoreRef);
    const state = current.getState();
    if (state.phase !== "IDLE") {
      current.dispatch(flush());
    }
  }, []);
  const isDragging2 = useCallback6(() => {
    const state = getStore(lazyStoreRef).getState();
    if (state.phase === "DROP_ANIMATING") {
      return true;
    }
    if (state.phase === "IDLE") {
      return false;
    }
    return state.isDragging;
  }, []);
  const appCallbacks = useMemo6(() => ({
    isDragging: isDragging2,
    tryAbort: tryResetStore
  }), [isDragging2, tryResetStore]);
  setCallbacks(appCallbacks);
  const getCanLift = useCallback6((id2) => canStartDrag(getStore(lazyStoreRef).getState(), id2), []);
  const getIsMovementAllowed = useCallback6(() => isMovementAllowed(getStore(lazyStoreRef).getState()), []);
  const appContext = useMemo6(() => ({
    marshal: dimensionMarshal,
    focus: focusMarshal,
    contextId,
    canLift: getCanLift,
    isMovementAllowed: getIsMovementAllowed,
    dragHandleUsageInstructionsId,
    registry
  }), [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
  useSensorMarshal({
    contextId,
    store,
    registry,
    customSensors: sensors || null,
    enableDefaultSensors: props.enableDefaultSensors !== false
  });
  (0, import_react6.useEffect)(() => {
    return tryResetStore;
  }, [tryResetStore]);
  return import_react6.default.createElement(AppContext.Provider, {
    value: appContext
  }, import_react6.default.createElement(Provider_default, {
    context: StoreContext,
    store
  }, props.children));
}
function useUniqueContextId() {
  return import_react6.default.useId();
}
function DragDropContext(props) {
  const contextId = useUniqueContextId();
  const dragHandleUsageInstructions2 = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
  return import_react6.default.createElement(ErrorBoundary, null, (setCallbacks) => import_react6.default.createElement(App, {
    nonce: props.nonce,
    contextId,
    setCallbacks,
    dragHandleUsageInstructions: dragHandleUsageInstructions2,
    enableDefaultSensors: props.enableDefaultSensors,
    sensors: props.sensors,
    onBeforeCapture: props.onBeforeCapture,
    onBeforeDragStart: props.onBeforeDragStart,
    onDragStart: props.onDragStart,
    onDragUpdate: props.onDragUpdate,
    onDragEnd: props.onDragEnd,
    autoScrollerOptions: props.autoScrollerOptions
  }, props.children));
}
var zIndexOptions = {
  dragging: 5e3,
  dropAnimating: 4500
};
var getDraggingTransition = (shouldAnimateDragMovement, dropping) => {
  if (dropping) {
    return transitions.drop(dropping.duration);
  }
  if (shouldAnimateDragMovement) {
    return transitions.snap;
  }
  return transitions.fluid;
};
var getDraggingOpacity = (isCombining, isDropAnimating) => {
  if (!isCombining) {
    return void 0;
  }
  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
};
var getShouldDraggingAnimate = (dragging) => {
  if (dragging.forceShouldAnimate != null) {
    return dragging.forceShouldAnimate;
  }
  return dragging.mode === "SNAP";
};
function getDraggingStyle(dragging) {
  const dimension = dragging.dimension;
  const box = dimension.client;
  const {
    offset: offset4,
    combineWith,
    dropping
  } = dragging;
  const isCombining = Boolean(combineWith);
  const shouldAnimate = getShouldDraggingAnimate(dragging);
  const isDropAnimating = Boolean(dropping);
  const transform = isDropAnimating ? transforms.drop(offset4, isCombining) : transforms.moveTo(offset4);
  const style3 = {
    position: "fixed",
    top: box.marginBox.top,
    left: box.marginBox.left,
    boxSizing: "border-box",
    width: box.borderBox.width,
    height: box.borderBox.height,
    transition: getDraggingTransition(shouldAnimate, dropping),
    transform,
    opacity: getDraggingOpacity(isCombining, isDropAnimating),
    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
    pointerEvents: "none"
  };
  return style3;
}
function getSecondaryStyle(secondary) {
  return {
    transform: transforms.moveTo(secondary.offset),
    transition: secondary.shouldAnimateDisplacement ? void 0 : "none"
  };
}
function getStyle$1(mapped) {
  return mapped.type === "DRAGGING" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
}
function getDimension$1(descriptor, el2, windowScroll = origin) {
  const computedStyles = window.getComputedStyle(el2);
  const borderBox = el2.getBoundingClientRect();
  const client = calculateBox(borderBox, computedStyles);
  const page = withScroll(client, windowScroll);
  const placeholder3 = {
    client,
    tagName: el2.tagName.toLowerCase(),
    display: computedStyles.display
  };
  const displaceBy = {
    x: client.marginBox.width,
    y: client.marginBox.height
  };
  const dimension = {
    descriptor,
    placeholder: placeholder3,
    displaceBy,
    client,
    page
  };
  return dimension;
}
function useDraggablePublisher(args) {
  const uniqueId = useUniqueId("draggable");
  const {
    descriptor,
    registry,
    getDraggableRef,
    canDragInteractiveElements,
    shouldRespectForcePress,
    isEnabled
  } = args;
  const options2 = useMemo6(() => ({
    canDragInteractiveElements,
    shouldRespectForcePress,
    isEnabled
  }), [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
  const getDimension2 = useCallback6((windowScroll) => {
    const el2 = getDraggableRef();
    !el2 ? true ? invariant3(false, "Cannot get dimension when no ref is set") : invariant3() : void 0;
    return getDimension$1(descriptor, el2, windowScroll);
  }, [descriptor, getDraggableRef]);
  const entry = useMemo6(() => ({
    uniqueId,
    descriptor,
    options: options2,
    getDimension: getDimension2
  }), [descriptor, getDimension2, options2, uniqueId]);
  const publishedRef = (0, import_react6.useRef)(entry);
  const isFirstPublishRef = (0, import_react6.useRef)(true);
  useIsomorphicLayoutEffect3(() => {
    registry.draggable.register(publishedRef.current);
    return () => registry.draggable.unregister(publishedRef.current);
  }, [registry.draggable]);
  useIsomorphicLayoutEffect3(() => {
    if (isFirstPublishRef.current) {
      isFirstPublishRef.current = false;
      return;
    }
    const last = publishedRef.current;
    publishedRef.current = entry;
    registry.draggable.update(entry, last);
  }, [entry, registry.draggable]);
}
var DroppableContext = import_react6.default.createContext(null);
function checkIsValidInnerRef(el2) {
  !(el2 && isHtmlElement2(el2)) ? true ? invariant3(false, `
    provided.innerRef has not been provided with a HTMLElement.

    You can find a guide on using the innerRef callback functions at:
    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md
  `) : invariant3() : void 0;
}
function useValidation$1(props, contextId, getRef) {
  useDevSetupWarning(() => {
    function prefix3(id3) {
      return `Draggable[id: ${id3}]: `;
    }
    const id2 = props.draggableId;
    !id2 ? true ? invariant3(false, "Draggable requires a draggableId") : invariant3(false) : void 0;
    !(typeof id2 === "string") ? true ? invariant3(false, `Draggable requires a [string] draggableId.
      Provided: [type: ${typeof id2}] (value: ${id2})`) : invariant3(false) : void 0;
    !Number.isInteger(props.index) ? true ? invariant3(false, `${prefix3(id2)} requires an integer index prop`) : invariant3(false) : void 0;
    if (props.mapped.type === "DRAGGING") {
      return;
    }
    checkIsValidInnerRef(getRef());
    if (props.isEnabled) {
      !findDragHandle(contextId, id2) ? true ? invariant3(false, `${prefix3(id2)} Unable to find drag handle`) : invariant3(false) : void 0;
    }
  });
}
function useClonePropValidation(isClone) {
  useDev(() => {
    const initialRef = (0, import_react6.useRef)(isClone);
    useDevSetupWarning(() => {
      !(isClone === initialRef.current) ? true ? invariant3(false, "Draggable isClone prop value changed during component life") : invariant3(false) : void 0;
    }, [isClone]);
  });
}
function useRequiredContext(Context) {
  const result = (0, import_react6.useContext)(Context);
  !result ? true ? invariant3(false, "Could not find required context") : invariant3() : void 0;
  return result;
}
function preventHtml5Dnd(event) {
  event.preventDefault();
}
var Draggable = (props) => {
  const ref2 = (0, import_react6.useRef)(null);
  const setRef2 = useCallback6((el2 = null) => {
    ref2.current = el2;
  }, []);
  const getRef = useCallback6(() => ref2.current, []);
  const {
    contextId,
    dragHandleUsageInstructionsId,
    registry
  } = useRequiredContext(AppContext);
  const {
    type,
    droppableId
  } = useRequiredContext(DroppableContext);
  const descriptor = useMemo6(() => ({
    id: props.draggableId,
    index: props.index,
    type,
    droppableId
  }), [props.draggableId, props.index, type, droppableId]);
  const {
    children,
    draggableId,
    isEnabled,
    shouldRespectForcePress,
    canDragInteractiveElements,
    isClone,
    mapped,
    dropAnimationFinished: dropAnimationFinishedAction
  } = props;
  useValidation$1(props, contextId, getRef);
  useClonePropValidation(isClone);
  if (!isClone) {
    const forPublisher = useMemo6(() => ({
      descriptor,
      registry,
      getDraggableRef: getRef,
      canDragInteractiveElements,
      shouldRespectForcePress,
      isEnabled
    }), [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
    useDraggablePublisher(forPublisher);
  }
  const dragHandleProps = useMemo6(() => isEnabled ? {
    tabIndex: 0,
    role: "button",
    "aria-describedby": dragHandleUsageInstructionsId,
    "data-rfd-drag-handle-draggable-id": draggableId,
    "data-rfd-drag-handle-context-id": contextId,
    draggable: false,
    onDragStart: preventHtml5Dnd
  } : null, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
  const onMoveEnd = useCallback6((event) => {
    if (mapped.type !== "DRAGGING") {
      return;
    }
    if (!mapped.dropping) {
      return;
    }
    if (event.propertyName !== "transform") {
      return;
    }
    (0, import_react_dom2.flushSync)(dropAnimationFinishedAction);
  }, [dropAnimationFinishedAction, mapped]);
  const provided = useMemo6(() => {
    const style3 = getStyle$1(mapped);
    const onTransitionEnd = mapped.type === "DRAGGING" && mapped.dropping ? onMoveEnd : void 0;
    const result = {
      innerRef: setRef2,
      draggableProps: {
        "data-rfd-draggable-context-id": contextId,
        "data-rfd-draggable-id": draggableId,
        style: style3,
        onTransitionEnd
      },
      dragHandleProps
    };
    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef2]);
  const rubric = useMemo6(() => ({
    draggableId: descriptor.id,
    type: descriptor.type,
    source: {
      index: descriptor.index,
      droppableId: descriptor.droppableId
    }
  }), [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
  return import_react6.default.createElement(import_react6.default.Fragment, null, children(provided, mapped.snapshot, rubric));
};
var isStrictEqual = (a2, b2) => a2 === b2;
var whatIsDraggedOverFromResult = (result) => {
  const {
    combine: combine2,
    destination
  } = result;
  if (destination) {
    return destination.droppableId;
  }
  if (combine2) {
    return combine2.droppableId;
  }
  return null;
};
var getCombineWithFromResult = (result) => {
  return result.combine ? result.combine.draggableId : null;
};
var getCombineWithFromImpact = (impact) => {
  return impact.at && impact.at.type === "COMBINE" ? impact.at.combine.draggableId : null;
};
function getDraggableSelector() {
  const memoizedOffset = memoizeOne2((x, y) => ({
    x,
    y
  }));
  const getMemoizedSnapshot = memoizeOne2((mode, isClone, draggingOver = null, combineWith = null, dropping = null) => ({
    isDragging: true,
    isClone,
    isDropAnimating: Boolean(dropping),
    dropAnimation: dropping,
    mode,
    draggingOver,
    combineWith,
    combineTargetFor: null
  }));
  const getMemoizedProps = memoizeOne2((offset4, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null) => ({
    mapped: {
      type: "DRAGGING",
      dropping: null,
      draggingOver,
      combineWith,
      mode,
      offset: offset4,
      dimension,
      forceShouldAnimate,
      snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
    }
  }));
  const selector = (state, ownProps) => {
    if (isDragging(state)) {
      if (state.critical.draggable.id !== ownProps.draggableId) {
        return null;
      }
      const offset4 = state.current.client.offset;
      const dimension = state.dimensions.draggables[ownProps.draggableId];
      const draggingOver = whatIsDraggedOver(state.impact);
      const combineWith = getCombineWithFromImpact(state.impact);
      const forceShouldAnimate = state.forceShouldAnimate;
      return getMemoizedProps(memoizedOffset(offset4.x, offset4.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (completed.result.draggableId !== ownProps.draggableId) {
        return null;
      }
      const isClone = ownProps.isClone;
      const dimension = state.dimensions.draggables[ownProps.draggableId];
      const result = completed.result;
      const mode = result.mode;
      const draggingOver = whatIsDraggedOverFromResult(result);
      const combineWith = getCombineWithFromResult(result);
      const duration = state.dropDuration;
      const dropping = {
        duration,
        curve: curves.drop,
        moveTo: state.newHomeClientOffset,
        opacity: combineWith ? combine.opacity.drop : null,
        scale: combineWith ? combine.scale.drop : null
      };
      return {
        mapped: {
          type: "DRAGGING",
          offset: state.newHomeClientOffset,
          dimension,
          dropping,
          draggingOver,
          combineWith,
          mode,
          forceShouldAnimate: null,
          snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)
        }
      };
    }
    return null;
  };
  return selector;
}
function getSecondarySnapshot(combineTargetFor = null) {
  return {
    isDragging: false,
    isDropAnimating: false,
    isClone: false,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor,
    combineWith: null
  };
}
var atRest = {
  mapped: {
    type: "SECONDARY",
    offset: origin,
    combineTargetFor: null,
    shouldAnimateDisplacement: true,
    snapshot: getSecondarySnapshot(null)
  }
};
function getSecondarySelector() {
  const memoizedOffset = memoizeOne2((x, y) => ({
    x,
    y
  }));
  const getMemoizedSnapshot = memoizeOne2(getSecondarySnapshot);
  const getMemoizedProps = memoizeOne2((offset4, combineTargetFor = null, shouldAnimateDisplacement) => ({
    mapped: {
      type: "SECONDARY",
      offset: offset4,
      combineTargetFor,
      shouldAnimateDisplacement,
      snapshot: getMemoizedSnapshot(combineTargetFor)
    }
  }));
  const getFallback = (combineTargetFor) => {
    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
  };
  const getProps = (ownId, draggingId, impact, afterCritical) => {
    const visualDisplacement = impact.displaced.visible[ownId];
    const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
    const combine2 = tryGetCombine(impact);
    const combineTargetFor = combine2 && combine2.draggableId === ownId ? draggingId : null;
    if (!visualDisplacement) {
      if (!isAfterCriticalInVirtualList) {
        return getFallback(combineTargetFor);
      }
      if (impact.displaced.invisible[ownId]) {
        return null;
      }
      const change = negate(afterCritical.displacedBy.point);
      const offset5 = memoizedOffset(change.x, change.y);
      return getMemoizedProps(offset5, combineTargetFor, true);
    }
    if (isAfterCriticalInVirtualList) {
      return getFallback(combineTargetFor);
    }
    const displaceBy = impact.displacedBy.point;
    const offset4 = memoizedOffset(displaceBy.x, displaceBy.y);
    return getMemoizedProps(offset4, combineTargetFor, visualDisplacement.shouldAnimate);
  };
  const selector = (state, ownProps) => {
    if (isDragging(state)) {
      if (state.critical.draggable.id === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (completed.result.draggableId === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
    }
    return null;
  };
  return selector;
}
var makeMapStateToProps$1 = () => {
  const draggingSelector = getDraggableSelector();
  const secondarySelector = getSecondarySelector();
  const selector = (state, ownProps) => draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
  return selector;
};
var mapDispatchToProps$1 = {
  dropAnimationFinished
};
var ConnectedDraggable = connect_default(makeMapStateToProps$1, mapDispatchToProps$1, null, {
  context: StoreContext,
  areStatePropsEqual: isStrictEqual
})(Draggable);
function PrivateDraggable(props) {
  const droppableContext = useRequiredContext(DroppableContext);
  const isUsingCloneFor = droppableContext.isUsingCloneFor;
  if (isUsingCloneFor === props.draggableId && !props.isClone) {
    return null;
  }
  return import_react6.default.createElement(ConnectedDraggable, props);
}
function PublicDraggable(props) {
  const isEnabled = typeof props.isDragDisabled === "boolean" ? !props.isDragDisabled : true;
  const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
  const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
  return import_react6.default.createElement(PrivateDraggable, _extends({}, props, {
    isClone: false,
    isEnabled,
    canDragInteractiveElements,
    shouldRespectForcePress
  }));
}
var isEqual3 = (base2) => (value) => base2 === value;
var isScroll = isEqual3("scroll");
var isAuto = isEqual3("auto");
var isVisible = isEqual3("visible");
var isEither = (overflow, fn2) => fn2(overflow.overflowX) || fn2(overflow.overflowY);
var isBoth = (overflow, fn2) => fn2(overflow.overflowX) && fn2(overflow.overflowY);
var isElementScrollable = (el2) => {
  const style3 = window.getComputedStyle(el2);
  const overflow = {
    overflowX: style3.overflowX,
    overflowY: style3.overflowY
  };
  return isEither(overflow, isScroll) || isEither(overflow, isAuto);
};
var isBodyScrollable = () => {
  if (false) {
    return false;
  }
  const body = getBodyElement();
  const html = document.documentElement;
  !html ? true ? invariant3() : invariant3() : void 0;
  if (!isElementScrollable(body)) {
    return false;
  }
  const htmlStyle = window.getComputedStyle(html);
  const htmlOverflow = {
    overflowX: htmlStyle.overflowX,
    overflowY: htmlStyle.overflowY
  };
  if (isBoth(htmlOverflow, isVisible)) {
    return false;
  }
  true ? warning4(`
    We have detected that your <body> element might be a scroll container.
    We have found no reliable way of detecting whether the <body> element is a scroll container.
    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)

    Because we cannot determine if the <body> is a scroll container, and generally it is not one,
    we will be treating the <body> as *not* a scroll container

    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md
  `) : void 0;
  return false;
};
var getClosestScrollable = (el2) => {
  if (el2 == null) {
    return null;
  }
  if (el2 === document.body) {
    return isBodyScrollable() ? el2 : null;
  }
  if (el2 === document.documentElement) {
    return null;
  }
  if (!isElementScrollable(el2)) {
    return getClosestScrollable(el2.parentElement);
  }
  return el2;
};
var checkForNestedScrollContainers = (scrollable) => {
  if (!scrollable) {
    return;
  }
  const anotherScrollParent = getClosestScrollable(scrollable.parentElement);
  if (!anotherScrollParent) {
    return;
  }
  true ? warning4(`
    Droppable: unsupported nested scroll container detected.
    A Droppable can only have one scroll parent (which can be itself)
    Nested scroll containers are currently not supported.

    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131
  `) : void 0;
};
var getScroll = (el2) => ({
  x: el2.scrollLeft,
  y: el2.scrollTop
});
var getIsFixed = (el2) => {
  if (!el2) {
    return false;
  }
  const style3 = window.getComputedStyle(el2);
  if (style3.position === "fixed") {
    return true;
  }
  return getIsFixed(el2.parentElement);
};
var getEnv = (start3) => {
  const closestScrollable = getClosestScrollable(start3);
  const isFixedOnPage = getIsFixed(start3);
  return {
    closestScrollable,
    isFixedOnPage
  };
};
var getDroppableDimension = ({
  descriptor,
  isEnabled,
  isCombineEnabled,
  isFixedOnPage,
  direction: direction2,
  client,
  page,
  closest: closest2
}) => {
  const frame = (() => {
    if (!closest2) {
      return null;
    }
    const {
      scrollSize,
      client: frameClient
    } = closest2;
    const maxScroll = getMaxScroll({
      scrollHeight: scrollSize.scrollHeight,
      scrollWidth: scrollSize.scrollWidth,
      height: frameClient.paddingBox.height,
      width: frameClient.paddingBox.width
    });
    return {
      pageMarginBox: closest2.page.marginBox,
      frameClient,
      scrollSize,
      shouldClipSubject: closest2.shouldClipSubject,
      scroll: {
        initial: closest2.scroll,
        current: closest2.scroll,
        max: maxScroll,
        diff: {
          value: origin,
          displacement: origin
        }
      }
    };
  })();
  const axis = direction2 === "vertical" ? vertical : horizontal;
  const subject = getSubject({
    page,
    withPlaceholder: null,
    axis,
    frame
  });
  const dimension = {
    descriptor,
    isCombineEnabled,
    isFixedOnPage,
    axis,
    isEnabled,
    client,
    page,
    frame,
    subject
  };
  return dimension;
};
var getClient = (targetRef, closestScrollable) => {
  const base2 = getBox(targetRef);
  if (!closestScrollable) {
    return base2;
  }
  if (targetRef !== closestScrollable) {
    return base2;
  }
  const top2 = base2.paddingBox.top - closestScrollable.scrollTop;
  const left2 = base2.paddingBox.left - closestScrollable.scrollLeft;
  const bottom2 = top2 + closestScrollable.scrollHeight;
  const right2 = left2 + closestScrollable.scrollWidth;
  const paddingBox = {
    top: top2,
    right: right2,
    bottom: bottom2,
    left: left2
  };
  const borderBox = expand(paddingBox, base2.border);
  const client = createBox({
    borderBox,
    margin: base2.margin,
    border: base2.border,
    padding: base2.padding
  });
  return client;
};
var getDimension = ({
  ref: ref2,
  descriptor,
  env,
  windowScroll,
  direction: direction2,
  isDropDisabled,
  isCombineEnabled,
  shouldClipSubject
}) => {
  const closestScrollable = env.closestScrollable;
  const client = getClient(ref2, closestScrollable);
  const page = withScroll(client, windowScroll);
  const closest2 = (() => {
    if (!closestScrollable) {
      return null;
    }
    const frameClient = getBox(closestScrollable);
    const scrollSize = {
      scrollHeight: closestScrollable.scrollHeight,
      scrollWidth: closestScrollable.scrollWidth
    };
    return {
      client: frameClient,
      page: withScroll(frameClient, windowScroll),
      scroll: getScroll(closestScrollable),
      scrollSize,
      shouldClipSubject
    };
  })();
  const dimension = getDroppableDimension({
    descriptor,
    isEnabled: !isDropDisabled,
    isCombineEnabled,
    isFixedOnPage: env.isFixedOnPage,
    direction: direction2,
    client,
    page,
    closest: closest2
  });
  return dimension;
};
var immediate = {
  passive: false
};
var delayed = {
  passive: true
};
var getListenerOptions = (options2) => options2.shouldPublishImmediately ? immediate : delayed;
var getClosestScrollableFromDrag = (dragging) => dragging && dragging.env.closestScrollable || null;
function useDroppablePublisher(args) {
  const whileDraggingRef = (0, import_react6.useRef)(null);
  const appContext = useRequiredContext(AppContext);
  const uniqueId = useUniqueId("droppable");
  const {
    registry,
    marshal
  } = appContext;
  const previousRef = usePrevious(args);
  const descriptor = useMemo6(() => ({
    id: args.droppableId,
    type: args.type,
    mode: args.mode
  }), [args.droppableId, args.mode, args.type]);
  const publishedDescriptorRef = (0, import_react6.useRef)(descriptor);
  const memoizedUpdateScroll = useMemo6(() => memoizeOne2((x, y) => {
    !whileDraggingRef.current ? true ? invariant3(false, "Can only update scroll when dragging") : invariant3() : void 0;
    const scroll3 = {
      x,
      y
    };
    marshal.updateDroppableScroll(descriptor.id, scroll3);
  }), [descriptor.id, marshal]);
  const getClosestScroll = useCallback6(() => {
    const dragging = whileDraggingRef.current;
    if (!dragging || !dragging.env.closestScrollable) {
      return origin;
    }
    return getScroll(dragging.env.closestScrollable);
  }, []);
  const updateScroll = useCallback6(() => {
    const scroll3 = getClosestScroll();
    memoizedUpdateScroll(scroll3.x, scroll3.y);
  }, [getClosestScroll, memoizedUpdateScroll]);
  const scheduleScrollUpdate = useMemo6(() => raf_schd_esm_default(updateScroll), [updateScroll]);
  const onClosestScroll = useCallback6(() => {
    const dragging = whileDraggingRef.current;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest2) ? true ? invariant3(false, "Could not find scroll options while scrolling") : invariant3() : void 0;
    const options2 = dragging.scrollOptions;
    if (options2.shouldPublishImmediately) {
      updateScroll();
      return;
    }
    scheduleScrollUpdate();
  }, [scheduleScrollUpdate, updateScroll]);
  const getDimensionAndWatchScroll = useCallback6((windowScroll, options2) => {
    !!whileDraggingRef.current ? true ? invariant3(false, "Cannot collect a droppable while a drag is occurring") : invariant3() : void 0;
    const previous = previousRef.current;
    const ref2 = previous.getDroppableRef();
    !ref2 ? true ? invariant3(false, "Cannot collect without a droppable ref") : invariant3() : void 0;
    const env = getEnv(ref2);
    const dragging = {
      ref: ref2,
      descriptor,
      env,
      scrollOptions: options2
    };
    whileDraggingRef.current = dragging;
    const dimension = getDimension({
      ref: ref2,
      descriptor,
      env,
      windowScroll,
      direction: previous.direction,
      isDropDisabled: previous.isDropDisabled,
      isCombineEnabled: previous.isCombineEnabled,
      shouldClipSubject: !previous.ignoreContainerClipping
    });
    const scrollable = env.closestScrollable;
    if (scrollable) {
      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
      scrollable.addEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
      if (true) {
        checkForNestedScrollContainers(scrollable);
      }
    }
    return dimension;
  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
  const getScrollWhileDragging = useCallback6(() => {
    const dragging = whileDraggingRef.current;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest2) ? true ? invariant3(false, "Can only recollect Droppable client for Droppables that have a scroll container") : invariant3() : void 0;
    return getScroll(closest2);
  }, []);
  const dragStopped = useCallback6(() => {
    const dragging = whileDraggingRef.current;
    !dragging ? true ? invariant3(false, "Cannot stop drag when no active drag") : invariant3() : void 0;
    const closest2 = getClosestScrollableFromDrag(dragging);
    whileDraggingRef.current = null;
    if (!closest2) {
      return;
    }
    scheduleScrollUpdate.cancel();
    closest2.removeAttribute(scrollContainer.contextId);
    closest2.removeEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
  }, [onClosestScroll, scheduleScrollUpdate]);
  const scroll2 = useCallback6((change) => {
    const dragging = whileDraggingRef.current;
    !dragging ? true ? invariant3(false, "Cannot scroll when there is no drag") : invariant3() : void 0;
    const closest2 = getClosestScrollableFromDrag(dragging);
    !closest2 ? true ? invariant3(false, "Cannot scroll a droppable with no closest scrollable") : invariant3() : void 0;
    closest2.scrollTop += change.y;
    closest2.scrollLeft += change.x;
  }, []);
  const callbacks = useMemo6(() => {
    return {
      getDimensionAndWatchScroll,
      getScrollWhileDragging,
      dragStopped,
      scroll: scroll2
    };
  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll2]);
  const entry = useMemo6(() => ({
    uniqueId,
    descriptor,
    callbacks
  }), [callbacks, descriptor, uniqueId]);
  useIsomorphicLayoutEffect3(() => {
    publishedDescriptorRef.current = entry.descriptor;
    registry.droppable.register(entry);
    return () => {
      if (whileDraggingRef.current) {
        true ? warning4("Unsupported: changing the droppableId or type of a Droppable during a drag") : void 0;
        dragStopped();
      }
      registry.droppable.unregister(entry);
    };
  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
  useIsomorphicLayoutEffect3(() => {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
  }, [args.isDropDisabled, marshal]);
  useIsomorphicLayoutEffect3(() => {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
  }, [args.isCombineEnabled, marshal]);
}
function noop2() {
}
var empty = {
  width: 0,
  height: 0,
  margin: noSpacing2
};
var getSize = ({
  isAnimatingOpenOnMount,
  placeholder: placeholder3,
  animate
}) => {
  if (isAnimatingOpenOnMount) {
    return empty;
  }
  if (animate === "close") {
    return empty;
  }
  return {
    height: placeholder3.client.borderBox.height,
    width: placeholder3.client.borderBox.width,
    margin: placeholder3.client.margin
  };
};
var getStyle = ({
  isAnimatingOpenOnMount,
  placeholder: placeholder3,
  animate
}) => {
  const size2 = getSize({
    isAnimatingOpenOnMount,
    placeholder: placeholder3,
    animate
  });
  return {
    display: placeholder3.display,
    boxSizing: "border-box",
    width: size2.width,
    height: size2.height,
    marginTop: size2.margin.top,
    marginRight: size2.margin.right,
    marginBottom: size2.margin.bottom,
    marginLeft: size2.margin.left,
    flexShrink: "0",
    flexGrow: "0",
    pointerEvents: "none",
    transition: animate !== "none" ? transitions.placeholder : null
  };
};
var Placeholder = (props) => {
  const animateOpenTimerRef = (0, import_react6.useRef)(null);
  const tryClearAnimateOpenTimer = useCallback6(() => {
    if (!animateOpenTimerRef.current) {
      return;
    }
    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);
  const {
    animate,
    onTransitionEnd,
    onClose,
    contextId
  } = props;
  const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0, import_react6.useState)(props.animate === "open");
  (0, import_react6.useEffect)(() => {
    if (!isAnimatingOpenOnMount) {
      return noop2;
    }
    if (animate !== "open") {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop2;
    }
    if (animateOpenTimerRef.current) {
      return noop2;
    }
    animateOpenTimerRef.current = setTimeout(() => {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });
    return tryClearAnimateOpenTimer;
  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
  const onSizeChangeEnd = useCallback6((event) => {
    if (event.propertyName !== "height") {
      return;
    }
    onTransitionEnd();
    if (animate === "close") {
      onClose();
    }
  }, [animate, onClose, onTransitionEnd]);
  const style3 = getStyle({
    isAnimatingOpenOnMount,
    animate: props.animate,
    placeholder: props.placeholder
  });
  return import_react6.default.createElement(props.placeholder.tagName, {
    style: style3,
    "data-rfd-placeholder-context-id": contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props.innerRef
  });
};
var Placeholder$1 = import_react6.default.memo(Placeholder);
function isBoolean2(value) {
  return typeof value === "boolean";
}
function runChecks(args, checks) {
  checks.forEach((check) => check(args));
}
var shared = [function required({
  props
}) {
  !props.droppableId ? true ? invariant3(false, "A Droppable requires a droppableId prop") : invariant3() : void 0;
  !(typeof props.droppableId === "string") ? true ? invariant3(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : invariant3() : void 0;
}, function boolean2({
  props
}) {
  !isBoolean2(props.isDropDisabled) ? true ? invariant3(false, "isDropDisabled must be a boolean") : invariant3() : void 0;
  !isBoolean2(props.isCombineEnabled) ? true ? invariant3(false, "isCombineEnabled must be a boolean") : invariant3() : void 0;
  !isBoolean2(props.ignoreContainerClipping) ? true ? invariant3(false, "ignoreContainerClipping must be a boolean") : invariant3() : void 0;
}, function ref({
  getDroppableRef
}) {
  checkIsValidInnerRef(getDroppableRef());
}];
var standard = [function placeholder({
  props,
  getPlaceholderRef
}) {
  if (!props.placeholder) {
    return;
  }
  const ref2 = getPlaceholderRef();
  if (ref2) {
    return;
  }
  true ? warning4(`
      Droppable setup issue [droppableId: "${props.droppableId}"]:
      DroppableProvided > placeholder could not be found.

      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.
      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md
    `) : void 0;
}];
var virtual = [function hasClone({
  props
}) {
  !props.renderClone ? true ? invariant3(false, "Must provide a clone render function (renderClone) for virtual lists") : invariant3() : void 0;
}, function hasNoPlaceholder({
  getPlaceholderRef
}) {
  !!getPlaceholderRef() ? true ? invariant3(false, "Expected virtual list to not have a placeholder") : invariant3() : void 0;
}];
function useValidation(args) {
  useDevSetupWarning(() => {
    runChecks(args, shared);
    if (args.props.mode === "standard") {
      runChecks(args, standard);
    }
    if (args.props.mode === "virtual") {
      runChecks(args, virtual);
    }
  });
}
var AnimateInOut = class extends import_react6.default.PureComponent {
  constructor(...args) {
    super(...args);
    this.state = {
      isVisible: Boolean(this.props.on),
      data: this.props.on,
      animate: this.props.shouldAnimate && this.props.on ? "open" : "none"
    };
    this.onClose = () => {
      if (this.state.animate !== "close") {
        return;
      }
      this.setState({
        isVisible: false
      });
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (!props.shouldAnimate) {
      return {
        isVisible: Boolean(props.on),
        data: props.on,
        animate: "none"
      };
    }
    if (props.on) {
      return {
        isVisible: true,
        data: props.on,
        animate: "open"
      };
    }
    if (state.isVisible) {
      return {
        isVisible: true,
        data: state.data,
        animate: "close"
      };
    }
    return {
      isVisible: false,
      animate: "close",
      data: null
    };
  }
  render() {
    if (!this.state.isVisible) {
      return null;
    }
    const provided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(provided);
  }
};
var Droppable = (props) => {
  const appContext = (0, import_react6.useContext)(AppContext);
  !appContext ? true ? invariant3(false, "Could not find app context") : invariant3() : void 0;
  const {
    contextId,
    isMovementAllowed: isMovementAllowed2
  } = appContext;
  const droppableRef = (0, import_react6.useRef)(null);
  const placeholderRef = (0, import_react6.useRef)(null);
  const {
    children,
    droppableId,
    type,
    mode,
    direction: direction2,
    ignoreContainerClipping,
    isDropDisabled,
    isCombineEnabled,
    snapshot,
    useClone,
    updateViewportMaxScroll: updateViewportMaxScroll2,
    getContainerForClone
  } = props;
  const getDroppableRef = useCallback6(() => droppableRef.current, []);
  const setDroppableRef = useCallback6((value = null) => {
    droppableRef.current = value;
  }, []);
  const getPlaceholderRef = useCallback6(() => placeholderRef.current, []);
  const setPlaceholderRef = useCallback6((value = null) => {
    placeholderRef.current = value;
  }, []);
  useValidation({
    props,
    getDroppableRef,
    getPlaceholderRef
  });
  const onPlaceholderTransitionEnd = useCallback6(() => {
    if (isMovementAllowed2()) {
      updateViewportMaxScroll2({
        maxScroll: getMaxWindowScroll()
      });
    }
  }, [isMovementAllowed2, updateViewportMaxScroll2]);
  useDroppablePublisher({
    droppableId,
    type,
    mode,
    direction: direction2,
    isDropDisabled,
    isCombineEnabled,
    ignoreContainerClipping,
    getDroppableRef
  });
  const placeholder3 = useMemo6(() => import_react6.default.createElement(AnimateInOut, {
    on: props.placeholder,
    shouldAnimate: props.shouldAnimatePlaceholder
  }, ({
    onClose,
    data,
    animate
  }) => import_react6.default.createElement(Placeholder$1, {
    placeholder: data,
    onClose,
    innerRef: setPlaceholderRef,
    animate,
    contextId,
    onTransitionEnd: onPlaceholderTransitionEnd
  })), [contextId, onPlaceholderTransitionEnd, props.placeholder, props.shouldAnimatePlaceholder, setPlaceholderRef]);
  const provided = useMemo6(() => ({
    innerRef: setDroppableRef,
    placeholder: placeholder3,
    droppableProps: {
      "data-rfd-droppable-id": droppableId,
      "data-rfd-droppable-context-id": contextId
    }
  }), [contextId, droppableId, placeholder3, setDroppableRef]);
  const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
  const droppableContext = useMemo6(() => ({
    droppableId,
    type,
    isUsingCloneFor
  }), [droppableId, isUsingCloneFor, type]);
  function getClone() {
    if (!useClone) {
      return null;
    }
    const {
      dragging,
      render: render2
    } = useClone;
    const node = import_react6.default.createElement(PrivateDraggable, {
      draggableId: dragging.draggableId,
      index: dragging.source.index,
      isClone: true,
      isEnabled: true,
      shouldRespectForcePress: false,
      canDragInteractiveElements: true
    }, (draggableProvided, draggableSnapshot) => render2(draggableProvided, draggableSnapshot, dragging));
    return import_react_dom2.default.createPortal(node, getContainerForClone());
  }
  return import_react6.default.createElement(DroppableContext.Provider, {
    value: droppableContext
  }, children(provided, snapshot), getClone());
};
function getBody() {
  !document.body ? true ? invariant3(false, "document.body is not ready") : invariant3() : void 0;
  return document.body;
}
var defaultProps = {
  mode: "standard",
  type: "DEFAULT",
  direction: "vertical",
  isDropDisabled: false,
  isCombineEnabled: false,
  ignoreContainerClipping: false,
  renderClone: null,
  getContainerForClone: getBody
};
var attachDefaultPropsToOwnProps = (ownProps) => {
  let mergedProps = {
    ...ownProps
  };
  let defaultPropKey;
  for (defaultPropKey in defaultProps) {
    if (ownProps[defaultPropKey] === void 0) {
      mergedProps = {
        ...mergedProps,
        [defaultPropKey]: defaultProps[defaultPropKey]
      };
    }
  }
  return mergedProps;
};
var isMatchingType = (type, critical) => type === critical.droppable.type;
var getDraggable = (critical, dimensions) => dimensions.draggables[critical.draggable.id];
var makeMapStateToProps = () => {
  const idleWithAnimation = {
    placeholder: null,
    shouldAnimatePlaceholder: true,
    snapshot: {
      isDraggingOver: false,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: false
    },
    useClone: null
  };
  const idleWithoutAnimation = {
    ...idleWithAnimation,
    shouldAnimatePlaceholder: false
  };
  const getDraggableRubric = memoizeOne2((descriptor) => ({
    draggableId: descriptor.id,
    type: descriptor.type,
    source: {
      index: descriptor.index,
      droppableId: descriptor.droppableId
    }
  }));
  const getMapProps = memoizeOne2((id2, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) => {
    const draggableId = dragging.descriptor.id;
    const isHome = dragging.descriptor.droppableId === id2;
    if (isHome) {
      const useClone = renderClone ? {
        render: renderClone,
        dragging: getDraggableRubric(dragging.descriptor)
      } : null;
      const snapshot2 = {
        isDraggingOver: isDraggingOverForConsumer,
        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
        draggingFromThisWith: draggableId,
        isUsingPlaceholder: true
      };
      return {
        placeholder: dragging.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: snapshot2,
        useClone
      };
    }
    if (!isEnabled) {
      return idleWithoutAnimation;
    }
    if (!isDraggingOverForImpact) {
      return idleWithAnimation;
    }
    const snapshot = {
      isDraggingOver: isDraggingOverForConsumer,
      draggingOverWith: draggableId,
      draggingFromThisWith: null,
      isUsingPlaceholder: true
    };
    return {
      placeholder: dragging.placeholder,
      shouldAnimatePlaceholder: true,
      snapshot,
      useClone: null
    };
  });
  const selector = (state, ownProps) => {
    const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);
    const id2 = ownPropsWithDefaultProps.droppableId;
    const type = ownPropsWithDefaultProps.type;
    const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;
    const renderClone = ownPropsWithDefaultProps.renderClone;
    if (isDragging(state)) {
      const critical = state.critical;
      if (!isMatchingType(type, critical)) {
        return idleWithoutAnimation;
      }
      const dragging = getDraggable(critical, state.dimensions);
      const isDraggingOver = whatIsDraggedOver(state.impact) === id2;
      return getMapProps(id2, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
    }
    if (state.phase === "DROP_ANIMATING") {
      const completed = state.completed;
      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }
      const dragging = getDraggable(completed.critical, state.dimensions);
      return getMapProps(id2, isEnabled, whatIsDraggedOverFromResult(completed.result) === id2, whatIsDraggedOver(completed.impact) === id2, dragging, renderClone);
    }
    if (state.phase === "IDLE" && state.completed && !state.shouldFlush) {
      const completed = state.completed;
      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }
      const wasOver = whatIsDraggedOver(completed.impact) === id2;
      const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === "COMBINE");
      const isHome = completed.critical.droppable.id === id2;
      if (wasOver) {
        return wasCombining ? idleWithAnimation : idleWithoutAnimation;
      }
      if (isHome) {
        return idleWithAnimation;
      }
      return idleWithoutAnimation;
    }
    return idleWithoutAnimation;
  };
  return selector;
};
var mapDispatchToProps = {
  updateViewportMaxScroll
};
var ConnectedDroppable = connect_default(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps) => {
  return {
    ...attachDefaultPropsToOwnProps(ownProps),
    ...stateProps,
    ...dispatchProps
  };
}, {
  context: StoreContext,
  areStatePropsEqual: isStrictEqual
})(Droppable);
var ConnectedDroppable$1 = ConnectedDroppable;

// ../../../node_modules/@firecms/core/dist/index.es.js
var import_react_image_file_resizer = __toESM(require_build());

// ../../../node_modules/@firecms/editor/dist/index.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react8 = __toESM(require_react());

// ../../../node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      if (this.content[i2] === key) return i2;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      f(this.content[i2], this.content[i2 + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map4) {
    map4 = OrderedMap.from(map4);
    if (!map4.size) return this;
    return new OrderedMap(map4.content.concat(this.subtract(map4).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map4) {
    map4 = OrderedMap.from(map4);
    if (!map4.size) return this;
    return new OrderedMap(this.subtract(map4).content.concat(map4.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map4) {
    var result = this;
    map4 = OrderedMap.from(map4);
    for (var i2 = 0; i2 < map4.content.length; i2 += 2)
      result = result.remove(map4.content[i2]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// ../../../node_modules/prosemirror-model/dist/index.js
function findDiffStart(a2, b2, pos) {
  for (let i2 = 0; ; i2++) {
    if (i2 == a2.childCount || i2 == b2.childCount)
      return a2.childCount == b2.childCount ? null : pos;
    let childA = a2.child(i2), childB = b2.child(i2);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a2, b2, posA, posB) {
  for (let iA = a2.childCount, iB = b2.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a2.child(--iA), childB = b2.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size2;
    posB -= size2;
  }
}
var Fragment3 = class _Fragment {
  /**
  @internal
  */
  constructor(content, size2) {
    this.content = content;
    this.size = size2 || 0;
    if (size2 == null)
      for (let i2 = 0; i2 < content.length; i2++)
        this.size += content[i2].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i2 = 0, pos = 0; pos < to; i2++) {
      let child = this.content[i2], end3 = pos + child.nodeSize;
      if (end3 > from2 && f(child, nodeStart + pos, parent || null, i2) !== false && child.content.size) {
        let start3 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start3), Math.min(child.content.size, to - start3), f, nodeStart + start3);
      }
      pos = end3;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i2 = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i2 = 1;
    }
    for (; i2 < other.content.length; i2++)
      content.push(other.content[i2]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size2 = 0;
    if (to > from2)
      for (let i2 = 0, pos = 0; pos < to; i2++) {
        let child = this.content[i2], end3 = pos + child.nodeSize;
        if (end3 > from2) {
          if (pos < from2 || end3 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size2 += child.nodeSize;
        }
        pos = end3;
      }
    return new _Fragment(result, size2);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index2, node) {
    let current = this.content[index2];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size2 = this.size + node.nodeSize - current.nodeSize;
    copy2[index2] = node;
    return new _Fragment(copy2, size2);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i2 = 0; i2 < this.content.length; i2++)
      if (!this.content[i2].eq(other.content[i2]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i2 = 0, p3 = 0; i2 < this.content.length; i2++) {
      let child = this.content[i2];
      f(child, p3, i2);
      p3 += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i2 = 0, curPos = 0; ; i2++) {
      let cur = this.child(i2), end3 = curPos + cur.nodeSize;
      if (end3 >= pos) {
        if (end3 == pos || round2 > 0)
          return retIndex(i2 + 1, end3);
        return retIndex(i2, curPos);
      }
      curPos = end3;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n2) => n2.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema2, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema2.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array2) {
    if (!array2.length)
      return _Fragment.empty;
    let joined, size2 = 0;
    for (let i2 = 0; i2 < array2.length; i2++) {
      let node = array2[i2];
      size2 += node.nodeSize;
      if (i2 && node.isText && array2[i2 - 1].sameMarkup(node)) {
        if (!joined)
          joined = array2.slice(0, i2);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array2, size2);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment3.empty = new Fragment3([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index2, offset4) {
  found.index = index2;
  found.offset = offset4;
  return found;
}
function compareDeep(a2, b2) {
  if (a2 === b2)
    return true;
  if (!(a2 && typeof a2 == "object") || !(b2 && typeof b2 == "object"))
    return false;
  let array2 = Array.isArray(a2);
  if (Array.isArray(b2) != array2)
    return false;
  if (array2) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (!compareDeep(a2[i2], b2[i2]))
        return false;
  } else {
    for (let p3 in a2)
      if (!(p3 in b2) || !compareDeep(a2[p3], b2[p3]))
        return false;
    for (let p3 in b2)
      if (!(p3 in a2))
        return false;
  }
  return true;
}
var Mark = class _Mark {
  /**
  @internal
  */
  constructor(type, attrs2) {
    this.type = type;
    this.attrs = attrs2;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set2) {
    let copy2, placed = false;
    for (let i2 = 0; i2 < set2.length; i2++) {
      let other = set2[i2];
      if (this.eq(other))
        return set2;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set2.slice(0, i2);
      } else if (other.type.excludes(this.type)) {
        return set2;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set2.slice(0, i2);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set2.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set2) {
    for (let i2 = 0; i2 < set2.length; i2++)
      if (this.eq(set2[i2]))
        return set2.slice(0, i2).concat(set2.slice(i2 + 1));
    return set2;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set2) {
    for (let i2 = 0; i2 < set2.length; i2++)
      if (this.eq(set2[i2]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema2, json2) {
    if (!json2)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema2.marks[json2.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json2.type} in this schema`);
    let mark = type.create(json2.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a2, b2) {
    if (a2 == b2)
      return true;
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (!a2[i2].eq(b2[i2]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark.none;
    if (marks instanceof _Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a2, b2) => a2.type.rank - b2.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json2 = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json2.openStart = this.openStart;
    if (this.openEnd > 0)
      json2.openEnd = this.openEnd;
    return json2;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema2, json2) {
    if (!json2)
      return _Slice.empty;
    let openStart = json2.openStart || 0, openEnd = json2.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment3.fromJSON(schema2, json2.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild)
      openStart++;
    for (let n2 = fragment.lastChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment3.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index: index2, offset: offset4 } = content.findIndex(from2), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset4 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from2 - offset4 - 1, to - offset4 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index2, offset: offset4 } = content.findIndex(dist), child = content.maybeChild(index2);
  if (offset4 == dist || child.isText) {
    if (parent && !parent.canReplace(index2, index2, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset4 - 1, insert);
  return inner && content.replaceChild(index2, child.copy(inner));
}
function replace2($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index2 = $from.index(depth), node = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index2, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start3, end: end3 } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start3, end3, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i2 = startIndex; i2 < endIndex; i2++)
    addNode(node.child(i2), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment3(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment3(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i2 = extra - 1; i2 >= 0; i2--)
    node = $along.node(i2).copy(Fragment3.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i2 = 0; i2 < index2; i2++)
      pos += node.child(i2).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main2 = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i2 = 0; i2 < marks.length; i2++)
      if (marks[i2].type.spec.inclusive === false && (!other || !marks[i2].isInSet(other.marks)))
        marks = marks[i2--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i2 = 0; i2 < marks.length; i2++)
      if (marks[i2].type.spec.inclusive === false && (!next || !marks[i2].isInSet(next.marks)))
        marks = marks[i2--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i2 = 1; i2 <= this.depth; i2++)
      str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start3 = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index: index2, offset: offset4 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset4;
      path.push(node, index2, start3 + offset4);
      if (!rem)
        break;
      node = node.child(index2);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start3 += offset4 + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    let cache = resolveCache.get(doc3);
    if (cache) {
      for (let i2 = 0; i2 < cache.elts.length; i2++) {
        let elt = cache.elts[i2];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc3, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc3, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
};
var ResolveCache = class {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
};
var resolveCacheSize = 12;
var resolveCache = /* @__PURE__ */ new WeakMap();
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node2 = class _Node {
  /**
  @internal
  */
  constructor(type, attrs2, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs2;
    this.marks = marks;
    this.content = content || Fragment3.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index2) {
    return this.content.child(index2);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs2, marks) {
    return this.type == type && compareDeep(this.attrs, attrs2 || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start3 = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start3, $to.pos - start3);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace2(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index2, offset: offset4 } = node.content.findIndex(pos);
      node = node.maybeChild(index2);
      if (!node)
        return null;
      if (offset4 == pos || node.isText)
        return node;
      pos -= offset4 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index2, offset: offset4 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset: offset4 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset: offset4 } = this.content.findIndex(pos);
    if (offset4 < pos)
      return { node: this.content.child(index2), index: index2, offset: offset4 };
    let node = this.content.child(index2 - 1);
    return { node, index: index2 - 1, offset: offset4 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index2) {
    let match85 = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match85)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match85;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment3.empty, start3 = 0, end3 = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start3, end3);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i2 = start3; i2 < end3; i2++)
      if (!this.type.allowsMarks(replacement.child(i2).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start3 = this.contentMatchAt(from2).matchType(type);
    let end3 = start3 && start3.matchFragment(this.content, to);
    return end3 ? end3.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark.none;
    for (let i2 = 0; i2 < this.marks.length; i2++) {
      let mark = this.marks[i2];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n2) => n2.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema2, json2) {
    if (!json2)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json2.marks) {
      if (!Array.isArray(json2.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json2.marks.map(schema2.markFromJSON);
    }
    if (json2.type == "text") {
      if (typeof json2.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema2.text(json2.text, marks);
    }
    let content = Fragment3.fromJSON(schema2, json2.content);
    let node = schema2.nodeType(json2.type).create(json2.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node2.prototype.text = void 0;
var TextNode = class _TextNode extends Node2 {
  /**
  @internal
  */
  constructor(type, attrs2, content, marks) {
    super(type, attrs2, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i2 = marks.length - 1; i2 >= 0; i2--)
    str = marks[i2].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string2, nodeTypes) {
    let stream = new TokenStream(string2, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match85 = dfa(nfa(expr));
    checkForDeadEnds(match85, stream);
    return match85;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i2 = 0; i2 < this.next.length; i2++)
      if (this.next[i2].type == type)
        return this.next[i2].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start3 = 0, end3 = frag.childCount) {
    let cur = this;
    for (let i2 = start3; cur && i2 < end3; i2++)
      cur = cur.matchType(frag.child(i2).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i2 = 0; i2 < this.next.length; i2++) {
      let { type } = this.next[i2];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i2 = 0; i2 < this.next.length; i2++)
      for (let j2 = 0; j2 < other.next.length; j2++)
        if (this.next[i2].type == other.next[j2].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search2(match85, types) {
      let finished = match85.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment3.from(types.map((tp) => tp.createAndFill()));
      for (let i2 = 0; i2 < match85.next.length; i2++) {
        let { type, next } = match85.next[i2];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search2(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search2(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i2 = 0; i2 < this.wrapCache.length; i2 += 2)
      if (this.wrapCache[i2] == target)
        return this.wrapCache[i2 + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match85 = current.match;
      if (match85.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i2 = 0; i2 < match85.next.length; i2++) {
        let { type, next } = match85.next[i2];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n2) {
    if (n2 >= this.next.length)
      throw new RangeError(`There's no ${n2}th edge in this content match`);
    return this.next[n2];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i2 = 0; i2 < m.next.length; i2++)
        if (seen.indexOf(m.next[i2].next) == -1)
          scan(m.next[i2].next);
    }
    scan(this);
    return seen.map((m, i2) => {
      let out = i2 + (m.validEnd ? "*" : " ") + " ";
      for (let i3 = 0; i3 < m.next.length; i3++)
        out += (i3 ? ", " : "") + m.next[i3].type.name + "->" + seen.indexOf(m.next[i3].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string2, nodeTypes) {
    this.string = string2;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string2.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min3 = parseNum(stream), max3 = min3;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max3 = parseNum(stream);
    else
      max3 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min3, max: max3, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect2(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect2(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i2 = 0; ; i2++) {
        let next = compile(expr2.exprs[i2], from2);
        if (i2 == expr2.exprs.length - 1)
          return next;
        connect2(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect2(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect2(compile(expr2.expr, from2), loop);
      connect2(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i2 = 0; i2 < expr2.min; i2++) {
        let next = node();
        connect2(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect2(compile(expr2.expr, cur), cur);
      } else {
        for (let i2 = expr2.min; i2 < expr2.max; i2++) {
          let next = node();
          edge(cur, next);
          connect2(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a2, b2) {
  return b2 - a2;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i2 = 0; i2 < edges.length; i2++) {
      let { term, to } = edges[i2];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set2;
        for (let i2 = 0; i2 < out.length; i2++)
          if (out[i2][0] == term)
            set2 = out[i2][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set2)
            out.push([term, set2 = []]);
          if (set2.indexOf(node2) == -1)
            set2.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i2 = 0; i2 < out.length; i2++) {
      let states2 = out[i2][1].sort(cmp);
      state.next.push({ type: out[i2][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match85, stream) {
  for (let i2 = 0, work = [match85]; i2 < work.length; i2++) {
    let state = work[i2], dead = !state.validEnd, nodes = [];
    for (let j2 = 0; j2 < state.next.length; j2++) {
      let { type, next } = state.next[j2];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs2) {
  let defaults4 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs2) {
    let attr = attrs2[attrName];
    if (!attr.hasDefault)
      return null;
    defaults4[attrName] = attr.default;
  }
  return defaults4;
}
function computeAttrs(attrs2, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs2) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs2[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs2, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs2))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs2) {
    let attr = attrs2[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs2) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs2)
    for (let name in attrs2)
      result[name] = new Attribute(typeName, name, attrs2[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema2, spec) {
    this.name = name;
    this.schema = schema2;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n2 in this.attrs)
      if (this.attrs[n2].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs2) {
    if (!attrs2 && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs2);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs2 = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node2(this, this.computeAttrs(attrs2), Fragment3.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs2 = null, content, marks) {
    content = Fragment3.from(content);
    this.checkContent(content);
    return new Node2(this, this.computeAttrs(attrs2), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs2 = null, content, marks) {
    attrs2 = this.computeAttrs(attrs2);
    content = Fragment3.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment3.empty, true);
    if (!after)
      return null;
    return new Node2(this, attrs2, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i2 = 0; i2 < content.childCount; i2++)
      if (!this.allowsMarks(content.child(i2).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs2) {
    checkAttrs(this.attrs, attrs2, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i2 = 0; i2 < marks.length; i2++)
      if (!this.allowsMarkType(marks[i2].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i2 = 0; i2 < marks.length; i2++) {
      if (!this.allowsMarkType(marks[i2].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i2);
      } else if (copy2) {
        copy2.push(marks[i2]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema2) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema2, spec));
    let topType = schema2.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
var Attribute = class {
  constructor(typeName, attrName, options2) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options2, "default");
    this.default = options2.default;
    this.validate = typeof options2.validate == "string" ? validateType(typeName, attrName, options2.validate) : options2.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema2, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema2;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults4 = defaultAttrs(this.attrs);
    this.instance = defaults4 ? new Mark(this, defaults4) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs2 = null) {
    if (!attrs2 && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs2));
  }
  /**
  @internal
  */
  static compile(marks, schema2) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema2, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set2) {
    for (var i2 = 0; i2 < set2.length; i2++)
      if (set2[i2].type == this) {
        set2 = set2.slice(0, i2).concat(set2.slice(i2 + 1));
        i2--;
      }
    return set2;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set2) {
    for (let i2 = 0; i2 < set2.length; i2++)
      if (set2[i2].type == this)
        return set2[i2];
  }
  /**
  @internal
  */
  checkAttrs(attrs2) {
    checkAttrs(this.attrs, attrs2, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs2 = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs2, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs2) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs2);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json2) {
    return Node2.fromJSON(this, json2);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json2) {
    return Mark.fromJSON(this, json2);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema2, marks) {
  let found2 = [];
  for (let i2 = 0; i2 < marks.length; i2++) {
    let name = marks[i2], mark = schema2.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema2.marks) {
        let mark2 = schema2.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i2] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
var DOMParser = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema2, rules) {
    this.schema = schema2;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node = schema2.nodes[r2.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options2 = {}) {
    let context = new ParseContext(this, options2, false);
    context.addAll(dom, Mark.none, options2.from, options2.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options2 = {}) {
    let context = new ParseContext(this, options2, true);
    context.addAll(dom, Mark.none, options2.from, options2.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i2 = after ? this.tags.indexOf(after) + 1 : 0; i2 < this.tags.length; i2++) {
      let rule = this.tags[i2];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i2 = after ? this.styles.indexOf(after) + 1 : 0; i2 < this.styles.length; i2++) {
      let rule = this.styles[i2], style3 = rule.style;
      if (style3.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style3.length > prop.length && (style3.charCodeAt(prop.length) != 61 || style3.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema2) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
      for (; i2 < result.length; i2++) {
        let next = result[i2], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i2, 0, rule);
    }
    for (let name in schema2.marks) {
      let rules = schema2.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema2.nodes) {
      let rules = schema2.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema2) {
    return schema2.cached.domParser || (schema2.cached.domParser = new _DOMParser(schema2, _DOMParser.schemaRules(schema2)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs2, marks, solid, match85, options2) {
    this.type = type;
    this.attrs = attrs2;
    this.marks = marks;
    this.solid = solid;
    this.options = options2;
    this.content = [];
    this.activeMarks = Mark.none;
    this.match = match85 || (options2 & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment3.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start3 = this.type.contentMatch, wrap2;
        if (wrap2 = start3.findWrapping(node.type)) {
          this.match = start3;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment3.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment3.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options2, isOpen) {
    this.parser = parser;
    this.options = options2;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options2.topNode, topContext;
    let topOptions = wsOptionsFor(null, options2.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options2.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options2.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top2 = this.top, preserveWS = top2.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top2.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top2 = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top2.content.length && top2.content[0].isInline && this.open) {
          this.open--;
          top2 = this.top;
        }
        sync = true;
        if (!top2.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top2);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles2 = dom.style;
    if (styles2 && styles2.length)
      for (let i2 = 0; i2 < this.parser.matchedStyles.length; i2++) {
        let name = this.parser.matchedStyles[i2], value = styles2.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index2 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end3 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end3; dom = dom.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index2);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i2 = 0; i2 < route.length; i2++)
      marks = this.enterInner(route[i2], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks, cautious) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top2 = this.top;
      if (top2.match)
        top2.match = top2.match.matchType(node.type);
      let nodeMarks = Mark.none;
      for (let m of innerMarks.concat(node.marks))
        if (top2.type ? top2.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top2.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs2, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs2), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs2, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs2, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.match = top2.match && top2.match.matchType(type);
    let options2 = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options2 |= OPT_OPEN_LEFT;
    let applyMarks = Mark.none;
    marks = marks.filter((m) => {
      if (top2.type ? top2.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs2, applyMarks, solid, null, options2));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i2 = this.nodes.length - 1;
    if (i2 > this.open) {
      for (; i2 > this.open; i2--)
        this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i2 = this.open; i2 >= 0; i2--) {
      if (this.nodes[i2] == to) {
        this.open = i2;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i2].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i2 = this.open; i2 >= 0; i2--) {
      let content = this.nodes[i2].content;
      for (let j2 = content.length - 1; j2 >= 0; j2--)
        pos += content[j2].nodeSize;
      if (i2)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset4) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].node == parent && this.find[i2].offset == offset4)
          this.find[i2].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node))
          this.find[i2].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
          let pos = content.compareDocumentPosition(this.find[i2].node);
          if (pos & (before ? 2 : 4))
            this.find[i2].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].node == textNode)
          this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match85 = (i2, depth) => {
      for (; i2 >= 0; i2--) {
        let part = parts[i2];
        if (part == "") {
          if (i2 == parts.length - 1 || i2 == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match85(i2 - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match85(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match85) => {
      seen.push(match85);
      for (let i2 = 0; i2 < match85.edgeCount; i2++) {
        let { type, next } = match85.edge(i2);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options2 = {}, target) {
    if (!target)
      target = doc(options2).createDocumentFragment();
    let top2 = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node.marks.length) {
          let add3 = node.marks[rendered++];
          let markDOM = this.serializeMark(add3, node.isInline, options2);
          if (markDOM) {
            active.push([add3, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node, options2));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options2) {
    let { dom, contentDOM } = renderSpec(doc(options2), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options2, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options2 = {}) {
    let dom = this.serializeNodeInner(node, options2);
    for (let i2 = node.marks.length - 1; i2 >= 0; i2--) {
      let wrap2 = this.serializeMark(node.marks[i2], node.isInline, options2);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options2 = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc(options2), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc3, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema2) {
    return schema2.cached.domSerializer || (schema2.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema2) {
    let result = gatherToDOM(schema2.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema2) {
    return gatherToDOM(schema2.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options2) {
  return options2.document || window.document;
}
var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs2) {
  let value = suspiciousAttributeCache.get(attrs2);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs2, value = suspiciousAttributesInner(attrs2));
  return value;
}
function suspiciousAttributesInner(attrs2) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i2 = 0; i2 < value.length; i2++)
            scan(value[i2]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs2);
  return result;
}
function renderSpec(doc3, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc3.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space2 = tagName.indexOf(" ");
  if (space2 > 0) {
    xmlNS = tagName.slice(0, space2);
    tagName = tagName.slice(space2 + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
  let attrs2 = structure[1], start3 = 1;
  if (attrs2 && typeof attrs2 == "object" && attrs2.nodeType == null && !Array.isArray(attrs2)) {
    start3 = 2;
    for (let name in attrs2)
      if (attrs2[name] != null) {
        let space3 = name.indexOf(" ");
        if (space3 > 0)
          dom.setAttributeNS(name.slice(0, space3), name.slice(space3 + 1), attrs2[name]);
        else
          dom.setAttribute(name, attrs2[name]);
      }
  }
  for (let i2 = start3; i2 < structure.length; i2++) {
    let child = structure[i2];
    if (child === 0) {
      if (i2 < structure.length - 1 || i2 > start3)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}

// ../../../node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index2, offset4) {
  return index2 + offset4 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i2 = 0; i2 < index2; i2++)
        diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
      let start3 = this.ranges[i2] - (this.inverted ? diff : 0);
      if (start3 > pos)
        break;
      let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end3 = start3 + oldSize;
      if (pos <= end3) {
        let side = !oldSize ? assoc : pos == start3 ? -1 : pos == end3 ? 1 : assoc;
        let result = start3 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start3 : end3) ? null : makeRecover(i2 / 3, pos - start3);
        let del2 = pos == start3 ? DEL_AFTER : pos == end3 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start3 : pos != end3)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
      let start3 = this.ranges[i2] - (this.inverted ? diff : 0);
      if (start3 > pos)
        break;
      let oldSize = this.ranges[i2 + oldIndex], end3 = start3 + oldSize;
      if (pos <= end3 && i2 == index2 * 3)
        return true;
      diff += this.ranges[i2 + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
      let start3 = this.ranges[i2], oldStart = start3 - (this.inverted ? diff : 0), newStart = start3 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n2) {
    return n2 == 0 ? _StepMap.empty : new _StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this._maps, this.mirror, from2, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map4, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map4);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i2 = 0, startSize = this._maps.length; i2 < mapping._maps.length; i2++) {
      let mirr = mapping.getMirror(i2);
      this.appendMap(mapping._maps[i2], mirr != null && mirr < i2 ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n2) {
    if (this.mirror) {
      for (let i2 = 0; i2 < this.mirror.length; i2++)
        if (this.mirror[i2] == n2)
          return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n2, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n2, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i2 = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i2 >= 0; i2--) {
      let mirr = mapping.getMirror(i2);
      this.appendMap(mapping._maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i2 = this.from; i2 < this.to; i2++)
      pos = this._maps[i2].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i2 = this.from; i2 < this.to; i2++) {
      let map4 = this._maps[i2], result = map4.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i2);
        if (corr != null && corr > i2 && corr < this.to) {
          i2 = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema2, json2) {
    if (!json2 || !json2.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json2.stepType];
    if (!type)
      throw new RangeError(`No step type ${json2.stepType} defined`);
    return type.fromJSON(schema2, json2);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id2, stepClass) {
    if (id2 in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id2);
    stepsByID[id2] = stepClass;
    stepClass.prototype.jsonID = id2;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message2) {
    return new _StepResult(null, message2);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from2, to, slice2) {
    try {
      return _StepResult.ok(doc3.replace(from2, to, slice2));
    } catch (e2) {
      if (e2 instanceof ReplaceError)
        return _StepResult.fail(e2.message);
      throw e2;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i2 = 0; i2 < fragment.childCount; i2++) {
    let child = fragment.child(i2);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i2);
    mapped.push(child);
  }
  return Fragment3.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema2, json2) {
    if (typeof json2.from != "number" || typeof json2.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json2.from, json2.to, schema2.markFromJSON(json2.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema2, json2) {
    if (typeof json2.from != "number" || typeof json2.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json2.from, json2.to, schema2.markFromJSON(json2.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment3.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i2 = 0; i2 < node.marks.length; i2++)
          if (!node.marks[i2].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i2]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema2, json2) {
    if (typeof json2.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json2.pos, schema2.markFromJSON(json2.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment3.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema2, json2) {
    if (typeof json2.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json2.pos, schema2.markFromJSON(json2.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json2 = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json2.slice = this.slice.toJSON();
    if (this.structure)
      json2.structure = true;
    return json2;
  }
  /**
  @internal
  */
  static fromJSON(schema2, json2) {
    if (typeof json2.from != "number" || typeof json2.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json2.from, json2.to, Slice.fromJSON(schema2, json2.slice), !!json2.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json2 = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json2.slice = this.slice.toJSON();
    if (this.structure)
      json2.structure = true;
    return json2;
  }
  /**
  @internal
  */
  static fromJSON(schema2, json2) {
    if (typeof json2.from != "number" || typeof json2.to != "number" || typeof json2.gapFrom != "number" || typeof json2.gapTo != "number" || typeof json2.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json2.from, json2.to, json2.gapFrom, json2.gapTo, Slice.fromJSON(schema2, json2.slice), json2.insert, !!json2.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr3, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr3.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start3 = Math.max(pos, from2), end3 = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i2 = 0; i2 < marks.length; i2++) {
        if (!marks[i2].isInSet(newSet)) {
          if (removing && removing.to == start3 && removing.mark.eq(marks[i2]))
            removing.to = end3;
          else
            removed.push(removing = new RemoveMarkStep(start3, end3, marks[i2]));
        }
      }
      if (adding && adding.to == start3)
        adding.to = end3;
      else
        added.push(adding = new AddMarkStep(start3, end3, mark));
    }
  });
  removed.forEach((s2) => tr3.step(s2));
  added.forEach((s2) => tr3.step(s2));
}
function removeMark(tr3, from2, to, mark) {
  let matched = [], step = 0;
  tr3.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set2 = node.marks, found2;
      while (found2 = mark.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(found2);
        set2 = found2.removeFromSet(set2);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end3 = Math.min(pos + node.nodeSize, to);
      for (let i2 = 0; i2 < toRemove.length; i2++) {
        let style3 = toRemove[i2], found2;
        for (let j2 = 0; j2 < matched.length; j2++) {
          let m = matched[j2];
          if (m.step == step - 1 && style3.eq(matched[j2].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end3;
          found2.step = step;
        } else {
          matched.push({ style: style3, from: Math.max(pos, from2), to: end3, step });
        }
      }
    }
  });
  matched.forEach((m) => tr3.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr3, pos, parentType, match85 = parentType.contentMatch, clearNewlines = true) {
  let node = tr3.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i2 = 0; i2 < node.childCount; i2++) {
    let child = node.child(i2), end3 = cur + child.nodeSize;
    let allowed = match85.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end3, Slice.empty));
    } else {
      match85 = allowed;
      for (let j2 = 0; j2 < child.marks.length; j2++)
        if (!parentType.allowsMarkType(child.marks[j2].type))
          tr3.step(new RemoveMarkStep(cur, end3, child.marks[j2]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment3.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end3;
  }
  if (!match85.validEnd) {
    let fill = match85.fillBefore(Fragment3.empty, true);
    tr3.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i2 = replSteps.length - 1; i2 >= 0; i2--)
    tr3.step(replSteps[i2]);
}
function canCut(node, start3, end3) {
  return (start3 == 0 || node.canReplace(start3, node.childCount)) && (end3 == node.childCount || node.canReplace(0, end3));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index2 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index2, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index2, endIndex))
      break;
  }
  return null;
}
function lift2(tr3, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start3 = gapStart, end3 = gapEnd;
  let before = Fragment3.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment3.from($from.node(d).copy(before));
      openStart++;
    } else {
      start3--;
    }
  let after = Fragment3.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment3.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end3++;
    }
  tr3.step(new ReplaceAroundStep(start3, end3, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs2 = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs: attrs2 }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i2 = startIndex; innerMatch && i2 < endIndex; i2++)
    innerMatch = innerMatch.matchType(parent.child(i2).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr3, range, wrappers) {
  let content = Fragment3.empty;
  for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
    if (content.size) {
      let match85 = wrappers[i2].type.contentMatch.matchFragment(content);
      if (!match85 || !match85.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment3.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
  }
  let start3 = range.start, end3 = range.end;
  tr3.step(new ReplaceAroundStep(start3, end3, start3, end3, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr3, from2, to, type, attrs2) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr3.steps.length;
  tr3.doc.nodesBetween(from2, to, (node, pos) => {
    let attrsHere = typeof attrs2 == "function" ? attrs2(node) : attrs2;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr3.doc, tr3.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr3, node, pos, mapFrom);
      clearIncompatible(tr3, tr3.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr3.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr3.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment3.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr3, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr3, node, pos, mapFrom) {
  node.forEach((child, offset4) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start3 = tr3.mapping.slice(mapFrom).map(pos + 1 + offset4 + m.index);
        tr3.replaceWith(start3, start3 + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr3, node, pos, mapFrom) {
  node.forEach((child, offset4) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start3 = tr3.mapping.slice(mapFrom).map(pos + 1 + offset4);
      tr3.replaceWith(start3, start3 + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type);
}
function setNodeMarkup(tr3, pos, type, attrs2, marks) {
  let node = tr3.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs2, null, marks || node.marks);
  if (node.isLeaf)
    return tr3.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr3.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment3.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i2 = depth - 2; d > base2; d--, i2--) {
    let node = $pos.node(d), index3 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index3, node.childCount);
    let overrideChild = typesAfter && typesAfter[i2 + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i2] || node;
    if (!node.canReplace(index3 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split2(tr3, pos, depth = 1, typesAfter) {
  let $pos = tr3.doc.resolve(pos), before = Fragment3.empty, after = Fragment3.empty;
  for (let d = $pos.depth, e2 = $pos.depth - depth, i2 = depth - 1; d > e2; d--, i2--) {
    before = Fragment3.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i2];
    after = Fragment3.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr3.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index2 = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function canAppendWithSubstitutedLinebreaks(a2, b2) {
  if (!b2.content.size)
    a2.type.compatibleContent(b2.type);
  let match85 = a2.contentMatchAt(a2.childCount);
  let { linebreakReplacement } = a2.type.schema;
  for (let i2 = 0; i2 < b2.childCount; i2++) {
    let child = b2.child(i2);
    let type = child.type == linebreakReplacement ? a2.type.schema.nodes.text : child.type;
    match85 = match85.matchType(type);
    if (!match85)
      return false;
    if (!a2.type.allowsMarks(child.marks))
      return false;
  }
  return match85.validEnd;
}
function joinable2(a2, b2) {
  return !!(a2 && b2 && !a2.isLeaf && canAppendWithSubstitutedLinebreaks(a2, b2));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index2 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index2++;
      after = $pos.node(d).maybeChild(index2);
    } else {
      before = $pos.node(d).maybeChild(index2 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index2, index2 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr3, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr3.doc.type.schema;
  let $before = tr3.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr3.steps.length;
  if (convertNewlines === false) {
    let $after = tr3.doc.resolve(pos + depth);
    replaceLinebreaks(tr3, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr3, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr3.mapping.slice(mapFrom), start3 = mapping.map(pos - depth);
  tr3.step(new ReplaceStep(start3, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr3.doc.resolve(start3);
    replaceNewlines(tr3, $full.node(), $full.before(), tr3.steps.length);
  }
  return tr3;
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d + 1);
      if (index2 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i2 = 0; i2 < slice2.openStart; i2++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment3.empty;
    for (let i2 = 0; i2 <= $from.depth; i2++) {
      let node = $from.node(i2);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i2))
      });
    }
    for (let i2 = $from.depth; i2 > 0; i2--)
      this.placed = Fragment3.from($from.node(i2).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match: match85 } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match85.matchType(first2.type) || (inject = match85.fillBefore(Fragment3.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match85.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match85.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i2 = 0; i2 < wrap2.length; i2++)
        this.openFrontierNode(wrap2[i2]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add3 = [];
    let { match: match85, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i2 = 0; i2 < inject.childCount; i2++)
        add3.push(inject.child(i2));
      match85 = match85.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match85.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match85 = matches2;
        add3.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment3.from(add3));
    this.frontier[frontierDepth].match = match85;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i2 = 0, cur = fragment; i2 < openEndCount; i2++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
      let { match: match85, type } = this.frontier[i2];
      let dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
      let fit = contentAfterFits($to, i2, type, match85, dropInner);
      if (!fit)
        continue;
      for (let d = i2 - 1; d >= 0; d--) {
        let { match: match86, type: type2 } = this.frontier[d];
        let matches2 = contentAfterFits($to, d, type2, match86, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i2, fit, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add3 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add3);
    }
    return $to;
  }
  openFrontierNode(type, attrs2 = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment3.from(type.create(attrs2, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add3 = open.match.fillBefore(Fragment3.empty, true);
    if (add3.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add3);
  }
};
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i2 = 0; i2 < depth; i2++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment3.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match85, open) {
  let node = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match85.fillBefore(node.content, true, index2);
  return fit && !invalidMarks(type, node.content, index2) ? fit : null;
}
function invalidMarks(type, fragment, start3) {
  for (let i2 = start3; i2 < fragment.childCount; i2++)
    if (!type.allowsMarks(fragment.child(i2).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr3, from2, to, slice2) {
  if (!slice2.size)
    return tr3.deleteRange(from2, to);
  let $from = tr3.doc.resolve(from2), $to = tr3.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr3.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr3.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i2 = 0; ; i2++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i2 == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j2 = slice2.openStart; j2 >= 0; j2--) {
    let openDepth = (j2 + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i2 = 0; i2 < targetDepths.length; i2++) {
      let targetDepth = targetDepths[(i2 + preferredTargetIndex) % targetDepths.length], expand3 = true;
      if (targetDepth < 0) {
        expand3 = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr3.replace($from.before(targetDepth), expand3 ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr3.steps.length;
  for (let i2 = targetDepths.length - 1; i2 >= 0; i2--) {
    tr3.replace(from2, to, slice2);
    if (tr3.steps.length > startSteps)
      break;
    let depth = targetDepths[i2];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match85 = parent.contentMatchAt(0);
    let start3 = match85.fillBefore(fragment).append(fragment);
    fragment = start3.append(match85.matchFragment(start3).fillBefore(Fragment3.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr3, from2, to, node) {
  if (!node.isInline && from2 == to && tr3.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr3.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr3.replaceRange(from2, to, new Slice(Fragment3.from(node), 0, 0));
}
function deleteRange(tr3, from2, to) {
  let $from = tr3.doc.resolve(from2), $to = tr3.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i2 = 0; i2 < covered.length; i2++) {
    let depth = covered[i2], last = i2 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr3.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr3.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr3.delete($from.before(d), to);
  }
  tr3.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start3 = $from.start(d);
    if (start3 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start3 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start3 - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs2 = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs2[name] = node.attrs[name];
    attrs2[this.attr] = this.value;
    let updated = node.type.create(attrs2, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment3.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema2, json2) {
    if (typeof json2.pos != "number" || typeof json2.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json2.pos, json2.attr, json2.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let attrs2 = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs2[name] = doc3.attrs[name];
    attrs2[this.attr] = this.value;
    let updated = doc3.type.create(attrs2, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema2, json2) {
    if (typeof json2.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json2.attr, json2.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message2) {
  let err = Error.call(this, message2);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment3.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift2(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs2 = null) {
    setBlockType(this, from2, to, type, attrs2);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs2 = null, marks) {
    setNodeMarkup(this, pos, type, attrs2, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node = this.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark) {
      if (mark.isInSet(node.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set2 = node.marks, found2, steps = [];
      while (found2 = mark.isInSet(set2)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set2 = found2.removeFromSet(set2);
      }
      for (let i2 = steps.length - 1; i2 >= 0; i2--)
        this.step(steps[i2]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split2(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match85) {
    clearIncompatible(this, pos, parentType, match85);
    return this;
  }
};

// ../../../node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++)
      if (ranges[i2].$from.pos != ranges[i2].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr3, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i2 = 0; i2 < content.openEnd; i2++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr3.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let { $from, $to } = ranges[i2], mapping = tr3.mapping.slice(mapFrom);
      tr3.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content);
      if (i2 == 0)
        selectionToInsertionEnd(tr3, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr3, node) {
    let mapFrom = tr3.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let { $from, $to } = ranges[i2], mapping = tr3.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i2) {
        tr3.deleteRange(from2, to);
      } else {
        tr3.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd(tr3, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json2) {
    if (!json2 || !json2.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls2 = classesById[json2.type];
    if (!cls2)
      throw new RangeError(`No selection type ${json2.type} defined`);
    return cls2.fromJSON(doc3, json2);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id2, selectionClass) {
    if (id2 in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id2);
    classesById[id2] = selectionClass;
    selectionClass.prototype.jsonID = id2;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr3, content = Slice.empty) {
    super.replace(tr3, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr3.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json2) {
    if (typeof json2.anchor != "number" || typeof json2.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json2.anchor), doc3.resolve(json2.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment3.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json2) {
    if (typeof json2.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json2.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from2) {
    return new _NodeSelection(doc3.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr3, content = Slice.empty) {
    if (content == Slice.empty) {
      tr3.delete(0, tr3.doc.content.size);
      let sel = Selection.atStart(tr3.doc);
      if (!sel.eq(tr3.selection))
        tr3.setSelection(sel);
    } else {
      super.replace(tr3, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index2, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i2 = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node.childCount : i2 >= 0; i2 += dir) {
    let child = node.child(i2);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr3, startLen, bias) {
  let last = tr3.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr3.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map4 = tr3.mapping.maps[last], end3;
  map4.forEach((_from, _to, _newFrom, newTo) => {
    if (end3 == null)
      end3 = newTo;
  });
  tr3.setSelection(Selection.near(tr3.doc.resolve(end3), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema2 = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema2.text(text), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema2.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
var FieldDesc = class {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr3) {
      return tr3.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr3) {
      return tr3.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr3, _marks, _old, state) {
      return state.selection.$cursor ? tr3.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr3, prev) {
      return tr3.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema2, plugins) {
    this.schema = schema2;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr3) {
    return this.applyTransaction(tr3).state;
  }
  /**
  @internal
  */
  filterTransaction(tr3, ignore = -1) {
    for (let i2 = 0; i2 < this.config.plugins.length; i2++)
      if (i2 != ignore) {
        let plugin = this.config.plugins[i2];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr3, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i2 = 0; i2 < this.config.plugins.length; i2++) {
        let plugin = this.config.plugins[i2];
        if (plugin.spec.appendTransaction) {
          let n2 = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
          let tr3 = n2 < trs.length && plugin.spec.appendTransaction.call(plugin, n2 ? trs.slice(n2) : trs, oldState, newState);
          if (tr3 && newState.filterTransaction(tr3, i2)) {
            tr3.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j2 = 0; j2 < this.config.plugins.length; j2++)
                seen.push(j2 < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr3);
            newState = newState.applyInner(tr3);
            haveNew = true;
          }
          if (seen)
            seen[i2] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr3) {
    if (!tr3.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i2 = 0; i2 < fields.length; i2++) {
      let field = fields[i2];
      newInstance[field.name] = field.apply(tr3, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new _EditorState($config);
    for (let i2 = 0; i2 < $config.fields.length; i2++)
      instance[$config.fields[i2].name] = $config.fields[i2].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new _EditorState($config);
    for (let i2 = 0; i2 < fields.length; i2++) {
      let name = fields[i2].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json2, pluginFields) {
    if (!json2)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node2.fromJSON(config.schema, json2.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json2.selection);
      } else if (field.name == "storedMarks") {
        if (json2.storedMarks)
          instance.storedMarks = json2.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json2, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json2[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
};
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey3("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey3(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey3(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// ../../../node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var clearReusedRange = function() {
  reusedRange = null;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset4) {
  for (; ; ) {
    if (node.nodeType == 3 && offset4)
      return node;
    if (node.nodeType == 1 && offset4 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset4 - 1];
      offset4 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset4 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset4) {
  for (; ; ) {
    if (node.nodeType == 3 && offset4 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset4 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset4];
      offset4 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset4 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset4, parent) {
  for (let atStart = offset4 == 0, atEnd = offset4 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index2 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  let vp = doc3.defaultView && doc3.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
      break;
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i2 = 0; i2 < stack.length; i2++) {
    let { dom, top: top2, left: left2 } = stack[i2];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest2, dxClosest = 2e8, coordsClosest, offset4 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest2 = child;
          dxClosest = dx;
          coordsClosest = dx && closest2.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset4 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest2 && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset4 = childIndex + 1;
    }
  }
  if (!closest2 && firstBelow) {
    closest2 = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest2 && closest2.nodeType == 3)
    return findOffsetInText(closest2, coordsClosest);
  if (!closest2 || dxClosest && closest2.nodeType == 1)
    return { node, offset: offset4 };
  return findOffsetInNode(closest2, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i2 = 0; i2 < len; i2++) {
    range.setEnd(node, i2 + 1);
    range.setStart(node, i2);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset4 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset4, bias);
}
function posFromCaret(view, node, offset4, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset4, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
      let child = element.childNodes[i2];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j2 = 0; j2 < rects.length; j2++) {
          let rect = rects[j2];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i2 = (i2 + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset4 = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset4 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p3 = elt; node && p3; p3 = parentNode(p3))
      if (p3.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset4 = Math.min(offset4, node.childNodes.length);
      if (offset4 < node.childNodes.length) {
        let next = node.childNodes[offset4], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset4++;
      }
    }
    let prev;
    if (webkit && offset4 && node.nodeType == 1 && (prev = node.childNodes[offset4 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset4--;
    if (node == view.dom && offset4 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset4 == 0 || node.nodeType != 1 || node.childNodes[offset4 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset4, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset4, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset4 : offset4 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset4, offset4), side);
      if (gecko && offset4 && /\s/.test(node.nodeValue[offset4 - 1]) && offset4 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset4 - 1, offset4 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset4, offset4 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset4, to = offset4, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset4) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset4 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset4 && (side < 0 || offset4 == nodeSize(node))) {
      let before = node.childNodes[offset4 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset4 < nodeSize(node)) {
      let after = node.childNodes[offset4];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset4 && (side < 0 || offset4 == nodeSize(node))) {
    let before = node.childNodes[offset4 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset4 < nodeSize(node)) {
    let after = node.childNodes[offset4];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i2 = 0; i2 < boxes.length; i2++) {
        let box = boxes[i2];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset4 = $head.parentOffset, atStart = !offset4, atEnd = offset4 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size2 = 0;
    for (let i2 = 0; i2 < this.children.length; i2++)
      size2 += this.children[i2].size;
    return size2;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i2 = 0; i2 < this.children.length; i2++)
      this.children[i2].destroy();
  }
  posBeforeChild(child) {
    for (let i2 = 0, pos = this.posAtStart; ; i2++) {
      let cur = this.children[i2];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset4, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset4 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset4];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset4 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset4 == 0)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = false;
            break;
          }
          if (search2.previousSibling)
            break;
        }
      if (atEnd == null && offset4 == dom.childNodes.length)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = true;
            break;
          }
          if (search2.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset4, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset4, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i2 = 0, offset4 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end3 = offset4 + child.size;
      if (offset4 == pos && end3 != offset4) {
        while (!child.border && child.children.length) {
          for (let i3 = 0; i3 < child.children.length; i3++) {
            let inner = child.children[i3];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end3)
        return child.descAt(pos - offset4 - child.border);
      offset4 = end3;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i2 = 0, offset4 = 0;
    for (let curPos = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end3 = curPos + child.size;
      if (end3 > pos || child instanceof TrailingHackViewDesc) {
        offset4 = pos - curPos;
        break;
      }
      curPos = end3;
    }
    if (offset4)
      return this.children[i2].domFromPos(offset4 - this.children[i2].border, side);
    for (let prev; i2 && !(prev = this.children[i2 - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i2--) {
    }
    if (side <= 0) {
      let prev, enter3 = true;
      for (; ; i2--, enter3 = false) {
        prev = i2 ? this.children[i2 - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter3 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter3 = true;
      for (; ; i2++, enter3 = false) {
        next = i2 < this.children.length ? this.children[i2] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter3 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset4 = base2, i2 = 0; ; i2++) {
      let child = this.children[i2], end3 = offset4 + child.size;
      if (fromOffset == -1 && from2 <= end3) {
        let childBase = offset4 + child.border;
        if (from2 >= childBase && to <= end3 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset4;
        for (let j2 = i2; j2 > 0; j2--) {
          let prev = this.children[j2 - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end3 > to || i2 == this.children.length - 1)) {
        to = end3;
        for (let j2 = i2 + 1; j2 < this.children.length; j2++) {
          let next = this.children[j2];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset4 = end3;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset4 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset4 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset4];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i2 = 0, offset4 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end3 = offset4 + child.size;
      if (from2 > offset4 && to < end3)
        return child.setSelection(anchor - offset4 - child.border, head - offset4 - child.border, view, force);
      offset4 = end3;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset4 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset4 && node.nodeValue[offset4 - 1] == "\n");
        if (brKludge && offset4 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset4 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset4 = 0, i2 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end3 = offset4 + child.size;
      if (offset4 == end3 ? from2 <= end3 && to >= offset4 : from2 < end3 && to > offset4) {
        let startInside = offset4 + child.border, endInside = end3 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset4 || to == end3 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset4 = end3;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  isText(text) {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset4) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset4 ? this.size : 0);
    return this.posAtStart + offset4;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size2 = this.size;
    if (to < size2)
      nodes = replaceNodes(nodes, to, size2, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i2 = 0; i2 < nodes.length; i2++)
      nodes[i2].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i2 = this.children.length - 1; i2 >= 0; i2--) {
        let child = this.children[i2];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment3.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i2, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i2 == this.node.childCount ? Mark.none : this.node.child(i2).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i2) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i2)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i2, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n2 = this.nodeDOM; n2; n2 = n2.parentNode)
      if (n2 == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset4, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset4, this.node.text.length);
    return super.localPosFromDOM(dom, offset4, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i2 = 0; i2 < descs.length; i2++) {
    let desc = descs[i2], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i2 = 0; i2 < outerDeco.length; i2++) {
    let attrs2 = outerDeco[i2].type.attrs;
    if (!attrs2)
      continue;
    if (attrs2.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs2.nodeName));
    for (let name in attrs2) {
      let val = attrs2[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i2 = 0; i2 < curComputed.length; i2++) {
    let deco = curComputed[i2], prev = prevComputed[i2];
    if (i2) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i2 = 0; i2 < prevList.length; i2++)
      if (curList.indexOf(prevList[i2]) == -1)
        dom.classList.remove(prevList[i2]);
    for (let i2 = 0; i2 < curList.length; i2++)
      if (prevList.indexOf(curList[i2]) == -1)
        dom.classList.add(curList[i2]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a2, b2) {
  if (a2.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!a2[i2].type.eq(b2[i2].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start3, end3) {
    if (start3 == end3)
      return;
    for (let i2 = start3; i2 < end3; i2++)
      this.top.children[i2].destroy();
    this.top.children.splice(start3, end3 - start3);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
        let next = this.top.children[i2];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i2;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index2) {
    let found2 = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i2 = this.index, e2 = Math.min(this.top.children.length, i2 + 5); i2 < e2; i2++) {
        let child = this.top.children[i2];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i2;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i2 = this.index; i2 < this.top.children.length; i2++) {
            if (this.top.children[i2] == desc)
              return i2;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index2, pos) {
    for (let i2 = this.index; i2 < this.top.children.length; i2++) {
      let next = this.top.children[i2];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i2);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i2);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches2.push(desc);
  }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a2, b2) {
  return a2.type.side - b2.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset4 = 0;
  if (locals.length == 0) {
    for (let i2 = 0; i2 < parent.childCount; i2++) {
      let child = parent.child(i2);
      onNode(child, locals, deco.forChild(offset4, child), i2);
      offset4 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset4) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i2 = 0; i2 < widgets.length; i2++)
          onWidget(widgets[i2], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i2 = 0; i2 < active.length; i2++)
      if (active[i2].to <= offset4)
        active.splice(i2--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset4 && locals[decoIndex].to > offset4)
      active.push(locals[decoIndex++]);
    let end3 = offset4 + child.nodeSize;
    if (child.isText) {
      let cutAt = end3;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i2 = 0; i2 < active.length; i2++)
        if (active[i2].to < cutAt)
          cutAt = active[i2].to;
      if (cutAt < end3) {
        restNode = child.cut(cutAt - offset4);
        child = child.cut(0, cutAt - offset4);
        end3 = cutAt;
        index2 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end3)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset4, child), index2);
    offset4 = end3;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i2 = 0, pos = 0; i2 < frag.childCount && pos <= to; ) {
    let child = frag.child(i2++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i2 < frag.childCount) {
      let next = frag.child(i2++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i2 = 0, off = 0; i2 < nodes.length; i2++) {
    let child = nodes[i2], start3 = off, end3 = off += child.size;
    if (start3 >= to || end3 <= from2) {
      result.push(child);
    } else {
      if (start3 < from2)
        result.push(child.slice(0, from2 - start3, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end3 > to)
        result.push(child.slice(to - start3, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin2 = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min3 = head, max3 = head;
      for (let i2 = 0; i2 < domSel.rangeCount; i2++) {
        let range = domSel.getRangeAt(i2);
        min3 = Math.min(min3, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max3 = Math.max(max3, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min3 < 0)
        return null;
      [anchor, head] = max3 == view.state.selection.anchor ? [max3, min3] : [min3, max3];
      $head = doc3.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc3.resolve(anchor);
  if (!selection) {
    let bias = origin2 == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset4 } = view.docView.domFromPos(pos, 0);
  let after = offset4 < node.childNodes.length ? node.childNodes[offset4] : null;
  let before = offset4 ? node.childNodes[offset4 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset4 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset4) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setStart(node.parentNode, domIndex(node) + 1);
  else
    range.setStart(node, 0);
  range.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply2(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply2(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply2(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply2(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply2(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply2(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply2(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset4 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset4 < nodeLen(node) && isIgnorable(node.childNodes[offset4], -1))
    force = true;
  for (; ; ) {
    if (offset4 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset4 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset4;
        } else if (before.nodeType == 3) {
          node = before;
          offset4 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset4 = 0;
      } else {
        node = prev;
        offset4 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset4);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset4 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset4 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset4];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset4;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset4 = len = 0;
      } else {
        node = next;
        offset4 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset4) {
  while (node && offset4 == node.childNodes.length && !hasBlockDesc(node)) {
    offset4 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset4 < node.childNodes.length) {
    let next = node.childNodes[offset4];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset4 = 0;
  }
}
function textNodeBefore(node, offset4) {
  while (node && !offset4 && !hasBlockDesc(node)) {
    offset4 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset4) {
    let next = node.childNodes[offset4 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset4 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset4) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset4)) {
      node = after;
      offset4 = 0;
    } else if (before = textNodeBefore(node, offset4)) {
      node = before;
      offset4 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset4);
    range.setStart(node, offset4);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset4);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply2(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply2(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty3 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty3)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr3 = view.state.tr;
    if (dir < 0)
      tr3.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr3.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr3);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code2 = event.keyCode, mods = getMods(event);
  if (code2 == 8 || mac && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code2 == 46 && !event.shiftKey || mac && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37 || mac && code2 == 66 && mods == "c") {
    let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 39 || mac && code2 == 70 && mods == "c") {
    let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 38 || mac && code2 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code2 == 40 || mac && code2 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i2 = needsWrap.length - 1; i2 >= 0; i2--) {
      let wrapper = doc3.createElement(needsWrap[i2]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment3.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema: schema2 } = view.state, serializer = DOMSerializer.fromSchema(schema2);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p3 = dom.appendChild(document.createElement("p"));
        if (block)
          p3.appendChild(serializer.serializeNode(schema2.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i2 = +sliceData[3]; i2 > 0; i2--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match85 = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match85.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match85 = match85.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment3.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i2 = wrap2.length - 1; i2 >= from2; i2--)
    node = wrap2[i2].create(null, Fragment3.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match85 = sibling.contentMatchAt(sibling.childCount);
    if (match85.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment3.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment3.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment3.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
var _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s2) => s2 });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n2) => "<" + n2 + ">").join("") + html + wrap2.map((n2) => "</" + n2 + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap2)
    for (let i2 = 0; i2 < wrap2.length; i2++)
      elt = elt.querySelector(wrap2[i2]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i2 = 0; i2 < nodes.length; i2++) {
    let node = nodes[i2];
    if (node.childNodes.length == 1 && node.textContent == " " && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema2 = slice2.content.firstChild.type.schema, array2;
  try {
    array2 = JSON.parse(context);
  } catch (e2) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i2 = array2.length - 2; i2 >= 0; i2 -= 2) {
    let type = schema2.nodes[array2[i2]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment3.from(type.create(array2[i2 + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin2) {
  view.input.lastSelectionOrigin = origin2;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view.input.lastIOSEnter = now2;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now2) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
      view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    if (view.someProp(propName, (f) => i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin2) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr3 = view.state.tr.setSelection(selection);
  if (origin2 == "pointer")
    tr3.setMeta("pointer", true);
  view.dispatch(tr3);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i2);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    let nodePos = $pos.before(i2);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset4 = sel.focusOffset; node && node.nodeType == 1 && offset4 != 0; ) {
          let before = offset4 < 0 ? node.lastChild : node.childNodes[offset4 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset4 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !view.state.selection.empty)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr3 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr3.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move2, node) {
    this.slice = slice2;
    this.move = move2;
    this.node = node;
  }
};
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e2) => e2.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move2 = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move2))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr3 = view.state.tr;
  if (move2) {
    let { node } = dragging;
    if (node)
      node.replace(tr3);
    else
      tr3.deleteSelection();
  }
  let pos = tr3.mapping.map(insertPos);
  let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr3.doc;
  if (isNode)
    tr3.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr3.replaceRange(pos, pos, slice2);
  if (tr3.doc.eq(beforeInsert))
    return;
  let $pos = tr3.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr3.setSelection(new NodeSelection($pos));
  } else {
    let end3 = tr3.mapping.map(insertPos);
    tr3.mapping.maps[tr3.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end3 = newTo);
    tr3.setSelection(selectionBetween(view, $pos, tr3.doc.resolve(end3)));
  }
  view.focus();
  view.dispatch(tr3.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a2, b2) {
  if (a2 == b2)
    return true;
  for (let p3 in a2)
    if (a2[p3] !== b2[p3])
      return false;
  for (let p3 in b2)
    if (!(p3 in a2))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset4, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset4, pos - offset4, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs2, spec) {
    this.attrs = attrs2;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset4, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset4;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset4;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs2, spec) {
    this.attrs = attrs2;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset4, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset4, to.pos - offset4, this);
  }
  valid(node, span) {
    let { index: index2, offset: offset4 } = node.content.findIndex(span.from), child;
    return offset4 == span.from && !(child = node.child(index2)).isText && offset4 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset4 = 0) {
    return this.type.eq(other.type) && this.from + offset4 == other.from && this.to + offset4 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset4, oldOffset) {
    return this.type.map(mapping, this, offset4, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs2, spec) {
    return new _Decoration(from2, to, new InlineType(attrs2, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs2, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs2, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty2;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start3, end3, predicate) {
    let result = [];
    this.findInner(start3 == null ? 0 : start3, end3 == null ? 1e9 : end3, result, 0, predicate);
    return result;
  }
  findInner(start3, end3, result, offset4, predicate) {
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let span = this.local[i2];
      if (span.from <= end3 && span.to >= start3 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset4, span.to + offset4));
    }
    for (let i2 = 0; i2 < this.children.length; i2 += 3) {
      if (this.children[i2] < end3 && this.children[i2 + 1] > start3) {
        let childOff = this.children[i2] + 1;
        this.children[i2 + 2].findInner(start3 - childOff, end3 - childOff, result, offset4 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options2) {
    if (this == empty2 || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options2 || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset4, oldOffset, options2) {
    let newLocal;
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let mapped = this.local[i2].map(mapping, offset4, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options2.onRemove)
        options2.onRemove(this.local[i2].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset4, oldOffset, options2);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty2;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty2)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset4) {
    let children, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset4, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset4);
    for (let i2 = 0; i2 < local.length; i2++)
      if (!local[i2].type.valid(doc3, local[i2]))
        local.splice(i2--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty2)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset4) {
    let children = this.children, local = this.local;
    for (let i2 = 0; i2 < children.length; i2 += 3) {
      let found2;
      let from2 = children[i2] + offset4, to = children[i2 + 1] + offset4;
      for (let j2 = 0, span; j2 < decorations.length; j2++)
        if (span = decorations[j2]) {
          if (span.from > from2 && span.to < to) {
            decorations[j2] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i2 + 2].removeInner(found2, from2 + 1);
      if (removed != empty2) {
        children[i2 + 2] = removed;
      } else {
        children.splice(i2, 3);
        i2 -= 3;
      }
    }
    if (local.length) {
      for (let i2 = 0, span; i2 < decorations.length; i2++)
        if (span = decorations[i2]) {
          for (let j2 = 0; j2 < local.length; j2++)
            if (local[j2].eq(span, offset4)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j2--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new _DecorationSet(local, children) : empty2;
  }
  forChild(offset4, node) {
    if (this == empty2)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i2 = 0; i2 < this.children.length; i2 += 3)
      if (this.children[i2] >= offset4) {
        if (this.children[i2] == offset4)
          child = this.children[i2 + 2];
        break;
      }
    let start3 = offset4 + 1, end3 = start3 + node.content.size;
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let dec = this.local[i2];
      if (dec.from < end3 && dec.to > start3 && dec.type instanceof InlineType) {
        let from2 = Math.max(start3, dec.from) - start3, to = Math.min(end3, dec.to) - start3;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty2;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i2 = 0; i2 < this.local.length; i2++)
      if (!this.local[i2].eq(other.local[i2]))
        return false;
    for (let i2 = 0; i2 < this.children.length; i2 += 3)
      if (this.children[i2] != other.children[i2] || this.children[i2 + 1] != other.children[i2 + 1] || !this.children[i2 + 2].eq(other.children[i2 + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty2)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i2 = 0; i2 < this.local.length; i2++) {
      if (!(this.local[i2].type instanceof InlineType))
        result.push(this.local[i2]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty2 = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset4, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i2 = 0; i2 < this.members.length; i2++) {
      let result = this.members[i2].forChild(offset4, child);
      if (result == empty2)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i2 = 0; i2 < this.members.length; i2++)
      if (!this.members[i2].eq(other.members[i2]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i2 = 0; i2 < this.members.length; i2++) {
      let locals = this.members[i2].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j2 = 0; j2 < locals.length; j2++)
          result.push(locals[j2]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty2;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i2 = 0; i2 < this.members.length; i2++)
      this.members[i2].forEachSet(f);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset4, oldOffset, options2) {
  let children = oldChildren.slice();
  for (let i2 = 0, baseOffset = oldOffset; i2 < mapping.maps.length; i2++) {
    let moved = 0;
    mapping.maps[i2].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i3 = 0; i3 < children.length; i3 += 3) {
        let end3 = children[i3 + 1];
        if (end3 < 0 || oldStart > end3 + baseOffset - moved)
          continue;
        let start3 = children[i3] + baseOffset - moved;
        if (oldEnd >= start3) {
          children[i3 + 1] = oldStart <= start3 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i3] += dSize;
          children[i3 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i2].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i2 = 0; i2 < children.length; i2 += 3)
    if (children[i2 + 1] < 0) {
      if (children[i2 + 1] == -2) {
        mustRebuild = true;
        children[i2 + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i2] + oldOffset), fromLocal = from2 - offset4;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i2 + 1] + oldOffset, -1), toLocal = to - offset4;
      let { index: index2, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i2 + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i2] + oldOffset + 1, options2);
        if (mapped != empty2) {
          children[i2] = fromLocal;
          children[i2 + 1] = toLocal;
          children[i2 + 2] = mapped;
        } else {
          children[i2 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset4, oldOffset, options2);
    let built = buildTree(decorations, node, 0, options2);
    newLocal = built.local;
    for (let i2 = 0; i2 < children.length; i2 += 3)
      if (children[i2 + 1] < 0) {
        children.splice(i2, 3);
        i2 -= 3;
      }
    for (let i2 = 0, j2 = 0; i2 < built.children.length; i2 += 3) {
      let from2 = built.children[i2];
      while (j2 < children.length && children[j2] < from2)
        j2 += 3;
      children.splice(j2, 0, built.children[i2], built.children[i2 + 1], built.children[i2 + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset4) {
  if (!offset4 || !spans.length)
    return spans;
  let result = [];
  for (let i2 = 0; i2 < spans.length; i2++) {
    let span = spans[i2];
    result.push(new Decoration(span.from + offset4, span.to + offset4, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset4, oldOffset, options2) {
  function gather(set2, oldOffset2) {
    for (let i2 = 0; i2 < set2.local.length; i2++) {
      let mapped = set2.local[i2].map(mapping, offset4, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options2.onRemove)
        options2.onRemove(set2.local[i2].spec);
    }
    for (let i2 = 0; i2 < set2.children.length; i2 += 3)
      gather(set2.children[i2 + 2], set2.children[i2] + oldOffset2 + 1);
  }
  for (let i2 = 0; i2 < children.length; i2 += 3)
    if (children[i2 + 1] == -1)
      gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset4) {
  if (node.isLeaf)
    return null;
  let end3 = offset4 + node.nodeSize, found2 = null;
  for (let i2 = 0, span; i2 < spans.length; i2++) {
    if ((span = spans[i2]) && span.from > offset4 && span.to < end3) {
      (found2 || (found2 = [])).push(span);
      spans[i2] = null;
    }
  }
  return found2;
}
function withoutNulls(array2) {
  let result = [];
  for (let i2 = 0; i2 < array2.length; i2++)
    if (array2[i2] != null)
      result.push(array2[i2]);
  return result;
}
function buildTree(spans, node, offset4, options2) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset4);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset4 + localStart + 1, options2);
      if (subtree != empty2)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset4).sort(byPos);
  for (let i2 = 0; i2 < locals.length; i2++)
    if (!locals[i2].type.valid(node, locals[i2])) {
      if (options2.onRemove)
        options2.onRemove(locals[i2].spec);
      locals.splice(i2--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty2;
}
function byPos(a2, b2) {
  return a2.from - b2.from || a2.to - b2.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i2 = 0; i2 < working.length - 1; i2++) {
    let span = working[i2];
    if (span.from != span.to)
      for (let j2 = i2 + 1; j2 < working.length; j2++) {
        let next = working[j2];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j2] = next.copy(next.from, span.to);
            insertAhead(working, j2 + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i2] = span.copy(span.from, next.from);
            insertAhead(working, j2, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array2, i2, deco) {
  while (i2 < array2.length && byPos(deco, array2[i2]) > 0)
    i2++;
  array2.splice(i2, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty2)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i2 = 0; i2 < mutations.length; i2++)
        this.queue.push(mutations[i2]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e2) => {
        this.queue.push({ target: e2.target, type: "characterData", oldValue: e2.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i2 = 0; i2 < take.length; i2++)
          this.queue.push(take[i2]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i2 = 0; i2 < mutations.length; i2++) {
        let result = this.registerMutation(mutations[i2], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n2) => n2.nodeName == "BR");
      if (brs.length == 2) {
        let [a2, b2] = brs;
        if (a2.parentNode && a2.parentNode.parentNode == b2.parentNode)
          b2.remove();
        else
          a2.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
        let node = mut.addedNodes[i2];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i2];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p3 = node.parentNode; p3 && p3 != view.dom; p3 = p3.parentNode) {
    let desc = view.docView.nearestDesc(p3, true);
    if (desc && desc.node.isBlock)
      return p3;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin2 = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin2);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr4 = view.state.tr.setSelection(newSel);
      if (origin2 == "pointer")
        tr4.setMeta("pointer", true);
      else if (origin2 == "key")
        tr4.scrollIntoView();
      if (compositionID)
        tr4.setMeta("composition", compositionID);
      view.dispatch(tr4);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared2 = $before.sharedDepth(to);
  from2 = $before.before(shared2 + 1);
  to = view.state.doc.resolve(to).after(shared2 + 1);
  let sel = view.state.selection;
  let parse5 = parseBetween(view, from2, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse5.from, parse5.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse5.doc.content, parse5.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n2) => n2.nodeType == 1 && !isInline.test(n2.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse5.sel && parse5.sel.anchor != parse5.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse5.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse5.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr4 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr4.setMeta("composition", compositionID);
          view.dispatch(tr4);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse5.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse5.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse5.from && parse5.doc.textBetween(change.start - parse5.from - 1, change.start - parse5.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse5.doc.resolveNoCache(change.start - parse5.from);
  let $to = parse5.doc.resolveNoCache(change.endB - parse5.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n2) => n2.nodeName == "DIV" || n2.nodeName == "P")) || !inlineChange && $from.pos < parse5.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse5.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse5.sel && parse5.sel.anchor == parse5.sel.head && parse5.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse5.doc.resolveNoCache(change.endB - parse5.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr3, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr3 = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr3 = view.state.tr;
      if (markChange.type == "add")
        tr3.addMark(chFrom, chTo, markChange.mark);
      else
        tr3.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
        return;
      tr3 = view.state.tr.insertText(text, chFrom, chTo);
    }
  }
  if (!tr3)
    tr3 = view.state.tr.replace(chFrom, chTo, parse5.doc.slice(change.start - parse5.from, change.endB - parse5.from));
  if (parse5.sel) {
    let sel2 = resolveSelection(view, tr3.doc, parse5.sel);
    if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr3.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
      tr3.setSelection(sel2);
  }
  if (storedMarks)
    tr3.ensureMarks(storedMarks);
  if (compositionID)
    tr3.setMeta("composition", compositionID);
  view.dispatch(tr3.scrollIntoView());
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update2;
  for (let i2 = 0; i2 < prevMarks.length; i2++)
    added = prevMarks[i2].removeFromSet(added);
  for (let i2 = 0; i2 < curMarks.length; i2++)
    removed = curMarks[i2].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update2 = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update2 = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i2 = 0; i2 < prev.childCount; i2++)
    updated.push(update2(prev.child(i2)));
  if (Fragment3.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start3, end3, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end3 - start3 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start3);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end3 == start3 + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end3 || skipClosingAndOpening($next, true, false) < end3)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end3 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end3++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end3++;
    }
  }
  return end3;
}
function findDiff(a2, b2, pos, preferredPos, preferredSide) {
  let start3 = a2.findDiffStart(b2, pos);
  if (start3 == null)
    return null;
  let { a: endA, b: endB } = a2.findDiffEnd(b2, pos + a2.size, pos + b2.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start3 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start3;
  }
  if (endA < start3 && a2.size < b2.size) {
    let move2 = preferredPos <= start3 && preferredPos >= endA ? start3 - preferredPos : 0;
    start3 -= move2;
    if (start3 && start3 < b2.size && isSurrogatePair(b2.textBetween(start3 - 1, start3 + 1)))
      start3 += move2 ? 1 : -1;
    endB = start3 + (endB - endA);
    endA = start3;
  } else if (endB < start3) {
    let move2 = preferredPos <= start3 && preferredPos >= endB ? start3 - preferredPos : 0;
    start3 -= move2;
    if (start3 && start3 < a2.size && isSurrogatePair(a2.textBetween(start3 - 1, start3 + 1)))
      start3 += move2 ? 1 : -1;
    endA = start3 + (endA - endB);
    endB = start3;
  }
  return { start: start3, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a2 = str.charCodeAt(0), b2 = str.charCodeAt(1);
  return a2 >= 56320 && a2 <= 57343 && b2 >= 55296 && b2 <= 56319;
}
var __serializeForClipboard = serializeForClipboard;
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll2 = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll2 == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll2 == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll2 == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
        let plugin = this.directPlugins[i2];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i2 = 0; i2 < this.state.plugins.length; i2++) {
        let plugin = this.state.plugins[i2];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i2 = 0; i2 < this.pluginViews.length; i2++) {
        let pluginView = this.pluginViews[i2];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
      let prop2 = this.directPlugins[i2].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i2 = 0; i2 < plugins.length; i2++) {
        let prop2 = plugins[i2].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search2 = this.dom.parentNode; search2; search2 = search2.parentNode) {
        if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
          if (!search2.getSelection)
            Object.getPrototypeOf(search2).getSelection = () => search2.ownerDocument.getSelection();
          return this._root = search2;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset4, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset4, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr3) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr3);
    else
      this.updateState(this.state.apply(tr3));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function computeDocDeco(view) {
  let attrs2 = /* @__PURE__ */ Object.create(null);
  attrs2.class = "ProseMirror";
  attrs2.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs2.class += " " + value[attr];
        else if (attr == "style")
          attrs2.style = (attrs2.style ? attrs2.style + ";" : "") + value[attr];
        else if (!attrs2[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs2[attr] = String(value[attr]);
      }
  });
  if (!attrs2.translate)
    attrs2.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs2)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add3(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add3);
  view.someProp("markViews", add3);
  return result;
}
function changedNodeViews(a2, b2) {
  let nA = 0, nB = 0;
  for (let prop in a2) {
    if (a2[prop] != b2[prop])
      return true;
    nA++;
  }
  for (let _ in b2)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// ../../../node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift3 = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i2 = 0; i2 < 10; i2++) base[48 + i2] = base[96 + i2] = String(i2);
var i2;
for (i2 = 1; i2 <= 24; i2++) base[i2 + 111] = "F" + i2;
var i2;
for (i2 = 65; i2 <= 90; i2++) {
  base[i2] = String.fromCharCode(i2 + 32);
  shift3[i2] = String.fromCharCode(i2);
}
var i2;
for (code2 in base) if (!shift3.hasOwnProperty(code2)) shift3[code2] = base[code2];
var code2;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift3 : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}

// ../../../node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
var windows2 = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift4, meta;
  for (let i2 = 0; i2 < parts.length - 1; i2++) {
    let mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift4 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift4)
    result = "Shift-" + result;
  return result;
}
function normalize(map4) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map4)
    copy2[normalizeKeyName(prop)] = map4[prop];
  return copy2;
}
function modifiers(name, event, shift4 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift4 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map4 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map4[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map4[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map4[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// ../../../node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr3 = state.tr.step(delStep);
          tr3.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr3.doc.resolve(tr3.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr3.doc, $cut.pos - before.nodeSize));
          dispatch(tr3.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
var joinTextblockForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr3 = state.tr.step(step);
    tr3.setSelection(TextSelection.create(tr3.doc, beforePos));
    dispatch(tr3.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch, view) => {
  let { $head, empty: empty3 } = state.selection, $cut = $head;
  if (!empty3)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
      if ($pos.index(i2) > 0)
        return $pos.doc.resolve($pos.before(i2 + 1));
      if ($pos.node(i2).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr3 = state.tr.step(delStep);
        tr3.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr3.doc.resolve(tr3.mapping.map($cut.pos)), 1) : NodeSelection.create(tr3.doc, tr3.mapping.map($cut.pos)));
        dispatch(tr3.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch, view) => {
  let { $head, empty: empty3 } = state.selection, $cut = $head;
  if (!empty3)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
      let parent = $pos.node(i2);
      if ($pos.index(i2) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i2 + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr3 = state.tr.join(point);
    if (nodeSel)
      tr3.setSelection(NodeSelection.create(tr3.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr3.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift3 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match85) {
  for (let i2 = 0; i2 < match85.edgeCount; i2++) {
    let { type } = match85.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr3 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr3.setSelection(Selection.near(tr3.doc.resolve(pos), 1));
    dispatch(tr3.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr3 = state.tr.insert(side, type.createAndFill());
    tr3.setSelection(TextSelection.create(tr3.doc, side + 1));
    dispatch(tr3.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        let splitType = splitNode && splitNode($to.parent, atEnd, $from);
        types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr3 = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr3.deleteSelection();
    let splitPos = tr3.mapping.map($from.pos);
    let can = canSplit(tr3.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr3.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr3.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr3.mapping.map($from.before(splitDepth)), $first = tr3.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr3.setNodeMarkup(tr3.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr3.scrollIntoView());
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match85;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match85 = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match85.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end3 = $cut.pos + after.nodeSize, wrap2 = Fragment3.empty;
      for (let i2 = conn.length - 1; i2 >= 0; i2--)
        wrap2 = Fragment3.from(conn[i2].create(null, wrap2));
      wrap2 = Fragment3.from(before.copy(wrap2));
      let tr3 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end3, $cut.pos, end3, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr3.doc.resolve(end3 + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr3.doc, $joinAt.pos))
        tr3.join($joinAt.pos);
      dispatch(tr3.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end3 = Fragment3.empty;
        for (let i2 = wrap2.length - 1; i2 >= 0; i2--)
          end3 = Fragment3.from(wrap2[i2].copy(end3));
        let tr3 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end3, wrap2.length, 0), 0, true));
        dispatch(tr3.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs2 = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs2);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs2 = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i2 = 0; i2 < state.selection.ranges.length && !applicable; i2++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i2];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs2))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr3 = state.tr;
      for (let i2 = 0; i2 < state.selection.ranges.length; i2++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i2];
        tr3.setBlockType(from2, to, nodeType, attrs2);
      }
      dispatch(tr3.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i2 = 0; i2 < commands2.length; i2++)
      if (commands2[i2](state, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// ../../../node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs2 = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr3 = dispatch ? state.tr : null;
    if (!wrapRangeInList(tr3, range, listType, attrs2))
      return false;
    if (dispatch)
      dispatch(tr3.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr3, range, listType, attrs2 = null) {
  let doJoin = false, outerRange = range, doc3 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc3.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs2, range);
  if (!wrap2)
    return false;
  if (tr3)
    doWrapInList(tr3, range, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr3, range, wrappers, joinBefore, listType) {
  let content = Fragment3.empty;
  for (let i2 = wrappers.length - 1; i2 >= 0; i2--)
    content = Fragment3.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
  tr3.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i2 = 0; i2 < wrappers.length; i2++)
    if (wrappers[i2].type == listType)
      found2 = i2 + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i2 = range.startIndex, e2 = range.endIndex, first2 = true; i2 < e2; i2++, first2 = false) {
    if (!first2 && canSplit(tr3.doc, splitPos, splitDepth)) {
      tr3.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i2).nodeSize;
  }
  return tr3;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr3 = state.tr, end3 = range.end, endOfList = range.$to.end(range.depth);
  if (end3 < endOfList) {
    tr3.step(new ReplaceAroundStep(end3 - 1, endOfList, end3, endOfList, new Slice(Fragment3.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr3.doc.resolve(range.$from.pos), tr3.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr3.lift(range, target);
  let $after = tr3.doc.resolve(tr3.mapping.map(end3, -1) - 1);
  if (canJoin(tr3.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr3.join($after.pos);
  dispatch(tr3.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr3 = state.tr, list = range.parent;
  for (let pos = range.end, i2 = range.endIndex - 1, e2 = range.startIndex; i2 > e2; i2--) {
    pos -= list.child(i2).nodeSize;
    tr3.delete(pos - 1, pos + 1);
  }
  let $start = tr3.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr3.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment3.empty : Fragment3.from(list))))
    return false;
  let start3 = $start.pos, end3 = start3 + item.nodeSize;
  tr3.step(new ReplaceAroundStep(start3 - (atStart ? 1 : 0), end3 + (atEnd ? 1 : 0), start3 + 1, end3 - 1, new Slice((atStart ? Fragment3.empty : Fragment3.from(list.copy(Fragment3.empty))).append(atEnd ? Fragment3.empty : Fragment3.from(list.copy(Fragment3.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr3.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment3.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment3.from(itemType.create(null, Fragment3.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// ../../../node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr3 } = state;
    const props = this.buildProps(tr3);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr3.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr3);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr3 = startTr || state.tr;
    const run3 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr3.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr3);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr3, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run3
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr3 = startTr || state.tr;
    const props = this.buildProps(tr3, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr3, dispatch)
    };
  }
  buildProps(tr3, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr3,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr3
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr3, shouldDispatch),
      can: () => this.createCan(tr3),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn2) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn2);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn2) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn2) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn2) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn2.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema2) {
  if (typeof nameOrType === "string") {
    if (!schema2.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema2.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items2, item) => {
    const mergedAttributes = { ...items2 };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style3) => style3.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style3) => style3.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style3) => {
          const [property, val] = style3.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style3) => {
          const [property, val] = style3.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction2(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction2(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items2, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items2;
        }
        return {
          ...items2,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions.reduce((fields, e2) => {
      const extendNodeSchema = getExtensionField(e2, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema2 = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
      linebreakReplacement: callOrReturn(getExtensionField(extension, "linebreakReplacement", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema2.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema2.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema2.toText = renderText;
    }
    return [extension.name, schema2];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions.reduce((fields, e2) => {
      const extendMarkSchema = getExtensionField(e2, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema2 = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema2.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema2.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema2];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema2) {
  return schema2.nodes[name] || schema2.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function getHTMLFromFragment(fragment, schema2) {
  const documentFragment = DOMSerializer.fromSchema(schema2).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index2) => {
    var _a, _b;
    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index: index2
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text);
  }
  const inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a;
  const { editor, from: from2, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match85 = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match85) {
      return;
    }
    const tr3 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr3
    });
    const range = {
      from: from2 - (match85[0].length - text.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match: match85,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr3.steps.length) {
      return;
    }
    tr3.setMeta(plugin, {
      transform: tr3,
      from: from2,
      to,
      text
    });
    view.dispatch(tr3);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr3, prev, state) {
        const stored = tr3.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr3.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment3.from(text), state.schema);
            }
            const { from: from2 } = simulatedInputMeta;
            const to = from2 + text.length;
            run$1({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr3.selectionSet || tr3.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run$1({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject3(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject3(target) && isPlainObject3(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject3(source[key]) && isPlainObject3(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Mark2 = class _Mark {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Mark(config);
  }
  configure(options2 = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options2);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Mark(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr: tr3 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr3.removeStoredMark(removeMark2);
      }
      tr3.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr3);
      return true;
    }
    return false;
  }
};
function isNumber2(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text, find2, event) => {
  if (isRegExp(find2)) {
    return [...text.matchAll(find2)];
  }
  const matches2 = find2(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "￼");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match85) => {
      if (match85.index === void 0) {
        return;
      }
      const start3 = resolvedFrom + match85.index + 1;
      const end3 = start3 + match85[0].length;
      const range = {
        from: state.tr.mapping.map(start3),
        to: state.tr.mapping.map(end3)
      };
      const handler = rule.handler({
        state,
        range,
        match: match85,
        commands: commands2,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text) => {
  var _a;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({ state, from: from2, to, rule, pasteEvt }) => {
    const tr3 = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr3
    });
    const handler = run({
      editor,
      state: chainableState,
      from: Math.max(from2 - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr3.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr3;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment3.from(text), state.schema);
          }
          const { from: from3 } = simulatedPasteMeta;
          const to2 = from3 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from3,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber2(from2) || !to || from2 === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from2,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
function findDuplicates(items2) {
  const filtered = items2.filter((el2, index2) => items2.indexOf(el2) !== index2);
  return Array.from(new Set(filtered));
}
var ExtensionManager = class _ExtensionManager {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = _ExtensionManager.resolve(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(extensions) {
    const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(extensions) {
    return extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(extensions) {
    const defaultPriority = 100;
    return extensions.sort((a2, b2) => {
      const priorityA = getExtensionField(a2, "priority") || defaultPriority;
      const priorityB = getExtensionField(b2, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = _ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations, innerDecorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          // pass-through
          node,
          view,
          getPos,
          decorations,
          innerDecorations,
          // tiptap-specific
          editor,
          extension,
          HTMLAttributes
        });
      };
      return [extension.name, nodeview];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy2 = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy2) {
        this.editor.on("destroy", onDestroy2);
      }
    });
  }
};
var Extension = class _Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Extension(config);
  }
  configure(options2 = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options2);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function getTextBetween(startNode, range, options2) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema2) {
  return Object.fromEntries(Object.entries(schema2.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema: schema2 } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema2);
            const range = { from: from2, to };
            return getTextBetween(doc3, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
var clearNodes = () => ({ state, tr: tr3, dispatch }) => {
  const { selection } = tr3;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr3;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr3.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr3.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn2) => (props) => {
  return fn2(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr3 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr3.deleteRange(originRange.from, originRange.to);
  const newPos = tr3.mapping.map(targetPos);
  tr3.insert(newPos, contentSlice.content);
  tr3.setSelection(new TextSelection(tr3.doc.resolve(newPos - 1)));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr3, dispatch }) => {
  const { selection } = tr3;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr3.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr3.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr: tr3, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr3.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr3.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr: tr3, dispatch }) => {
  const { from: from2, to } = range;
  if (dispatch) {
    tr3.delete(from2, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter2 = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
function objectIncludes(object1, object2, options2 = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options2.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k2) => [k2, item.attrs[k2]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a;
  if (!$pos || !type) {
    return;
  }
  let start3 = $pos.parent.childAfter($pos.parentOffset);
  if (!start3.node || !start3.node.marks.some((mark2) => mark2.type === type)) {
    start3 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start3.node || !start3.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a = start3.node.marks[0]) === null || _a === void 0 ? void 0 : _a.attrs);
  const mark = findMarkInSet([...start3.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start3.index;
  let startPos = $pos.start() + start3.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start3.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema2) {
  if (typeof nameOrType === "string") {
    if (!schema2.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema2.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr3, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr3;
  const { $from, from: from2, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr3.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands2) => (props) => {
  const items2 = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i2 = 0; i2 < items2.length; i2 += 1) {
    if (items2[i2](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min3 = 0, max3 = 0) {
  return Math.min(Math.max(value, min3), max3);
}
function resolveFocusPosition(doc3, position2 = null) {
  if (!position2) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position2 === "start" || position2 === true) {
    return selectionAtStart;
  }
  if (position2 === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position2 === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position2, minPos, maxPos), minMax(position2, minPos, maxPos));
}
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus2 = (position2 = null, options2 = {}) => ({ editor, view, tr: tr3, dispatch }) => {
  options2 = {
    scrollIntoView: true,
    ...options2
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options2 === null || options2 === void 0 ? void 0 : options2.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position2 === null || position2 === false) {
    return true;
  }
  if (dispatch && position2 === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr3.doc, position2) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr3.setSelection(selection);
    }
    if (isSameSelection && tr3.storedMarks) {
      tr3.setStoredMarks(tr3.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach2 = (items2, fn2) => (props) => {
  return items2.every((item, index2) => fn2(item, { ...props, index: index2 }));
};
var insertContent = (value, options2) => ({ tr: tr3, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr3.selection.from, to: tr3.selection.to }, value, options2);
};
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i2 = children.length - 1; i2 >= 0; i2 -= 1) {
    const child = children[i2];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema2, options2) {
  if (content instanceof Node2 || content instanceof Fragment3) {
    return content;
  }
  options2 = {
    slice: true,
    parseOptions: {},
    ...options2
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment3.fromArray(content.map((item) => schema2.nodeFromJSON(item)));
      }
      const node = schema2.nodeFromJSON(content);
      if (options2.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error2) {
      if (options2.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error2 });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error2);
      return createNodeFromContent("", schema2, options2);
    }
  }
  if (isTextContent) {
    if (options2.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema2.spec.topNode,
        marks: schema2.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema2.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e2) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e2 === "string" ? e2 : e2.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options2.slice) {
        DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options2.parseOptions);
      } else {
        DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options2.parseOptions);
      }
      if (options2.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
      }
    }
    const parser = DOMParser.fromSchema(schema2);
    if (options2.slice) {
      return parser.parseSlice(elementFromString(content), options2.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options2.parseOptions);
  }
  return createNodeFromContent("", schema2, options2);
}
function selectionToInsertionEnd2(tr3, startLen, bias) {
  const last = tr3.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr3.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map4 = tr3.mapping.maps[last];
  let end3 = 0;
  map4.forEach((_from, _to, _newFrom, newTo) => {
    if (end3 === 0) {
      end3 = newTo;
    }
  });
  tr3.setSelection(Selection.near(tr3.doc.resolve(end3), bias));
}
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position2, value, options2) => ({ tr: tr3, dispatch, editor }) => {
  var _a;
  if (dispatch) {
    options2 = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options2
    };
    let content;
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options2.parseOptions
        },
        errorOnInvalidContent: (_a = options2.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck
      });
    } catch (e2) {
      editor.emit("contentError", {
        editor,
        error: e2,
        disableCollaboration: () => {
          if (editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
      return false;
    }
    let { from: from2, to } = typeof position2 === "number" ? { from: position2, to: position2 } : { from: position2.from, to: position2.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr3.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment3) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr3.insertText(newContent, from2, to);
    } else {
      newContent = content;
      tr3.replaceWith(from2, to, newContent);
    }
    if (options2.updateSelection) {
      selectionToInsertionEnd2(tr3, tr3.steps.length - 1, -1);
    }
    if (options2.applyInputRules) {
      tr3.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options2.applyPasteRules) {
      tr3.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ state, dispatch, tr: tr3 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr3.join(point, 2);
    if (dispatch) {
      dispatch(tr3);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr: tr3 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr3.join(point, 2);
    if (dispatch) {
      dispatch(tr3);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch }) => {
  return joinTextblockBackward(state, dispatch);
};
var joinTextblockForward2 = () => ({ state, dispatch }) => {
  return joinTextblockForward(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift4;
  let meta;
  for (let i2 = 0; i2 < parts.length - 1; i2 += 1) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift4 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift4) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr3, dispatch }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr3.mapping);
    if (newStep && dispatch) {
      tr3.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty3 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty3) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift4 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive3 = isNodeActive(state, type, attributes);
  if (!isActive3) {
    return false;
  }
  return lift3(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function getSchemaTypeNameByName(name, schema2) {
  if (schema2.nodes[name]) {
    return "node";
  }
  if (schema2.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr3, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr3.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr3.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr3.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr: tr3, dispatch }) => {
  if (dispatch) {
    tr3.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr: tr3, dispatch }) => {
  if (dispatch) {
    const selection = new AllSelection(tr3.doc);
    tr3.setSelection(selection);
  }
  return true;
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
function createDocument(content, schema2, parseOptions = {}, options2 = {}) {
  return createNodeFromContent(content, schema2, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options2.errorOnInvalidContent
  });
}
var setContent = (content, emitUpdate = false, parseOptions = {}, options2 = {}) => ({ editor, tr: tr3, dispatch, commands: commands2 }) => {
  var _a, _b;
  const { doc: doc3 } = tr3;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: (_a = options2.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck
    });
    if (dispatch) {
      tr3.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch) {
    tr3.setMeta("preventUpdate", !emitUpdate);
  }
  return commands2.insertContentAt({ from: 0, to: doc3.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: (_b = options2.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty3 } = state.selection;
  const marks = [];
  if (empty3) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt2(match85) {
  for (let i2 = 0; i2 < match85.edgeCount; i2 += 1) {
    const { type } = match85.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i2 = $pos.depth; i2 > 0; i2 -= 1) {
    const node = $pos.node(i2);
    if (predicate(node)) {
      return {
        pos: i2 > 0 ? $pos.before(i2) : 0,
        start: $pos.start(i2),
        depth: i2,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getText2(node, options2) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options2);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array2, by = JSON.stringify) {
  const seen = {};
  return array2.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_, i2) => i2 !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index2];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index2).map(from2, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty3, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty3) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive2(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
  var _a;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a = node.text) !== null && _a !== void 0 ? _a : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from2, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start3 = view.coordsAtPos(resolvedFrom);
  const end3 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start3.top, end3.top);
  const bottom2 = Math.max(start3.bottom, end3.bottom);
  const left2 = Math.min(start3.left, end3.left);
  const right2 = Math.max(start3.right, end3.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function canSetMark(state, tr3, newMarkType) {
  var _a;
  const { selection } = tr3;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr3, state, dispatch }) => {
  const { selection } = tr3;
  const { empty: empty3, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty3) {
      const oldAttributes = getMarkAttributes(state, type);
      tr3.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr3.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr3.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr3, type);
};
var setMeta = (key, value) => ({ tr: tr3 }) => {
  tr3.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType2(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position2) => ({ tr: tr3, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr3;
    const from2 = minMax(position2, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from2);
    tr3.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position2) => ({ tr: tr3, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr3;
    const { from: from2, to } = typeof position2 === "number" ? { from: position2, to: position2 } : position2;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr3.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr3, state, dispatch, editor }) => {
  const { selection, doc: doc3 } = tr3;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr3.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr3.doc, tr3.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr3.doc, tr3.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr3.deleteSelection();
      }
      tr3.split(tr3.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr3.mapping.map($from.before());
        const $first = tr3.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr3.setNodeMarkup(tr3.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr3.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr3, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment3.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment3.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment3.from(type.createAndFill(null, nextType2) || void 0));
      const start3 = $from.before($from.depth - (depthBefore - 1));
      tr3.replace(start3, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr3.doc.nodesBetween(start3, tr3.doc.content.size, (n2, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n2.isTextblock && n2.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr3.setSelection(TextSelection.near(tr3.doc.resolve(sel)));
      }
      tr3.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr3.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr3.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr3.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr3.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr3, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr3.selection);
  if (!list) {
    return true;
  }
  const before = tr3.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr3.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr3.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr3.join(list.pos);
  return true;
};
var joinListForwards = (tr3, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr3.selection);
  if (!list) {
    return true;
  }
  const after = tr3.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr3.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr3.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr3.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr3, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr3.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr3, listType)).command(() => joinListForwards(tr3, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr3, listType)).command(() => joinListForwards(tr3, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr3.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr3, listType)).command(() => joinListForwards(tr3, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options2 = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options2;
  const type = getMarkType(typeOrName, state.schema);
  const isActive3 = isMarkActive(state, type, attributes);
  if (isActive3) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive3 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive3) {
    return commands2.setNode(toggleType, attributesToCopy);
  }
  return commands2.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive3 = isNodeActive(state, type, attributes);
  if (isActive3) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i2 = 0; i2 < plugins.length; i2 += 1) {
    const plugin = plugins[i2];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr3 = state.tr;
        const toUndo = undoable.transform;
        for (let j2 = toUndo.steps.length - 1; j2 >= 0; j2 -= 1) {
          tr3.step(toUndo.steps[j2].invert(toUndo.docs[j2]));
        }
        if (undoable.text) {
          const marks = tr3.doc.resolve(undoable.from).marks();
          tr3.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr3.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr3, dispatch }) => {
  const { selection } = tr3;
  const { empty: empty3, ranges } = selection;
  if (empty3) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr3.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options2 = {}) => ({ tr: tr3, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options2;
  const { selection } = tr3;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty3, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty3 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs2 = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range = getMarkRange($from, type, attrs2);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr3.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr3.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr3.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr3, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr3.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr3.selection.empty) {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (pos < from2 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from2 && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr3.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr3.addMark(trimmedFrom2, trimmedTo2, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr3.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr3.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var commands = Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear: createParagraphNear2,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange: deleteRange2,
  deleteSelection: deleteSelection2,
  enter: enter2,
  exitCode: exitCode2,
  extendMarkRange,
  first,
  focus: focus2,
  forEach: forEach2,
  insertContent,
  insertContentAt,
  joinBackward: joinBackward2,
  joinDown: joinDown2,
  joinForward: joinForward2,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward: joinTextblockBackward2,
  joinTextblockForward: joinTextblockForward2,
  joinUp: joinUp2,
  keyboardShortcut,
  lift: lift4,
  liftEmptyBlock: liftEmptyBlock2,
  liftListItem: liftListItem2,
  newlineInCode: newlineInCode2,
  resetAttributes,
  scrollIntoView,
  selectAll: selectAll2,
  selectNodeBackward: selectNodeBackward2,
  selectNodeForward: selectNodeForward2,
  selectParentNode: selectParentNode2,
  selectTextblockEnd: selectTextblockEnd2,
  selectTextblockStart: selectTextblockStart2,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem: sinkListItem2,
  splitBlock: splitBlock2,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn: wrapIn2,
  wrapInList: wrapInList2
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e2, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e2,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr: tr3 }) => {
        const { selection, doc: doc3 } = tr3;
        const { empty: empty3, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr3.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty3 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr4) => tr4.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty3, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty3 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr3 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr3
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr3.steps.length) {
            return;
          }
          return tr3;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e2, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e2,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var index = Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Drop,
  Editable,
  FocusEvents,
  Keymap,
  Paste,
  Tabindex
});
var NodePos = class _NodePos {
  get name() {
    return this.node.type.name;
  }
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a;
    return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset4) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset4 + (isNonTextAtom ? 0 : 1);
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index2 = 0; index2 < attrKeys.length; index2 += 1) {
            const key = attrKeys[index2];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr: tr3 } = this.editor.state;
    tr3.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr3);
  }
};
var style2 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style3, nonce, suffix2) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix2 ? `-${suffix2}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix2 ? `-${suffix2}` : ""}`, "");
  styleNode.innerHTML = style3;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor = class extends EventEmitter {
  constructor(options2 = {}) {
    super();
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: error2 }) => {
        throw error2;
      },
      onPaste: () => null,
      onDrop: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options2);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
    this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style2, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options2 = {}) {
    this.options = {
      ...this.options,
      ...options2
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction2(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = prevPlugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var _a;
    let doc3;
    try {
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (e2) {
      if (!(e2 instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e2.message)) {
        throw e2;
      }
      this.emit("contentError", {
        editor: this,
        error: e2,
        disableCollaboration: () => {
          if (this.storage.collaboration) {
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
    }
    const selection = resolveFocusPosition(doc3, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a = this.options.editorProps) === null || _a === void 0 ? void 0 : _a.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc3,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn2) {
    this.isCapturingTransaction = true;
    fn2();
    this.isCapturingTransaction = false;
    const tr3 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr3;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction,
      nextState: state
    });
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus3 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus3) {
      this.emit("focus", {
        editor: this,
        event: focus3.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive2(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options2) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      const dom = this.view.dom;
      if (dom && dom.editor) {
        delete dom.editor;
      }
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
  $node(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match: match85 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match85);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr3 } = state;
      const captureGroup = match85[match85.length - 1];
      const fullMatch = match85[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr3.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr3.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr3.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr3.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match: match85 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match85) || {};
      const { tr: tr3 } = state;
      const start3 = range.from;
      let end3 = range.to;
      const newNode = config.type.create(attributes);
      if (match85[1]) {
        const offset4 = match85[0].lastIndexOf(match85[1]);
        let matchStart = start3 + offset4;
        if (matchStart > end3) {
          matchStart = end3;
        } else {
          end3 = matchStart + match85[1].length;
        }
        const lastChar = match85[0][match85[0].length - 1];
        tr3.insertText(lastChar, start3 + match85[0].length - 1);
        tr3.replaceWith(matchStart, end3, newNode);
      } else if (match85[0]) {
        const insertionStart = config.type.isInline ? start3 : start3 - 1;
        tr3.insert(insertionStart, config.type.create(attributes)).delete(tr3.mapping.map(start3), tr3.mapping.map(end3));
      }
      tr3.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match: match85 }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match85) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match: match85, chain }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match85) || {};
      const tr3 = state.tr.delete(range.from, range.to);
      const $start = tr3.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr3.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr3.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr3.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr3.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match85, before))) {
        tr3.join(range.from - 1);
      }
    }
  });
}
var Node3 = class _Node {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Node(config);
  }
  configure(options2 = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options2);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Node(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match: match85, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match85, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr3 } = state;
      const captureGroup = match85[match85.length - 1];
      const fullMatch = match85[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr3.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr3.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr3.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr3.removeStoredMark(config.type);
      }
    }
  });
}
function escapeForRegEx(string2) {
  return string2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// ../../../node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start2 = "start";
var end2 = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start2, placement + "-" + end2]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start2, placement + "-" + end2]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// ../../../node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument2 = node.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node;
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement2(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// ../../../node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style3 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style3);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style3 = styleProperties.reduce(function(style4, property) {
        style4[property] = "";
        return style4;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style3);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// ../../../node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// ../../../node_modules/@popperjs/core/lib/utils/math.js
var max2 = Math.max;
var min2 = Math.min;
var round = Math.round;

// ../../../node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement2(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement2(element) {
  return ((isElement2(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement2(element)
  );
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// ../../../node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// ../../../node_modules/@popperjs/core/lib/utils/within.js
function within(min3, value, max3) {
  return max2(min3, min2(value, max3));
}
function withinMaxClamp(min3, value, max3) {
  var v = within(min3, value, max3);
  return v > max3 ? max3 : v;
}

// ../../../node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// ../../../node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// ../../../node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// ../../../node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options2 = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min3 = paddingObject[minProp];
  var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset4 = within(min3, center, max3);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset4, _state$modifiersData$.centerOffset = offset4 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// ../../../node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// ../../../node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement2(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end2) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end2) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// ../../../node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll2) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll2) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// ../../../node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// ../../../node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll4(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement2(element)).left + getWindowScroll4(element).scrollLeft;
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement2(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement2(element);
  var winScroll = getWindowScroll4(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// ../../../node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement2(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement2(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// ../../../node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start2:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end2:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// ../../../node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement2(element) ? element : element.contextElement || getDocumentElement2(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset4 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset4[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// ../../../node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}

// ../../../node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options2 = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start2;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// ../../../node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// ../../../node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset4) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset4 === "function" ? offset4(Object.assign({}, rects, {
    placement
  })) : offset4, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
function offset3(_ref2) {
  var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
  var _options$offset = options2.offset, offset4 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset4);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset3
};

// ../../../node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// ../../../node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// ../../../node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options2 = _ref.options, name = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset4 = popperOffsets2[mainAxis];
    var min3 = offset4 + overflow[mainSide];
    var max3 = offset4 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset4 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset4 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min2(min3, tetherMin) : min3, offset4, tether ? max2(max3, tetherMax) : max3);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset4;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// ../../../node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll4(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// ../../../node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement2(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll2.scrollLeft - offsets.x,
    y: rect.top + scroll2.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// ../../../node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers2) {
  var map4 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map4.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map4.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// ../../../node_modules/@popperjs/core/lib/utils/debounce.js
function debounce3(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// ../../../node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// ../../../node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options3);
        state.scrollParents = {
          reference: isElement2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce3(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state2) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
        if (typeof effect5 === "function") {
          var cleanupFn = effect5({
            state,
            name,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// ../../../node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// ../../../node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// ../../../node_modules/tippy.js/dist/tippy.esm.js
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index2, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index2];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce4(fn2, ms2) {
  if (ms2 === 0) {
    return fn2;
  }
  var timeout2;
  return function(arg) {
    clearTimeout(timeout2);
    timeout2 = setTimeout(function() {
      fn2(arg);
    }, ms2);
  };
}
function removeProperties(obj, keys2) {
  var clone3 = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone3[key];
  });
  return clone3;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index2) {
    return arr.indexOf(item) === index2;
  });
}
function getBasePlacement2(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement3(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement3(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el2) {
    if (el2) {
      el2.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el2) {
    if (el2) {
      el2.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement2(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now2 = performance.now();
  if (now2 - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now2;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser2 ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean2(value) {
  var spacesAndTabs2 = /[ \t]{2,}/g;
  var lineStartWithSpaces2 = /^[ \t]*/gm;
  return value.replace(spacesAndTabs2, " ").replace(lineStartWithSpaces2, "").trim();
}
function getDevMessage2(message2) {
  return clean2("\n  %ctippy.js\n\n  %c" + clean2(message2) + "\n\n  %c👷‍ This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage2(message2) {
  return [
    getDevMessage2(message2),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (true) {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message2) {
  if (condition && !visitedMessages.has(message2)) {
    var _console;
    visitedMessages.add(message2);
    (_console = console).warn.apply(_console, getFormattedMessage2(message2));
  }
}
function errorWhen(condition, message2) {
  if (condition && !visitedMessages.has(message2)) {
    var _console2;
    visitedMessages.add(message2);
    (_console2 = console).error.apply(_console2, getFormattedMessage2(message2));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps2 = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps2);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (true) {
    validateProps5(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps2[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps2[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps2, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e2) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps2.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps5(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps2, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow3 = div();
  if (value === true) {
    arrow3.className = ARROW_CLASS;
  } else {
    arrow3.className = SVG_ARROW_CLASS;
    if (isElement3(value)) {
      arrow3.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow3, value);
    }
  }
  return arrow3;
}
function setContent2(content, props) {
  if (isElement3(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent2(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent2(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow3) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow3);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow3) {
      box2.removeChild(arrow3);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps2, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners2 = [];
  var debouncedOnMouseMove = debounce4(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id2 = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id2,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent3,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (true) {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps2.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id3 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id3 : id3);
      } else {
        var nextValue = currentValue && currentValue.replace(id3, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el2) {
      return actualContains(el2, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc3 = getDocument();
    doc3.addEventListener("mousedown", onDocumentPress, true);
    doc3.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc3 = getDocument();
    doc3.removeEventListener("mousedown", onDocumentPress, true);
    doc3.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options2) {
    if (options2 === void 0) {
      options2 = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options2);
      listeners2.push({
        node,
        eventType,
        handler,
        options: options2
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners2.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options2 = _ref.options;
      node.removeEventListener(eventType, handler, options2);
    });
    listeners2 = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset4 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow3 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset4
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow3) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow3,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper3(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    if (true) {
      warnWhen(instance.props.interactive && appendTo === defaultProps2.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce4(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent3(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps2.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide2() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps2.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i2) {
      return i2 !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (true) {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps2.plugins.concat(optionalProps.plugins || []);
  if (true) {
    validateTargets(targets);
    validateProps5(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (true) {
    var isSingleContentElement = isElement3(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement3(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps2;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, applyStyles_default, {
  effect: function effect4(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
var tippy_esm_default = tippy;

// ../../../node_modules/@tiptap/extension-bubble-menu/dist/index.js
var BubbleMenuView = class {
  constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from2, to }) => {
      const { doc: doc3, selection } = state;
      const { empty: empty3 } = selection;
      const isEmptyTextBlock = !doc3.textBetween(from2, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty3 || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.handleDebouncedUpdate = (view2, oldState) => {
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (this.updateDebounceTimer) {
        clearTimeout(this.updateDebounceTimer);
      }
      this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, this.updateDelay);
    };
    this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
      var _a, _b, _c;
      const { state, composing } = view2;
      const { selection } = state;
      const isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from2 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
        editor: this.editor,
        element: this.element,
        view: view2,
        state,
        oldState,
        from: from2,
        to
      });
      if (!shouldShow2) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
          if (isNodeSelection(state.selection)) {
            let node = view2.nodeDOM(from2);
            if (node) {
              const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
              if (nodeViewWrapper) {
                node = nodeViewWrapper.firstChild;
              }
              if (node) {
                return node.getBoundingClientRect();
              }
            }
          }
          return posToDOMRect(view2, from2, to);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.from !== state.selection.to;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
    const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var BubbleMenuPlugin = (options2) => {
  return new Plugin({
    key: typeof options2.pluginKey === "string" ? new PluginKey(options2.pluginKey) : options2.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options2 })
  });
};
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// ../../../node_modules/@tiptap/react/dist/index.js
var import_react7 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// ../../../node_modules/@tiptap/extension-floating-menu/dist/index.js
var FloatingMenuView = class {
  getTextContent(node) {
    return getText2(node, { textSerializers: getTextSerializersFromSchema(this.editor.schema) });
  }
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state }) => {
      const { selection } = state;
      const { $anchor, empty: empty3 } = selection;
      const isRootDepth = $anchor.depth === 1;
      const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent && $anchor.parent.childCount === 0 && !this.getTextContent($anchor.parent);
      if (!view2.hasFocus() || !empty3 || !isRootDepth || !isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    var _a, _b, _c;
    const { state } = view;
    const { doc: doc3, selection } = state;
    const { from: from2, to } = selection;
    const isSame = oldState && oldState.doc.eq(doc3) && oldState.selection.eq(selection);
    if (isSame) {
      return;
    }
    this.createTooltip();
    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
      editor: this.editor,
      view,
      state,
      oldState
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => posToDOMRect(view, from2, to))
    });
    this.show();
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var FloatingMenuPlugin = (options2) => {
  return new Plugin({
    key: typeof options2.pluginKey === "string" ? new PluginKey(options2.pluginKey) : options2.pluginKey,
    view: (view) => new FloatingMenuView({ view, ...options2 })
  });
};
var FloatingMenu = Extension.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      FloatingMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// ../../../node_modules/@tiptap/react/dist/index.js
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var shim = { exports: {} };
var useSyncExternalStoreShim_development = {};
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
  hasRequiredUseSyncExternalStoreShim_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React$1 = import_react7.default;
      var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error2(format3) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format3, args);
          }
        }
      }
      function printWarning(level, format3, args) {
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();
          if (stack !== "") {
            format3 += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format3);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function is3(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is3;
      var useState10 = React$1.useState, useEffect11 = React$1.useEffect, useLayoutEffect8 = React$1.useLayoutEffect, useDebugValue3 = React$1.useDebugValue;
      var didWarnOld18Alpha = false;
      var didWarnUncachedGetSnapshot = false;
      function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
        {
          if (!didWarnOld18Alpha) {
            if (React$1.startTransition !== void 0) {
              didWarnOld18Alpha = true;
              error2("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
            }
          }
        }
        var value = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            if (!objectIs(value, cachedValue)) {
              error2("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var _useState = useState10({
          inst: {
            value,
            getSnapshot
          }
        }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect8(function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
        }, [subscribe, value, getSnapshot]);
        useEffect11(function() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          };
          return subscribe(handleStoreChange);
        }, [subscribe]);
        useDebugValue3(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error3) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
        return getSnapshot();
      }
      var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var isServerEnvironment = !canUseDOM2;
      var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
      var useSyncExternalStore$2 = React$1.useSyncExternalStore !== void 0 ? React$1.useSyncExternalStore : shim2;
      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return useSyncExternalStoreShim_development;
}
if (false) {
  shim.exports = requireUseSyncExternalStoreShim_production_min();
} else {
  shim.exports = requireUseSyncExternalStoreShim_development();
}
var shimExports = shim.exports;
var mergeRefs = (...refs) => {
  return (node) => {
    refs.forEach((ref2) => {
      if (typeof ref2 === "function") {
        ref2(node);
      } else if (ref2) {
        ref2.current = node;
      }
    });
  };
};
var Portals = ({ contentComponent }) => {
  const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);
  return import_react7.default.createElement(import_react7.default.Fragment, null, Object.values(renderers));
};
function getInstance() {
  const subscribers = /* @__PURE__ */ new Set();
  let renderers = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    },
    getSnapshot() {
      return renderers;
    },
    getServerSnapshot() {
      return renderers;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(id2, renderer) {
      renderers = {
        ...renderers,
        [id2]: import_react_dom3.default.createPortal(renderer.reactElement, renderer.element, id2)
      };
      subscribers.forEach((subscriber) => subscriber());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(id2) {
      const nextRenderers = { ...renderers };
      delete nextRenderers[id2];
      renderers = nextRenderers;
      subscribers.forEach((subscriber) => subscriber());
    }
  };
}
var PureEditorContent = class extends import_react7.default.Component {
  constructor(props) {
    var _a;
    super(props);
    this.editorContentRef = import_react7.default.createRef();
    this.initialized = false;
    this.state = {
      hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const editor = this.props.editor;
    if (editor && !editor.isDestroyed && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.options.element.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = getInstance();
      if (!this.state.hasContentComponentInitialized) {
        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
          this.setState((prevState) => {
            if (!prevState.hasContentComponentInitialized) {
              return {
                hasContentComponentInitialized: true
              };
            }
            return prevState;
          });
          if (this.unsubscribeToContentComponent) {
            this.unsubscribeToContentComponent();
          }
        });
      }
      editor.createNodeViews();
      this.initialized = true;
    }
  }
  componentWillUnmount() {
    const editor = this.props.editor;
    if (!editor) {
      return;
    }
    this.initialized = false;
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    if (this.unsubscribeToContentComponent) {
      this.unsubscribeToContentComponent();
    }
    editor.contentComponent = null;
    if (!editor.options.element.firstChild) {
      return;
    }
    const newElement = document.createElement("div");
    newElement.append(...editor.options.element.childNodes);
    editor.setOptions({
      element: newElement
    });
  }
  render() {
    const { editor, innerRef, ...rest } = this.props;
    return import_react7.default.createElement(
      import_react7.default.Fragment,
      null,
      import_react7.default.createElement("div", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),
      (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && import_react7.default.createElement(Portals, { contentComponent: editor.contentComponent })
    );
  }
};
var EditorContentWithKey = (0, import_react7.forwardRef)((props, ref2) => {
  const key = import_react7.default.useMemo(() => {
    return Math.floor(Math.random() * 4294967295).toString();
  }, [props.editor]);
  return import_react7.default.createElement(PureEditorContent, {
    key,
    innerRef: ref2,
    ...props
  });
});
var EditorContent = import_react7.default.memo(EditorContentWithKey);
var react = function equal2(a2, b2) {
  if (a2 === b2) return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor) return false;
    var length, i2, keys2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length) return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal2(a2[i2], b2[i2])) return false;
      return true;
    }
    if (a2 instanceof Map && b2 instanceof Map) {
      if (a2.size !== b2.size) return false;
      for (i2 of a2.entries())
        if (!b2.has(i2[0])) return false;
      for (i2 of a2.entries())
        if (!equal2(i2[1], b2.get(i2[0]))) return false;
      return true;
    }
    if (a2 instanceof Set && b2 instanceof Set) {
      if (a2.size !== b2.size) return false;
      for (i2 of a2.entries())
        if (!b2.has(i2[0])) return false;
      return true;
    }
    if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
      length = a2.length;
      if (length != b2.length) return false;
      for (i2 = length; i2-- !== 0; )
        if (a2[i2] !== b2[i2]) return false;
      return true;
    }
    if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b2).length) return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2])) return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys2[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!equal2(a2[key], b2[key])) return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
var deepEqual = getDefaultExportFromCjs(react);
var withSelector = { exports: {} };
var withSelector_development = {};
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  if (hasRequiredWithSelector_development) return withSelector_development;
  hasRequiredWithSelector_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React$1 = import_react7.default;
      var shim2 = shimExports;
      function is3(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is3;
      var useSyncExternalStore2 = shim2.useSyncExternalStore;
      var useRef11 = React$1.useRef, useEffect11 = React$1.useEffect, useMemo11 = React$1.useMemo, useDebugValue3 = React$1.useDebugValue;
      function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual4) {
        var instRef = useRef11(null);
        var inst;
        if (instRef.current === null) {
          inst = {
            hasValue: false,
            value: null
          };
          instRef.current = inst;
        } else {
          inst = instRef.current;
        }
        var _useMemo = useMemo11(function() {
          var hasMemo = false;
          var memoizedSnapshot;
          var memoizedSelection;
          var memoizedSelector = function(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              var _nextSelection = selector(nextSnapshot);
              if (isEqual4 !== void 0) {
                if (inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual4(currentSelection, _nextSelection)) {
                    memoizedSelection = currentSelection;
                    return currentSelection;
                  }
                }
              }
              memoizedSelection = _nextSelection;
              return _nextSelection;
            }
            var prevSnapshot = memoizedSnapshot;
            var prevSelection = memoizedSelection;
            if (objectIs(prevSnapshot, nextSnapshot)) {
              return prevSelection;
            }
            var nextSelection = selector(nextSnapshot);
            if (isEqual4 !== void 0 && isEqual4(prevSelection, nextSelection)) {
              return prevSelection;
            }
            memoizedSnapshot = nextSnapshot;
            memoizedSelection = nextSelection;
            return nextSelection;
          };
          var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          var getSnapshotWithSelector = function() {
            return memoizedSelector(getSnapshot());
          };
          var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          };
          return [getSnapshotWithSelector, getServerSnapshotWithSelector];
        }, [getSnapshot, getServerSnapshot, selector, isEqual4]), getSelection2 = _useMemo[0], getServerSelection = _useMemo[1];
        var value = useSyncExternalStore2(subscribe, getSelection2, getServerSelection);
        useEffect11(function() {
          inst.hasValue = true;
          inst.value = value;
        }, [value]);
        useDebugValue3(value);
        return value;
      }
      withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return withSelector_development;
}
if (false) {
  withSelector.exports = requireWithSelector_production_min();
} else {
  withSelector.exports = requireWithSelector_development();
}
var withSelectorExports = withSelector.exports;
var useIsomorphicLayoutEffect4 = typeof window !== "undefined" ? import_react7.useLayoutEffect : import_react7.useEffect;
var EditorStateManager = class {
  constructor(initialEditor) {
    this.transactionNumber = 0;
    this.lastTransactionNumber = 0;
    this.subscribers = /* @__PURE__ */ new Set();
    this.editor = initialEditor;
    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };
    this.getSnapshot = this.getSnapshot.bind(this);
    this.getServerSnapshot = this.getServerSnapshot.bind(this);
    this.watch = this.watch.bind(this);
    this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    if (this.transactionNumber === this.lastTransactionNumber) {
      return this.lastSnapshot;
    }
    this.lastTransactionNumber = this.transactionNumber;
    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };
    return this.lastSnapshot;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(nextEditor) {
    this.editor = nextEditor;
    if (this.editor) {
      const fn2 = () => {
        this.transactionNumber += 1;
        this.subscribers.forEach((callback) => callback());
      };
      const currentEditor = this.editor;
      currentEditor.on("transaction", fn2);
      return () => {
        currentEditor.off("transaction", fn2);
      };
    }
    return void 0;
  }
};
function useEditorState(options2) {
  var _a;
  const [editorStateManager] = (0, import_react7.useState)(() => new EditorStateManager(options2.editor));
  const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options2.selector, (_a = options2.equalityFn) !== null && _a !== void 0 ? _a : deepEqual);
  useIsomorphicLayoutEffect4(() => {
    return editorStateManager.watch(options2.editor);
  }, [options2.editor, editorStateManager]);
  (0, import_react7.useDebugValue)(selectedState);
  return selectedState;
}
var isDev = true;
var isSSR = typeof window === "undefined";
var isNext = isSSR || Boolean(typeof window !== "undefined" && window.next);
var EditorInstanceManager = class _EditorInstanceManager {
  constructor(options2) {
    this.editor = null;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.isComponentMounted = false;
    this.previousDeps = null;
    this.instanceId = "";
    this.options = options2;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.setEditor(this.getInitialEditor());
    this.scheduleDestroy();
    this.getEditor = this.getEditor.bind(this);
    this.getServerSnapshot = this.getServerSnapshot.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);
    this.scheduleDestroy = this.scheduleDestroy.bind(this);
    this.onRender = this.onRender.bind(this);
    this.createEditor = this.createEditor.bind(this);
  }
  setEditor(editor) {
    this.editor = editor;
    this.instanceId = Math.random().toString(36).slice(2, 9);
    this.subscriptions.forEach((cb) => cb());
  }
  getInitialEditor() {
    if (this.options.current.immediatelyRender === void 0) {
      if (isSSR || isNext) {
        if (isDev) {
          console.warn("Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.");
        }
        return null;
      }
      return this.createEditor();
    }
    if (this.options.current.immediatelyRender && isSSR && isDev) {
      throw new Error("Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.");
    }
    if (this.options.current.immediatelyRender) {
      return this.createEditor();
    }
    return null;
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const optionsToApply = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onBlur: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onCreate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onDestroy: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onFocus: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onSelectionUpdate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onTransaction: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onUpdate: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onContentError: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onDrop: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      },
      onPaste: (...args) => {
        var _a, _b;
        return (_b = (_a = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
      }
    };
    const editor = new Editor(optionsToApply);
    return editor;
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(onStoreChange) {
    this.subscriptions.add(onStoreChange);
    return () => {
      this.subscriptions.delete(onStoreChange);
    };
  }
  static compareOptions(a2, b2) {
    return Object.keys(a2).every((key) => {
      if (["onCreate", "onBeforeCreate", "onDestroy", "onUpdate", "onTransaction", "onFocus", "onBlur", "onSelectionUpdate", "onContentError", "onDrop", "onPaste"].includes(key)) {
        return true;
      }
      if (key === "extensions" && a2.extensions && b2.extensions) {
        if (a2.extensions.length !== b2.extensions.length) {
          return false;
        }
        return a2.extensions.every((extension, index2) => {
          var _a;
          if (extension !== ((_a = b2.extensions) === null || _a === void 0 ? void 0 : _a[index2])) {
            return false;
          }
          return true;
        });
      }
      if (a2[key] !== b2[key]) {
        return false;
      }
      return true;
    });
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(deps) {
    return () => {
      this.isComponentMounted = true;
      clearTimeout(this.scheduledDestructionTimeout);
      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {
        if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {
          this.editor.setOptions({
            ...this.options.current,
            editable: this.editor.isEditable
          });
        }
      } else {
        this.refreshEditorInstance(deps);
      }
      return () => {
        this.isComponentMounted = false;
        this.scheduleDestroy();
      };
    };
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(deps) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = deps;
        return;
      }
      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index2) => dep === deps[index2]);
      if (depsAreEqual) {
        return;
      }
    }
    if (this.editor && !this.editor.isDestroyed) {
      this.editor.destroy();
    }
    this.setEditor(this.createEditor());
    this.previousDeps = deps;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const currentInstanceId = this.instanceId;
    const currentEditor = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === currentInstanceId) {
        if (currentEditor) {
          currentEditor.setOptions(this.options.current);
        }
        return;
      }
      if (currentEditor && !currentEditor.isDestroyed) {
        currentEditor.destroy();
        if (this.instanceId === currentInstanceId) {
          this.setEditor(null);
        }
      }
    }, 1);
  }
};
function useEditor(options2 = {}, deps = []) {
  const mostRecentOptions = (0, import_react7.useRef)(options2);
  mostRecentOptions.current = options2;
  const [instanceManager] = (0, import_react7.useState)(() => new EditorInstanceManager(mostRecentOptions));
  const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);
  (0, import_react7.useDebugValue)(editor);
  (0, import_react7.useEffect)(instanceManager.onRender(deps));
  useEditorState({
    editor,
    selector: ({ transactionNumber }) => {
      if (options2.shouldRerenderOnTransaction === false) {
        return null;
      }
      if (options2.immediatelyRender && transactionNumber === 0) {
        return 0;
      }
      return transactionNumber + 1;
    }
  });
  return editor;
}
var EditorContext = (0, import_react7.createContext)({
  editor: null
});
var EditorConsumer = EditorContext.Consumer;
var useCurrentEditor = () => (0, import_react7.useContext)(EditorContext);
function EditorProvider({ children, slotAfter, slotBefore, editorContainerProps = {}, ...editorOptions }) {
  const editor = useEditor(editorOptions);
  if (!editor) {
    return null;
  }
  return import_react7.default.createElement(
    EditorContext.Provider,
    { value: { editor } },
    slotBefore,
    import_react7.default.createElement(EditorConsumer, null, ({ editor: currentEditor }) => import_react7.default.createElement(EditorContent, { editor: currentEditor, ...editorContainerProps })),
    children,
    slotAfter
  );
}
var BubbleMenu2 = (props) => {
  const [element, setElement] = (0, import_react7.useState)(null);
  const { editor: currentEditor } = useCurrentEditor();
  (0, import_react7.useEffect)(() => {
    var _a;
    if (!element) {
      return;
    }
    if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {
      return;
    }
    const { pluginKey = "bubbleMenu", editor, tippyOptions = {}, updateDelay, shouldShow = null } = props;
    const menuEditor = editor || currentEditor;
    if (!menuEditor) {
      console.warn("BubbleMenu component is not rendered inside of an editor component or does not have editor prop.");
      return;
    }
    const plugin = BubbleMenuPlugin({
      updateDelay,
      editor: menuEditor,
      element,
      pluginKey,
      shouldShow,
      tippyOptions
    });
    menuEditor.registerPlugin(plugin);
    return () => {
      menuEditor.unregisterPlugin(pluginKey);
    };
  }, [props.editor, currentEditor, element]);
  return import_react7.default.createElement("div", { ref: setElement, className: props.className, style: { visibility: "hidden" } }, props.children);
};
var ReactNodeViewContext = (0, import_react7.createContext)({
  onDragStart: void 0
});
var useReactNodeView = () => (0, import_react7.useContext)(ReactNodeViewContext);
var NodeViewWrapper = import_react7.default.forwardRef((props, ref2) => {
  const { onDragStart: onDragStart2 } = useReactNodeView();
  const Tag = props.as || "div";
  return (
    // @ts-ignore
    import_react7.default.createElement(Tag, { ...props, ref: ref2, "data-node-view-wrapper": "", onDragStart: onDragStart2, style: {
      whiteSpace: "normal",
      ...props.style
    } })
  );
});
function isClassComponent(Component3) {
  return !!(typeof Component3 === "function" && Component3.prototype && Component3.prototype.isReactComponent);
}
function isForwardRefComponent(Component3) {
  var _a;
  return !!(typeof Component3 === "object" && ((_a = Component3.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === "Symbol(react.forward_ref)");
}
var ReactRenderer = class {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(component, { editor, props = {}, as = "div", className = "" }) {
    this.ref = null;
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.component = component;
    this.editor = editor;
    this.props = props;
    this.element = document.createElement(as);
    this.element.classList.add("react-renderer");
    if (className) {
      this.element.classList.add(...className.split(" "));
    }
    if (this.editor.isInitialized) {
      (0, import_react_dom3.flushSync)(() => {
        this.render();
      });
    } else {
      this.render();
    }
  }
  /**
   * Render the React component.
   */
  render() {
    var _a;
    const Component3 = this.component;
    const props = this.props;
    const editor = this.editor;
    if (isClassComponent(Component3) || isForwardRefComponent(Component3)) {
      props.ref = (ref2) => {
        this.ref = ref2;
      };
    }
    this.reactElement = import_react7.default.createElement(Component3, { ...props });
    (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(props = {}) {
    this.props = {
      ...this.props,
      ...props
    };
    this.render();
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var _a;
    const editor = this.editor;
    (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.removeRenderer(this.id);
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(attributes) {
    Object.keys(attributes).forEach((key) => {
      this.element.setAttribute(key, attributes[key]);
    });
  }
};

// ../../../node_modules/@tiptap/extension-document/dist/index.js
var Document = Node3.create({
  name: "doc",
  topNode: true,
  content: "block+"
});

// ../../../node_modules/prosemirror-markdown/dist/index.js
var schema = new Schema({
  nodes: {
    doc: {
      content: "block+"
    },
    paragraph: {
      content: "inline*",
      group: "block",
      parseDOM: [{ tag: "p" }],
      toDOM() {
        return ["p", 0];
      }
    },
    blockquote: {
      content: "block+",
      group: "block",
      parseDOM: [{ tag: "blockquote" }],
      toDOM() {
        return ["blockquote", 0];
      }
    },
    horizontal_rule: {
      group: "block",
      parseDOM: [{ tag: "hr" }],
      toDOM() {
        return ["div", ["hr"]];
      }
    },
    heading: {
      attrs: { level: { default: 1 } },
      content: "(text | image)*",
      group: "block",
      defining: true,
      parseDOM: [
        { tag: "h1", attrs: { level: 1 } },
        { tag: "h2", attrs: { level: 2 } },
        { tag: "h3", attrs: { level: 3 } },
        { tag: "h4", attrs: { level: 4 } },
        { tag: "h5", attrs: { level: 5 } },
        { tag: "h6", attrs: { level: 6 } }
      ],
      toDOM(node) {
        return ["h" + node.attrs.level, 0];
      }
    },
    code_block: {
      content: "text*",
      group: "block",
      code: true,
      defining: true,
      marks: "",
      attrs: { params: { default: "" } },
      parseDOM: [{ tag: "pre", preserveWhitespace: "full", getAttrs: (node) => ({ params: node.getAttribute("data-params") || "" }) }],
      toDOM(node) {
        return ["pre", node.attrs.params ? { "data-params": node.attrs.params } : {}, ["code", 0]];
      }
    },
    ordered_list: {
      content: "list_item+",
      group: "block",
      attrs: { order: { default: 1 }, tight: { default: false } },
      parseDOM: [{ tag: "ol", getAttrs(dom) {
        return {
          order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1,
          tight: dom.hasAttribute("data-tight")
        };
      } }],
      toDOM(node) {
        return ["ol", {
          start: node.attrs.order == 1 ? null : node.attrs.order,
          "data-tight": node.attrs.tight ? "true" : null
        }, 0];
      }
    },
    bullet_list: {
      content: "list_item+",
      group: "block",
      attrs: { tight: { default: false } },
      parseDOM: [{ tag: "ul", getAttrs: (dom) => ({ tight: dom.hasAttribute("data-tight") }) }],
      toDOM(node) {
        return ["ul", { "data-tight": node.attrs.tight ? "true" : null }, 0];
      }
    },
    list_item: {
      content: "block+",
      defining: true,
      parseDOM: [{ tag: "li" }],
      toDOM() {
        return ["li", 0];
      }
    },
    text: {
      group: "inline"
    },
    image: {
      inline: true,
      attrs: {
        src: {},
        alt: { default: null },
        title: { default: null }
      },
      group: "inline",
      draggable: true,
      parseDOM: [{ tag: "img[src]", getAttrs(dom) {
        return {
          src: dom.getAttribute("src"),
          title: dom.getAttribute("title"),
          alt: dom.getAttribute("alt")
        };
      } }],
      toDOM(node) {
        return ["img", node.attrs];
      }
    },
    hard_break: {
      inline: true,
      group: "inline",
      selectable: false,
      parseDOM: [{ tag: "br" }],
      toDOM() {
        return ["br"];
      }
    }
  },
  marks: {
    em: {
      parseDOM: [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (m) => m.type.name == "em" }
      ],
      toDOM() {
        return ["em"];
      }
    },
    strong: {
      parseDOM: [
        { tag: "strong" },
        { tag: "b", getAttrs: (node) => node.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (m) => m.type.name == "strong" },
        { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
      ],
      toDOM() {
        return ["strong"];
      }
    },
    link: {
      attrs: {
        href: {},
        title: { default: null }
      },
      inclusive: false,
      parseDOM: [{ tag: "a[href]", getAttrs(dom) {
        return { href: dom.getAttribute("href"), title: dom.getAttribute("title") };
      } }],
      toDOM(node) {
        return ["a", node.attrs];
      }
    },
    code: {
      code: true,
      parseDOM: [{ tag: "code" }],
      toDOM() {
        return ["code"];
      }
    }
  }
});
function maybeMerge(a2, b2) {
  if (a2.isText && b2.isText && Mark.sameSet(a2.marks, b2.marks))
    return a2.withText(a2.text + b2.text);
}
var MarkdownParseState = class {
  constructor(schema2, tokenHandlers2) {
    this.schema = schema2;
    this.tokenHandlers = tokenHandlers2;
    this.stack = [{ type: schema2.topNodeType, attrs: null, content: [], marks: Mark.none }];
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  push(elt) {
    if (this.stack.length)
      this.top().content.push(elt);
  }
  // Adds the given text to the current position in the document,
  // using the current marks as styling.
  addText(text) {
    if (!text)
      return;
    let top2 = this.top(), nodes = top2.content, last = nodes[nodes.length - 1];
    let node = this.schema.text(text, top2.marks), merged;
    if (last && (merged = maybeMerge(last, node)))
      nodes[nodes.length - 1] = merged;
    else
      nodes.push(node);
  }
  // Adds the given mark to the set of active marks.
  openMark(mark) {
    let top2 = this.top();
    top2.marks = mark.addToSet(top2.marks);
  }
  // Removes the given mark from the set of active marks.
  closeMark(mark) {
    let top2 = this.top();
    top2.marks = mark.removeFromSet(top2.marks);
  }
  parseTokens(toks) {
    for (let i2 = 0; i2 < toks.length; i2++) {
      let tok = toks[i2];
      let handler = this.tokenHandlers[tok.type];
      if (!handler)
        throw new Error("Token type `" + tok.type + "` not supported by Markdown parser");
      handler(this, tok, toks, i2);
    }
  }
  // Add a node at the current position.
  addNode(type, attrs2, content) {
    let top2 = this.top();
    let node = type.createAndFill(attrs2, content, top2 ? top2.marks : []);
    if (!node)
      return null;
    this.push(node);
    return node;
  }
  // Wrap subsequent content in a node of the given type.
  openNode(type, attrs2) {
    this.stack.push({ type, attrs: attrs2, content: [], marks: Mark.none });
  }
  // Close and return the node that is currently on top of the stack.
  closeNode() {
    let info = this.stack.pop();
    return this.addNode(info.type, info.attrs, info.content);
  }
};
function attrs(spec, token, tokens, i2) {
  if (spec.getAttrs)
    return spec.getAttrs(token, tokens, i2);
  else if (spec.attrs instanceof Function)
    return spec.attrs(token);
  else
    return spec.attrs;
}
function noCloseToken(spec, type) {
  return spec.noCloseToken || type == "code_inline" || type == "code_block" || type == "fence";
}
function withoutTrailingNewline(str) {
  return str[str.length - 1] == "\n" ? str.slice(0, str.length - 1) : str;
}
function noOp4() {
}
function tokenHandlers(schema2, tokens) {
  let handlers2 = /* @__PURE__ */ Object.create(null);
  for (let type in tokens) {
    let spec = tokens[type];
    if (spec.block) {
      let nodeType = schema2.nodeType(spec.block);
      if (noCloseToken(spec, type)) {
        handlers2[type] = (state, tok, tokens2, i2) => {
          state.openNode(nodeType, attrs(spec, tok, tokens2, i2));
          state.addText(withoutTrailingNewline(tok.content));
          state.closeNode();
        };
      } else {
        handlers2[type + "_open"] = (state, tok, tokens2, i2) => state.openNode(nodeType, attrs(spec, tok, tokens2, i2));
        handlers2[type + "_close"] = (state) => state.closeNode();
      }
    } else if (spec.node) {
      let nodeType = schema2.nodeType(spec.node);
      handlers2[type] = (state, tok, tokens2, i2) => state.addNode(nodeType, attrs(spec, tok, tokens2, i2));
    } else if (spec.mark) {
      let markType = schema2.marks[spec.mark];
      if (noCloseToken(spec, type)) {
        handlers2[type] = (state, tok, tokens2, i2) => {
          state.openMark(markType.create(attrs(spec, tok, tokens2, i2)));
          state.addText(withoutTrailingNewline(tok.content));
          state.closeMark(markType);
        };
      } else {
        handlers2[type + "_open"] = (state, tok, tokens2, i2) => state.openMark(markType.create(attrs(spec, tok, tokens2, i2)));
        handlers2[type + "_close"] = (state) => state.closeMark(markType);
      }
    } else if (spec.ignore) {
      if (noCloseToken(spec, type)) {
        handlers2[type] = noOp4;
      } else {
        handlers2[type + "_open"] = noOp4;
        handlers2[type + "_close"] = noOp4;
      }
    } else {
      throw new RangeError("Unrecognized parsing spec " + JSON.stringify(spec));
    }
  }
  handlers2.text = (state, tok) => state.addText(tok.content);
  handlers2.inline = (state, tok) => state.parseTokens(tok.children);
  handlers2.softbreak = handlers2.softbreak || ((state) => state.addText(" "));
  return handlers2;
}
var MarkdownParser = class {
  /**
  Create a parser with the given configuration. You can configure
  the markdown-it parser to parse the dialect you want, and provide
  a description of the ProseMirror entities those tokens map to in
  the `tokens` object, which maps token names to descriptions of
  what to do with them. Such a description is an object, and may
  have the following properties:
  */
  constructor(schema2, tokenizer, tokens) {
    this.schema = schema2;
    this.tokenizer = tokenizer;
    this.tokens = tokens;
    this.tokenHandlers = tokenHandlers(schema2, tokens);
  }
  /**
  Parse a string as [CommonMark](http://commonmark.org/) markup,
  and create a ProseMirror document as prescribed by this parser's
  rules.
  
  The second argument, when given, is passed through to the
  [Markdown
  parser](https://markdown-it.github.io/markdown-it/#MarkdownIt.parse).
  */
  parse(text, markdownEnv = {}) {
    let state = new MarkdownParseState(this.schema, this.tokenHandlers), doc3;
    state.parseTokens(this.tokenizer.parse(text, markdownEnv));
    do {
      doc3 = state.closeNode();
    } while (state.stack.length);
    return doc3 || this.schema.topNodeType.createAndFill();
  }
};
function listIsTight(tokens, i2) {
  while (++i2 < tokens.length)
    if (tokens[i2].type != "list_item_open")
      return tokens[i2].hidden;
  return false;
}
var defaultMarkdownParser = new MarkdownParser(schema, lib_default("commonmark", { html: false }), {
  blockquote: { block: "blockquote" },
  paragraph: { block: "paragraph" },
  list_item: { block: "list_item" },
  bullet_list: { block: "bullet_list", getAttrs: (_, tokens, i2) => ({ tight: listIsTight(tokens, i2) }) },
  ordered_list: { block: "ordered_list", getAttrs: (tok, tokens, i2) => ({
    order: +tok.attrGet("start") || 1,
    tight: listIsTight(tokens, i2)
  }) },
  heading: { block: "heading", getAttrs: (tok) => ({ level: +tok.tag.slice(1) }) },
  code_block: { block: "code_block", noCloseToken: true },
  fence: { block: "code_block", getAttrs: (tok) => ({ params: tok.info || "" }), noCloseToken: true },
  hr: { node: "horizontal_rule" },
  image: { node: "image", getAttrs: (tok) => ({
    src: tok.attrGet("src"),
    title: tok.attrGet("title") || null,
    alt: tok.children[0] && tok.children[0].content || null
  }) },
  hardbreak: { node: "hard_break" },
  em: { mark: "em" },
  strong: { mark: "strong" },
  link: { mark: "link", getAttrs: (tok) => ({
    href: tok.attrGet("href"),
    title: tok.attrGet("title") || null
  }) },
  code_inline: { mark: "code", noCloseToken: true }
});
var blankMark = { open: "", close: "", mixable: true };
var MarkdownSerializer = class {
  /**
  Construct a serializer with the given configuration. The `nodes`
  object should map node names in a given schema to function that
  take a serializer state and such a node, and serialize the node.
  */
  constructor(nodes, marks, options2 = {}) {
    this.nodes = nodes;
    this.marks = marks;
    this.options = options2;
  }
  /**
  Serialize the content of the given node to
  [CommonMark](http://commonmark.org/).
  */
  serialize(content, options2 = {}) {
    options2 = Object.assign({}, this.options, options2);
    let state = new MarkdownSerializerState(this.nodes, this.marks, options2);
    state.renderContent(content);
    return state.out;
  }
};
var defaultMarkdownSerializer = new MarkdownSerializer({
  blockquote(state, node) {
    state.wrapBlock("> ", null, node, () => state.renderContent(node));
  },
  code_block(state, node) {
    const backticks = node.textContent.match(/`{3,}/gm);
    const fence = backticks ? backticks.sort().slice(-1)[0] + "`" : "```";
    state.write(fence + (node.attrs.params || "") + "\n");
    state.text(node.textContent, false);
    state.write("\n");
    state.write(fence);
    state.closeBlock(node);
  },
  heading(state, node) {
    state.write(state.repeat("#", node.attrs.level) + " ");
    state.renderInline(node, false);
    state.closeBlock(node);
  },
  horizontal_rule(state, node) {
    state.write(node.attrs.markup || "---");
    state.closeBlock(node);
  },
  bullet_list(state, node) {
    state.renderList(node, "  ", () => (node.attrs.bullet || "*") + " ");
  },
  ordered_list(state, node) {
    let start3 = node.attrs.order || 1;
    let maxW = String(start3 + node.childCount - 1).length;
    let space2 = state.repeat(" ", maxW + 2);
    state.renderList(node, space2, (i2) => {
      let nStr = String(start3 + i2);
      return state.repeat(" ", maxW - nStr.length) + nStr + ". ";
    });
  },
  list_item(state, node) {
    state.renderContent(node);
  },
  paragraph(state, node) {
    state.renderInline(node);
    state.closeBlock(node);
  },
  image(state, node) {
    state.write("![" + state.esc(node.attrs.alt || "") + "](" + node.attrs.src.replace(/[\(\)]/g, "\\$&") + (node.attrs.title ? ' "' + node.attrs.title.replace(/"/g, '\\"') + '"' : "") + ")");
  },
  hard_break(state, node, parent, index2) {
    for (let i2 = index2 + 1; i2 < parent.childCount; i2++)
      if (parent.child(i2).type != node.type) {
        state.write("\\\n");
        return;
      }
  },
  text(state, node) {
    state.text(node.text, !state.inAutolink);
  }
}, {
  em: { open: "*", close: "*", mixable: true, expelEnclosingWhitespace: true },
  strong: { open: "**", close: "**", mixable: true, expelEnclosingWhitespace: true },
  link: {
    open(state, mark, parent, index2) {
      state.inAutolink = isPlainURL(mark, parent, index2);
      return state.inAutolink ? "<" : "[";
    },
    close(state, mark, parent, index2) {
      let { inAutolink } = state;
      state.inAutolink = void 0;
      return inAutolink ? ">" : "](" + mark.attrs.href.replace(/[\(\)"]/g, "\\$&") + (mark.attrs.title ? ` "${mark.attrs.title.replace(/"/g, '\\"')}"` : "") + ")";
    },
    mixable: true
  },
  code: {
    open(_state, _mark, parent, index2) {
      return backticksFor(parent.child(index2), -1);
    },
    close(_state, _mark, parent, index2) {
      return backticksFor(parent.child(index2 - 1), 1);
    },
    escape: false
  }
});
function backticksFor(node, side) {
  let ticks = /`+/g, m, len = 0;
  if (node.isText)
    while (m = ticks.exec(node.text))
      len = Math.max(len, m[0].length);
  let result = len > 0 && side > 0 ? " `" : "`";
  for (let i2 = 0; i2 < len; i2++)
    result += "`";
  if (len > 0 && side < 0)
    result += " ";
  return result;
}
function isPlainURL(link, parent, index2) {
  if (link.attrs.title || !/^\w+:/.test(link.attrs.href))
    return false;
  let content = parent.child(index2);
  if (!content.isText || content.text != link.attrs.href || content.marks[content.marks.length - 1] != link)
    return false;
  return index2 == parent.childCount - 1 || !link.isInSet(parent.child(index2 + 1).marks);
}
var MarkdownSerializerState = class {
  /**
  @internal
  */
  constructor(nodes, marks, options2) {
    this.nodes = nodes;
    this.marks = marks;
    this.options = options2;
    this.delim = "";
    this.out = "";
    this.closed = null;
    this.inAutolink = void 0;
    this.atBlockStart = false;
    this.inTightList = false;
    if (typeof this.options.tightLists == "undefined")
      this.options.tightLists = false;
    if (typeof this.options.hardBreakNodeName == "undefined")
      this.options.hardBreakNodeName = "hard_break";
  }
  /**
  @internal
  */
  flushClose(size2 = 2) {
    if (this.closed) {
      if (!this.atBlank())
        this.out += "\n";
      if (size2 > 1) {
        let delimMin = this.delim;
        let trim2 = /\s+$/.exec(delimMin);
        if (trim2)
          delimMin = delimMin.slice(0, delimMin.length - trim2[0].length);
        for (let i2 = 1; i2 < size2; i2++)
          this.out += delimMin + "\n";
      }
      this.closed = null;
    }
  }
  /**
  @internal
  */
  getMark(name) {
    let info = this.marks[name];
    if (!info) {
      if (this.options.strict !== false)
        throw new Error(`Mark type \`${name}\` not supported by Markdown renderer`);
      info = blankMark;
    }
    return info;
  }
  /**
  Render a block, prefixing each line with `delim`, and the first
  line in `firstDelim`. `node` should be the node that is closed at
  the end of the block, and `f` is a function that renders the
  content of the block.
  */
  wrapBlock(delim, firstDelim, node, f) {
    let old = this.delim;
    this.write(firstDelim != null ? firstDelim : delim);
    this.delim += delim;
    f();
    this.delim = old;
    this.closeBlock(node);
  }
  /**
  @internal
  */
  atBlank() {
    return /(^|\n)$/.test(this.out);
  }
  /**
  Ensure the current content ends with a newline.
  */
  ensureNewLine() {
    if (!this.atBlank())
      this.out += "\n";
  }
  /**
  Prepare the state for writing output (closing closed paragraphs,
  adding delimiters, and so on), and then optionally add content
  (unescaped) to the output.
  */
  write(content) {
    this.flushClose();
    if (this.delim && this.atBlank())
      this.out += this.delim;
    if (content)
      this.out += content;
  }
  /**
  Close the block for the given node.
  */
  closeBlock(node) {
    this.closed = node;
  }
  /**
  Add the given text to the document. When escape is not `false`,
  it will be escaped.
  */
  text(text, escape2 = true) {
    let lines = text.split("\n");
    for (let i2 = 0; i2 < lines.length; i2++) {
      this.write();
      if (!escape2 && lines[i2][0] == "[" && /(^|[^\\])\!$/.test(this.out))
        this.out = this.out.slice(0, this.out.length - 1) + "\\!";
      this.out += escape2 ? this.esc(lines[i2], this.atBlockStart) : lines[i2];
      if (i2 != lines.length - 1)
        this.out += "\n";
    }
  }
  /**
  Render the given node as a block.
  */
  render(node, parent, index2) {
    if (this.nodes[node.type.name]) {
      this.nodes[node.type.name](this, node, parent, index2);
    } else {
      if (this.options.strict !== false) {
        throw new Error("Token type `" + node.type.name + "` not supported by Markdown renderer");
      } else if (!node.type.isLeaf) {
        if (node.type.inlineContent)
          this.renderInline(node);
        else
          this.renderContent(node);
        if (node.isBlock)
          this.closeBlock(node);
      }
    }
  }
  /**
  Render the contents of `parent` as block nodes.
  */
  renderContent(parent) {
    parent.forEach((node, _, i2) => this.render(node, parent, i2));
  }
  /**
  Render the contents of `parent` as inline content.
  */
  renderInline(parent, fromBlockStart = true) {
    this.atBlockStart = fromBlockStart;
    let active = [], trailing = "";
    let progress = (node, offset4, index2) => {
      let marks = node ? node.marks : [];
      if (node && node.type.name === this.options.hardBreakNodeName)
        marks = marks.filter((m) => {
          if (index2 + 1 == parent.childCount)
            return false;
          let next = parent.child(index2 + 1);
          return m.isInSet(next.marks) && (!next.isText || /\S/.test(next.text));
        });
      let leading = trailing;
      trailing = "";
      if (node && node.isText && marks.some((mark) => {
        let info = this.getMark(mark.type.name);
        return info && info.expelEnclosingWhitespace && !mark.isInSet(active);
      })) {
        let [_, lead, rest] = /^(\s*)(.*)$/m.exec(node.text);
        if (lead) {
          leading += lead;
          node = rest ? node.withText(rest) : null;
          if (!node)
            marks = active;
        }
      }
      if (node && node.isText && marks.some((mark) => {
        let info = this.getMark(mark.type.name);
        return info && info.expelEnclosingWhitespace && (index2 == parent.childCount - 1 || !mark.isInSet(parent.child(index2 + 1).marks));
      })) {
        let [_, rest, trail] = /^(.*?)(\s*)$/m.exec(node.text);
        if (trail) {
          trailing = trail;
          node = rest ? node.withText(rest) : null;
          if (!node)
            marks = active;
        }
      }
      let inner = marks.length ? marks[marks.length - 1] : null;
      let noEsc = inner && this.getMark(inner.type.name).escape === false;
      let len = marks.length - (noEsc ? 1 : 0);
      outer: for (let i2 = 0; i2 < len; i2++) {
        let mark = marks[i2];
        if (!this.getMark(mark.type.name).mixable)
          break;
        for (let j2 = 0; j2 < active.length; j2++) {
          let other = active[j2];
          if (!this.getMark(other.type.name).mixable)
            break;
          if (mark.eq(other)) {
            if (i2 > j2)
              marks = marks.slice(0, j2).concat(mark).concat(marks.slice(j2, i2)).concat(marks.slice(i2 + 1, len));
            else if (j2 > i2)
              marks = marks.slice(0, i2).concat(marks.slice(i2 + 1, j2)).concat(mark).concat(marks.slice(j2, len));
            continue outer;
          }
        }
      }
      let keep = 0;
      while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep]))
        ++keep;
      while (keep < active.length)
        this.text(this.markString(active.pop(), false, parent, index2), false);
      if (leading)
        this.text(leading);
      if (node) {
        while (active.length < len) {
          let add3 = marks[active.length];
          active.push(add3);
          this.text(this.markString(add3, true, parent, index2), false);
          this.atBlockStart = false;
        }
        if (noEsc && node.isText)
          this.text(this.markString(inner, true, parent, index2) + node.text + this.markString(inner, false, parent, index2 + 1), false);
        else
          this.render(node, parent, index2);
        this.atBlockStart = false;
      }
      if ((node === null || node === void 0 ? void 0 : node.isText) && node.nodeSize > 0) {
        this.atBlockStart = false;
      }
    };
    parent.forEach(progress);
    progress(null, 0, parent.childCount);
    this.atBlockStart = false;
  }
  /**
  Render a node's content as a list. `delim` should be the extra
  indentation added to all lines except the first in an item,
  `firstDelim` is a function going from an item index to a
  delimiter for the first line of the item.
  */
  renderList(node, delim, firstDelim) {
    if (this.closed && this.closed.type == node.type)
      this.flushClose(3);
    else if (this.inTightList)
      this.flushClose(1);
    let isTight = typeof node.attrs.tight != "undefined" ? node.attrs.tight : this.options.tightLists;
    let prevTight = this.inTightList;
    this.inTightList = isTight;
    node.forEach((child, _, i2) => {
      if (i2 && isTight)
        this.flushClose(1);
      this.wrapBlock(delim, firstDelim(i2), node, () => this.render(child, node, i2));
    });
    this.inTightList = prevTight;
  }
  /**
  Escape the given string so that it can safely appear in Markdown
  content. If `startOfLine` is true, also escape characters that
  have special meaning only at the start of the line.
  */
  esc(str, startOfLine = false) {
    str = str.replace(/[`*\\~\[\]_]/g, (m, i2) => m == "_" && i2 > 0 && i2 + 1 < str.length && str[i2 - 1].match(/\w/) && str[i2 + 1].match(/\w/) ? m : "\\" + m);
    if (startOfLine)
      str = str.replace(/^(\+[ ]|[\-*>])/, "\\$&").replace(/^(\s*)(#{1,6})(\s|$)/, "$1\\$2$3").replace(/^(\s*\d+)\.\s/, "$1\\. ");
    if (this.options.escapeExtraCharacters)
      str = str.replace(this.options.escapeExtraCharacters, "\\$&");
    return str;
  }
  /**
  @internal
  */
  quote(str) {
    let wrap2 = str.indexOf('"') == -1 ? '""' : str.indexOf("'") == -1 ? "''" : "()";
    return wrap2[0] + str + wrap2[1];
  }
  /**
  Repeat the given string `n` times.
  */
  repeat(str, n2) {
    let out = "";
    for (let i2 = 0; i2 < n2; i2++)
      out += str;
    return out;
  }
  /**
  Get the markdown string for a given opening or closing mark.
  */
  markString(mark, open, parent, index2) {
    let info = this.getMark(mark.type.name);
    let value = open ? info.open : info.close;
    return typeof value == "string" ? value : value(this, mark, parent, index2);
  }
  /**
  Get leading and trailing whitespace from a string. Values of
  leading or trailing property of the return object will be undefined
  if there is no match.
  */
  getEnclosingWhitespace(text) {
    return {
      leading: (text.match(/^(\s+)/) || [void 0])[0],
      trailing: (text.match(/(\s+)$/) || [void 0])[0]
    };
  }
};

// ../../../node_modules/tiptap-markdown/dist/tiptap-markdown.es.js
var import_markdown_it_task_lists = __toESM(require_markdown_it_task_lists());
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var MarkdownTightLists = Extension.create({
  name: "markdownTightLists",
  addOptions: () => ({
    tight: true,
    tightClass: "tight",
    listTypes: ["bulletList", "orderedList"]
  }),
  addGlobalAttributes() {
    return [{
      types: this.options.listTypes,
      attributes: {
        tight: {
          default: this.options.tight,
          parseHTML: (element) => element.getAttribute("data-tight") === "true" || !element.querySelector("p"),
          renderHTML: (attributes) => ({
            class: attributes.tight ? this.options.tightClass : null,
            "data-tight": attributes.tight ? "true" : null
          })
        }
      }
    }];
  },
  addCommands() {
    var _this = this;
    return {
      toggleTight: function() {
        let tight = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return (_ref) => {
          let {
            editor,
            commands: commands2
          } = _ref;
          function toggleTight(name) {
            if (!editor.isActive(name)) {
              return false;
            }
            const attrs2 = editor.getAttributes(name);
            return commands2.updateAttributes(name, {
              tight: tight !== null && tight !== void 0 ? tight : !(attrs2 !== null && attrs2 !== void 0 && attrs2.tight)
            });
          }
          return _this.options.listTypes.some((name) => toggleTight(name));
        };
      }
    };
  }
});
var md = lib_default();
function scanDelims(text, pos) {
  md.inline.State.prototype.scanDelims.call({
    src: text,
    posMax: text.length
  });
  const state = new md.inline.State(text, null, null, []);
  return state.scanDelims(pos, true);
}
function shiftDelim(text, delim, start3, offset4) {
  let res = text.substring(0, start3) + text.substring(start3 + delim.length);
  res = res.substring(0, start3 + offset4) + delim + res.substring(start3 + offset4);
  return res;
}
function trimStart(text, delim, from2, to) {
  let pos = from2, res = text;
  while (pos < to) {
    if (scanDelims(res, pos).can_open) {
      break;
    }
    res = shiftDelim(res, delim, pos, 1);
    pos++;
  }
  return {
    text: res,
    from: pos,
    to
  };
}
function trimEnd(text, delim, from2, to) {
  let pos = to, res = text;
  while (pos > from2) {
    if (scanDelims(res, pos).can_close) {
      break;
    }
    res = shiftDelim(res, delim, pos, -1);
    pos--;
  }
  return {
    text: res,
    from: from2,
    to: pos
  };
}
function trimInline(text, delim, from2, to) {
  let state = {
    text,
    from: from2,
    to
  };
  state = trimStart(state.text, delim, state.from, state.to);
  state = trimEnd(state.text, delim, state.from, state.to);
  if (state.to - state.from < delim.length + 1) {
    state.text = state.text.substring(0, state.from) + state.text.substring(state.to + delim.length);
  }
  return state.text;
}
var MarkdownSerializerState2 = class extends MarkdownSerializerState {
  constructor(nodes, marks, options2) {
    super(nodes, marks, options2 !== null && options2 !== void 0 ? options2 : {});
    __publicField2(this, "inTable", false);
    this.inlines = [];
  }
  render(node, parent, index2) {
    super.render(node, parent, index2);
    const top2 = this.inlines[this.inlines.length - 1];
    if (top2 !== null && top2 !== void 0 && top2.start && top2 !== null && top2 !== void 0 && top2.end) {
      const {
        delimiter,
        start: start3,
        end: end3
      } = this.normalizeInline(top2);
      this.out = trimInline(this.out, delimiter, start3, end3);
      this.inlines.pop();
    }
  }
  markString(mark, open, parent, index2) {
    const info = this.marks[mark.type.name];
    if (info.expelEnclosingWhitespace) {
      if (open) {
        this.inlines.push({
          start: this.out.length,
          delimiter: info.open
        });
      } else {
        const top2 = this.inlines.pop();
        this.inlines.push({
          ...top2,
          end: this.out.length
        });
      }
    }
    return super.markString(mark, open, parent, index2);
  }
  normalizeInline(inline) {
    let {
      start: start3,
      end: end3
    } = inline;
    while (this.out.charAt(start3).match(/\s/)) {
      start3++;
    }
    return {
      ...inline,
      start: start3
    };
  }
};
var HTMLMark = Mark2.create({
  name: "markdownHTMLMark",
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: {
          open(state, mark) {
            var _getMarkTags$, _getMarkTags;
            if (!this.editor.storage.markdown.options.html) {
              console.warn(`Tiptap Markdown: "${mark.type.name}" mark is only available in html mode`);
              return "";
            }
            return (_getMarkTags$ = (_getMarkTags = getMarkTags(mark)) === null || _getMarkTags === void 0 ? void 0 : _getMarkTags[0]) !== null && _getMarkTags$ !== void 0 ? _getMarkTags$ : "";
          },
          close(state, mark) {
            var _getMarkTags$2, _getMarkTags2;
            if (!this.editor.storage.markdown.options.html) {
              return "";
            }
            return (_getMarkTags$2 = (_getMarkTags2 = getMarkTags(mark)) === null || _getMarkTags2 === void 0 ? void 0 : _getMarkTags2[1]) !== null && _getMarkTags$2 !== void 0 ? _getMarkTags$2 : "";
          }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function getMarkTags(mark) {
  const schema2 = mark.type.schema;
  const node = schema2.text(" ", [mark]);
  const html = getHTMLFromFragment(Fragment3.from(node), schema2);
  const match85 = html.match(/^(<.*?>) (<\/.*?>)$/);
  return match85 ? [match85[1], match85[2]] : null;
}
function elementFromString2(value) {
  const wrappedValue = `<body>${value}</body>`;
  return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
}
function escapeHTML(value) {
  return value === null || value === void 0 ? void 0 : value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function extractElement(node) {
  const parent = node.parentElement;
  const prepend2 = parent.cloneNode();
  while (parent.firstChild && parent.firstChild !== node) {
    prepend2.appendChild(parent.firstChild);
  }
  if (prepend2.childNodes.length > 0) {
    parent.parentElement.insertBefore(prepend2, parent);
  }
  parent.parentElement.insertBefore(node, parent);
  if (parent.childNodes.length === 0) {
    parent.remove();
  }
}
function unwrapElement(node) {
  const parent = node.parentNode;
  while (node.firstChild)
    parent.insertBefore(node.firstChild, node);
  parent.removeChild(node);
}
var HTMLNode = Node3.create({
  name: "markdownHTMLNode",
  addStorage() {
    return {
      markdown: {
        serialize(state, node, parent) {
          if (this.editor.storage.markdown.options.html) {
            state.write(serializeHTML(node, parent));
          } else {
            console.warn(`Tiptap Markdown: "${node.type.name}" node is only available in html mode`);
            state.write(`[${node.type.name}]`);
          }
          if (node.isBlock) {
            state.closeBlock(node);
          }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function serializeHTML(node, parent) {
  const schema2 = node.type.schema;
  const html = getHTMLFromFragment(Fragment3.from(node), schema2);
  if (node.isBlock && (parent instanceof Fragment3 || parent.type.name === schema2.topNodeType.name)) {
    return formatBlock(html);
  }
  return html;
}
function formatBlock(html) {
  const dom = elementFromString2(html);
  const element = dom.firstElementChild;
  element.innerHTML = element.innerHTML.trim() ? `
${element.innerHTML}
` : `
`;
  return element.outerHTML;
}
var Blockquote = Node3.create({
  name: "blockquote"
});
var Blockquote$1 = Blockquote.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.blockquote,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var BulletList = Node3.create({
  name: "bulletList"
});
var BulletList$1 = BulletList.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node) {
          return state.renderList(node, "  ", () => (this.editor.storage.markdown.options.bulletListMarker || "-") + " ");
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var CodeBlock = Node3.create({
  name: "codeBlock"
});
var CodeBlock$1 = CodeBlock.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node) {
          state.write("```" + (node.attrs.language || "") + "\n");
          state.text(node.textContent, false);
          state.ensureNewLine();
          state.write("```");
          state.closeBlock(node);
        },
        parse: {
          setup(markdownit2) {
            var _this$options$languag;
            markdownit2.set({
              langPrefix: (_this$options$languag = this.options.languageClassPrefix) !== null && _this$options$languag !== void 0 ? _this$options$languag : "language-"
            });
          },
          updateDOM(element) {
            element.innerHTML = element.innerHTML.replace(/\n<\/code><\/pre>/g, "</code></pre>");
          }
        }
      }
    };
  }
});
var HardBreak = Node3.create({
  name: "hardBreak"
});
var HardBreak$1 = HardBreak.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node, parent, index2) {
          for (let i2 = index2 + 1; i2 < parent.childCount; i2++)
            if (parent.child(i2).type != node.type) {
              state.write(state.inTable ? HTMLNode.storage.markdown.serialize.call(this, state, node, parent) : "\\\n");
              return;
            }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var Heading = Node3.create({
  name: "heading"
});
var Heading$1 = Heading.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.heading,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var HorizontalRule = Node3.create({
  name: "horizontalRule"
});
var HorizontalRule$1 = HorizontalRule.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.horizontal_rule,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var Image2 = Node3.create({
  name: "image"
});
var Image$1 = Image2.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.image,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var ListItem = Node3.create({
  name: "listItem"
});
var ListItem$1 = ListItem.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.list_item,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var OrderedList = Node3.create({
  name: "orderedList"
});
function findIndexOfAdjacentNode(node, parent, index2) {
  let i2 = 0;
  for (; index2 - i2 > 0; i2++) {
    if (parent.child(index2 - i2 - 1).type.name !== node.type.name) {
      break;
    }
  }
  return i2;
}
var OrderedList$1 = OrderedList.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node, parent, index2) {
          const start3 = node.attrs.start || 1;
          const maxW = String(start3 + node.childCount - 1).length;
          const space2 = state.repeat(" ", maxW + 2);
          const adjacentIndex = findIndexOfAdjacentNode(node, parent, index2);
          const separator = adjacentIndex % 2 ? ") " : ". ";
          state.renderList(node, space2, (i2) => {
            const nStr = String(start3 + i2);
            return state.repeat(" ", maxW - nStr.length) + nStr + separator;
          });
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var Paragraph = Node3.create({
  name: "paragraph"
});
var Paragraph$1 = Paragraph.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.nodes.paragraph,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function childNodes(node) {
  var _node$content$content, _node$content;
  return (_node$content$content = node === null || node === void 0 || (_node$content = node.content) === null || _node$content === void 0 ? void 0 : _node$content.content) !== null && _node$content$content !== void 0 ? _node$content$content : [];
}
var Table = Node3.create({
  name: "table"
});
var Table$1 = Table.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node, parent) {
          if (!isMarkdownSerializable(node)) {
            HTMLNode.storage.markdown.serialize.call(this, state, node, parent);
            return;
          }
          state.inTable = true;
          node.forEach((row, p3, i2) => {
            state.write("| ");
            row.forEach((col, p22, j2) => {
              if (j2) {
                state.write(" | ");
              }
              const cellContent = col.firstChild;
              if (cellContent.textContent.trim()) {
                state.renderInline(cellContent);
              }
            });
            state.write(" |");
            state.ensureNewLine();
            if (!i2) {
              const delimiterRow = Array.from({
                length: row.childCount
              }).map(() => "---").join(" | ");
              state.write(`| ${delimiterRow} |`);
              state.ensureNewLine();
            }
          });
          state.closeBlock(node);
          state.inTable = false;
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function hasSpan(node) {
  return node.attrs.colspan > 1 || node.attrs.rowspan > 1;
}
function isMarkdownSerializable(node) {
  const rows = childNodes(node);
  const firstRow = rows[0];
  const bodyRows = rows.slice(1);
  if (childNodes(firstRow).some((cell) => cell.type.name !== "tableHeader" || hasSpan(cell) || cell.childCount > 1)) {
    return false;
  }
  if (bodyRows.some((row) => childNodes(row).some((cell) => cell.type.name === "tableHeader" || hasSpan(cell) || cell.childCount > 1))) {
    return false;
  }
  return true;
}
var TaskItem = Node3.create({
  name: "taskItem"
});
var TaskItem$1 = TaskItem.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node) {
          const check = node.attrs.checked ? "[x]" : "[ ]";
          state.write(`${check} `);
          state.renderContent(node);
        },
        parse: {
          updateDOM(element) {
            [...element.querySelectorAll(".task-list-item")].forEach((item) => {
              const input = item.querySelector("input");
              item.setAttribute("data-type", "taskItem");
              if (input) {
                item.setAttribute("data-checked", input.checked);
                input.remove();
              }
            });
          }
        }
      }
    };
  }
});
var TaskList = Node3.create({
  name: "taskList"
});
var TaskList$1 = TaskList.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: BulletList$1.storage.markdown.serialize,
        parse: {
          setup(markdownit2) {
            markdownit2.use(import_markdown_it_task_lists.default);
          },
          updateDOM(element) {
            [...element.querySelectorAll(".contains-task-list")].forEach((list) => {
              list.setAttribute("data-type", "taskList");
            });
          }
        }
      }
    };
  }
});
var Text = Node3.create({
  name: "text"
});
var Text$1 = Text.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize(state, node) {
          state.text(escapeHTML(node.text));
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var Bold = Mark2.create({
  name: "bold"
});
var Bold$1 = Bold.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.marks.strong,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var Code = Mark2.create({
  name: "code"
});
var Code$1 = Code.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.marks.code,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var Italic = Mark2.create({
  name: "italic"
});
var Italic$1 = Italic.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.marks.em,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var Link2 = Mark2.create({
  name: "link"
});
var Link$1 = Link2.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: defaultMarkdownSerializer.marks.link,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var Strike = Mark2.create({
  name: "strike"
});
var Strike$1 = Strike.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage() {
    return {
      markdown: {
        serialize: {
          open: "~~",
          close: "~~",
          expelEnclosingWhitespace: true
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
var markdownExtensions = [Blockquote$1, BulletList$1, CodeBlock$1, HardBreak$1, Heading$1, HorizontalRule$1, HTMLNode, Image$1, ListItem$1, OrderedList$1, Paragraph$1, Table$1, TaskItem$1, TaskList$1, Text$1, Bold$1, Code$1, HTMLMark, Italic$1, Link$1, Strike$1];
function getMarkdownSpec(extension) {
  var _extension$storage, _markdownExtensions$f;
  const markdownSpec = (_extension$storage = extension.storage) === null || _extension$storage === void 0 ? void 0 : _extension$storage.markdown;
  const defaultMarkdownSpec = (_markdownExtensions$f = markdownExtensions.find((e2) => e2.name === extension.name)) === null || _markdownExtensions$f === void 0 ? void 0 : _markdownExtensions$f.storage.markdown;
  if (markdownSpec || defaultMarkdownSpec) {
    return {
      ...defaultMarkdownSpec,
      ...markdownSpec
    };
  }
  return null;
}
var MarkdownSerializer2 = class {
  constructor(editor) {
    __publicField2(this, "editor", null);
    this.editor = editor;
  }
  serialize(content) {
    const state = new MarkdownSerializerState2(this.nodes, this.marks, {
      hardBreakNodeName: HardBreak$1.name
    });
    state.renderContent(content);
    return state.out;
  }
  get nodes() {
    var _this$editor$extensio;
    return {
      ...Object.fromEntries(Object.keys(this.editor.schema.nodes).map((name) => [name, this.serializeNode(HTMLNode)])),
      ...Object.fromEntries((_this$editor$extensio = this.editor.extensionManager.extensions.filter((extension) => extension.type === "node" && this.serializeNode(extension)).map((extension) => [extension.name, this.serializeNode(extension)])) !== null && _this$editor$extensio !== void 0 ? _this$editor$extensio : [])
    };
  }
  get marks() {
    var _this$editor$extensio2;
    return {
      ...Object.fromEntries(Object.keys(this.editor.schema.marks).map((name) => [name, this.serializeMark(HTMLMark)])),
      ...Object.fromEntries((_this$editor$extensio2 = this.editor.extensionManager.extensions.filter((extension) => extension.type === "mark" && this.serializeMark(extension)).map((extension) => [extension.name, this.serializeMark(extension)])) !== null && _this$editor$extensio2 !== void 0 ? _this$editor$extensio2 : [])
    };
  }
  serializeNode(node) {
    var _getMarkdownSpec;
    return (_getMarkdownSpec = getMarkdownSpec(node)) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.serialize) === null || _getMarkdownSpec === void 0 ? void 0 : _getMarkdownSpec.bind({
      editor: this.editor,
      options: node.options
    });
  }
  serializeMark(mark) {
    var _getMarkdownSpec2;
    const serialize = (_getMarkdownSpec2 = getMarkdownSpec(mark)) === null || _getMarkdownSpec2 === void 0 ? void 0 : _getMarkdownSpec2.serialize;
    return serialize ? {
      ...serialize,
      open: typeof serialize.open === "function" ? serialize.open.bind({
        editor: this.editor,
        options: mark.options
      }) : serialize.open,
      close: typeof serialize.close === "function" ? serialize.close.bind({
        editor: this.editor,
        options: mark.options
      }) : serialize.close
    } : null;
  }
};
var MarkdownParser2 = class {
  constructor(editor, _ref) {
    __publicField2(this, "editor", null);
    __publicField2(this, "md", null);
    let {
      html,
      linkify,
      breaks
    } = _ref;
    this.editor = editor;
    this.md = this.withPatchedRenderer(lib_default({
      html,
      linkify,
      breaks
    }));
  }
  parse(content) {
    let {
      inline
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof content === "string") {
      this.editor.extensionManager.extensions.forEach((extension) => {
        var _getMarkdownSpec;
        return (_getMarkdownSpec = getMarkdownSpec(extension)) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.parse) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.setup) === null || _getMarkdownSpec === void 0 ? void 0 : _getMarkdownSpec.call({
          editor: this.editor,
          options: extension.options
        }, this.md);
      });
      const renderedHTML = this.md.render(content);
      const element = elementFromString2(renderedHTML);
      this.editor.extensionManager.extensions.forEach((extension) => {
        var _getMarkdownSpec2;
        return (_getMarkdownSpec2 = getMarkdownSpec(extension)) === null || _getMarkdownSpec2 === void 0 || (_getMarkdownSpec2 = _getMarkdownSpec2.parse) === null || _getMarkdownSpec2 === void 0 || (_getMarkdownSpec2 = _getMarkdownSpec2.updateDOM) === null || _getMarkdownSpec2 === void 0 ? void 0 : _getMarkdownSpec2.call({
          editor: this.editor,
          options: extension.options
        }, element);
      });
      this.normalizeDOM(element, {
        inline,
        content
      });
      return element.innerHTML;
    }
    return content;
  }
  normalizeDOM(node, _ref2) {
    let {
      inline,
      content
    } = _ref2;
    this.normalizeBlocks(node);
    node.querySelectorAll("*").forEach((el2) => {
      var _el$nextSibling;
      if (((_el$nextSibling = el2.nextSibling) === null || _el$nextSibling === void 0 ? void 0 : _el$nextSibling.nodeType) === Node.TEXT_NODE && !el2.closest("pre")) {
        el2.nextSibling.textContent = el2.nextSibling.textContent.replace(/^\n/, "");
      }
    });
    if (inline) {
      this.normalizeInline(node, content);
    }
    return node;
  }
  normalizeBlocks(node) {
    const blocks = Object.values(this.editor.schema.nodes).filter((node2) => node2.isBlock);
    const selector = blocks.map((block) => {
      var _block$spec$parseDOM;
      return (_block$spec$parseDOM = block.spec.parseDOM) === null || _block$spec$parseDOM === void 0 ? void 0 : _block$spec$parseDOM.map((spec) => spec.tag);
    }).flat().filter(Boolean).join(",");
    if (!selector) {
      return;
    }
    [...node.querySelectorAll(selector)].forEach((el2) => {
      if (el2.parentElement.matches("p")) {
        extractElement(el2);
      }
    });
  }
  normalizeInline(node, content) {
    var _node$firstElementChi;
    if ((_node$firstElementChi = node.firstElementChild) !== null && _node$firstElementChi !== void 0 && _node$firstElementChi.matches("p")) {
      var _content$match$, _content$match, _content$match$2, _content$match2;
      const firstParagraph = node.firstElementChild;
      const {
        nextElementSibling
      } = firstParagraph;
      const startSpaces = (_content$match$ = (_content$match = content.match(/^\s+/)) === null || _content$match === void 0 ? void 0 : _content$match[0]) !== null && _content$match$ !== void 0 ? _content$match$ : "";
      const endSpaces = !nextElementSibling ? (_content$match$2 = (_content$match2 = content.match(/\s+$/)) === null || _content$match2 === void 0 ? void 0 : _content$match2[0]) !== null && _content$match$2 !== void 0 ? _content$match$2 : "" : "";
      if (content.match(/^\n\n/)) {
        firstParagraph.innerHTML = `${firstParagraph.innerHTML}${endSpaces}`;
        return;
      }
      unwrapElement(firstParagraph);
      node.innerHTML = `${startSpaces}${node.innerHTML}${endSpaces}`;
    }
  }
  /**
   * @param {markdownit} md
   */
  withPatchedRenderer(md2) {
    const withoutNewLine = (renderer) => function() {
      const rendered = renderer(...arguments);
      if (rendered === "\n") {
        return rendered;
      }
      if (rendered[rendered.length - 1] === "\n") {
        return rendered.slice(0, -1);
      }
      return rendered;
    };
    md2.renderer.rules.hardbreak = withoutNewLine(md2.renderer.rules.hardbreak);
    md2.renderer.rules.softbreak = withoutNewLine(md2.renderer.rules.softbreak);
    md2.renderer.rules.fence = withoutNewLine(md2.renderer.rules.fence);
    md2.renderer.rules.code_block = withoutNewLine(md2.renderer.rules.code_block);
    md2.renderer.renderToken = withoutNewLine(md2.renderer.renderToken.bind(md2.renderer));
    return md2;
  }
};
var MarkdownClipboard = Extension.create({
  name: "markdownClipboard",
  addOptions() {
    return {
      transformPastedText: false,
      transformCopiedText: false
    };
  },
  addProseMirrorPlugins() {
    return [new Plugin({
      key: new PluginKey("markdownClipboard"),
      props: {
        clipboardTextParser: (text, context, plainText) => {
          if (plainText || !this.options.transformPastedText) {
            return null;
          }
          const parsed = this.editor.storage.markdown.parser.parse(text, {
            inline: true
          });
          return DOMParser.fromSchema(this.editor.schema).parseSlice(elementFromString2(parsed), {
            preserveWhitespace: true,
            context
          });
        },
        /**
         * @param {import('prosemirror-model').Slice} slice
         */
        clipboardTextSerializer: (slice2) => {
          if (!this.options.transformCopiedText) {
            return null;
          }
          return this.editor.storage.markdown.serializer.serialize(slice2.content);
        }
      }
    })];
  }
});
var Markdown2 = Extension.create({
  name: "markdown",
  priority: 50,
  addOptions() {
    return {
      html: true,
      tightLists: true,
      tightListClass: "tight",
      bulletListMarker: "-",
      linkify: false,
      breaks: false,
      transformPastedText: false,
      transformCopiedText: false
    };
  },
  addCommands() {
    const commands2 = index.Commands.config.addCommands();
    return {
      setContent: (content, emitUpdate, parseOptions) => (props) => {
        return commands2.setContent(props.editor.storage.markdown.parser.parse(content), emitUpdate, parseOptions)(props);
      },
      insertContentAt: (range, content, options2) => (props) => {
        return commands2.insertContentAt(range, props.editor.storage.markdown.parser.parse(content, {
          inline: true
        }), options2)(props);
      }
    };
  },
  onBeforeCreate() {
    this.editor.storage.markdown = {
      options: {
        ...this.options
      },
      parser: new MarkdownParser2(this.editor, this.options),
      serializer: new MarkdownSerializer2(this.editor),
      getMarkdown: () => {
        return this.editor.storage.markdown.serializer.serialize(this.editor.state.doc);
      }
    };
    this.editor.options.initialContent = this.editor.options.content;
    this.editor.options.content = this.editor.storage.markdown.parser.parse(this.editor.options.content);
  },
  onCreate() {
    this.editor.options.content = this.editor.options.initialContent;
    delete this.editor.options.initialContent;
  },
  addStorage() {
    return {
      /// storage will be defined in onBeforeCreate() to prevent initial object overriding
    };
  },
  addExtensions() {
    return [MarkdownTightLists.configure({
      tight: this.options.tightLists,
      tightClass: this.options.tightListClass
    }), MarkdownClipboard.configure({
      transformPastedText: this.options.transformPastedText,
      transformCopiedText: this.options.transformCopiedText
    })];
  }
});

// ../../../node_modules/@tiptap/extension-underline/dist/index.js
var Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style3) => style3.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleUnderline: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});

// ../../../node_modules/@tiptap/extension-heading/dist/index.js
var Heading2 = Node3.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items2, level) => ({
      ...items2,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});

// ../../../node_modules/@tiptap/extension-text-style/dist/index.js
var mergeNestedSpanStyles = (element) => {
  if (!element.children.length) {
    return;
  }
  const childSpans = element.querySelectorAll("span");
  if (!childSpans) {
    return;
  }
  childSpans.forEach((childSpan) => {
    var _a, _b;
    const childStyle = childSpan.getAttribute("style");
    const closestParentSpanStyleOfChild = (_b = (_a = childSpan.parentElement) === null || _a === void 0 ? void 0 : _a.closest("span")) === null || _b === void 0 ? void 0 : _b.getAttribute("style");
    childSpan.setAttribute("style", `${closestParentSpanStyleOfChild};${childStyle}`);
  });
};
var TextStyle = Mark2.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: false
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element) => {
          const hasStyles = element.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          if (this.options.mergeNestedSpanStyles) {
            mergeNestedSpanStyles(element);
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ tr: tr3 }) => {
        const { selection } = tr3;
        tr3.doc.nodesBetween(selection.from, selection.to, (node, pos) => {
          if (node.isTextblock) {
            return true;
          }
          if (!node.marks.filter((mark) => mark.type === this.type).some((mark) => Object.values(mark.attrs).some((value) => !!value))) {
            tr3.removeMark(pos, pos + node.nodeSize, this.type);
          }
        });
        return true;
      }
    };
  }
});

// ../../../node_modules/@tiptap/extension-color/dist/index.js
var Color = Extension.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (element) => {
              var _a;
              return (_a = element.style.color) === null || _a === void 0 ? void 0 : _a.replace(/['"]+/g, "");
            },
            renderHTML: (attributes) => {
              if (!attributes.color) {
                return {};
              }
              return {
                style: `color: ${attributes.color}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (color) => ({ chain }) => {
        return chain().setMark("textStyle", { color }).run();
      },
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});

// ../../../node_modules/@tiptap/extension-highlight/dist/index.js
var inputRegex = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
var pasteRegex = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
var Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold2 = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic2 = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var pasteRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var Strike2 = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style3) => style3.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});

// ../../../node_modules/@firecms/editor/dist/index.es.js
var import_react_compiler_runtime2 = __toESM(require_dist());

// ../../../node_modules/@tiptap/extension-blockquote/dist/index.js
var inputRegex3 = /^\s*>\s$/;
var Blockquote2 = Node3.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex3,
        type: this.type
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-bullet-list/dist/index.js
var ListItemName = "listItem";
var TextStyleName = "textStyle";
var inputRegex4 = /^\s*([-+*])\s$/;
var BulletList2 = Node3.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex4,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex4,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// ../../../node_modules/@tiptap/extension-code/dist/index.js
var inputRegex5 = /(^|[^`])`([^`]+)`(?!`)/;
var pasteRegex3 = /(^|[^`])`([^`]+)`(?!`)/g;
var Code2 = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex5,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex3,
        type: this.type
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-code-block/dist/index.js
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock2 = Node3.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty3, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty3 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty3 } = selection;
        if (!empty3 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr3 }) => {
          tr3.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc3 } = state;
        const { $from, empty: empty3 } = selection;
        if (!empty3 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc3.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr: tr3 }) => {
            tr3.setSelection(Selection.near(doc3.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match85) => ({
          language: match85[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match85) => ({
          language: match85[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr: tr3, schema: schema2 } = view.state;
            const textNode = schema2.text(text.replace(/\r\n?/g, "\n"));
            tr3.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr3.selection.$from.parent.type !== this.type) {
              tr3.setSelection(TextSelection.near(tr3.doc.resolve(Math.max(0, tr3.selection.from - 2))));
            }
            tr3.setMeta("paste", true);
            view.dispatch(tr3);
            return true;
          }
        }
      })
    ];
  }
});

// ../../../node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options2 = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options2);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options2) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options2.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options2.color === false ? void 0 : options2.color || "black";
    this.class = options2.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e2) => {
        this[name](e2);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - halfWidth, bottom: top2 + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout2) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout2);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// ../../../node_modules/@tiptap/extension-dropcursor/dist/index.js
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});

// ../../../node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json2) {
    if (typeof json2.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc3.resolve(json2.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && _GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (_GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (_GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.index(d), parent = $pos.node(d);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow2("horiz", -1),
  "ArrowRight": arrow2("horiz", 1),
  "ArrowUp": arrow2("vert", -1),
  "ArrowDown": arrow2("vert", 1)
});
function arrow2(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment3.empty;
  for (let i2 = insert.length - 1; i2 >= 0; i2--)
    frag = Fragment3.from(insert[i2].createAndFill(null, frag));
  let tr3 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr3.setSelection(TextSelection.near(tr3.doc.resolve($from.pos + 1)));
  view.dispatch(tr3);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// ../../../node_modules/@tiptap/extension-gapcursor/dist/index.js
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
    };
  }
});

// ../../../node_modules/@tiptap/extension-hard-break/dist/index.js
var HardBreak2 = Node3.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr: tr3, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr3.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});

// ../../../node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get2(i2) {
  if (i2 < 0 || i2 >= this.length) {
    return void 0;
  }
  return this.getInner(i2);
};
RopeSequence.prototype.forEach = function forEach3(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map2(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i2) {
    return result.push(f(elt, i2));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i2) {
    return this.values[i2];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start3) {
    for (var i2 = from2; i2 < to; i2++) {
      if (f(this.values[i2], start3 + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start3) {
    for (var i2 = from2 - 1; i2 >= to; i2--) {
      if (f(this.values[i2], start3 + i2) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i2) {
    return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start3) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start3) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start3 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start3) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start3 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start3) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// ../../../node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch = class _Branch {
  constructor(items2, eventCount) {
    this.items = items2;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end3 = this.items.length;
    for (; ; end3--) {
      let next = this.items.get(end3 - 1);
      if (next.selection) {
        --end3;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end3, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i2) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end3, i2 + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map4;
        if (step && transform.maybeStep(step).doc) {
          map4 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map4, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map4)
          remap.appendMap(map4, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end3).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i2 = 0; i2 < transform.steps.length; i2++) {
      let step = transform.steps[i2].invert(transform.docs[i2]);
      let item = new Item(transform.mapping.maps[i2], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i2)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i2) => {
      let mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array2) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array2.map((map4) => new Item(map4))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start3 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start3);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map4 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map4, step, selection));
      } else {
        rebasedItems.push(new Item(map4));
      }
    }, start3);
    let newMaps = [];
    for (let i2 = rebasedCount; i2 < newUntil; i2++)
      newMaps.push(new Item(mapping.maps[i2]));
    let items2 = this.items.slice(0, start3).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items2, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items2 = [], events = 0;
    this.items.forEach((item, i2) => {
      if (i2 >= upto) {
        items2.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map4 = step && step.getMap();
        mapFrom--;
        if (map4)
          remap.appendMap(map4, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map4.invert(), step, selection), merged, last = items2.length - 1;
          if (merged = items2.length && items2[last].merge(newItem))
            items2[last] = merged;
          else
            items2.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items2.reverse()), events);
  }
};
Branch.empty = new Branch(dist_default2.empty, 0);
function cutOffEvents(items2, n2) {
  let cutPoint;
  items2.forEach((item, i2) => {
    if (item.selection && n2-- == 0) {
      cutPoint = i2;
      return false;
    }
  });
  return items2.slice(cutPoint);
}
var Item = class _Item {
  constructor(map4, step, selection, mirrorOffset) {
    this.map = map4;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr3, options2) {
  let historyTr = tr3.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr3.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr3.getMeta("appendedTransaction");
  if (tr3.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr3, void 0, options2, mustPreserveItems(state)), history2.undone, rangesFor(tr3.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr3, void 0, options2, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr3.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr3.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr3.time || 0) - options2.newGroupDelay || !isAdjacentTo(tr3, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr3.mapping) : rangesFor(tr3.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr3, newGroup ? state.selection.getBookmark() : void 0, options2, mustPreserveItems(state)), Branch.empty, prevRanges, tr3.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr3.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr3, rebased), history2.undone.rebased(tr3, rebased), mapRanges(history2.prevRanges, tr3.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr3.mapping.maps), history2.undone.addMaps(tr3.mapping.maps), mapRanges(history2.prevRanges, tr3.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start3, end3) => {
    for (let i2 = 0; i2 < prevRanges.length; i2 += 2)
      if (start3 <= prevRanges[i2 + 1] && end3 >= prevRanges[i2])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i2 = maps.length - 1; i2 >= 0 && result.length == 0; i2--)
    maps[i2].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i2 = 0; i2 < ranges.length; i2 += 2) {
    let from2 = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i2 = 0; i2 < plugins.length; i2++)
      if (plugins[i2].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr3, hist, state) {
        return applyTransaction(hist, state, tr3, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e2) {
          let inputType = e2.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e2.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll2) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr3 = histTransaction(hist, state, redo2);
      if (tr3)
        dispatch(scroll2 ? tr3.scrollIntoView() : tr3);
    }
    return true;
  };
}
var undo = buildCommand(false, true);
var redo = buildCommand(true, true);
var undoNoScroll = buildCommand(false, false);
var redoNoScroll = buildCommand(true, false);

// ../../../node_modules/@tiptap/extension-history/dist/index.js
var History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
});

// ../../../node_modules/@tiptap/extension-horizontal-rule/dist/index.js
var HorizontalRule2 = Node3.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain, state }) => {
        const { selection } = state;
        const { $from: $originFrom, $to: $originTo } = selection;
        const currentChain = chain();
        if ($originFrom.parentOffset === 0) {
          currentChain.insertContentAt({
            from: Math.max($originFrom.pos - 1, 0),
            to: $originTo.pos
          }, {
            type: this.name
          });
        } else if (isNodeSelection(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr: tr3, dispatch }) => {
          var _a;
          if (dispatch) {
            const { $to } = tr3.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr3.setSelection(TextSelection.create(tr3.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr3.setSelection(NodeSelection.create(tr3.doc, $to.pos));
              } else {
                tr3.setSelection(TextSelection.create(tr3.doc, $to.pos));
              }
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
              if (node) {
                tr3.insert(posAfter, node);
                tr3.setSelection(TextSelection.create(tr3.doc, posAfter + 1));
              }
            }
            tr3.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-list-item/dist/index.js
var ListItem2 = Node3.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});

// ../../../node_modules/@tiptap/extension-ordered-list/dist/index.js
var ListItemName2 = "listItem";
var TextStyleName2 = "textStyle";
var inputRegex6 = /^(\d+)\.\s$/;
var OrderedList2 = Node3.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: void 0,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start3, ...attributesWithoutStart } = HTMLAttributes;
    return start3 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex6,
      type: this.type,
      getAttributes: (match85) => ({ start: +match85[1] }),
      joinPredicate: (match85, node) => node.childCount + node.attrs.start === +match85[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex6,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match85) => ({ start: +match85[1], ...this.editor.getAttributes(TextStyleName2) }),
        joinPredicate: (match85, node) => node.childCount + node.attrs.start === +match85[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// ../../../node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph2 = Node3.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// ../../../node_modules/@tiptap/extension-text/dist/index.js
var Text2 = Node3.create({
  name: "text",
  group: "inline"
});

// ../../../node_modules/@tiptap/starter-kit/dist/index.js
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const extensions = [];
    if (this.options.bold !== false) {
      extensions.push(Bold2.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.bold));
    }
    if (this.options.blockquote !== false) {
      extensions.push(Blockquote2.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.blockquote));
    }
    if (this.options.bulletList !== false) {
      extensions.push(BulletList2.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(Code2.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(CodeBlock2.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(HardBreak2.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(Heading2.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
    }
    if (this.options.history !== false) {
      extensions.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(HorizontalRule2.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(Italic2.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem2.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList2.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(Paragraph2.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(Strike2.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
    }
    if (this.options.text !== false) {
      extensions.push(Text2.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
    }
    return extensions;
  }
});

// ../../../node_modules/linkifyjs/dist/linkify.mjs
var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
var assign = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t2, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k2 in flags) {
    const group = registerGroup(k2, groups);
    if (group.indexOf(t2) < 0) {
      group.push(t2);
    }
  }
}
function flagsForToken(t2, groups) {
  const result = {};
  for (const c5 in groups) {
    if (groups[c5].indexOf(t2) >= 0) {
      result[c5] = true;
    }
  }
  return result;
}
function State(token = null) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i2 = 0; i2 < state.jr.length; i2++) {
      const regex = state.jr[i2][0];
      const nextState2 = state.jr[i2][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly = false) {
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i2 = 0; i2 < inputs.length; i2++) {
      this.tt(inputs[i2], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp2, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp2, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i2 = 0; i2 < len - 1; i2++) {
      state = state.tt(input[i2]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t2 = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t2) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t2, allFlags, groups);
        } else if (flags) {
          addToGroups(t2, flags, groups);
        }
      }
      nextState.t = t2;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta2 = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
var tr2 = (state, regexp2, next, flags, groups) => state.tr(regexp2, next, flags, groups);
var ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
var tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
var WORD = "WORD";
var UWORD = "UWORD";
var ASCIINUMERICAL = "ASCIINUMERICAL";
var ALPHANUMERICAL = "ALPHANUMERICAL";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL = "NL";
var OPENBRACE = "OPENBRACE";
var CLOSEBRACE = "CLOSEBRACE";
var OPENBRACKET = "OPENBRACKET";
var CLOSEBRACKET = "CLOSEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEPAREN = "CLOSEPAREN";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = Object.freeze({
  __proto__: null,
  ALPHANUMERICAL,
  AMPERSAND,
  APOSTROPHE,
  ASCIINUMERICAL,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  CLOSEANGLEBRACKET,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEPAREN,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EMOJI: EMOJI$1,
  EQUALS,
  EXCLAMATION,
  FULLWIDTHGREATERTHAN,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHLESSTHAN,
  FULLWIDTHMIDDLEDOT,
  FULLWIDTHRIGHTPAREN,
  HYPHEN,
  LEFTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  LOCALHOST,
  NL,
  NUM,
  OPENANGLEBRACKET,
  OPENBRACE,
  OPENBRACKET,
  OPENPAREN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  RIGHTCORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  SCHEME,
  SEMI,
  SLASH,
  SLASH_SCHEME,
  SYM,
  TILDE,
  TLD,
  UNDERSCORE,
  UTLD,
  UWORD,
  WORD,
  WS
});
var ASCII_LETTER = /[a-z]/;
var LETTER = new RegExp("\\p{L}", "u");
var EMOJI = new RegExp("\\p{Emoji}", "u");
var EMOJI_VARIATION$1 = /\ufe0f/;
var DIGIT = /\d/;
var SPACE2 = /\s/;
var regexp = Object.freeze({
  __proto__: null,
  ASCII_LETTER,
  DIGIT,
  EMOJI,
  EMOJI_VARIATION: EMOJI_VARIATION$1,
  LETTER,
  SPACE: SPACE2
});
var CR = "\r";
var LF = "\n";
var EMOJI_VARIATION = "️";
var EMOJI_JOINER = "‍";
var OBJECT_REPLACEMENT = "￼";
var tlds = null;
var utlds = null;
function init$2(customSchemes = []) {
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "（", FULLWIDTHLEFTPAREN);
  tt(Start, "）", FULLWIDTHRIGHTPAREN);
  tt(Start, "「", LEFTCORNERBRACKET);
  tt(Start, "」", RIGHTCORNERBRACKET);
  tt(Start, "『", LEFTWHITECORNERBRACKET);
  tt(Start, "』", RIGHTWHITECORNERBRACKET);
  tt(Start, "＜", FULLWIDTHLESSTHAN);
  tt(Start, "＞", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  tt(Start, "・", FULLWIDTHMIDDLEDOT);
  const Num = tr2(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr2(Num, DIGIT, Num);
  const Asciinumeric = tr2(Num, ASCII_LETTER, ASCIINUMERICAL, {
    [asciinumeric]: true
  });
  const Alphanumeric = tr2(Num, LETTER, ALPHANUMERICAL, {
    [alphanumeric]: true
  });
  const Word = tr2(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr2(Word, DIGIT, Asciinumeric);
  tr2(Word, ASCII_LETTER, Word);
  tr2(Asciinumeric, DIGIT, Asciinumeric);
  tr2(Asciinumeric, ASCII_LETTER, Asciinumeric);
  const UWord = tr2(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr2(UWord, ASCII_LETTER);
  tr2(UWord, DIGIT, Alphanumeric);
  tr2(UWord, LETTER, UWord);
  tr2(Alphanumeric, DIGIT, Alphanumeric);
  tr2(Alphanumeric, ASCII_LETTER);
  tr2(Alphanumeric, LETTER, Alphanumeric);
  const Nl2 = tt(Start, LF, NL, {
    [whitespace]: true
  });
  const Cr = tt(Start, CR, WS, {
    [whitespace]: true
  });
  const Ws = tr2(Start, SPACE2, WS, {
    [whitespace]: true
  });
  tt(Start, OBJECT_REPLACEMENT, Ws);
  tt(Cr, LF, Nl2);
  tt(Cr, OBJECT_REPLACEMENT, Ws);
  tr2(Cr, SPACE2, Ws);
  tt(Ws, CR);
  tt(Ws, LF);
  tr2(Ws, SPACE2, Ws);
  tt(Ws, OBJECT_REPLACEMENT, Ws);
  const Emoji = tr2(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tt(Emoji, "#");
  tr2(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tt(EmojiJoiner, "#");
  tr2(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
  for (let i2 = 0; i2 < tlds.length; i2++) {
    fastts(Start, tlds[i2], TLD, WORD, wordjr);
  }
  for (let i2 = 0; i2 < utlds.length; i2++) {
    fastts(Start, utlds[i2], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a2, b2) => a2[0] > b2[0] ? 1 : -1);
  for (let i2 = 0; i2 < customSchemes.length; i2++) {
    const sch = customSchemes[i2][0];
    const optionalSlashSlash = customSchemes[i2][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$12(start3, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c5) => c5.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start3;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index2 = 0;
  while (index2 < len) {
    let first2 = str.charCodeAt(index2);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index2 + 1 === len || (second = str.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str[index2] : str.slice(index2, index2 + 2);
    result.push(char);
    index2 += char.length;
  }
  return result;
}
function fastts(state, input, t2, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i2 = 0; i2 < len - 1; i2++) {
    const char = input[i2];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t2);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack = [];
  let i2 = 0;
  let digits = "0123456789";
  while (i2 < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i2 + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i2, i2 + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i2 += popDigitCount;
    } else {
      stack.push(encoded[i2]);
      i2++;
    }
  }
  return words;
}
var defaults3 = {
  defaultProtocol: "http",
  events: null,
  format: noop3,
  formatHref: noop3,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender = null) {
  let o2 = assign({}, defaults3);
  if (opts) {
    o2 = assign(o2, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o2.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i2 = 0; i2 < ignoredTags.length; i2++) {
    uppercaseIgnoredTags.push(ignoredTags[i2].toUpperCase());
  }
  this.o = o2;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults3,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults3[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop3(val) {
  return val;
}
var options = Object.freeze({
  __proto__: null,
  Options,
  assign,
  defaults: defaults3
});
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options2) {
    const val = this.toString();
    const truncate = options2.get("truncate", val, this);
    const formatted = options2.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "…" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options2) {
    return options2.get("formatHref", this.toHref(options2.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol = defaults3.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options2) {
    return {
      type: this.t,
      value: this.toFormattedString(options2),
      isLink: this.isLink,
      href: this.toFormattedHref(options2),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options2) {
    return options2.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options2) {
    const token = this;
    const href = this.toHref(options2.get("defaultProtocol"));
    const formattedHref = options2.get("formatHref", href, this);
    const tagName = options2.get("tagName", href, token);
    const content = this.toFormattedString(options2);
    const attributes = {};
    const className = options2.get("className", href, token);
    const target = options2.get("target", href, token);
    const rel = options2.get("rel", href, token);
    const attrs2 = options2.getObj("attributes", href, token);
    const eventListeners = options2.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs2) {
      assign(attributes, attrs2);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p3 in props) {
    Token.prototype[p3] = props[p3];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var Text3 = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2 = defaults3.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var multi = Object.freeze({
  __proto__: null,
  Base: MultiToken,
  Email,
  MultiToken,
  Nl,
  Text: Text3,
  Url,
  createTokenClass
});
var makeState = (arg) => new State(arg);
function init$1({
  groups
}) {
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta2(Localpart, localpartAccepting, Localpart);
  ta2(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta2(Start, groups.domain, Domain);
  ta2(Start, groups.scheme, Scheme);
  ta2(Start, groups.slashscheme, SlashScheme);
  ta2(Domain, localpartAccepting, Localpart);
  ta2(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta2(LocalpartDot, localpartAccepting, Localpart);
  ta2(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta2(LocalpartAt, groups.domain, EmailDomain);
  ta2(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta2(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta2(EmailDomainDot, groups.tld, Email$1);
  ta2(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
  ta2(EmailDomainHyphen, groups.domain, EmailDomain);
  ta2(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta2(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  tt(DomainHyphen, HYPHEN, DomainHyphen);
  ta2(DomainHyphen, groups.domain, Domain);
  ta2(DomainDot, localpartAccepting, Localpart);
  ta2(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta2(DomainDot, groups.tld, DomainDotTld);
  ta2(DomainDot, groups.utld, DomainDotTld);
  ta2(DomainDotTld, groups.domain, Domain);
  ta2(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta2(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta2(Url$1, qsAccepting, Url$1);
  ta2(Url$1, qsNonAccepting, UrlNonaccept);
  ta2(UrlNonaccept, qsAccepting, Url$1);
  ta2(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta2(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta2(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta2(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  tt(SchemeColon, QUERY, Url$1);
  ta2(UriPrefix, groups.domain, Url$1);
  ta2(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i2 = 0; i2 < bracketPairs.length; i2++) {
    const [OPEN, CLOSE] = bracketPairs[i2];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta2(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta2(UrlOpen, qsNonAccepting);
    ta2(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta2(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta2(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta2(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run2(start3, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start3;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text3, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text3, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || (() => {
});
var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
  return INIT;
}
function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i2 = 0; i2 < INIT.tokenQueue.length; i2++) {
    INIT.tokenQueue[i2][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i2 = 0; i2 < INIT.pluginQueue.length; i2++) {
    INIT.pluginQueue[i2][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
  return INIT;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run2(INIT.parser.start, str, run$12(INIT.scanner.start, str));
}
tokenize.scan = run$12;
function find(str, type = null, opts = null) {
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options2 = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i2 = 0; i2 < tokens.length; i2++) {
    const token = tokens[i2];
    if (token.isLink && (!type || token.t === type) && options2.check(token)) {
      filtered.push(token.toFormattedObject(options2));
    }
  }
  return filtered;
}

// ../../../node_modules/@tiptap/extension-link/dist/index.js
function isValidLinkStructure(tokens) {
  if (tokens.length === 1) {
    return tokens[0].isLink;
  }
  if (tokens.length === 3 && tokens[1].isLink) {
    return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
  }
  return false;
}
function autolink(options2) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr3 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s2) => s2 !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t2) => t2.toObject(options2.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => options2.validate(link.value)).filter((link) => options2.shouldAutoLink(link.value)).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options2.type)) {
              return;
            }
            tr3.addMark(link.from, link.to, options2.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr3.steps.length) {
        return;
      }
      return tr3;
    }
  });
}
function clickHandler(options2) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a, _b;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let a2 = event.target;
        const els = [];
        while (a2.nodeName !== "DIV") {
          els.push(a2);
          a2 = a2.parentNode;
        }
        if (!els.find((value) => value.nodeName === "A")) {
          return false;
        }
        const attrs2 = getAttributes(view.state, options2.type.name);
        const link = event.target;
        const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs2.href;
        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs2.target;
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options2) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty3 } = selection;
        if (empty3) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent, { defaultProtocol: options2.defaultProtocol }).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link) {
          return false;
        }
        return options2.editor.commands.setMark(options2.type, {
          href: link.href
        });
      }
    }
  });
}
var ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function isAllowedUri(uri, protocols) {
  const allowedProtocols = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(ATTR_WHITESPACE, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
var Link3 = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => !!url
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element) {
          return element.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          const href = dom.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return [
        "a",
        mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }),
        0
      ];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text) => {
          const foundLinks = [];
          if (text) {
            const { protocols, defaultProtocol } = this.options;
            const links = find(text).filter((item) => item.isLink && this.options.isAllowedUri(item.value, {
              defaultValidate: (href) => !!isAllowedUri(href, protocols),
              protocols,
              defaultProtocol
            }));
            if (links.length) {
              links.forEach((link) => foundLinks.push({
                text: link.value,
                data: {
                  href: link.href
                },
                index: link.start
              }));
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match85) => {
          var _a;
          return {
            href: (_a = match85.data) === null || _a === void 0 ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (url) => this.options.isAllowedUri(url, {
          defaultValidate: (href) => !!isAllowedUri(href, protocols),
          protocols,
          defaultProtocol
        }),
        shouldAutoLink: this.options.shouldAutoLink
      }));
    }
    if (this.options.openOnClick === true) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      }));
    }
    return plugins;
  }
});

// ../../../node_modules/@tiptap/extension-image/dist/index.js
var inputRegex7 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image3 = Node3.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options2) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options2
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex7,
        type: this.type,
        getAttributes: (match85) => {
          const [, , alt, src, title] = match85;
          return { src, alt, title };
        }
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-placeholder/dist/index.js
var Placeholder2 = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc3.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && isNodeEmpty(node);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes2 = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes2.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes2.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-task-item/dist/index.js
var inputRegex8 = /^\s*(\[([( |x])?\])\s$/;
var TaskItem2 = Node3.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: false,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: true,
  addAttributes() {
    return {
      checked: {
        default: false,
        keepOnSplit: false,
        parseHTML: (element) => {
          const dataChecked = element.getAttribute("data-checked");
          return dataChecked === "" || dataChecked === "true";
        },
        renderHTML: (attributes) => ({
          "data-checked": attributes.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "li",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: node.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const shortcuts = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    if (!this.options.nested) {
      return shortcuts;
    }
    return {
      ...shortcuts,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    };
  },
  addNodeView() {
    return ({ node, HTMLAttributes, getPos, editor }) => {
      const listItem2 = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content = document.createElement("div");
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      checkbox.addEventListener("mousedown", (event) => event.preventDefault());
      checkbox.addEventListener("change", (event) => {
        if (!editor.isEditable && !this.options.onReadOnlyChecked) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { checked } = event.target;
        if (editor.isEditable && typeof getPos === "function") {
          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: tr3 }) => {
            const position2 = getPos();
            if (typeof position2 !== "number") {
              return false;
            }
            const currentNode = tr3.doc.nodeAt(position2);
            tr3.setNodeMarkup(position2, void 0, {
              ...currentNode === null || currentNode === void 0 ? void 0 : currentNode.attrs,
              checked
            });
            return true;
          }).run();
        }
        if (!editor.isEditable && this.options.onReadOnlyChecked) {
          if (!this.options.onReadOnlyChecked(node, checked)) {
            checkbox.checked = !checkbox.checked;
          }
        }
      });
      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {
        listItem2.setAttribute(key, value);
      });
      listItem2.dataset.checked = node.attrs.checked;
      checkbox.checked = node.attrs.checked;
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem2.append(checkboxWrapper, content);
      Object.entries(HTMLAttributes).forEach(([key, value]) => {
        listItem2.setAttribute(key, value);
      });
      return {
        dom: listItem2,
        contentDOM: content,
        update: (updatedNode) => {
          if (updatedNode.type !== this.type) {
            return false;
          }
          listItem2.dataset.checked = updatedNode.attrs.checked;
          checkbox.checked = updatedNode.attrs.checked;
          return true;
        }
      };
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex8,
        type: this.type,
        getAttributes: (match85) => ({
          checked: match85[match85.length - 1] === "x"
        })
      })
    ];
  }
});

// ../../../node_modules/@tiptap/extension-task-list/dist/index.js
var TaskList2 = Node3.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: commands2 }) => {
        return commands2.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});

// ../../../node_modules/@tiptap/suggestion/dist/index.js
function findSuggestionMatch(config) {
  var _a;
  const { char, allowSpaces: allowSpacesOption, allowToIncludeChar, allowedPrefixes, startOfLine, $position } = config;
  const allowSpaces = allowSpacesOption && !allowToIncludeChar;
  const escapedChar = escapeForRegEx(char);
  const suffix2 = new RegExp(`\\s${escapedChar}$`);
  const prefix3 = startOfLine ? "^" : "";
  const finalEscapedChar = allowToIncludeChar ? "" : escapedChar;
  const regexp2 = allowSpaces ? new RegExp(`${prefix3}${escapedChar}.*?(?=\\s${finalEscapedChar}|$)`, "gm") : new RegExp(`${prefix3}(?:^)?${escapedChar}[^\\s${finalEscapedChar}]*`, "gm");
  const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;
  if (!text) {
    return null;
  }
  const textFrom = $position.pos - text.length;
  const match85 = Array.from(text.matchAll(regexp2)).pop();
  if (!match85 || match85.input === void 0 || match85.index === void 0) {
    return null;
  }
  const matchPrefix = match85.input.slice(Math.max(0, match85.index - 1), match85.index);
  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  const from2 = textFrom + match85.index;
  let to = from2 + match85[0].length;
  if (allowSpaces && suffix2.test(text.slice(to - 1, to + 1))) {
    match85[0] += " ";
    to += 1;
  }
  if (from2 < $position.pos && to >= $position.pos) {
    return {
      range: {
        from: from2,
        to
      },
      query: match85[0].slice(char.length),
      text: match85[0]
    };
  }
  return null;
}
var SuggestionPluginKey = new PluginKey("suggestion");
function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, allowToIncludeChar = false, allowedPrefixes = [" "], startOfLine = false, decorationTag = "span", decorationClass = "suggestion", command: command2 = () => null, items: items2 = () => [], render: render2 = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch }) {
  let props;
  const renderer = render2 === null || render2 === void 0 ? void 0 : render2();
  const plugin = new Plugin({
    key: pluginKey,
    view() {
      return {
        update: async (view, prevState) => {
          var _a, _b, _c, _d, _e, _f, _g;
          const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
          const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
          const moved = prev.active && next.active && prev.range.from !== next.range.from;
          const started = !prev.active && next.active;
          const stopped = prev.active && !next.active;
          const changed = !started && !stopped && prev.query !== next.query;
          const handleStart = started || moved && changed;
          const handleChange = changed || moved;
          const handleExit = stopped || moved && changed;
          if (!handleStart && !handleChange && !handleExit) {
            return;
          }
          const state = handleExit && !handleStart ? prev : next;
          const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
          props = {
            editor,
            range: state.range,
            query: state.query,
            text: state.text,
            items: [],
            command: (commandProps) => {
              return command2({
                editor,
                range: state.range,
                props: commandProps
              });
            },
            decorationNode,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: decorationNode ? () => {
              var _a2;
              const { decorationId } = (_a2 = this.key) === null || _a2 === void 0 ? void 0 : _a2.getState(editor.state);
              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
              return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
            } : null
          };
          if (handleStart) {
            (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
          }
          if (handleChange) {
            (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
          }
          if (handleChange || handleStart) {
            props.items = await items2({
              editor,
              query: state.query
            });
          }
          if (handleExit) {
            (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
          }
          if (handleChange) {
            (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);
          }
          if (handleStart) {
            (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
          }
        },
        destroy: () => {
          var _a;
          if (!props) {
            return;
          }
          (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        const state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply(transaction, prev, _oldState, state) {
        const { isEditable } = editor;
        const { composing } = editor.view;
        const { selection } = transaction;
        const { empty: empty3, from: from2 } = selection;
        const next = { ...prev };
        next.composing = composing;
        if (isEditable && (empty3 || editor.view.composing)) {
          if ((from2 < prev.range.from || from2 > prev.range.to) && !composing && !prev.composing) {
            next.active = false;
          }
          const match85 = findSuggestionMatch$1({
            char,
            allowSpaces,
            allowToIncludeChar,
            allowedPrefixes,
            startOfLine,
            $position: selection.$from
          });
          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
          if (match85 && allow({
            editor,
            state,
            range: match85.range,
            isActive: prev.active
          })) {
            next.active = true;
            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next.range = match85.range;
            next.query = match85.query;
            next.text = match85.text;
          } else {
            next.active = false;
          }
        } else {
          next.active = false;
        }
        if (!next.active) {
          next.decorationId = null;
          next.range = { from: 0, to: 0 };
          next.query = null;
          next.text = null;
        }
        return next;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(view, event) {
        var _a;
        const { active, range } = plugin.getState(view.state);
        if (!active) {
          return false;
        }
        return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations(state) {
        const { active, range, decorationId } = plugin.getState(state);
        if (!active) {
          return null;
        }
        return DecorationSet.create(state.doc, [
          Decoration.inline(range.from, range.to, {
            nodeName: decorationTag,
            class: decorationClass,
            "data-decoration-id": decorationId
          })
        ]);
      }
    }
  });
  return plugin;
}

// ../../../node_modules/@firecms/editor/dist/index.es.js
var EditorBubble = (0, import_react8.forwardRef)((t0, ref2) => {
  const $ = (0, import_react_compiler_runtime2.c)(21);
  let children;
  let rest;
  let tippyOptions;
  if ($[0] !== t0) {
    ({
      children,
      tippyOptions,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = rest;
    $[3] = tippyOptions;
  } else {
    children = $[1];
    rest = $[2];
    tippyOptions = $[3];
  }
  const {
    editor
  } = useCurrentEditor();
  const instanceRef = (0, import_react8.useRef)(null);
  let t1;
  if ($[4] !== tippyOptions) {
    t1 = () => {
      var _a;
      if (!instanceRef.current || !(tippyOptions == null ? void 0 : tippyOptions.placement)) {
        return;
      }
      instanceRef.current.setProps({
        placement: tippyOptions.placement
      });
      (_a = instanceRef.current.popperInstance) == null ? void 0 : _a.update();
    };
    $[4] = tippyOptions;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const t2 = tippyOptions == null ? void 0 : tippyOptions.placement;
  let t3;
  if ($[6] !== t2) {
    t3 = [t2];
    $[6] = t2;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  (0, import_react8.useEffect)(t1, t3);
  let t4;
  const shouldShow = _temp$1;
  let t5;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (val) => {
      instanceRef.current = val;
    };
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== tippyOptions) {
    t6 = {
      onCreate: t5,
      moveTransition: "transform 0.15s ease-out",
      ...tippyOptions
    };
    $[9] = tippyOptions;
    $[10] = t6;
  } else {
    t6 = $[10];
  }
  let t7;
  if ($[11] !== rest || $[12] !== t6) {
    t7 = {
      shouldShow,
      tippyOptions: t6,
      ...rest
    };
    $[11] = rest;
    $[12] = t6;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  t4 = t7;
  const bubbleMenuProps = t4;
  if (!editor) {
    return null;
  }
  let t8;
  if ($[14] !== bubbleMenuProps || $[15] !== children || $[16] !== editor) {
    t8 = (0, import_jsx_runtime.jsx)(BubbleMenu2, { editor, ...bubbleMenuProps, children });
    $[14] = bubbleMenuProps;
    $[15] = children;
    $[16] = editor;
    $[17] = t8;
  } else {
    t8 = $[17];
  }
  let t9;
  if ($[18] !== ref2 || $[19] !== t8) {
    t9 = (0, import_jsx_runtime.jsx)("div", { ref: ref2, children: t8 });
    $[18] = ref2;
    $[19] = t8;
    $[20] = t9;
  } else {
    t9 = $[20];
  }
  return t9;
});
function _temp$1(t0) {
  const {
    editor: editor_0,
    state
  } = t0;
  const {
    selection
  } = state;
  const {
    empty: empty3
  } = selection;
  if (editor_0.isActive("image") || empty3 || isNodeSelection(selection)) {
    return false;
  }
  return true;
}
var EditorBubbleItem = (0, import_react8.forwardRef)((t0, ref2) => {
  const $ = (0, import_react_compiler_runtime2.c)(14);
  let asChild;
  let children;
  let onSelect;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      asChild,
      onSelect,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = asChild;
    $[2] = children;
    $[3] = onSelect;
    $[4] = rest;
  } else {
    asChild = $[1];
    children = $[2];
    onSelect = $[3];
    rest = $[4];
  }
  const {
    editor
  } = useCurrentEditor();
  const Comp = asChild ? Slot : "div";
  if (!editor) {
    return null;
  }
  let t1;
  if ($[5] !== editor || $[6] !== onSelect) {
    t1 = () => onSelect == null ? void 0 : onSelect(editor);
    $[5] = editor;
    $[6] = onSelect;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  let t2;
  if ($[8] !== Comp || $[9] !== children || $[10] !== ref2 || $[11] !== rest || $[12] !== t1) {
    t2 = (0, import_jsx_runtime.jsx)(Comp, { ref: ref2, ...rest, onClick: t1, children });
    $[8] = Comp;
    $[9] = children;
    $[10] = ref2;
    $[11] = rest;
    $[12] = t1;
    $[13] = t2;
  } else {
    t2 = $[13];
  }
  return t2;
});
EditorBubbleItem.displayName = "EditorBubbleItem";
var items = [{
  name: "Text",
  icon: TextFieldsIcon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleNode("paragraph", "paragraph").run(),
  // I feel like there has to be a more efficient way to do this – feel free to PR if you know how!
  isActive: (editor) => ((editor == null ? void 0 : editor.isActive("paragraph")) && !(editor == null ? void 0 : editor.isActive("bulletList")) && !(editor == null ? void 0 : editor.isActive("orderedList"))) ?? false
}, {
  name: "Heading 1",
  icon: LooksOneIcon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleHeading({
    level: 1
  }).run(),
  isActive: (editor) => (editor == null ? void 0 : editor.isActive("heading", {
    level: 1
  })) ?? false
}, {
  name: "Heading 2",
  icon: LooksTwoIcon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleHeading({
    level: 2
  }).run(),
  isActive: (editor) => (editor == null ? void 0 : editor.isActive("heading", {
    level: 2
  })) ?? false
}, {
  name: "Heading 3",
  icon: Looks3Icon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleHeading({
    level: 3
  }).run(),
  isActive: (editor) => (editor == null ? void 0 : editor.isActive("heading", {
    level: 3
  })) ?? false
}, {
  name: "To-do List",
  icon: CheckBoxIcon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleTaskList().run(),
  isActive: (editor) => (editor == null ? void 0 : editor.isActive("taskItem")) ?? false
}, {
  name: "Bullet List",
  icon: FormatListBulletedIcon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleBulletList().run(),
  isActive: (editor) => (editor == null ? void 0 : editor.isActive("bulletList")) ?? false
}, {
  name: "Numbered List",
  icon: FormatListNumberedIcon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleOrderedList().run(),
  isActive: (editor) => (editor == null ? void 0 : editor.isActive("orderedList")) ?? false
}, {
  name: "Quote",
  icon: FormatQuoteIcon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleNode("paragraph", "paragraph").toggleBlockquote().run(),
  isActive: (editor) => (editor == null ? void 0 : editor.isActive("blockquote")) ?? false
}, {
  name: "Code",
  icon: CodeIcon,
  command: (editor) => editor == null ? void 0 : editor.chain().focus().toggleCodeBlock().run(),
  isActive: (editor) => (editor == null ? void 0 : editor.isActive("codeBlock")) ?? false
}];
var NodeSelector = (t0) => {
  const $ = (0, import_react_compiler_runtime2.c)(16);
  const {
    open,
    onOpenChange,
    portalContainer
  } = t0;
  const {
    editor
  } = useCurrentEditor();
  if (!editor) {
    return null;
  }
  let t1;
  if ($[0] !== editor) {
    t1 = items.filter((item) => item.isActive(editor)).pop() ?? {
      name: "Multiple"
    };
    $[0] = editor;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const activeItem = t1;
  let t2;
  if ($[2] !== activeItem.name) {
    t2 = (0, import_jsx_runtime.jsx)("span", { className: "whitespace-nowrap text-sm", children: activeItem.name });
    $[2] = activeItem.name;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime.jsx)(KeyboardArrowDownIcon, { size: "small" });
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== t2) {
    t4 = (0, import_jsx_runtime.jsxs)(Button, { variant: "text", className: "gap-2 rounded-none", color: "text", children: [
      t2,
      t3
    ] });
    $[5] = t2;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== activeItem.name || $[8] !== onOpenChange) {
    t5 = items.map((item_0, index2) => (0, import_jsx_runtime.jsxs)(EditorBubbleItem, { onSelect: (editor_0) => {
      item_0.command(editor_0);
      onOpenChange(false);
    }, className: "flex cursor-pointer items-center justify-between rounded px-2 py-1 text-sm hover:bg-blue-50 hover:dark:bg-surface-700 text-surface-900 dark:text-white", children: [
      (0, import_jsx_runtime.jsxs)("div", { className: "flex items-center space-x-2", children: [
        (0, import_jsx_runtime.jsx)(item_0.icon, { size: "smallest" }),
        (0, import_jsx_runtime.jsx)("span", { children: item_0.name })
      ] }),
      activeItem.name === item_0.name && (0, import_jsx_runtime.jsx)(CheckIcon, { size: "smallest" })
    ] }, index2));
    $[7] = activeItem.name;
    $[8] = onOpenChange;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== onOpenChange || $[11] !== open || $[12] !== portalContainer || $[13] !== t4 || $[14] !== t5) {
    t6 = (0, import_jsx_runtime.jsx)(Popover, { sideOffset: 5, align: "start", portalContainer, className: "w-48 p-1", trigger: t4, modal: true, open, onOpenChange, children: t5 });
    $[10] = onOpenChange;
    $[11] = open;
    $[12] = portalContainer;
    $[13] = t4;
    $[14] = t5;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  return t6;
};
function isValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch (e2) {
    return false;
  }
}
function getUrlFromString(str) {
  if (isValidUrl(str)) return str;
  try {
    if (str.includes(".") && !str.includes(" ")) {
      return new URL(`https://${str}`).toString();
    }
    return null;
  } catch (e2) {
    return null;
  }
}
var LinkSelector = (t0) => {
  const $ = (0, import_react_compiler_runtime2.c)(24);
  const {
    open,
    onOpenChange
  } = t0;
  const inputRef = (0, import_react8.useRef)(null);
  const {
    editor
  } = useCurrentEditor();
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      var _a;
      inputRef.current && ((_a = inputRef.current) == null ? void 0 : _a.focus());
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  (0, import_react8.useEffect)(t1);
  if (!editor) {
    return null;
  }
  let t2;
  if ($[1] !== editor) {
    t2 = cls("underline decoration-stone-400 underline-offset-4", {
      "text-blue-500": editor.isActive("link")
    });
    $[1] = editor;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== t2) {
    t3 = (0, import_jsx_runtime.jsx)(Button, { variant: "text", className: "gap-2 rounded-none", color: "text", children: (0, import_jsx_runtime.jsx)("p", { className: t2, children: "Link" }) });
    $[3] = t2;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== editor) {
    t4 = (e2) => {
      const target = e2.currentTarget;
      e2.preventDefault();
      const input = target[0];
      const url = getUrlFromString(input.value);
      url && editor.chain().focus().setLink({
        href: url
      }).run();
    };
    $[5] = editor;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== editor) {
    t5 = editor.getAttributes("link").href || "";
    $[7] = editor;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = cls("text-surface-900 dark:text-white flex-grow bg-transparent p-1 text-sm outline-none", focusedDisabled);
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== open || $[11] !== t5) {
    t7 = (0, import_jsx_runtime.jsx)("input", { ref: inputRef, autoFocus: open, placeholder: "Paste a link", defaultValue: t5, className: t6 });
    $[10] = open;
    $[11] = t5;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  let t8;
  if ($[13] !== editor) {
    t8 = editor.getAttributes("link").href ? (0, import_jsx_runtime.jsx)(Button, { size: "small", variant: "text", type: "button", color: "text", className: "flex items-center", onClick: () => {
      editor.chain().focus().unsetLink().run();
    }, children: (0, import_jsx_runtime.jsx)(DeleteIcon, { size: "small" }) }) : (0, import_jsx_runtime.jsx)(Button, { size: "small", variant: "text", children: (0, import_jsx_runtime.jsx)(CheckIcon, { size: "small" }) });
    $[13] = editor;
    $[14] = t8;
  } else {
    t8 = $[14];
  }
  let t9;
  if ($[15] !== t4 || $[16] !== t7 || $[17] !== t8) {
    t9 = (0, import_jsx_runtime.jsxs)("form", { onSubmit: t4, className: "flex p-1", children: [
      t7,
      t8
    ] });
    $[15] = t4;
    $[16] = t7;
    $[17] = t8;
    $[18] = t9;
  } else {
    t9 = $[18];
  }
  let t10;
  if ($[19] !== onOpenChange || $[20] !== open || $[21] !== t3 || $[22] !== t9) {
    t10 = (0, import_jsx_runtime.jsx)(Popover, { modal: true, open, onOpenChange, trigger: t3, children: t9 });
    $[19] = onOpenChange;
    $[20] = open;
    $[21] = t3;
    $[22] = t9;
    $[23] = t10;
  } else {
    t10 = $[23];
  }
  return t10;
};
var TextButtons = () => {
  const $ = (0, import_react_compiler_runtime2.c)(2);
  const {
    editor
  } = useCurrentEditor();
  if (!editor) {
    return null;
  }
  let t0;
  if ($[0] !== editor) {
    const items2 = [{
      name: "bold",
      isActive: _temp,
      command: _temp2,
      icon: FormatBoldIcon
    }, {
      name: "italic",
      isActive: _temp3,
      command: _temp4,
      icon: FormatItalicIcon
    }, {
      name: "underline",
      isActive: _temp5,
      command: _temp6,
      icon: FormatUnderlinedIcon
    }, {
      name: "strike",
      isActive: _temp7,
      command: _temp8,
      icon: FormatStrikethroughIcon
    }, {
      name: "code",
      isActive: _temp9,
      command: _temp10,
      icon: CodeIcon
    }];
    t0 = (0, import_jsx_runtime.jsx)("div", { className: "flex", children: items2.map((item, index2) => (0, import_jsx_runtime.jsx)(EditorBubbleItem, { onSelect: (editor_10) => {
      item.command(editor_10);
    }, children: (0, import_jsx_runtime.jsx)(Button, { size: "small", color: "text", className: "gap-2 rounded-none h-full", variant: "text", children: (0, import_jsx_runtime.jsx)(item.icon, { className: cls({
      "text-inherit": !item.isActive(editor),
      "text-blue-500": item.isActive(editor)
    }) }) }) }, index2)) });
    $[0] = editor;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
};
function _temp(editor_0) {
  return (editor_0 == null ? void 0 : editor_0.isActive("bold")) ?? false;
}
function _temp2(editor_1) {
  return editor_1 == null ? void 0 : editor_1.chain().focus().toggleBold().run();
}
function _temp3(editor_2) {
  return (editor_2 == null ? void 0 : editor_2.isActive("italic")) ?? false;
}
function _temp4(editor_3) {
  return editor_3 == null ? void 0 : editor_3.chain().focus().toggleItalic().run();
}
function _temp5(editor_4) {
  return (editor_4 == null ? void 0 : editor_4.isActive("underline")) ?? false;
}
function _temp6(editor_5) {
  return editor_5 == null ? void 0 : editor_5.chain().focus().toggleUnderline().run();
}
function _temp7(editor_6) {
  return (editor_6 == null ? void 0 : editor_6.isActive("strike")) ?? false;
}
function _temp8(editor_7) {
  return editor_7 == null ? void 0 : editor_7.chain().focus().toggleStrike().run();
}
function _temp9(editor_8) {
  return (editor_8 == null ? void 0 : editor_8.isActive("code")) ?? false;
}
function _temp10(editor_9) {
  return editor_9 == null ? void 0 : editor_9.chain().focus().toggleCode().run();
}
function removeClassesFromJson(jsonObj) {
  if (Array.isArray(jsonObj)) {
    return jsonObj.map((item) => removeClassesFromJson(item));
  } else if (typeof jsonObj === "object" && jsonObj !== null) {
    if (jsonObj.attrs && typeof jsonObj.attrs === "object" && "class" in jsonObj.attrs) {
      delete jsonObj.attrs.class;
    }
    Object.keys(jsonObj).forEach((key) => {
      jsonObj[key] = removeClassesFromJson(jsonObj[key]);
    });
  }
  return jsonObj;
}
var loadingDecorationKey = new PluginKey("loadingDecoration");
var TextLoadingDecorationExtension = Extension.create({
  name: "loadingDecoration",
  addOptions() {
    return {
      pluginKey: loadingDecorationKey
    };
  },
  addProseMirrorPlugins() {
    const pluginKey = this.options.pluginKey;
    return [new Plugin({
      key: pluginKey,
      state: {
        init() {
          return {
            decorationSet: DecorationSet.empty,
            hasDecoration: false
          };
        },
        apply(tr3, oldState) {
          const action = tr3.getMeta(pluginKey);
          if ((action == null ? void 0 : action.type) === "loadingDecoration") {
            const {
              pos,
              remove,
              loadingHtml
            } = action;
            if (remove) {
              return {
                decorationSet: DecorationSet.empty,
                hasDecoration: false
              };
            }
            const decoration = Decoration.widget(pos, () => {
              const container = document.createElement("span");
              container.className = "loading-decoration";
              if (loadingHtml) {
                container.innerHTML = loadingHtml;
              } else {
                const span = document.createElement("span");
                span.innerText = "loading...";
                container.appendChild(span);
              }
              return container;
            });
            return {
              decorationSet: DecorationSet.empty.add(tr3.doc, [decoration]),
              hasDecoration: true
            };
          }
          return {
            decorationSet: oldState.decorationSet.map(tr3.mapping, tr3.doc),
            hasDecoration: oldState.hasDecoration
          };
        }
      },
      props: {
        decorations(state) {
          var _a;
          return ((_a = this.getState(state)) == null ? void 0 : _a.decorationSet) || DecorationSet.empty;
        }
      }
    })];
  },
  addCommands() {
    return {
      toggleLoadingDecoration: (loadingHtml) => ({
        state,
        dispatch
      }) => {
        const {
          selection
        } = state;
        const pos = selection.from;
        if (!dispatch) return false;
        const pluginKey = this.options.pluginKey;
        const tr3 = state.tr.setMeta(pluginKey, {
          pos,
          type: "loadingDecoration",
          remove: false,
          loadingHtml
        });
        dispatch(tr3);
        return true;
      },
      removeLoadingDecoration: () => ({
        state,
        dispatch
      }) => {
        if (!dispatch) return false;
        const pluginKey = this.options.pluginKey;
        const tr3 = state.tr.setMeta(pluginKey, {
          pos: 0,
          // We can pass any position as it will remove the entire decoration set
          type: "loadingDecoration",
          remove: true
        });
        dispatch(tr3);
        return true;
      }
    };
  }
});
var PlaceholderExtension = Placeholder2.configure({
  placeholder: ({
    node,
    editor
  }) => {
    editor.state.selection;
    function hasLoadingDecoration(editor2) {
      var _a;
      const pluginState = loadingDecorationKey.get(editor2.state);
      return ((_a = pluginState == null ? void 0 : pluginState.getState(editor2.state)) == null ? void 0 : _a.hasDecoration) ?? false;
    }
    const hasDecoration = hasLoadingDecoration(editor);
    if (hasDecoration) {
      return "";
    }
    if (node.type.name === "heading") {
      return `Heading ${node.attrs.level}`;
    }
    if (node.type.name === "paragraph") {
      return "Press '/' for commands";
    }
    return "";
  },
  includeChildren: true
});
var Horizontal = HorizontalRule2.extend({
  addInputRules() {
    return [new InputRule({
      find: /^(?:---|—-|___\s|\*\*\*\s)$/,
      handler: ({
        state,
        range
      }) => {
        const attributes = {};
        const {
          tr: tr3
        } = state;
        const start3 = range.from;
        const end3 = range.to;
        tr3.insert(start3 - 1, this.type.create(attributes)).delete(tr3.mapping.map(start3), tr3.mapping.map(end3));
      }
    })];
  }
});
var placeholder2 = PlaceholderExtension;
var tiptapLink = Link3.configure({
  HTMLAttributes: {
    class: cls("text-surface-700 dark:text-surface-accent-200 underline underline-offset-[3px] hover:text-primary transition-colors cursor-pointer")
  }
});
var taskList = TaskList2.configure({
  HTMLAttributes: {
    class: cls("not-prose")
  }
});
var taskItem = TaskItem2.configure({
  HTMLAttributes: {
    class: cls("flex items-start my-4")
  },
  nested: true
});
var horizontalRule = Horizontal.configure({
  HTMLAttributes: {
    class: cls("mt-4 mb-6 border-t", defaultBorderMixin)
  }
});
var bulletList = BulletList2.configure({
  HTMLAttributes: {
    class: cls("list-disc list-outside leading-3 -mt-2")
  }
});
var orderedList = OrderedList2.configure({
  HTMLAttributes: {
    class: cls("list-decimal list-outside leading-3 -mt-2")
  }
});
var listItem = ListItem2.configure({
  HTMLAttributes: {
    class: cls("leading-normal -mb-2")
  }
});
var blockquote = Blockquote2.configure({
  HTMLAttributes: {
    class: cls("border-l-4 border-primary")
  }
});
var codeBlock = CodeBlock2.configure({
  HTMLAttributes: {
    class: cls("rounded bg-blue-50 dark:bg-surface-700 border p-5 font-mono font-medium", defaultBorderMixin)
  }
});
var code = Code2.configure({
  HTMLAttributes: {
    class: cls("rounded-md bg-surface-accent-50 dark:bg-surface-700 px-1.5 py-1 font-mono font-medium"),
    spellcheck: "false"
  }
});
var starterKit = StarterKit.configure({
  document: false,
  horizontalRule: false,
  dropcursor: {
    color: "#DBEAFE",
    width: 4
  },
  gapcursor: false
});
async function onFileRead(view, readerEvent, pos, upload, image) {
  var _a;
  const {
    schema: schema2
  } = view.state;
  const plugin = view.state.plugins.find((p3) => p3.key === ImagePluginKey.key);
  if (!plugin) {
    console.error("Image plugin not found");
    return;
  }
  let decorationSet = plugin.getState(view.state);
  const placeholder22 = document.createElement("div");
  const imageElement = document.createElement("img");
  imageElement.setAttribute("class", "opacity-40 rounded-lg border " + defaultBorderMixin);
  imageElement.src = (_a = readerEvent.target) == null ? void 0 : _a.result;
  placeholder22.appendChild(imageElement);
  const deco = Decoration.widget(pos, placeholder22);
  decorationSet = decorationSet == null ? void 0 : decorationSet.add(view.state.doc, [deco]);
  view.dispatch(view.state.tr.setMeta(plugin, {
    decorationSet
  }));
  const src = await upload(image);
  console.debug("Uploaded image", src);
  const imageNode = schema2.nodes.image.create({
    src
  });
  const tr3 = view.state.tr.replaceWith(pos, pos, imageNode);
  decorationSet = decorationSet == null ? void 0 : decorationSet.remove([deco]);
  tr3.setMeta(plugin, {
    decorationSet
  });
  view.dispatch(tr3);
}
var ImagePluginKey = new PluginKey("imagePlugin");
var createDropImagePlugin = (upload) => {
  const plugin = new Plugin({
    key: ImagePluginKey,
    state: {
      // Initialize the plugin state with an empty DecorationSet
      init: () => DecorationSet.empty,
      // Apply transactions to update the state
      apply: (tr3, old) => {
        const meta = tr3.getMeta(plugin);
        if (meta && meta.decorationSet) {
          return meta.decorationSet;
        }
        return old.map(tr3.mapping, tr3.doc);
      }
    },
    props: {
      handleDOMEvents: {
        drop: (view, event) => {
          var _a, _b;
          if (!((_a = event.dataTransfer) == null ? void 0 : _a.files) || ((_b = event.dataTransfer) == null ? void 0 : _b.files.length) === 0) {
            return false;
          }
          event.preventDefault();
          const files = Array.from(event.dataTransfer.files);
          const images = files.filter((file) => /image/i.test(file.type));
          if (images.length === 0) {
            console.log("No images found in dropped files");
            return false;
          }
          images.forEach((image) => {
            const position2 = view.posAtCoords({
              left: event.clientX,
              top: event.clientY
            });
            if (!position2) return;
            const reader = new FileReader();
            reader.onload = async (readerEvent) => {
              await onFileRead(view, readerEvent, position2.pos, upload, image);
            };
            reader.readAsDataURL(image);
          });
          return true;
        }
      },
      handlePaste(view, event, slice2) {
        var _a;
        const items2 = Array.from(((_a = event.clipboardData) == null ? void 0 : _a.items) || []);
        const pos = view.state.selection.from;
        let anyImageFound = false;
        items2.forEach((item) => {
          const image = item.getAsFile();
          if (image) {
            anyImageFound = true;
            const reader = new FileReader();
            reader.onload = async (readerEvent) => {
              await onFileRead(view, readerEvent, pos, upload, image);
            };
            reader.readAsDataURL(image);
          }
        });
        return anyImageFound;
      },
      decorations(state) {
        return plugin.getState(state);
      }
    },
    view(editorView) {
      return {
        update(view, prevState) {
          const prevDecos = plugin.getState(prevState);
          const newDecos = plugin.getState(view.state);
          if (prevDecos !== newDecos) {
            view.updateState(view.state);
          }
        }
      };
    }
  });
  return plugin;
};
var createImageExtension = (dropImagePlugin) => {
  return Image3.extend({
    addProseMirrorPlugins() {
      return [dropImagePlugin];
    }
  }).configure({
    allowBase64: true,
    HTMLAttributes: {
      class: cls("rounded-lg border", defaultBorderMixin)
    }
  });
};
var CustomKeymap = Extension.create({
  name: "CustomKeymap",
  addCommands() {
    return {
      selectTextWithinNodeBoundaries: () => ({
        editor,
        commands: commands2
      }) => {
        const {
          state
        } = editor;
        const {
          tr: tr3
        } = state;
        const startNodePos = tr3.selection.$from.start();
        const endNodePos = tr3.selection.$to.end();
        return commands2.setTextSelection({
          from: startNodePos,
          to: endNodePos
        });
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-a": ({
        editor
      }) => {
        const {
          state
        } = editor;
        const {
          tr: tr3
        } = state;
        const startSelectionPos = tr3.selection.from;
        const endSelectionPos = tr3.selection.to;
        const startNodePos = tr3.selection.$from.start();
        const endNodePos = tr3.selection.$to.end();
        const isCurrentTextSelectionNotExtendedToNodeBoundaries = startSelectionPos > startNodePos || endSelectionPos < endNodePos;
        if (isCurrentTextSelectionNotExtendedToNodeBoundaries) {
          editor.chain().selectTextWithinNodeBoundaries().run();
          return true;
        }
        return false;
      }
    };
  }
});
function absoluteRect(element) {
  const data = element.getBoundingClientRect();
  let ancestor = element.parentElement;
  while (ancestor && window.getComputedStyle(ancestor).position === "static") {
    ancestor = ancestor.parentElement;
  }
  const ancestorRect = ancestor == null ? void 0 : ancestor.getBoundingClientRect();
  return {
    top: data.top - ((ancestorRect == null ? void 0 : ancestorRect.top) ?? 0),
    left: data.left - ((ancestorRect == null ? void 0 : ancestorRect.left) ?? 0),
    width: data.width
  };
}
function nodeDOMAtCoords(coords) {
  return document.elementsFromPoint(coords.x, coords.y).find((elem) => {
    var _a, _b;
    return ((_b = (_a = elem.parentElement) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, ".ProseMirror")) || elem.matches(["li", "p:not(:first-child)", "pre", "blockquote", "h1, h2, h3, h4, h5, h6"].join(", "));
  });
}
function nodePosAtDOM(node, view, options2) {
  var _a;
  const boundingRect = node.getBoundingClientRect();
  return (_a = view.posAtCoords({
    left: boundingRect.left + 50 + options2.dragHandleWidth,
    top: boundingRect.top + 1
  })) == null ? void 0 : _a.inside;
}
function DragHandle(options2) {
  function handleDragStart(event, view) {
    view.focus();
    if (!event.dataTransfer) return;
    const node = nodeDOMAtCoords({
      x: event.clientX + 50 + options2.dragHandleWidth,
      y: event.clientY
    });
    if (!(node instanceof Element)) return;
    const nodePos = nodePosAtDOM(node, view, options2);
    if (nodePos == null || nodePos < 0) return;
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, nodePos)));
    const slice2 = view.state.selection.content();
    const {
      dom,
      text
    } = __serializeForClipboard(view, slice2);
    event.dataTransfer.clearData();
    event.dataTransfer.setData("text/html", dom.innerHTML);
    event.dataTransfer.setData("text/plain", text);
    event.dataTransfer.effectAllowed = "copyMove";
    event.dataTransfer.setDragImage(node, 0, 0);
    view.dragging = {
      slice: slice2,
      move: event.ctrlKey
    };
  }
  function handleClick2(event, view) {
    view.focus();
    view.dom.classList.remove("dragging");
    const node = nodeDOMAtCoords({
      x: event.clientX + 50 + options2.dragHandleWidth,
      y: event.clientY
    });
    if (!(node instanceof Element)) return;
    const nodePos = nodePosAtDOM(node, view, options2);
    if (!nodePos) return;
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, nodePos)));
  }
  let dragHandleElement = null;
  function hideDragHandle() {
    if (dragHandleElement) {
      dragHandleElement.classList.add("hide");
    }
  }
  function showDragHandle() {
    if (dragHandleElement) {
      dragHandleElement.classList.remove("hide");
    }
  }
  return new Plugin({
    view: (view) => {
      var _a, _b;
      dragHandleElement = document.createElement("div");
      dragHandleElement.draggable = true;
      dragHandleElement.dataset.dragHandle = "";
      dragHandleElement.classList.add("drag-handle");
      dragHandleElement.addEventListener("dragstart", (e2) => {
        handleDragStart(e2, view);
      });
      dragHandleElement.addEventListener("click", (e2) => {
        handleClick2(e2, view);
      });
      hideDragHandle();
      (_b = (_a = view == null ? void 0 : view.dom) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.appendChild(dragHandleElement);
      return {
        destroy: () => {
        }
      };
    },
    props: {
      handleDOMEvents: {
        mousemove: (view, event) => {
          if (!view.editable) {
            return;
          }
          const node = nodeDOMAtCoords({
            x: event.clientX + 50 + options2.dragHandleWidth,
            y: event.clientY
          });
          if (!(node instanceof Element)) {
            hideDragHandle();
            return;
          }
          const compStyle = window.getComputedStyle(node);
          const lineHeight = parseInt(compStyle.lineHeight, 10);
          const paddingTop = parseInt(compStyle.paddingTop, 10);
          const rect = absoluteRect(node);
          rect.top += (lineHeight - 24) / 2;
          rect.top += paddingTop;
          if (node.matches("ul:not([data-type=taskList]) li, ol li")) {
            rect.left -= options2.dragHandleWidth;
          }
          rect.width = options2.dragHandleWidth;
          if (!dragHandleElement) return;
          dragHandleElement.style.left = `${rect.left - rect.width}px`;
          dragHandleElement.style.top = `${rect.top}px`;
          showDragHandle();
        },
        keydown: () => {
          hideDragHandle();
        },
        mousewheel: () => {
          hideDragHandle();
        },
        // dragging class is used for CSS
        dragstart: (view) => {
          view.dom.classList.add("dragging");
        },
        drop: (view) => {
          view.dom.classList.remove("dragging");
        },
        dragend: (view) => {
          view.dom.classList.remove("dragging");
        }
      }
    }
  });
}
var DragAndDrop = Extension.create({
  name: "dragAndDrop",
  addProseMirrorPlugins() {
    return [DragHandle({
      dragHandleWidth: 24
    })];
  }
});
function buildDecorationSet(highlight, doc3) {
  const decorations = [];
  if (highlight) {
    decorations.push(Decoration.inline(highlight.from, highlight.to, {
      class: "dark:bg-surface-accent-700 bg-surface-accent-300"
    }));
  }
  const decorationSet = DecorationSet.create(doc3, decorations);
  return decorationSet;
}
var HighlightDecorationExtension = (initialHighlight) => Extension.create({
  name: "highlightDecoration",
  addOptions() {
    return {
      pluginKey: new PluginKey("highlightDecoration"),
      highlight: initialHighlight
    };
  },
  addProseMirrorPlugins() {
    const pluginKey = this.options.pluginKey;
    return [new Plugin({
      key: pluginKey,
      state: {
        init: (_, {
          doc: doc3
        }) => {
          const highlight = this.options.highlight;
          const decorationSet = highlight && doc3 ? buildDecorationSet(highlight, doc3) : DecorationSet.empty;
          return {
            decorationSet,
            highlight
          };
        },
        apply(transaction, oldState) {
          const action = transaction.getMeta(pluginKey);
          const highlight = action == null ? void 0 : action.range;
          if ((action == null ? void 0 : action.type) === "highlightDecoration") {
            const doc3 = transaction.doc;
            const {
              remove
            } = action;
            if (remove) {
              return {
                decorationSet: DecorationSet.empty
              };
            }
            const decorationSet = buildDecorationSet(highlight, doc3);
            return {
              decorationSet,
              highlight
            };
          } else {
            return oldState;
          }
        }
      },
      props: {
        decorations(state) {
          const autocompleteState = this.getState(state);
          if (autocompleteState == null ? void 0 : autocompleteState.decorationSet) {
            return autocompleteState.decorationSet;
          } else {
            return DecorationSet.empty;
          }
        }
      }
    })];
  },
  addCommands() {
    return {
      toggleAutocompleteHighlight: (range) => ({
        state,
        dispatch
      }) => {
        const {
          selection
        } = state;
        const pos = selection.from;
        if (!dispatch) return false;
        const pluginKey = this.options.pluginKey;
        const tr3 = state.tr.setMeta(pluginKey, {
          pos,
          type: "highlightDecoration",
          remove: false,
          range
        });
        dispatch(tr3);
        return true;
      },
      removeAutocompleteHighlight: () => ({
        state,
        dispatch
      }) => {
        if (!dispatch) return false;
        const pluginKey = this.options.pluginKey;
        const tr3 = state.tr.setMeta(pluginKey, {
          pos: 0,
          // We can pass any position as it will remove the entire decoration set
          type: "highlightDecoration",
          remove: true
        });
        dispatch(tr3);
        return true;
      }
    };
  }
});
var CommandPluginKey = new PluginKey("slash-command");
var SlashCommand = Node3.create({
  name: "command",
  addOptions() {
    return {
      HTMLAttributes: {},
      renderText({
        options: options2,
        node
      }) {
        return `${options2.suggestion.char}${node.attrs.label ?? node.attrs.id}`;
      },
      deleteTriggerWithBackspace: false,
      renderHTML({
        options: options2,
        node
      }) {
        return ["span", mergeAttributes(this.HTMLAttributes, options2.HTMLAttributes), `${options2.suggestion.char}${node.attrs.label ?? node.attrs.id}`];
      },
      suggestion: {
        char: "/",
        pluginKey: CommandPluginKey,
        command: ({
          editor,
          range,
          props
        }) => {
          var _a, _b;
          const nodeAfter = editor.view.state.selection.$to.nodeAfter;
          const overrideSpace = (_a = nodeAfter == null ? void 0 : nodeAfter.text) == null ? void 0 : _a.startsWith(" ");
          if (overrideSpace) {
            range.to += 1;
          }
          editor.chain().focus().insertContentAt(range, [{
            type: this.name,
            attrs: props
          }, {
            type: "text",
            text: " "
          }]).run();
          (_b = window.getSelection()) == null ? void 0 : _b.collapseToEnd();
        },
        allow: ({
          state,
          range
        }) => {
          const $from = state.doc.resolve(range.from);
          const type = state.schema.nodes[this.name];
          const allow = !!$from.parent.type.contentMatch.matchType(type);
          return allow;
        }
      }
    };
  },
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      },
      label: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-label"),
        renderHTML: (attributes) => {
          if (!attributes.label) {
            return {};
          }
          return {
            "data-label": attributes.label
          };
        }
      }
    };
  },
  parseHTML() {
    return [{
      tag: `span[data-type="${this.name}"]`
    }];
  },
  renderHTML({
    node,
    HTMLAttributes
  }) {
    if (this.options.renderLabel !== void 0) {
      console.warn("renderLabel is deprecated use renderText and renderHTML instead");
      return ["span", mergeAttributes({
        "data-type": this.name
      }, this.options.HTMLAttributes, HTMLAttributes), this.options.renderLabel({
        options: this.options,
        node
      })];
    }
    const mergedOptions = {
      ...this.options
    };
    mergedOptions.HTMLAttributes = mergeAttributes({
      "data-type": this.name
    }, this.options.HTMLAttributes, HTMLAttributes);
    const html = this.options.renderHTML({
      options: mergedOptions,
      node
    });
    if (typeof html === "string") {
      return ["span", mergeAttributes({
        "data-type": this.name
      }, this.options.HTMLAttributes, HTMLAttributes), html];
    }
    return html;
  },
  renderText({
    node
  }) {
    return this.options.renderText({
      options: this.options,
      node
    });
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({
        tr: tr3,
        state
      }) => {
        let isCommand = false;
        const {
          selection
        } = state;
        const {
          empty: empty3,
          anchor
        } = selection;
        if (!empty3) {
          return false;
        }
        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {
          if (node.type.name === this.name) {
            isCommand = true;
            tr3.insertText(this.options.deleteTriggerWithBackspace ? "" : this.options.suggestion.char || "", pos, pos + node.nodeSize);
            return false;
          }
          return true;
        });
        return isCommand;
      })
    };
  },
  addProseMirrorPlugins() {
    return [Suggestion({
      editor: this.editor,
      ...this.options.suggestion
    })];
  }
});
var suggestion = (ref2, {
  upload,
  aiController
}) => ({
  items: ({
    query
  }) => {
    const availableSuggestionItems = [...suggestionItems];
    if (aiController) {
      availableSuggestionItems.push(autocompleteSuggestionItem);
    }
    return availableSuggestionItems.filter((item) => {
      var _a;
      const inTitle = item.title.toLowerCase().startsWith(query.toLowerCase());
      if (inTitle) return inTitle;
      const inSearchTerms = (_a = item.searchTerms) == null ? void 0 : _a.some((term) => term.toLowerCase().startsWith(query.toLowerCase()));
      return inSearchTerms;
    });
  },
  render: () => {
    let component;
    let popup;
    return {
      onStart: (props) => {
        component = new ReactRenderer(CommandList, {
          props: {
            ...props,
            upload,
            aiController
          },
          editor: props.editor
        });
        if (!props.clientRect) {
          return;
        }
        popup = tippy_esm_default("body", {
          getReferenceClientRect: props.clientRect,
          appendTo: ref2 == null ? void 0 : ref2.current,
          content: component.element,
          showOnCreate: true,
          interactive: true,
          trigger: "manual",
          placement: "bottom-start"
        });
      },
      onUpdate(props) {
        component.updateProps(props);
        if (!props.clientRect) {
          return;
        }
        popup[0].setProps({
          getReferenceClientRect: props.clientRect
        });
      },
      onKeyDown(props) {
        var _a;
        if (props.event.key === "Escape") {
          popup[0].hide();
          props.event.preventDefault();
          return true;
        }
        return (_a = component.ref) == null ? void 0 : _a.onKeyDown(props);
      },
      onExit() {
        if (popup && popup[0]) popup[0].destroy();
        component == null ? void 0 : component.destroy();
      }
    };
  }
});
var CommandList = (0, import_react8.forwardRef)((props, ref2) => {
  const $ = (0, import_react_compiler_runtime2.c)(33);
  const [selectedIndex, setSelectedIndex] = (0, import_react8.useState)(0);
  const {
    editor
  } = useCurrentEditor();
  let t0;
  if ($[0] !== editor || $[1] !== props.aiController || $[2] !== props.range || $[3] !== props.upload) {
    t0 = (item) => {
      var _a;
      if (!editor) {
        return;
      }
      (_a = item == null ? void 0 : item.command) == null ? void 0 : _a.call(item, {
        editor,
        range: props.range,
        upload: props.upload,
        aiController: props.aiController
      });
    };
    $[0] = editor;
    $[1] = props.aiController;
    $[2] = props.range;
    $[3] = props.upload;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  const selectItem = t0;
  let t1;
  if ($[5] !== props.items.length || $[6] !== selectedIndex) {
    t1 = () => {
      setSelectedIndex((selectedIndex + props.items.length - 1) % props.items.length);
    };
    $[5] = props.items.length;
    $[6] = selectedIndex;
    $[7] = t1;
  } else {
    t1 = $[7];
  }
  const upHandler = t1;
  let t2;
  if ($[8] !== props.items.length || $[9] !== selectedIndex) {
    t2 = () => {
      setSelectedIndex((selectedIndex + 1) % props.items.length);
    };
    $[8] = props.items.length;
    $[9] = selectedIndex;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const downHandler = t2;
  let t3;
  if ($[11] !== props.items || $[12] !== selectItem || $[13] !== selectedIndex) {
    t3 = () => {
      const item_0 = props.items[selectedIndex];
      selectItem(item_0);
    };
    $[11] = props.items;
    $[12] = selectItem;
    $[13] = selectedIndex;
    $[14] = t3;
  } else {
    t3 = $[14];
  }
  const enterHandler = t3;
  let t4;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = () => setSelectedIndex(0);
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  let t5;
  if ($[16] !== props.items) {
    t5 = [props.items];
    $[16] = props.items;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  (0, import_react8.useEffect)(t4, t5);
  let t6;
  if ($[18] !== downHandler || $[19] !== enterHandler || $[20] !== upHandler) {
    t6 = () => ({
      onKeyDown: (t72) => {
        const {
          event
        } = t72;
        if (event.key === "ArrowUp") {
          upHandler();
          return true;
        }
        if (event.key === "ArrowDown") {
          downHandler();
          return true;
        }
        if (event.key === "Enter") {
          enterHandler();
          return true;
        }
        return false;
      }
    });
    $[18] = downHandler;
    $[19] = enterHandler;
    $[20] = upHandler;
    $[21] = t6;
  } else {
    t6 = $[21];
  }
  (0, import_react8.useImperativeHandle)(ref2, t6);
  let t7;
  if ($[22] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = [];
    $[22] = t7;
  } else {
    t7 = $[22];
  }
  const itemRefs = (0, import_react8.useRef)(t7);
  let t8;
  let t9;
  if ($[23] !== selectedIndex) {
    t8 = () => {
      if (itemRefs.current[selectedIndex]) {
        itemRefs.current[selectedIndex].scrollIntoView({
          block: "nearest"
        });
      }
    };
    t9 = [selectedIndex];
    $[23] = selectedIndex;
    $[24] = t8;
    $[25] = t9;
  } else {
    t8 = $[24];
    t9 = $[25];
  }
  (0, import_react8.useEffect)(t8, t9);
  let t10;
  if ($[26] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = cls("text-surface-900 dark:text-white z-50 max-h-[280px] h-auto w-72 overflow-y-auto rounded-md border bg-white dark:bg-surface-900 px-1 py-2 shadow transition-all", defaultBorderMixin);
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  let t11;
  if ($[27] !== props.items || $[28] !== selectItem || $[29] !== selectedIndex) {
    t11 = props.items.length ? props.items.map((item_1, index2) => (0, import_jsx_runtime.jsxs)("button", { value: item_1.title, ref: (el2) => {
      if (!el2) {
        return;
      }
      itemRefs.current[index2] = el2;
    }, onClick: () => selectItem(item_1), tabIndex: index2 === selectedIndex ? 0 : -1, "aria-selected": index2 === selectedIndex, className: cls("flex w-full items-center space-x-2 rounded-md px-2 py-1 text-left text-sm hover:bg-blue-50 hover:dark:bg-surface-700 aria-selected:bg-blue-50 aria-selected:dark:bg-surface-700", index2 === selectedIndex ? "bg-blue-100 dark:bg-surface-accent-950" : ""), children: [
      (0, import_jsx_runtime.jsx)("div", { className: cls("flex h-10 w-10 items-center justify-center rounded-md border bg-white dark:bg-surface-900", defaultBorderMixin), children: item_1.icon }),
      (0, import_jsx_runtime.jsxs)("div", { children: [
        (0, import_jsx_runtime.jsx)("p", { className: "font-medium", children: item_1.title }),
        (0, import_jsx_runtime.jsx)("p", { className: "text-xs text-surface-700 dark:text-surface-accent-300", children: item_1.description })
      ] })
    ] }, item_1.title)) : (0, import_jsx_runtime.jsx)("div", { className: "item", children: "No result" });
    $[27] = props.items;
    $[28] = selectItem;
    $[29] = selectedIndex;
    $[30] = t11;
  } else {
    t11 = $[30];
  }
  let t12;
  if ($[31] !== t11) {
    t12 = (0, import_jsx_runtime.jsx)("div", { className: t10, children: t11 });
    $[31] = t11;
    $[32] = t12;
  } else {
    t12 = $[32];
  }
  return t12;
});
CommandList.displayName = "CommandList";
var autocompleteSuggestionItem = {
  title: "Autocomplete",
  description: "Add text based on the context.",
  searchTerms: ["ai"],
  icon: (0, import_jsx_runtime.jsx)(AutoFixHighIcon, { size: 18 }),
  command: async ({
    editor,
    range,
    aiController
  }) => {
    if (!aiController) throw Error("No AiController");
    editor.chain().focus().deleteRange(range).toggleNode("paragraph", "paragraph").run();
    const {
      state
    } = editor;
    const {
      from: from2,
      to
    } = state.selection;
    const textBeforeCursor = state.doc.textBetween(0, from2, "\n");
    const textAfterCursor = state.doc.textBetween(to, state.doc.content.size, "\n");
    let buffer = "";
    const result = await aiController.autocomplete(textBeforeCursor, textAfterCursor, (delta) => {
      buffer += delta;
      if (delta.length !== 0) {
        editor.chain().focus().toggleLoadingDecoration(buffer).run();
      }
    });
    editor.chain().focus().insertContent(result, {
      applyInputRules: false,
      applyPasteRules: false,
      parseOptions: {
        preserveWhitespace: false
      }
    }).run();
  }
};
var suggestionItems = [{
  title: "Text",
  description: "Just start typing with plain text.",
  searchTerms: ["p", "paragraph"],
  icon: (0, import_jsx_runtime.jsx)(TextFieldsIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).toggleNode("paragraph", "paragraph").run();
  }
}, {
  title: "To-do List",
  description: "Track tasks with a to-do list.",
  searchTerms: ["todo", "task", "list", "check", "checkbox"],
  icon: (0, import_jsx_runtime.jsx)(CheckBoxIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).toggleTaskList().run();
  }
}, {
  title: "Heading 1",
  description: "Big section heading.",
  searchTerms: ["title", "big", "large"],
  icon: (0, import_jsx_runtime.jsx)(LooksOneIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).setNode("heading", {
      level: 1
    }).run();
  }
}, {
  title: "Heading 2",
  description: "Medium section heading.",
  searchTerms: ["subtitle", "medium"],
  icon: (0, import_jsx_runtime.jsx)(LooksTwoIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).setNode("heading", {
      level: 2
    }).run();
  }
}, {
  title: "Heading 3",
  description: "Small section heading.",
  searchTerms: ["subtitle", "small"],
  icon: (0, import_jsx_runtime.jsx)(Looks3Icon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).setNode("heading", {
      level: 3
    }).run();
  }
}, {
  title: "Bullet List",
  description: "Create a simple bullet list.",
  searchTerms: ["unordered", "point"],
  icon: (0, import_jsx_runtime.jsx)(FormatListBulletedIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).toggleBulletList().run();
  }
}, {
  title: "Numbered List",
  description: "Create a list with numbering.",
  searchTerms: ["ordered"],
  icon: (0, import_jsx_runtime.jsx)(FormatListNumberedIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => {
    editor.chain().focus().deleteRange(range).toggleOrderedList().run();
  }
}, {
  title: "Quote",
  description: "Capture a quote.",
  searchTerms: ["blockquote"],
  icon: (0, import_jsx_runtime.jsx)(FormatQuoteIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => editor.chain().focus().deleteRange(range).toggleNode("paragraph", "paragraph").toggleBlockquote().run()
}, {
  title: "Code",
  description: "Capture a code snippet.",
  searchTerms: ["codeblock"],
  icon: (0, import_jsx_runtime.jsx)(CodeIcon, { size: 18 }),
  command: ({
    editor,
    range
  }) => editor.chain().focus().deleteRange(range).toggleCodeBlock().run()
}, {
  title: "Image",
  description: "Upload an image from your computer.",
  searchTerms: ["photo", "picture", "media", "upload", "file"],
  icon: (0, import_jsx_runtime.jsx)(ImageIcon, { size: 18 }),
  command: ({
    editor,
    range,
    upload
  }) => {
    editor.chain().focus().deleteRange(range).run();
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "image/*";
    input.onchange = async () => {
      var _a;
      if ((_a = input.files) == null ? void 0 : _a.length) {
        const file = input.files[0];
        if (!file) return;
        const pos = editor.view.state.selection.from;
        const fileList = input.files;
        const files = Array.from(fileList);
        const images = files.filter((file2) => /image/i.test(file2.type));
        if (images.length === 0) {
          console.log("No images found in uploaded files");
          return false;
        }
        const view = editor.view;
        images.forEach((image) => {
          const reader = new FileReader();
          reader.onload = async (readerEvent) => {
            await onFileRead(view, readerEvent, pos, upload, image);
          };
          reader.readAsDataURL(image);
        });
      }
      return true;
    };
    input.click();
  }
}];
var CustomDocument = Document.extend({
  // content: 'heading block*',
});
var proseClasses = {
  "sm": "prose-sm",
  "base": "prose-base",
  "lg": "prose-lg"
};
var FireCMSEditor = ({
  content,
  onJsonContentChange,
  onHtmlContentChange,
  onMarkdownContentChange,
  version: version2,
  textSize = "base",
  highlight,
  handleImageUpload,
  aiController,
  disabled
}) => {
  const ref2 = import_react8.default.useRef(null);
  const editorRef = import_react8.default.useRef(null);
  const imagePlugin = createDropImagePlugin(handleImageUpload);
  const imageExtension = (0, import_react8.useMemo)(() => createImageExtension(imagePlugin), []);
  const [openNode, setOpenNode] = (0, import_react8.useState)(false);
  const [openLink, setOpenLink] = (0, import_react8.useState)(false);
  useInjectStyles("Editor", cssStyles);
  const deferredHighlight = (0, import_react8.useDeferredValue)(highlight);
  (0, import_react8.useEffect)(() => {
    var _a;
    if (version2 === void 0) return;
    if (version2 > -1 && editorRef.current) {
      (_a = editorRef.current) == null ? void 0 : _a.commands.setContent(content ?? "");
    }
  }, [version2]);
  (0, import_react8.useEffect)(() => {
    var _a;
    (_a = editorRef == null ? void 0 : editorRef.current) == null ? void 0 : _a.setEditable(!disabled);
  }, [disabled]);
  (0, import_react8.useEffect)(() => {
    if (version2 === void 0) return;
    if (editorRef.current && version2 > 0) {
      const chain = editorRef.current.chain();
      if (deferredHighlight) {
        chain.focus().toggleAutocompleteHighlight(deferredHighlight).run();
      } else {
        chain.focus().removeAutocompleteHighlight().run();
      }
    }
  }, [deferredHighlight == null ? void 0 : deferredHighlight.from, deferredHighlight == null ? void 0 : deferredHighlight.to]);
  const onEditorUpdate = (editor) => {
    editorRef.current = editor;
    if (onMarkdownContentChange) {
      const markdown = editorRef.current.storage.markdown.getMarkdown();
      onMarkdownContentChange == null ? void 0 : onMarkdownContentChange(addLineBreakAfterImages(markdown));
    }
    if (onJsonContentChange) {
      const jsonContent = removeClassesFromJson(editor.getJSON());
      onJsonContentChange(jsonContent);
    }
    if (onHtmlContentChange) {
      onHtmlContentChange == null ? void 0 : onHtmlContentChange(editor.getHTML());
    }
  };
  const proseClass = proseClasses[textSize];
  const extensions = (0, import_react8.useMemo)(() => [
    starterKit,
    CustomDocument,
    HighlightDecorationExtension(highlight),
    TextLoadingDecorationExtension,
    Underline,
    Bold2,
    TextStyle,
    Italic2,
    Strike2,
    Color,
    Highlight.configure({
      multicolor: true
    }),
    // CustomBlock.configure({
    //     component: CustomComponent,
    //     delimiter: "```custom"
    // }),
    Heading2,
    CustomKeymap,
    DragAndDrop,
    placeholder2,
    tiptapLink,
    imageExtension,
    taskList,
    taskItem,
    Markdown2.configure({
      html: true
    }),
    horizontalRule,
    bulletList,
    orderedList,
    listItem,
    blockquote,
    codeBlock,
    code,
    SlashCommand.configure({
      HTMLAttributes: {
        class: "mention"
      },
      suggestion: suggestion(ref2, {
        upload: handleImageUpload,
        aiController
      })
    })
  ], []);
  return (0, import_jsx_runtime.jsx)("div", { ref: ref2, className: "relative min-h-[300px] w-full", children: (0, import_jsx_runtime.jsx)(EditorProvider, { content: content ?? "", extensions, editorProps: {
    editable: () => !disabled,
    attributes: {
      class: cls(proseClass, "prose-headings:font-title font-default focus:outline-none max-w-full p-12")
    }
  }, onCreate: ({
    editor: editor_0
  }) => {
    editorRef.current = editor_0;
    editor_0.setEditable(!disabled);
  }, onUpdate: ({
    editor: editor_1
  }) => {
    onEditorUpdate(editor_1);
  }, children: (0, import_jsx_runtime.jsxs)(EditorBubble, { tippyOptions: {
    placement: "top"
  }, className: cls("flex w-fit max-w-[90vw] h-10 overflow-hidden rounded border bg-white dark:bg-surface-900 shadow", defaultBorderMixin), children: [
    (0, import_jsx_runtime.jsx)(NodeSelector, { portalContainer: ref2.current, open: openNode, onOpenChange: setOpenNode }),
    (0, import_jsx_runtime.jsx)(Separator, { orientation: "vertical" }),
    (0, import_jsx_runtime.jsx)(LinkSelector, { open: openLink, onOpenChange: setOpenLink }),
    (0, import_jsx_runtime.jsx)(Separator, { orientation: "vertical" }),
    (0, import_jsx_runtime.jsx)(TextButtons, {})
  ] }) }) });
};
function addLineBreakAfterImages(markdown) {
  const imageRegex = /!\[.*?\]\(.*?\)/g;
  return markdown.replace(imageRegex, (match85) => `${match85}
`);
}
var cssStyles = `
.ProseMirror {
    box-shadow: none !important;
}
.ProseMirror .is-editor-empty:first-child::before {
  content: attr(data-placeholder);
  float: left;
  color:  rgb(100 116 139); //500
  pointer-events: none;
  height: 0;
}
.ProseMirror .is-empty::before {
  content: attr(data-placeholder);
  float: left;
  color:  rgb(100 116 139); //500
  pointer-events: none;
  height: 0;
}

[data-theme="dark"] {
  .ProseMirror .is-empty::before {
    color: rgb(100 116 139); //500
  }
}

.is-empty {
  cursor: text;
  color: rgb(100 116 139); //500
}


/* Custom image styles */

.ProseMirror img {
  transition: filter 0.1s ease-in-out;

  &:hover {
    cursor: pointer;
    filter: brightness(90%);
  }

  &.ProseMirror-selectednode {
    outline: 3px solid #5abbf7;
    filter: brightness(90%);
    box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000) !important;
  }
}

/* Custom TODO list checkboxes – shoutout to this awesome tutorial: https://moderncss.dev/pure-css-custom-checkbox-style/ */

ul[data-type="taskList"] li > label {
  margin-right: 0.2rem;
  user-select: none;
}

@media screen and (max-width: 768px) {
  ul[data-type="taskList"] li > label {
    margin-right: 0.5rem;
  }
}


[data-theme="dark"] {
  ul[data-type="taskList"] li > label input[type="checkbox"] {
    background-color: rgb(30 41 59); // 800
    border: 2px solid #666;
  
    &:hover {
      background-color: rgb(51 65 85); // 700
    }
  
    &:active {
      background-color: rgb(71 85 105);
    }
  }
}
  

ul[data-type="taskList"] li > label input[type="checkbox"] {
  -webkit-appearance: none;
  appearance: none;
  background-color: white;
  margin: 0;
  cursor: pointer;
  width: 1.2em;
  height: 1.2em;
  position: relative;
  top: 5px;
  border: 2px solid #777;
  border-radius: 0.25em;
  margin-right: 0.3rem;
  display: grid;
  place-content: center;

  &:hover {
    background-color: rgb(241 245 249); //100
  }

  &:active {
    background-color: rgb(226 232 240); //200
  }

  &::before {
    content: "";
    width: 0.65em;
    height: 0.65em;
    transform: scale(0);
    transition: 120ms transform ease-in-out;
    box-shadow: inset 1em 1em;
    transform-origin: center;
    clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
  }

  &:checked::before {
    transform: scale(1);
  }
}

[data-theme="dark"] {
  ul[data-type="taskList"] li[data-checked="true"] > div > p {
    color: rgb(226 232 240);
    text-decoration: line-through;
    text-decoration-thickness: 2px;
  }
}

ul[data-type="taskList"] li[data-checked="true"] > div > p {
  color: rgb(51 65 85); // 700
  text-decoration: line-through;
  text-decoration-thickness: 2px;
}

/* Overwrite tippy-box original max-width */

.tippy-box {
  max-width: 400px !important;
}

.ProseMirror:not(.dragging) .ProseMirror-selectednode {
  // outline: none !important;
  background-color: rgb(219 234 254); // blue 100
  transition: background-color 0.2s;
  box-shadow: none;
}

[data-theme="dark"] .ProseMirror:not(.dragging) .ProseMirror-selectednode {
  background-color:  rgb(51 65 85); // 700
}

.prose-base table p {
    margin: 0;
}

.drag-handle {
  position: absolute;
  opacity: 1;
  transition: opacity ease-in 0.2s;
  border-radius: 0.25rem;

  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10' style='fill: rgba(128, 128, 128, 0.9)'%3E%3Cpath d='M3,2 C2.44771525,2 2,1.55228475 2,1 C2,0.44771525 2.44771525,0 3,0 C3.55228475,0 4,0.44771525 4,1 C4,1.55228475 3.55228475,2 3,2 Z M3,6 C2.44771525,6 2,5.55228475 2,5 C2,4.44771525 2.44771525,4 3,4 C3.55228475,4 4,4.44771525 4,5 C4,5.55228475 3.55228475,6 3,6 Z M3,10 C2.44771525,10 2,9.55228475 2,9 C2,8.44771525 2.44771525,8 3,8 C3.55228475,8 4,8.44771525 4,9 C4,9.55228475 3.55228475,10 3,10 Z M7,2 C6.44771525,2 6,1.55228475 6,1 C6,0.44771525 6.44771525,0 7,0 C7.55228475,0 8,0.44771525 8,1 C8,1.55228475 7.55228475,2 7,2 Z M7,6 C6.44771525,6 6,5.55228475 6,5 C6,4.44771525 6.44771525,4 7,4 C7.55228475,4 8,4.44771525 8,5 C8,5.55228475 7.55228475,6 7,6 Z M7,10 C6.44771525,10 6,9.55228475 6,9 C6,8.44771525 6.44771525,8 7,8 C7.55228475,8 8,8.44771525 8,9 C8,9.55228475 7.55228475,10 7,10 Z'%3E%3C/path%3E%3C/svg%3E");
  background-size: calc(0.5em + 0.375rem) calc(0.5em + 0.375rem);
  background-repeat: no-repeat;
  background-position: center;
  width: 1.2rem;
  height: 1.5rem;
  z-index: 100;
  cursor: grab;

  &:hover {
    background-color: rgb(241 245 249); //100
    transition: background-color 0.2s;
  }

  &:active {
    background-color: rgb(226 232 240); //200
    transition: background-color 0.2s;
  }

  &.hide {
    opacity: 0;
    pointer-events: none;
  }

  @media screen and (max-width: 600px) {
    display: none;
    pointer-events: none;
  }
}

[data-theme="dark"] .drag-handle {
  &:hover {
    background-color: rgb(51 65 85); // 700
  }

  &:active {
    background-color: rgb(51 65 85); // 700
  }
}
`;

// ../../../node_modules/prism-react-renderer/dist/index.mjs
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_prism = __commonJS2({
  "../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js"(exports, module) {
    var Prism2 = function() {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o2) {
            return Object.prototype.toString.call(o2).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o2, visited) {
            visited = visited || {};
            var clone3;
            var id2;
            switch (_.util.type(o2)) {
              case "Object":
                id2 = _.util.objId(o2);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone3 = /** @type {Record<string, any>} */
                {};
                visited[id2] = clone3;
                for (var key in o2) {
                  if (o2.hasOwnProperty(key)) {
                    clone3[key] = deepClone(o2[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone3
                );
              case "Array":
                id2 = _.util.objId(o2);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone3 = [];
                visited[id2] = clone3;
                o2.forEach(function(v, i2) {
                  clone3[i2] = deepClone(v, visited);
                });
                return (
                  /** @type {any} */
                  clone3
                );
              default:
                return o2;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id2, redef) {
            var lang2 = _.util.clone(_.languages[id2]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o2, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i2 in o2) {
              if (o2.hasOwnProperty(i2)) {
                callback.call(o2, i2, o2[i2], type || i2);
                var property = o2[i2];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i2, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray3(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks2 = _.hooks.all;
            hooks2[name] = hooks2[name] || [];
            hooks2[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i2 = 0, callback; callback = callbacks[i2++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o2, language) {
        if (typeof o2 == "string") {
          return o2;
        }
        if (Array.isArray(o2)) {
          var s2 = "";
          o2.forEach(function(e2) {
            s2 += stringify(e2, language);
          });
          return s2;
        }
        var env = {
          type: o2.type,
          content: stringify(o2.content, language),
          tag: "span",
          classes: ["token", o2.type],
          attributes: {},
          language
        };
        var aliases = o2.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match85 = pattern.exec(text);
        if (match85 && lookbehind && match85[1]) {
          var lookbehindLength = match85[1].length;
          match85.index += lookbehindLength;
          match85[0] = match85[0].slice(lookbehindLength);
        }
        return match85;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j2 = 0; j2 < patterns.length; ++j2) {
            if (rematch && rematch.cause == token + "," + j2) {
              return;
            }
            var patternObj = patterns[j2];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match85;
              if (greedy) {
                match85 = matchPattern(pattern, pos, text, lookbehind);
                if (!match85 || match85.index >= text.length) {
                  break;
                }
                var from2 = match85.index;
                var to = match85.index + match85[0].length;
                var p3 = pos;
                p3 += currentNode.value.length;
                while (from2 >= p3) {
                  currentNode = currentNode.next;
                  p3 += currentNode.value.length;
                }
                p3 -= currentNode.value.length;
                pos = p3;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k2 = currentNode; k2 !== tokenList.tail && (p3 < to || typeof k2.value === "string"); k2 = k2.next) {
                  removeCount++;
                  p3 += k2.value.length;
                }
                removeCount--;
                str = text.slice(pos, p3);
                match85.index -= pos;
              } else {
                match85 = matchPattern(pattern, 0, str, lookbehind);
                if (!match85) {
                  continue;
                }
              }
              var from2 = match85.index;
              var matchStr = match85[0];
              var before = str.slice(0, from2);
              var after = str.slice(from2 + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange2(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j2,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange2(list, node, count) {
        var next = node.next;
        for (var i2 = 0; i2 < count && next !== list.tail; i2++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i2;
      }
      function toArray3(list) {
        var array2 = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array2.push(node.value);
          node = node.next;
        }
        return array2;
      }
      return _;
    }();
    module.exports = Prism2;
    Prism2.default = Prism2;
  }
});
var Prism = __toESM2(require_prism());
Prism.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e2) {
  "entity" === e2.type && (e2.attributes.title = e2.content.replace(/&amp;/, "&"));
}), Object.defineProperty(Prism.languages.markup.tag, "addInlined", { value: function(e2, n2) {
  var t2 = {}, t2 = (t2["language-" + n2] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: Prism.languages[n2] }, t2.cdata = /^<!\[CDATA\[|\]\]>$/i, { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: t2 } }), n2 = (t2["language-" + n2] = { pattern: /[\s\S]+/, inside: Prism.languages[n2] }, {});
  n2[e2] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
    return e2;
  }), "i"), lookbehind: true, greedy: true, inside: t2 }, Prism.languages.insertBefore("markup", "cdata", n2);
} }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", { value: function(e2, n2) {
  Prism.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e2 + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [n2, "language-" + n2], inside: Prism.languages[n2] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
} }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml, function(e2) {
  var n2 = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" }, t2 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, a2 = "(?:[^\\\\-]|" + t2.source + ")", a2 = RegExp(a2 + "-" + a2), r2 = { pattern: /(<|')[^<>']+(?=[>']$)/, lookbehind: true, alias: "variable" };
  e2.languages.regex = { "char-class": { pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/, lookbehind: true, inside: { "char-class-negation": { pattern: /(^\[)\^/, lookbehind: true, alias: "operator" }, "char-class-punctuation": { pattern: /^\[|\]$/, alias: "punctuation" }, range: { pattern: a2, inside: { escape: t2, "range-punctuation": { pattern: /-/, alias: "operator" } } }, "special-escape": n2, "char-set": { pattern: /\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, escape: t2 } }, "special-escape": n2, "char-set": { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, backreference: [{ pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" }, { pattern: /\\k<[^<>']+>/, alias: "keyword", inside: { "group-name": r2 } }], anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" }, escape: t2, group: [{ pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/, alias: "punctuation", inside: { "group-name": r2 } }, { pattern: /\)/, alias: "punctuation" }], quantifier: { pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/, alias: "number" }, alternation: { pattern: /\|/, alias: "keyword" } };
}(Prism), Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.javascript = Prism.languages.extend("clike", { "class-name": [Prism.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source + ")" + /(?![\w$])/.source), lookbehind: true }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: Prism.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: Prism.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), Prism.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: true, greedy: true, alias: "property" } }), Prism.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: true, alias: "property" } }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), Prism.languages.js = Prism.languages.javascript, Prism.languages.actionscript = Prism.languages.extend("javascript", { keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/, operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/ }), Prism.languages.actionscript["class-name"].alias = "function", delete Prism.languages.actionscript.parameter, delete Prism.languages.actionscript["literal-property"], Prism.languages.markup && Prism.languages.insertBefore("actionscript", "string", { xml: { pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/, lookbehind: true, inside: Prism.languages.markup } }), function(e2) {
  var n2 = /#(?!\{).+/, t2 = { pattern: /#\{[^}]+\}/, alias: "variable" };
  e2.languages.coffeescript = e2.languages.extend("javascript", { comment: n2, string: [{ pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: true }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: true, inside: { interpolation: t2 } }], keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/, "class-member": { pattern: /@(?!\d)\w+/, alias: "variable" } }), e2.languages.insertBefore("coffeescript", "comment", { "multiline-comment": { pattern: /###[\s\S]+?###/, alias: "comment" }, "block-regex": { pattern: /\/{3}[\s\S]*?\/{3}/, alias: "regex", inside: { comment: n2, interpolation: t2 } } }), e2.languages.insertBefore("coffeescript", "string", { "inline-javascript": { pattern: /`(?:\\[\s\S]|[^\\`])*`/, inside: { delimiter: { pattern: /^`|`$/, alias: "punctuation" }, script: { pattern: /[\s\S]+/, alias: "language-javascript", inside: e2.languages.javascript } } }, "multiline-string": [{ pattern: /'''[\s\S]*?'''/, greedy: true, alias: "string" }, { pattern: /"""[\s\S]*?"""/, greedy: true, alias: "string", inside: { interpolation: t2 } }] }), e2.languages.insertBefore("coffeescript", "keyword", { property: /(?!\d)\w+(?=\s*:(?!:))/ }), delete e2.languages.coffeescript["template-string"], e2.languages.coffee = e2.languages.coffeescript;
}(Prism), function(l2) {
  var e2 = l2.languages.javadoclike = { parameter: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m, lookbehind: true }, keyword: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m, lookbehind: true }, punctuation: /[{}]/ };
  Object.defineProperty(e2, "addSupport", { value: function(e22, o2) {
    (e22 = "string" == typeof e22 ? [e22] : e22).forEach(function(e3) {
      var n2 = function(e4) {
        e4.inside || (e4.inside = {}), e4.inside.rest = o2;
      }, t2 = "doc-comment";
      if (a2 = l2.languages[e3]) {
        var a2, r2 = a2[t2];
        if ((r2 = r2 ? r2 : (a2 = l2.languages.insertBefore(e3, "comment", { "doc-comment": { pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/, lookbehind: true, alias: "comment" } }))[t2]) instanceof RegExp && (r2 = a2[t2] = { pattern: r2 }), Array.isArray(r2))
          for (var s2 = 0, i2 = r2.length; s2 < i2; s2++)
            r2[s2] instanceof RegExp && (r2[s2] = { pattern: r2[s2] }), n2(r2[s2]);
        else
          n2(r2);
      }
    });
  } }), e2.addSupport(["java", "javascript", "php"], e2);
}(Prism), function(e2) {
  var n2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/, n2 = (e2.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + n2.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + n2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + n2.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + n2.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: n2, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, e2.languages.css.atrule.inside.rest = e2.languages.css, e2.languages.markup);
  n2 && (n2.tag.addInlined("style", "css"), n2.tag.addAttribute("style", "css"));
}(Prism), function(e2) {
  var n2 = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, n2 = (e2.languages.css.selector = { pattern: e2.languages.css.selector.pattern, lookbehind: true, inside: n2 = { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+/, class: /\.[-\w]+/, id: /#[-\w]+/, attribute: { pattern: RegExp(`\\[(?:[^[\\]"']|` + n2.source + ")*\\]"), greedy: true, inside: { punctuation: /^\[|\]$/, "case-sensitivity": { pattern: /(\s)[si]$/i, lookbehind: true, alias: "keyword" }, namespace: { pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/, lookbehind: true, inside: { punctuation: /\|$/ } }, "attr-name": { pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/, lookbehind: true }, "attr-value": [n2, { pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/, lookbehind: true }], operator: /[|~*^$]?=/ } }, "n-th": [{ pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/, lookbehind: true, inside: { number: /[\dn]+/, operator: /[+-]/ } }, { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: true }], combinator: />|\+|~|\|\|/, punctuation: /[(),]/ } }, e2.languages.css.atrule.inside["selector-function-argument"].inside = n2, e2.languages.insertBefore("css", "property", { variable: { pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i, lookbehind: true } }), { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: true }), t2 = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true };
  e2.languages.insertBefore("css", "function", { operator: { pattern: /(\s)[+\-*\/](?=\s)/, lookbehind: true }, hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" }, color: [{ pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i, lookbehind: true }, { pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i, inside: { unit: n2, number: t2, function: /[\w-]+(?=\()/, punctuation: /[(),]/ } }], entity: /\\[\da-f]{1,8}/i, unit: n2, number: t2 });
}(Prism), function(e2) {
  var n2 = /[*&][^\s[\]{},]+/, t2 = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, a2 = "(?:" + t2.source + "(?:[ 	]+" + n2.source + ")?|" + n2.source + "(?:[ 	]+" + t2.source + ")?)", r2 = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  }), s2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function i2(e22, n22) {
    n22 = (n22 || "").replace(/m/g, "") + "m";
    var t22 = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return a2;
    }).replace(/<<value>>/g, function() {
      return e22;
    });
    return RegExp(t22, n22);
  }
  e2.languages.yaml = { scalar: { pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
    return a2;
  })), lookbehind: true, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
    return a2;
  }).replace(/<<key>>/g, function() {
    return "(?:" + r2 + "|" + s2 + ")";
  })), lookbehind: true, greedy: true, alias: "atrule" }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: true, alias: "important" }, datetime: { pattern: i2(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: true, alias: "number" }, boolean: { pattern: i2(/false|true/.source, "i"), lookbehind: true, alias: "important" }, null: { pattern: i2(/null|~/.source, "i"), lookbehind: true, alias: "important" }, string: { pattern: i2(s2), lookbehind: true, greedy: true }, number: { pattern: i2(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: true }, tag: t2, important: n2, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, e2.languages.yml = e2.languages.yaml;
}(Prism), function(o2) {
  var n2 = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function e2(e22) {
    return e22 = e22.replace(/<inner>/g, function() {
      return n2;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + e22 + ")");
  }
  var t2 = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, a2 = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return t2;
  }), r2 = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source, l2 = (o2.languages.markdown = o2.languages.extend("markup", {}), o2.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: o2.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + a2 + r2 + "(?:" + a2 + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + a2 + r2 + ")(?:" + a2 + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(t2), inside: o2.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + a2 + ")" + r2 + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + a2 + "$"), inside: { "table-header": { pattern: RegExp(t2), alias: "important", inside: o2.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: e2(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: e2(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: e2(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: e2(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(n22) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(e22) {
      n22 !== e22 && (o2.languages.markdown[n22].inside.content.inside[e22] = o2.languages.markdown[e22]);
    });
  }), o2.hooks.add("after-tokenize", function(e22) {
    "markdown" !== e22.language && "md" !== e22.language || !function e3(n22) {
      if (n22 && "string" != typeof n22)
        for (var t22 = 0, a22 = n22.length; t22 < a22; t22++) {
          var r22, s2 = n22[t22];
          "code" !== s2.type ? e3(s2.content) : (r22 = s2.content[1], s2 = s2.content[3], r22 && s2 && "code-language" === r22.type && "code-block" === s2.type && "string" == typeof r22.content && (r22 = r22.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), r22 = "language-" + (r22 = (/[a-z][\w-]*/i.exec(r22) || [""])[0].toLowerCase()), s2.alias ? "string" == typeof s2.alias ? s2.alias = [s2.alias, r22] : s2.alias.push(r22) : s2.alias = [r22]));
        }
    }(e22.tokens);
  }), o2.hooks.add("wrap", function(e22) {
    if ("code-block" === e22.type) {
      for (var n22 = "", t22 = 0, a22 = e22.classes.length; t22 < a22; t22++) {
        var r22 = e22.classes[t22], r22 = /language-(.+)/.exec(r22);
        if (r22) {
          n22 = r22[1];
          break;
        }
      }
      var s2, i2 = o2.languages[n22];
      i2 ? e22.content = o2.highlight(function(e3) {
        e3 = e3.replace(l2, "");
        return e3 = e3.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(e4, n3) {
          var t3;
          return "#" === (n3 = n3.toLowerCase())[0] ? (t3 = "x" === n3[1] ? parseInt(n3.slice(2), 16) : Number(n3.slice(1)), c5(t3)) : u3[n3] || e4;
        });
      }(e22.content), i2, n22) : n22 && "none" !== n22 && o2.plugins.autoloader && (s2 = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random()), e22.attributes.id = s2, o2.plugins.autoloader.loadLanguages(n22, function() {
        var e3 = document.getElementById(s2);
        e3 && (e3.innerHTML = o2.highlight(e3.textContent, o2.languages[n22], n22));
      }));
    }
  }), RegExp(o2.languages.markup.tag.pattern.source, "gi")), u3 = { amp: "&", lt: "<", gt: ">", quot: '"' }, c5 = String.fromCodePoint || String.fromCharCode;
  o2.languages.md = o2.languages.markdown;
}(Prism), Prism.languages.graphql = { comment: /#.*/, description: { pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i, greedy: true, alias: "string", inside: { "language-markdown": { pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/, lookbehind: true, inside: Prism.languages.markdown } } }, string: { pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/, greedy: true }, number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, boolean: /\b(?:false|true)\b/, variable: /\$[a-z_]\w*/i, directive: { pattern: /@[a-z_]\w*/i, alias: "function" }, "attr-name": { pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i, greedy: true }, "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" }, scalar: /\b(?:Boolean|Float|ID|Int|String)\b/, constant: /\b[A-Z][A-Z_\d]*\b/, "class-name": { pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/, lookbehind: true }, fragment: { pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-mutation": { pattern: /(\bmutation\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-query": { pattern: /(\bquery\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/, operator: /[!=|&]|\.{3}/, "property-query": /\w+(?=\s*\()/, object: /\w+(?=\s*\{)/, punctuation: /[!(){}\[\]:=,]/, property: /\w+/ }, Prism.hooks.add("after-tokenize", function(e2) {
  if ("graphql" === e2.language)
    for (var i2 = e2.tokens.filter(function(e22) {
      return "string" != typeof e22 && "comment" !== e22.type && "scalar" !== e22.type;
    }), o2 = 0; o2 < i2.length; ) {
      var n2 = i2[o2++];
      if ("keyword" === n2.type && "mutation" === n2.content) {
        var t2 = [];
        if (p3(["definition-mutation", "punctuation"]) && "(" === c5(1).content) {
          o2 += 2;
          var a2 = d(/^\($/, /^\)$/);
          if (-1 === a2)
            continue;
          for (; o2 < a2; o2++) {
            var r2 = c5(0);
            "variable" === r2.type && (g2(r2, "variable-input"), t2.push(r2.content));
          }
          o2 = a2 + 1;
        }
        if (p3(["punctuation", "property-query"]) && "{" === c5(0).content && (o2++, g2(c5(0), "property-mutation"), 0 < t2.length)) {
          var s2 = d(/^\{$/, /^\}$/);
          if (-1 !== s2)
            for (var l2 = o2; l2 < s2; l2++) {
              var u3 = i2[l2];
              "variable" === u3.type && 0 <= t2.indexOf(u3.content) && g2(u3, "variable-input");
            }
        }
      }
    }
  function c5(e22) {
    return i2[o2 + e22];
  }
  function p3(e22, n22) {
    n22 = n22 || 0;
    for (var t22 = 0; t22 < e22.length; t22++) {
      var a22 = c5(t22 + n22);
      if (!a22 || a22.type !== e22[t22])
        return;
    }
    return 1;
  }
  function d(e22, n22) {
    for (var t22 = 1, a22 = o2; a22 < i2.length; a22++) {
      var r22 = i2[a22], s22 = r22.content;
      if ("punctuation" === r22.type && "string" == typeof s22) {
        if (e22.test(s22))
          t22++;
        else if (n22.test(s22) && 0 === --t22)
          return a22;
      }
    }
    return -1;
  }
  function g2(e22, n22) {
    var t22 = e22.alias;
    t22 ? Array.isArray(t22) || (e22.alias = t22 = [t22]) : e22.alias = t22 = [], t22.push(n22);
  }
}), Prism.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: true }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: true }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: true, lookbehind: true }, identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: true, lookbehind: true, inside: { punctuation: /^`|`$/ } }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:FALSE|NULL|TRUE)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ }, function(b2) {
  var e2 = b2.languages.javascript["template-string"], t2 = e2.pattern.source, m = e2.inside.interpolation, f = m.inside["interpolation-punctuation"], s2 = m.pattern.source;
  function n2(e22, n22) {
    if (b2.languages[e22])
      return { pattern: RegExp("((?:" + n22 + ")\\s*)" + t2), lookbehind: true, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, "embedded-code": { pattern: /[\s\S]+/, alias: e22 } } };
  }
  function h2(e22, n22, t22) {
    e22 = { code: e22, grammar: n22, language: t22 };
    return b2.hooks.run("before-tokenize", e22), e22.tokens = b2.tokenize(e22.code, e22.grammar), b2.hooks.run("after-tokenize", e22), e22.tokens;
  }
  function l2(a22, e22, r2) {
    var n22 = b2.tokenize(a22, { interpolation: { pattern: RegExp(s2), lookbehind: true } }), p3 = 0, d = {}, n22 = h2(n22.map(function(e3) {
      if ("string" == typeof e3)
        return e3;
      for (var n3, t22, e3 = e3.content; -1 !== a22.indexOf((t22 = p3++, n3 = "___" + r2.toUpperCase() + "_" + t22 + "___")); )
        ;
      return d[n3] = e3, n3;
    }).join(""), e22, r2), g2 = Object.keys(d);
    return p3 = 0, function e3(n3) {
      for (var t22 = 0; t22 < n3.length; t22++) {
        if (p3 >= g2.length)
          return;
        var a3, r22, s22, i2, o2, l22, u22, c5 = n3[t22];
        "string" == typeof c5 || "string" == typeof c5.content ? (a3 = g2[p3], -1 !== (u22 = (l22 = "string" == typeof c5 ? c5 : c5.content).indexOf(a3)) && (++p3, r22 = l22.substring(0, u22), o2 = d[a3], s22 = void 0, (i2 = {})["interpolation-punctuation"] = f, 3 === (i2 = b2.tokenize(o2, i2)).length && ((s22 = [1, 1]).push.apply(s22, h2(i2[1], b2.languages.javascript, "javascript")), i2.splice.apply(i2, s22)), s22 = new b2.Token("interpolation", i2, m.alias, o2), i2 = l22.substring(u22 + a3.length), o2 = [], r22 && o2.push(r22), o2.push(s22), i2 && (e3(l22 = [i2]), o2.push.apply(o2, l22)), "string" == typeof c5 ? (n3.splice.apply(n3, [t22, 1].concat(o2)), t22 += o2.length - 1) : c5.content = o2)) : (u22 = c5.content, Array.isArray(u22) ? e3(u22) : e3([u22]));
      }
    }(n22), new b2.Token(r2, n22, "language-" + r2, a22);
  }
  b2.languages.javascript["template-string"] = [n2("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), n2("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source), n2("svg", /\bsvg/.source), n2("markdown", /\b(?:markdown|md)/.source), n2("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source), n2("sql", /\bsql/.source), e2].filter(Boolean);
  var a2 = { javascript: true, js: true, typescript: true, ts: true, jsx: true, tsx: true };
  function u3(e22) {
    return "string" == typeof e22 ? e22 : Array.isArray(e22) ? e22.map(u3).join("") : u3(e22.content);
  }
  b2.hooks.add("after-tokenize", function(e22) {
    e22.language in a2 && !function e3(n22) {
      for (var t22 = 0, a22 = n22.length; t22 < a22; t22++) {
        var r2, s22, i2, o2 = n22[t22];
        "string" != typeof o2 && (r2 = o2.content, Array.isArray(r2) ? "template-string" === o2.type ? (o2 = r2[1], 3 === r2.length && "string" != typeof o2 && "embedded-code" === o2.type && (s22 = u3(o2), o2 = o2.alias, o2 = Array.isArray(o2) ? o2[0] : o2, i2 = b2.languages[o2]) && (r2[1] = l2(s22, i2, o2))) : e3(r2) : "string" != typeof r2 && e3([r2]));
      }
    }(e22.tokens);
  });
}(Prism), function(e2) {
  e2.languages.typescript = e2.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/ }), e2.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete e2.languages.typescript.parameter, delete e2.languages.typescript["literal-property"];
  var n2 = e2.languages.extend("typescript", {});
  delete n2["class-name"], e2.languages.typescript["class-name"].inside = n2, e2.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: n2 } } } }), e2.languages.ts = e2.languages.typescript;
}(Prism), function(e2) {
  var n2 = e2.languages.javascript, t2 = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, a2 = "(@(?:arg|argument|param|property)\\s+(?:" + t2 + "\\s+)?)";
  e2.languages.jsdoc = e2.languages.extend("javadoclike", { parameter: { pattern: RegExp(a2 + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source), lookbehind: true, inside: { punctuation: /\./ } } }), e2.languages.insertBefore("jsdoc", "keyword", { "optional-parameter": { pattern: RegExp(a2 + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source), lookbehind: true, inside: { parameter: { pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/, lookbehind: true, inside: { punctuation: /\./ } }, code: { pattern: /(=)[\s\S]*(?=\]$)/, lookbehind: true, inside: n2, alias: "language-javascript" }, punctuation: /[=[\]]/ } }, "class-name": [{ pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
    return t2;
  })), lookbehind: true, inside: { punctuation: /\./ } }, { pattern: RegExp("(@[a-z]+\\s+)" + t2), lookbehind: true, inside: { string: n2.string, number: n2.number, boolean: n2.boolean, keyword: e2.languages.typescript.keyword, operator: /=>|\.\.\.|[&|?:*]/, punctuation: /[.,;=<>{}()[\]]/ } }], example: { pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/, lookbehind: true, inside: { code: { pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m, lookbehind: true, inside: n2, alias: "language-javascript" } } } }), e2.languages.javadoclike.addSupport("javascript", e2.languages.jsdoc);
}(Prism), function(e2) {
  e2.languages.flow = e2.languages.extend("javascript", {}), e2.languages.insertBefore("flow", "keyword", { type: [{ pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/, alias: "class-name" }] }), e2.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete e2.languages.flow.parameter, e2.languages.insertBefore("flow", "operator", { "flow-punctuation": { pattern: /\{\||\|\}/, alias: "punctuation" } }), Array.isArray(e2.languages.flow.keyword) || (e2.languages.flow.keyword = [e2.languages.flow.keyword]), e2.languages.flow.keyword.unshift({ pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/, lookbehind: true }, { pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/, lookbehind: true });
}(Prism), Prism.languages.n4js = Prism.languages.extend("javascript", { keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/ }), Prism.languages.insertBefore("n4js", "constant", { annotation: { pattern: /@+\w+/, alias: "operator" } }), Prism.languages.n4jsd = Prism.languages.n4js, function(e2) {
  function n2(e22, n22) {
    return RegExp(e22.replace(/<ID>/g, function() {
      return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
    }), n22);
  }
  e2.languages.insertBefore("javascript", "function-variable", { "method-variable": { pattern: RegExp("(\\.\\s*)" + e2.languages.javascript["function-variable"].pattern.source), lookbehind: true, alias: ["function-variable", "method", "function", "property-access"] } }), e2.languages.insertBefore("javascript", "function", { method: { pattern: RegExp("(\\.\\s*)" + e2.languages.javascript.function.source), lookbehind: true, alias: ["function", "property-access"] } }), e2.languages.insertBefore("javascript", "constant", { "known-class-name": [{ pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/, alias: "class-name" }, { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }] }), e2.languages.insertBefore("javascript", "keyword", { imports: { pattern: n2(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source), lookbehind: true, inside: e2.languages.javascript }, exports: { pattern: n2(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source), lookbehind: true, inside: e2.languages.javascript } }), e2.languages.javascript.keyword.unshift({ pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" }, { pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/, alias: "control-flow" }, { pattern: /\bnull\b/, alias: ["null", "nil"] }, { pattern: /\bundefined\b/, alias: "nil" }), e2.languages.insertBefore("javascript", "operator", { spread: { pattern: /\.{3}/, alias: "operator" }, arrow: { pattern: /=>/, alias: "operator" } }), e2.languages.insertBefore("javascript", "punctuation", { "property-access": { pattern: n2(/(\.\s*)#?<ID>/.source), lookbehind: true }, "maybe-class-name": { pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/, lookbehind: true }, dom: { pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/, alias: "variable" }, console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" } });
  for (var t2 = ["function", "function-variable", "method", "method-variable", "property-access"], a2 = 0; a2 < t2.length; a2++) {
    var r2 = t2[a2], s2 = e2.languages.javascript[r2], r2 = (s2 = "RegExp" === e2.util.type(s2) ? e2.languages.javascript[r2] = { pattern: s2 } : s2).inside || {};
    (s2.inside = r2)["maybe-class-name"] = /^[A-Z][\s\S]*/;
  }
}(Prism), function(s2) {
  var e2 = s2.util.clone(s2.languages.javascript), t2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, a2 = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, r2 = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function n2(e22, n22) {
    return e22 = e22.replace(/<S>/g, function() {
      return t2;
    }).replace(/<BRACES>/g, function() {
      return a2;
    }).replace(/<SPREAD>/g, function() {
      return r2;
    }), RegExp(e22, n22);
  }
  r2 = n2(r2).source, s2.languages.jsx = s2.languages.extend("markup", e2), s2.languages.jsx.tag.pattern = n2(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), s2.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, s2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, s2.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, s2.languages.jsx.tag.inside.comment = e2.comment, s2.languages.insertBefore("inside", "attr-name", { spread: { pattern: n2(/<SPREAD>/.source), inside: s2.languages.jsx } }, s2.languages.jsx.tag), s2.languages.insertBefore("inside", "special-attr", { script: { pattern: n2(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: s2.languages.jsx } } }, s2.languages.jsx.tag);
  function i2(e22) {
    for (var n22 = [], t22 = 0; t22 < e22.length; t22++) {
      var a22 = e22[t22], r22 = false;
      "string" != typeof a22 && ("tag" === a22.type && a22.content[0] && "tag" === a22.content[0].type ? "</" === a22.content[0].content[0].content ? 0 < n22.length && n22[n22.length - 1].tagName === o2(a22.content[0].content[1]) && n22.pop() : "/>" !== a22.content[a22.content.length - 1].content && n22.push({ tagName: o2(a22.content[0].content[1]), openedBraces: 0 }) : 0 < n22.length && "punctuation" === a22.type && "{" === a22.content ? n22[n22.length - 1].openedBraces++ : 0 < n22.length && 0 < n22[n22.length - 1].openedBraces && "punctuation" === a22.type && "}" === a22.content ? n22[n22.length - 1].openedBraces-- : r22 = true), (r22 || "string" == typeof a22) && 0 < n22.length && 0 === n22[n22.length - 1].openedBraces && (r22 = o2(a22), t22 < e22.length - 1 && ("string" == typeof e22[t22 + 1] || "plain-text" === e22[t22 + 1].type) && (r22 += o2(e22[t22 + 1]), e22.splice(t22 + 1, 1)), 0 < t22 && ("string" == typeof e22[t22 - 1] || "plain-text" === e22[t22 - 1].type) && (r22 = o2(e22[t22 - 1]) + r22, e22.splice(t22 - 1, 1), t22--), e22[t22] = new s2.Token("plain-text", r22, null, r22)), a22.content && "string" != typeof a22.content && i2(a22.content);
    }
  }
  var o2 = function(e22) {
    return e22 ? "string" == typeof e22 ? e22 : "string" == typeof e22.content ? e22.content : e22.content.map(o2).join("") : "";
  };
  s2.hooks.add("after-tokenize", function(e22) {
    "jsx" !== e22.language && "tsx" !== e22.language || i2(e22.tokens);
  });
}(Prism), function(e2) {
  var n2 = e2.util.clone(e2.languages.typescript), n2 = (e2.languages.tsx = e2.languages.extend("jsx", n2), delete e2.languages.tsx.parameter, delete e2.languages.tsx["literal-property"], e2.languages.tsx.tag);
  n2.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + n2.pattern.source + ")", n2.pattern.flags), n2.lookbehind = true;
}(Prism), Prism.languages.swift = { comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: true, greedy: true }, "string-literal": [{ pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" }, punctuation: /\\(?=[\r\n])/, string: /[\s\S]+/ } }, { pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" }, string: /[\s\S]+/ } }], directive: { pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"), alias: "property", inside: { "directive-name": /^#\w+/, boolean: /\b(?:false|true)\b/, number: /\b\d+(?:\.\d+)*\b/, operator: /!|&&|\|\||[<>]=?/, punctuation: /[(),]/ } }, literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" }, "other-directive": { pattern: /#\w+\b/, alias: "property" }, attribute: { pattern: /@\w+/, alias: "atrule" }, "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: true, alias: "function" }, label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: true, alias: "important" }, keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/, boolean: /\b(?:false|true)\b/, nil: { pattern: /\bnil\b/, alias: "constant" }, "short-argument": /\$\d+\b/, omit: { pattern: /\b_\b/, alias: "keyword" }, number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i, "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/, function: /\b[a-z_]\w*(?=\s*\()/i, constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/, operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/, punctuation: /[{}[\]();,.:\\]/ }, Prism.languages.swift["string-literal"].forEach(function(e2) {
  e2.inside.interpolation.inside = Prism.languages.swift;
}), function(e2) {
  e2.languages.kotlin = e2.languages.extend("clike", { keyword: { pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/, lookbehind: true }, function: [{ pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: true }, { pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/, lookbehind: true, greedy: true }], number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/, operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/ }), delete e2.languages.kotlin["class-name"];
  var n2 = { "interpolation-punctuation": { pattern: /^\$\{?|\}$/, alias: "punctuation" }, expression: { pattern: /[\s\S]+/, inside: e2.languages.kotlin } };
  e2.languages.insertBefore("kotlin", "string", { "string-literal": [{ pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/, alias: "multiline", inside: { interpolation: { pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i, inside: n2 }, string: /[\s\S]+/ } }, { pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/, alias: "singleline", inside: { interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i, lookbehind: true, inside: n2 }, string: /[\s\S]+/ } }], char: { pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/, greedy: true } }), delete e2.languages.kotlin.string, e2.languages.insertBefore("kotlin", "keyword", { annotation: { pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/, alias: "builtin" } }), e2.languages.insertBefore("kotlin", "function", { label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" } }), e2.languages.kt = e2.languages.kotlin, e2.languages.kts = e2.languages.kotlin;
}(Prism), Prism.languages.c = Prism.languages.extend("clike", { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: true }, keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/, function: /\b[a-z_]\w*(?=\s*\()/i, number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/ }), Prism.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: true } }), Prism.languages.insertBefore("c", "string", { macro: { pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im, lookbehind: true, greedy: true, alias: "property", inside: { string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: true }, Prism.languages.c.string], char: Prism.languages.c.char, comment: Prism.languages.c.comment, "macro-name": [{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: true }, { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: true, alias: "function" }], directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: true, alias: "keyword" }, "directive-hash": /^#/, punctuation: /##|\\(?=[\r\n])/, expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c } } } }), Prism.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ }), delete Prism.languages.c.boolean, Prism.languages.objectivec = Prism.languages.extend("c", { string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/, operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/ }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec, Prism.languages.reason = Prism.languages.extend("clike", { string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true }, "class-name": /\b[A-Z]\w*/, keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/, operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/ }), Prism.languages.insertBefore("reason", "class-name", { char: { pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/, greedy: true }, constructor: /\b[A-Z]\w*\b(?!\s*\.)/, label: { pattern: /\b[a-z]\w*(?=::)/, alias: "symbol" } }), delete Prism.languages.reason.function, function(e2) {
  for (var n2 = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, t2 = 0; t2 < 2; t2++)
    n2 = n2.replace(/<self>/g, function() {
      return n2;
    });
  n2 = n2.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e2.languages.rust = { comment: [{ pattern: RegExp(/(^|[^\\])/.source + n2), lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: true }, char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: true }, attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: true, alias: "attr-name", inside: { string: null } }, "closure-params": { pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/, lookbehind: true, greedy: true, inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null } }, "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" }, "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: true, alias: "punctuation" }, variable: /\$\w+/, "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: true, alias: "function" }, "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: true, alias: "class-name" }, "module-declaration": [{ pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: true, alias: "namespace" }, { pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/, lookbehind: true, alias: "namespace", inside: { punctuation: /::/ } }], keyword: [/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/], function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/, macro: { pattern: /\b\w+!/, alias: "property" }, constant: /\b[A-Z_][A-Z_\d]+\b/, "class-name": /\b[A-Z]\w*\b/, namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } }, number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/, boolean: /\b(?:false|true)\b/, punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/, operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/ }, e2.languages.rust["closure-params"].inside.rest = e2.languages.rust, e2.languages.rust.attribute.inside.string = e2.languages.rust.string;
}(Prism), Prism.languages.go = Prism.languages.extend("clike", { string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/, lookbehind: true, greedy: true }, keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, boolean: /\b(?:_|false|iota|nil|true)\b/, number: [/\b0(?:b[01_]+|o[0-7_]+)i?\b/i, /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i, /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i], operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/ }), Prism.languages.insertBefore("go", "string", { char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: true } }), delete Prism.languages.go["class-name"], function(e2) {
  var n2 = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, t2 = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return n2.source;
  });
  e2.languages.cpp = e2.languages.extend("c", { "class-name": [{ pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
    return n2.source;
  })), lookbehind: true }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/], keyword: n2, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i, greedy: true }, operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:false|true)\b/ }), e2.languages.insertBefore("cpp", "string", { module: { pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
    return t2;
  }) + ")"), lookbehind: true, greedy: true, inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ } }, "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: true } }), e2.languages.insertBefore("cpp", "keyword", { "generic-function": { pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i, inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e2.languages.cpp } } } }), e2.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }), e2.languages.insertBefore("cpp", "class-name", { "base-clause": { pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/, lookbehind: true, greedy: true, inside: e2.languages.extend("cpp", {}) } }), e2.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, e2.languages.cpp["base-clause"]);
}(Prism), Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: true, greedy: true }, "string-interpolation": { pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: true, inside: { interpolation: { pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/, lookbehind: true, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: true }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: true, alias: "string" }, string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: true }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: true }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: true }, decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: true, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:False|None|True)\b/, number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i, operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python, Prism.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: true, greedy: true }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: true, greedy: true }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, Prism.languages.webmanifest = Prism.languages.json;
var themes_exports = {};
__export2(themes_exports, {
  dracula: () => dracula_default,
  duotoneDark: () => duotoneDark_default,
  duotoneLight: () => duotoneLight_default,
  github: () => github_default,
  gruvboxMaterialDark: () => gruvboxMaterialDark_default,
  gruvboxMaterialLight: () => gruvboxMaterialLight_default,
  jettwaveDark: () => jettwaveDark_default,
  jettwaveLight: () => jettwaveLight_default,
  nightOwl: () => nightOwl_default,
  nightOwlLight: () => nightOwlLight_default,
  oceanicNext: () => oceanicNext_default,
  okaidia: () => okaidia_default,
  oneDark: () => oneDark_default,
  oneLight: () => oneLight_default,
  palenight: () => palenight_default,
  shadesOfPurple: () => shadesOfPurple_default,
  synthwave84: () => synthwave84_default,
  ultramin: () => ultramin_default,
  vsDark: () => vsDark_default,
  vsLight: () => vsLight_default
});
var theme = {
  plain: {
    color: "#F8F8F2",
    backgroundColor: "#282A36"
  },
  styles: [
    {
      types: ["prolog", "constant", "builtin"],
      style: {
        color: "rgb(189, 147, 249)"
      }
    },
    {
      types: ["inserted", "function"],
      style: {
        color: "rgb(80, 250, 123)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgb(255, 85, 85)"
      }
    },
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 184, 108)"
      }
    },
    {
      types: ["punctuation", "symbol"],
      style: {
        color: "rgb(248, 248, 242)"
      }
    },
    {
      types: ["string", "char", "tag", "selector"],
      style: {
        color: "rgb(255, 121, 198)"
      }
    },
    {
      types: ["keyword", "variable"],
      style: {
        color: "rgb(189, 147, 249)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(98, 114, 164)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(241, 250, 140)"
      }
    }
  ]
};
var dracula_default = theme;
var theme2 = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#6c6783"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#e09142"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#9a86fd"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#eeebff"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#c4b9fe"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule",
        "placeholder",
        "variable"
      ],
      style: {
        color: "#ffcc99"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#c4b9fe"
      }
    }
  ]
};
var duotoneDark_default = theme2;
var theme3 = {
  plain: {
    backgroundColor: "#faf8f5",
    color: "#728fcb"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#b6ad9a"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#063289"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#b29762"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#2d2006"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#896724"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule"
      ],
      style: {
        color: "#728fcb"
      }
    },
    {
      types: ["placeholder", "variable"],
      style: {
        color: "#93abdc"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#896724"
      }
    }
  ]
};
var duotoneLight_default = theme3;
var theme4 = {
  plain: {
    color: "#393A34",
    backgroundColor: "#f6f8fa"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#999988",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#e3116c"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#393A34"
      }
    },
    {
      types: [
        "entity",
        "url",
        "symbol",
        "number",
        "boolean",
        "variable",
        "constant",
        "property",
        "regex",
        "inserted"
      ],
      style: {
        color: "#36acaa"
      }
    },
    {
      types: ["atrule", "keyword", "attr-name", "selector"],
      style: {
        color: "#00a4db"
      }
    },
    {
      types: ["function", "deleted", "tag"],
      style: {
        color: "#d73a49"
      }
    },
    {
      types: ["function-variable"],
      style: {
        color: "#6f42c1"
      }
    },
    {
      types: ["tag", "selector", "keyword"],
      style: {
        color: "#00009f"
      }
    }
  ]
};
var github_default = theme4;
var theme5 = {
  plain: {
    color: "#d6deeb",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(99, 119, 119)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(214, 222, 235)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(255, 203, 139)"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "rgb(127, 219, 202)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["property"],
      style: {
        color: "rgb(128, 203, 196)"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    }
  ]
};
var nightOwl_default = theme5;
var theme6 = {
  plain: {
    color: "#403f53",
    backgroundColor: "#FBFBFB"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(72, 118, 214)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(152, 159, 177)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "builtin", "char", "constant", "url"],
      style: {
        color: "rgb(72, 118, 214)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(201, 103, 101)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(170, 9, 130)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["function", "selector", "doctype"],
      style: {
        color: "rgb(153, 76, 195)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(17, 17, 17)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["operator", "property", "keyword", "namespace"],
      style: {
        color: "rgb(12, 150, 155)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(188, 84, 84)"
      }
    }
  ]
};
var nightOwlLight_default = theme6;
var colors = {
  char: "#D8DEE9",
  comment: "#999999",
  keyword: "#c5a5c5",
  primitive: "#5a9bcf",
  string: "#8dc891",
  variable: "#d7deea",
  boolean: "#ff8b50",
  punctuation: "#5FB3B3",
  tag: "#fc929e",
  function: "#79b6f2",
  className: "#FAC863",
  method: "#6699CC",
  operator: "#fc929e"
};
var theme7 = {
  plain: {
    backgroundColor: "#282c34",
    color: "#ffffff"
  },
  styles: [
    {
      types: ["attr-name"],
      style: {
        color: colors.keyword
      }
    },
    {
      types: ["attr-value"],
      style: {
        color: colors.string
      }
    },
    {
      types: [
        "comment",
        "block-comment",
        "prolog",
        "doctype",
        "cdata",
        "shebang"
      ],
      style: {
        color: colors.comment
      }
    },
    {
      types: [
        "property",
        "number",
        "function-name",
        "constant",
        "symbol",
        "deleted"
      ],
      style: {
        color: colors.primitive
      }
    },
    {
      types: ["boolean"],
      style: {
        color: colors.boolean
      }
    },
    {
      types: ["tag"],
      style: {
        color: colors.tag
      }
    },
    {
      types: ["string"],
      style: {
        color: colors.string
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: colors.string
      }
    },
    {
      types: ["selector", "char", "builtin", "inserted"],
      style: {
        color: colors.char
      }
    },
    {
      types: ["function"],
      style: {
        color: colors.function
      }
    },
    {
      types: ["operator", "entity", "url", "variable"],
      style: {
        color: colors.variable
      }
    },
    {
      types: ["keyword"],
      style: {
        color: colors.keyword
      }
    },
    {
      types: ["atrule", "class-name"],
      style: {
        color: colors.className
      }
    },
    {
      types: ["important"],
      style: {
        fontWeight: "400"
      }
    },
    {
      types: ["bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    }
  ]
};
var oceanicNext_default = theme7;
var theme8 = {
  plain: {
    color: "#f8f8f2",
    backgroundColor: "#272822"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "#f92672",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#8292a2",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "#a6e22e"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["number"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "#e6db74"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "#a6e22e",
        fontStyle: "italic"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "#66d9ef"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)",
        opacity: 0.7
      }
    },
    {
      types: ["tag", "property"],
      style: {
        color: "#f92672"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#a6e22e !important"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "#8292a2"
      }
    },
    {
      types: ["rule"],
      style: {
        color: "#e6db74"
      }
    }
  ]
};
var okaidia_default = theme8;
var theme9 = {
  plain: {
    color: "#bfc7d5",
    backgroundColor: "#292d3e"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(105, 112, 152)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "inserted"],
      style: {
        color: "rgb(195, 232, 141)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      types: ["punctuation", "selector"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(191, 199, 213)"
      }
    },
    {
      types: ["class-name", "attr-name"],
      style: {
        color: "rgb(255, 203, 107)"
      }
    },
    {
      types: ["tag", "deleted"],
      style: {
        color: "rgb(255, 85, 114)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(137, 221, 255)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["keyword"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "rgb(221, 221, 221)"
      }
    }
  ]
};
var palenight_default = theme9;
var theme10 = {
  plain: {
    color: "#9EFEFF",
    backgroundColor: "#2D2A55"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(179, 98, 255)",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "rgb(255, 255, 255)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(165, 255, 144)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["number", "boolean"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 180, 84)"
      }
    },
    {
      types: [
        "keyword",
        "operator",
        "property",
        "namespace",
        "tag",
        "selector",
        "doctype"
      ],
      style: {
        color: "rgb(255, 157, 0)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "rgb(250, 208, 0)"
      }
    }
  ]
};
var shadesOfPurple_default = theme10;
var theme11 = {
  plain: {
    backgroundColor: "linear-gradient(to bottom, #2a2139 75%, #34294f)",
    backgroundImage: "#34294f",
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
  },
  styles: [
    {
      types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#495495",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#ccc"
      }
    },
    {
      types: [
        "tag",
        "attr-name",
        "namespace",
        "number",
        "unit",
        "hexcode",
        "deleted"
      ],
      style: {
        color: "#e2777a"
      }
    },
    {
      types: ["property", "selector"],
      style: {
        color: "#72f1b8",
        textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
      }
    },
    {
      types: ["function-name"],
      style: {
        color: "#6196cc"
      }
    },
    {
      types: ["boolean", "selector-id", "function"],
      style: {
        color: "#fdfdfd",
        textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      }
    },
    {
      types: ["class-name", "maybe-class-name", "builtin"],
      style: {
        color: "#fff5f6",
        textShadow: "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
      }
    },
    {
      types: ["constant", "symbol"],
      style: {
        color: "#f92aad",
        textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
      }
    },
    {
      types: ["important", "atrule", "keyword", "selector-class"],
      style: {
        color: "#f4eee4",
        textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      }
    },
    {
      types: ["string", "char", "attr-value", "regex", "variable"],
      style: {
        color: "#f87c32"
      }
    },
    {
      types: ["parameter"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity", "url"],
      style: {
        color: "#67cdcc"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "ffffffee"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity"],
      style: {
        cursor: "help"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "green"
      }
    }
  ]
};
var synthwave84_default = theme11;
var theme12 = {
  plain: {
    color: "#282a2e",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(197, 200, 198)"
      }
    },
    {
      types: ["string", "number", "builtin", "variable"],
      style: {
        color: "rgb(150, 152, 150)"
      }
    },
    {
      types: ["class-name", "function", "tag", "attr-name"],
      style: {
        color: "rgb(40, 42, 46)"
      }
    }
  ]
};
var ultramin_default = theme12;
var theme13 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "rgb(0, 0, 128)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(106, 153, 85)"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "rgb(181, 206, 168)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(100, 102, 149)"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "rgb(156, 220, 254)"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "rgb(206, 145, 120)"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "rgb(215, 186, 125)"
      }
    },
    {
      // Fix tag color
      types: ["tag"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      // Fix tag color for HTML
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "rgb(212, 212, 212)"
      }
    },
    {
      // Fix punctuation color for HTML
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "rgb(220, 220, 170)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      types: ["char"],
      style: {
        color: "rgb(209, 105, 105)"
      }
    }
  ]
};
var vsDark_default = theme13;
var theme14 = {
  plain: {
    color: "#000000",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(0, 128, 0)"
      }
    },
    {
      types: ["builtin"],
      style: {
        color: "rgb(0, 112, 193)"
      }
    },
    {
      types: ["number", "variable", "inserted"],
      style: {
        color: "rgb(9, 134, 88)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(0, 0, 0)"
      }
    },
    {
      types: ["constant", "char"],
      style: {
        color: "rgb(129, 31, 63)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(128, 0, 0)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 0, 0)"
      }
    },
    {
      types: ["deleted", "string"],
      style: {
        color: "rgb(163, 21, 21)"
      }
    },
    {
      types: ["changed", "punctuation"],
      style: {
        color: "rgb(4, 81, 165)"
      }
    },
    {
      types: ["function", "keyword"],
      style: {
        color: "rgb(0, 0, 255)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(38, 127, 153)"
      }
    }
  ]
};
var vsLight_default = theme14;
var theme15 = {
  plain: {
    color: "#f8fafc",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#569CD6"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#f8fafc"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#9CDCFE"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#cbd5e1"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#D4D4D4"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#7dd3fc"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var jettwaveDark_default = theme15;
var theme16 = {
  plain: {
    color: "#0f172a",
    backgroundColor: "#f1f5f9"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#0f172a"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#64748b"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#475569"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#0e7490"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var jettwaveLight_default = theme16;
var theme17 = {
  plain: {
    backgroundColor: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(220, 10%, 40%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "maybe-class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: { color: "hsl(29, 54%, 61%)" }
    },
    {
      types: ["keyword"],
      style: { color: "hsl(286, 60%, 67%)" }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(355, 65%, 65%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value"
      ],
      style: {
        color: "hsl(95, 38%, 62%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(207, 82%, 66%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(187, 47%, 55%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    }
  ]
};
var oneDark_default = theme17;
var theme18 = {
  plain: {
    backgroundColor: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(230, 4%, 64%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: {
        color: "hsl(35, 99%, 36%)"
      }
    },
    {
      types: ["keyword"],
      style: {
        color: "hsl(301, 63%, 40%)"
      }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(5, 74%, 59%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value",
        "punctuation"
      ],
      style: {
        color: "hsl(119, 34%, 47%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(221, 87%, 60%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(198, 99%, 37%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    }
  ]
};
var oneLight_default = theme18;
var theme19 = {
  plain: {
    color: "#ebdbb2",
    backgroundColor: "#292828"
  },
  styles: [
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin",
        "function"
      ],
      style: {
        color: "#d8a657"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#7daea3"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#e78a4e"
      }
    },
    {
      types: ["attr-name", "char", "url", "regex"],
      style: {
        color: "#a9b665"
      }
    },
    {
      types: ["attr-value", "string"],
      style: {
        color: "#89b482"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#ea6962"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#d3869b"
      }
    }
  ]
};
var gruvboxMaterialDark_default = theme19;
var theme20 = {
  plain: {
    color: "#654735",
    backgroundColor: "#f9f5d7"
  },
  styles: [
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#af2528"
      }
    },
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin"
      ],
      style: {
        color: "#b4730e"
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#477a5b"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#266b79"
      }
    },
    {
      types: ["function", "attr-name", "char", "url"],
      style: {
        color: "#72761e"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#b94c07"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#924f79"
      }
    }
  ]
};
var gruvboxMaterialLight_default = theme20;
var useGetLineProps = (themeDictionary) => (0, import_react11.useCallback)(
  (_a) => {
    var _b = _a, { className, style: style3, line } = _b, rest = __objRest(_b, ["className", "style", "line"]);
    const output = __spreadProps(__spreadValues({}, rest), {
      className: clsx_default("token-line", className)
    });
    if (typeof themeDictionary === "object" && "plain" in themeDictionary)
      output.style = themeDictionary.plain;
    if (typeof style3 === "object")
      output.style = __spreadValues(__spreadValues({}, output.style || {}), style3);
    return output;
  },
  [themeDictionary]
);
var useGetTokenProps = (themeDictionary) => {
  const styleForToken = (0, import_react12.useCallback)(
    ({ types, empty: empty3 }) => {
      if (themeDictionary == null)
        return void 0;
      else if (types.length === 1 && types[0] === "plain") {
        return empty3 != null ? { display: "inline-block" } : void 0;
      } else if (types.length === 1 && empty3 != null) {
        return themeDictionary[types[0]];
      }
      return Object.assign(
        empty3 != null ? { display: "inline-block" } : {},
        ...types.map((type) => themeDictionary[type])
      );
    },
    [themeDictionary]
  );
  return (0, import_react12.useCallback)(
    (_a) => {
      var _b = _a, { token, className, style: style3 } = _b, rest = __objRest(_b, ["token", "className", "style"]);
      const output = __spreadProps(__spreadValues({}, rest), {
        className: clsx_default("token", ...token.types, className),
        children: token.content,
        style: styleForToken(token)
      });
      if (style3 != null) {
        output.style = __spreadValues(__spreadValues({}, output.style || {}), style3);
      }
      return output;
    },
    [styleForToken]
  );
};
var newlineRe = /\r\n|\r|\n/;
var normalizeEmptyLines = (line) => {
  if (line.length === 0) {
    line.push({
      types: ["plain"],
      content: "\n",
      empty: true
    });
  } else if (line.length === 1 && line[0].content === "") {
    line[0].content = "\n";
    line[0].empty = true;
  }
};
var appendTypes = (types, add3) => {
  const typesSize = types.length;
  if (typesSize > 0 && types[typesSize - 1] === add3) {
    return types;
  }
  return types.concat(add3);
};
var normalizeTokens = (tokens) => {
  const typeArrStack = [[]];
  const tokenArrStack = [tokens];
  const tokenArrIndexStack = [0];
  const tokenArrSizeStack = [tokens.length];
  let i2 = 0;
  let stackIndex = 0;
  let currentLine = [];
  const acc = [currentLine];
  while (stackIndex > -1) {
    while ((i2 = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
      let content;
      let types = typeArrStack[stackIndex];
      const tokenArr = tokenArrStack[stackIndex];
      const token = tokenArr[i2];
      if (typeof token === "string") {
        types = stackIndex > 0 ? types : ["plain"];
        content = token;
      } else {
        types = appendTypes(types, token.type);
        if (token.alias) {
          types = appendTypes(types, token.alias);
        }
        content = token.content;
      }
      if (typeof content !== "string") {
        stackIndex++;
        typeArrStack.push(types);
        tokenArrStack.push(content);
        tokenArrIndexStack.push(0);
        tokenArrSizeStack.push(content.length);
        continue;
      }
      const splitByNewlines = content.split(newlineRe);
      const newlineCount = splitByNewlines.length;
      currentLine.push({
        types,
        content: splitByNewlines[0]
      });
      for (let i22 = 1; i22 < newlineCount; i22++) {
        normalizeEmptyLines(currentLine);
        acc.push(currentLine = []);
        currentLine.push({
          types,
          content: splitByNewlines[i22]
        });
      }
    }
    stackIndex--;
    typeArrStack.pop();
    tokenArrStack.pop();
    tokenArrIndexStack.pop();
    tokenArrSizeStack.pop();
  }
  normalizeEmptyLines(currentLine);
  return acc;
};
var normalizeTokens_default = normalizeTokens;
var useTokenize = ({ prism, code: code2, grammar, language }) => {
  return (0, import_react13.useMemo)(() => {
    if (grammar == null)
      return normalizeTokens_default([code2]);
    const prismConfig = {
      code: code2,
      grammar,
      language,
      tokens: []
    };
    prism.hooks.run("before-tokenize", prismConfig);
    prismConfig.tokens = prism.tokenize(code2, grammar);
    prism.hooks.run("after-tokenize", prismConfig);
    return normalizeTokens_default(prismConfig.tokens);
  }, [
    code2,
    grammar,
    language,
    // prism is a stable import
    prism
  ]);
};
var themeToDict = (theme21, language) => {
  const { plain } = theme21;
  const themeDict = theme21.styles.reduce((acc, themeEntry) => {
    const { languages: languages2, style: style3 } = themeEntry;
    if (languages2 && !languages2.includes(language)) {
      return acc;
    }
    themeEntry.types.forEach((type) => {
      const accStyle = __spreadValues(__spreadValues({}, acc[type]), style3);
      acc[type] = accStyle;
    });
    return acc;
  }, {});
  themeDict.root = plain;
  themeDict.plain = __spreadProps(__spreadValues({}, plain), { backgroundColor: void 0 });
  return themeDict;
};
var themeToDict_default = themeToDict;
var Highlight2 = ({
  children,
  language: _language,
  code: code2,
  theme: theme21,
  prism
}) => {
  const language = _language.toLowerCase();
  const themeDictionary = themeToDict_default(theme21, language);
  const getLineProps = useGetLineProps(themeDictionary);
  const getTokenProps = useGetTokenProps(themeDictionary);
  const grammar = prism.languages[language];
  const tokens = useTokenize({ prism, language, code: code2, grammar });
  return children({
    tokens,
    className: `prism-code language-${language}`,
    style: themeDictionary != null ? themeDictionary.root : {},
    getLineProps,
    getTokenProps
  });
};
var Highlight22 = (props) => (0, import_react10.createElement)(Highlight2, __spreadProps(__spreadValues({}, props), {
  prism: props.prism || Prism,
  theme: props.theme || vsDark_default,
  code: props.code,
  language: props.language
}));

// ../../../node_modules/@firecms/core/dist/index.es.js
var SnackbarProvider2 = (t0) => {
  const $ = (0, import_react_compiler_runtime3.c)(2);
  const {
    children
  } = t0;
  let t1;
  if ($[0] !== children) {
    t1 = (0, import_jsx_runtime2.jsx)(SnackbarProvider, { maxSnack: 3, autoHideDuration: 3500, children });
    $[0] = children;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  return t1;
};
var DEFAULT_MODE_STATE = {
  mode: "light",
  setMode: (mode) => {
  }
};
var ModeControllerContext = import_react14.default.createContext(DEFAULT_MODE_STATE);
var ModeControllerProvider = ModeControllerContext.Provider;
var AuthControllerContext = import_react14.default.createContext({});
function removeInitialAndTrailingSlashes(s2) {
  return removeInitialSlash(removeTrailingSlash(s2));
}
function removeInitialSlash(s2) {
  if (s2.startsWith("/")) return s2.slice(1);
  else return s2;
}
function removeTrailingSlash(s2) {
  if (s2.endsWith("/")) return s2.slice(0, -1);
  else return s2;
}
function addInitialSlash(s2) {
  if (s2.startsWith("/")) return s2;
  else return `/${s2}`;
}
function getLastSegment(path) {
  const cleanPath = removeInitialAndTrailingSlashes(path);
  if (cleanPath.includes("/")) {
    const segments = cleanPath.split("/");
    return segments[segments.length - 1];
  }
  return cleanPath;
}
function resolveCollectionPathIds(path, allCollections) {
  var _a;
  const cleanPath = removeInitialAndTrailingSlashes(path);
  const subpaths = cleanPath.split("/");
  if (subpaths.length % 2 === 0) {
    throw Error(`resolveCollectionPathIds: Collection paths must have an odd number of segments: ${path}`);
  }
  const exactMatch = allCollections.find((col) => col.path === cleanPath);
  if (exactMatch) {
    return exactMatch.path;
  }
  if (subpaths.length === 1) {
    const aliasedCollection = allCollections.find((col) => col.id === subpaths[0]);
    return (aliasedCollection == null ? void 0 : aliasedCollection.path) ?? subpaths[0];
  }
  let matchingCollection;
  let entityIndex = 1;
  for (const collection of allCollections) {
    const pathSegments = collection.path.split("/");
    if (pathSegments.length > 1 && subpaths.slice(0, pathSegments.length).join("/") === collection.path) {
      matchingCollection = collection;
      entityIndex = pathSegments.length;
      break;
    }
  }
  if (!matchingCollection) {
    const matchingCollections = allCollections.filter((col) => col.id === subpaths[0] || col.path === subpaths[0]);
    if (!matchingCollections.length) {
      return cleanPath;
    }
    matchingCollection = matchingCollections[0];
  }
  const entityId = subpaths[entityIndex];
  const remainingPath = subpaths.slice(entityIndex + 1);
  if (remainingPath.length > 0) {
    const subcollectionId = remainingPath[0];
    const subcollection = (_a = matchingCollection.subcollections) == null ? void 0 : _a.find((subcol) => subcol.id === subcollectionId);
    if (subcollection) {
      return `${matchingCollection.path}/${entityId}/${subcollection.path}`;
    }
  }
  if (remainingPath.length === 0) {
    return `${matchingCollection.path}/${entityId}`;
  }
  return `${matchingCollection.path}/${entityId}/${remainingPath.join("/")}`;
}
function getCollectionByPathOrId(pathOrId, collections) {
  const subpaths = removeInitialAndTrailingSlashes(pathOrId).split("/");
  if (subpaths.length % 2 === 0) {
    throw Error(`getCollectionByPathOrId: Collection paths must have an odd number of segments: ${pathOrId}`);
  }
  const subpathCombinations = getCollectionPathsCombinations(subpaths);
  let result;
  for (let i2 = 0; i2 < subpathCombinations.length; i2++) {
    const subpathCombination = subpathCombinations[i2];
    const navigationEntry = collections && collections.sort((a2, b2) => (a2.id ?? "").localeCompare(b2.id ?? "")).find((entry) => entry.id === subpathCombination || entry.path === subpathCombination);
    if (navigationEntry) {
      if (subpathCombination === pathOrId) {
        result = navigationEntry;
      } else if (navigationEntry.subcollections) {
        const newPath = pathOrId.replace(subpathCombination, "").split("/").slice(2).join("/");
        if (newPath.length > 0) result = getCollectionByPathOrId(newPath, navigationEntry.subcollections);
      }
    }
    if (result) break;
  }
  return result;
}
function getCollectionPathsCombinations(subpaths) {
  const entries = subpaths.length > 0 && subpaths.length % 2 === 0 ? subpaths.splice(0, subpaths.length - 1) : subpaths;
  const length = entries.length;
  const result = [];
  for (let i2 = length; i2 > 0; i2 = i2 - 2) {
    result.push(entries.slice(0, i2).join("/"));
  }
  return result;
}
function navigateToEntity({
  openEntityMode,
  collection,
  entityId,
  copy: copy2,
  path,
  fullIdPath,
  selectedTab,
  sideEntityController,
  onClose,
  navigation
}) {
  if (openEntityMode === "side_panel") {
    sideEntityController.open({
      entityId,
      path: fullIdPath ?? path,
      // fullIdPath,
      copy: copy2,
      selectedTab,
      collection,
      updateUrl: true,
      onClose
    });
  } else {
    let to = navigation.buildUrlCollectionPath(entityId ? `${fullIdPath ?? path}/${entityId}` : fullIdPath ?? path);
    if (entityId && selectedTab) {
      to += `/${selectedTab}`;
    }
    if (!entityId) {
      to += "#new";
    }
    if (copy2) {
      to += "#copy";
    }
    navigation.navigate(to);
  }
}
var EntityReference = class {
  constructor(id2, path) {
    /**
     * ID of the entity
     */
    __publicField(this, "id");
    /**
     * A string representing the path of the referenced document (relative
     * to the root of the database).
     */
    __publicField(this, "path");
    this.id = id2;
    this.path = path;
  }
  get pathWithId() {
    return `${this.path}/${this.id}`;
  }
  isEntityReference() {
    return true;
  }
};
var GeoPoint = class {
  constructor(latitude, longitude) {
    /**
     * The latitude of this GeoPoint instance.
     */
    __publicField(this, "latitude");
    /**
     * The longitude of this GeoPoint instance.
     */
    __publicField(this, "longitude");
    this.latitude = latitude;
    this.longitude = longitude;
  }
};
var Vector = class {
  constructor(value) {
    __publicField(this, "value");
    this.value = value;
  }
};
var pick = (obj, ...args) => ({
  ...args.reduce((res, key) => ({
    ...res,
    [key]: obj[key]
  }), {})
});
function isObject4(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep2(target, source, ignoreUndefined = false) {
  const targetIsObject = isObject4(target);
  const output = targetIsObject ? {
    ...target
  } : target;
  if (targetIsObject && isObject4(source)) {
    Object.keys(source).forEach((key) => {
      const sourceElement = source[key];
      if (ignoreUndefined && sourceElement === void 0) {
        return;
      }
      if (sourceElement instanceof Date) {
        Object.assign(output, {
          [key]: new Date(sourceElement.getTime())
        });
      } else if (isObject4(sourceElement)) {
        if (!(key in target)) Object.assign(output, {
          [key]: sourceElement
        });
        else output[key] = mergeDeep2(target[key], sourceElement);
      } else {
        Object.assign(output, {
          [key]: sourceElement
        });
      }
    });
  }
  return output;
}
function getValueInPath(o2, path) {
  if (!o2) return void 0;
  if (typeof o2 === "object") {
    if (path in o2) {
      return o2[path];
    }
    if (path.includes(".") || path.includes("[")) {
      let pathSegments = path.split(/[.[]/);
      if (path.includes("[")) {
        pathSegments = pathSegments.map((segment) => segment.replace("]", ""));
      }
      const firstSegment = pathSegments[0];
      const isArrayAndIndexExists = Array.isArray(o2[firstSegment]) && !isNaN(parseInt(pathSegments[1]));
      const nextObject = isArrayAndIndexExists ? o2[firstSegment][parseInt(pathSegments[1])] : o2[firstSegment];
      const nextPath = pathSegments.slice(isArrayAndIndexExists ? 2 : 1).join(".");
      if (nextPath === "") return nextObject;
      return getValueInPath(nextObject, nextPath);
    }
  }
  return void 0;
}
function removeInPath(o2, path) {
  let currentObject = {
    ...o2
  };
  const parts = path.split(".");
  const last = parts.pop();
  for (const part of parts) {
    currentObject = currentObject[part];
  }
  if (last) delete currentObject[last];
  return currentObject;
}
function removeFunctions(o2) {
  if (o2 === void 0) return void 0;
  if (o2 === null) return null;
  if (typeof o2 === "object") {
    return Object.entries(o2).filter(([_, value]) => typeof value !== "function").map(([key, value]) => {
      if (Array.isArray(value)) {
        return {
          [key]: value.map((v) => removeFunctions(v))
        };
      } else if (typeof value === "object") {
        return {
          [key]: removeFunctions(value)
        };
      } else return {
        [key]: value
      };
    }).reduce((a2, b2) => ({
      ...a2,
      ...b2
    }), {});
  }
  return o2;
}
function getHashValue(v) {
  if (!v) return null;
  if (typeof v === "object") {
    if ("id" in v) return v.id;
    else if (v instanceof Date) return v.toLocaleString();
    else if (v instanceof GeoPoint) return (0, import_object_hash.default)(v);
  }
  return (0, import_object_hash.default)(v, {
    ignoreUnknown: true
  });
}
function removeUndefined(value, removeEmptyStrings) {
  if (typeof value === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((v) => removeUndefined(v, removeEmptyStrings));
  }
  if (typeof value === "object") {
    const res = {};
    if (value === null) return value;
    Object.keys(value).forEach((key) => {
      if (!isEmptyObject2(value)) {
        const childRes = removeUndefined(value[key], removeEmptyStrings);
        const isString2 = typeof childRes === "string";
        const shouldKeepIfString = !removeEmptyStrings || removeEmptyStrings && !isString2 || removeEmptyStrings && isString2 && childRes !== "";
        if (childRes !== void 0 && !isEmptyObject2(childRes) && shouldKeepIfString) res[key] = childRes;
      }
    });
    return res;
  }
  return value;
}
function removeNulls(value) {
  if (typeof value === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((v) => removeNulls(v));
  }
  if (typeof value === "object") {
    const res = {};
    if (value === null) return value;
    Object.keys(value).forEach((key) => {
      if (value[key] !== null) res[key] = removeNulls(value[key]);
    });
    return res;
  }
  return value;
}
function isEmptyObject2(obj) {
  return obj && Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length === 0;
}
function removePropsIfExisting(source, comparison) {
  const isObject22 = (val) => typeof val === "object" && val !== null;
  const isArray2 = (val) => Array.isArray(val);
  if (!isObject22(source) || !isObject22(comparison)) {
    return source;
  }
  const res = isArray2(source) ? [...source] : {
    ...source
  };
  if (isArray2(res)) {
    for (let i2 = res.length - 1; i2 >= 0; i2--) {
      if (res[i2] === comparison[i2]) {
        res.splice(i2, 1);
      } else if (isObject22(res[i2]) && isObject22(comparison[i2])) {
        res[i2] = removePropsIfExisting(res[i2], comparison[i2]);
      }
    }
  } else {
    Object.keys(comparison).forEach((key) => {
      if (key in res) {
        if (isObject22(res[key]) && isObject22(comparison[key])) {
          res[key] = removePropsIfExisting(res[key], comparison[key]);
        } else if (res[key] === comparison[key]) {
          delete res[key];
        }
      }
    });
  }
  return res;
}
var DEFAULT_ONE_OF_TYPE = "type";
var DEFAULT_ONE_OF_VALUE = "value";
function isReadOnly(property) {
  if (property.readOnly) return true;
  if (property.dataType === "date") {
    if (property.autoValue) return true;
  }
  if (property.dataType === "reference") {
    return !property.path;
  }
  return false;
}
function isHidden(property) {
  return typeof property.disabled === "object" && Boolean(property.disabled.hidden);
}
function isPropertyBuilder(propertyOrBuilder) {
  return typeof propertyOrBuilder === "function";
}
function getDefaultValuesFor(properties) {
  if (!properties) return {};
  return Object.entries(properties).map(([key, property]) => {
    if (!property) return {};
    const value = getDefaultValueFor(property);
    return value === void 0 ? {} : {
      [key]: value
    };
  }).reduce((a2, b2) => ({
    ...a2,
    ...b2
  }), {});
}
function getDefaultValueFor(property) {
  if (!property) return void 0;
  if (isPropertyBuilder(property)) return void 0;
  if (property.defaultValue || property.defaultValue === null) {
    return property.defaultValue;
  } else if (property.dataType === "map" && property.properties) {
    const defaultValuesFor = getDefaultValuesFor(property.properties);
    if (Object.keys(defaultValuesFor).length === 0) return void 0;
    return defaultValuesFor;
  } else {
    return getDefaultValueForDataType(property.dataType);
  }
}
function getDefaultValueForDataType(dataType) {
  if (dataType === "string") {
    return null;
  } else if (dataType === "number") {
    return null;
  } else if (dataType === "boolean") {
    return false;
  } else if (dataType === "date") {
    return null;
  } else if (dataType === "array") {
    return [];
  } else if (dataType === "map") {
    return {};
  } else {
    return null;
  }
}
function updateDateAutoValues({
  inputValues,
  properties,
  status,
  timestampNowValue,
  setDateToMidnight
}) {
  return traverseValuesProperties(inputValues, properties, (inputValue, property) => {
    if (property.dataType === "date") {
      let resultDate;
      if (status === "existing" && property.autoValue === "on_update") {
        resultDate = timestampNowValue;
      } else if ((status === "new" || status === "copy") && (property.autoValue === "on_update" || property.autoValue === "on_create")) {
        resultDate = timestampNowValue;
      } else {
        resultDate = inputValue;
      }
      if (property.mode === "date") resultDate = setDateToMidnight(resultDate);
      return resultDate;
    } else {
      return inputValue;
    }
  }) ?? {};
}
function sanitizeData(values, properties) {
  const result = values;
  Object.entries(properties).forEach(([key, property]) => {
    var _a;
    if (values && values[key] !== void 0) result[key] = values[key];
    else if ((_a = property.validation) == null ? void 0 : _a.required) result[key] = null;
  });
  return result;
}
function getReferenceFrom(entity) {
  return new EntityReference(entity.id, entity.path);
}
function traverseValuesProperties(inputValues, properties, operation) {
  const updatedValues = Object.entries(properties).map(([key, property]) => {
    const inputValue = inputValues && inputValues[key];
    const updatedValue = traverseValueProperty(inputValue, property, operation);
    if (updatedValue === null) return null;
    if (updatedValue === void 0) return void 0;
    return {
      [key]: updatedValue
    };
  }).reduce((a2, b2) => ({
    ...a2,
    ...b2
  }), {});
  const result = {
    ...inputValues,
    ...updatedValues
  };
  if (Object.keys(result).length === 0) return void 0;
  return result;
}
function traverseValueProperty(inputValue, property, operation) {
  var _a, _b;
  let value;
  if (property.dataType === "map" && property.properties) {
    value = traverseValuesProperties(inputValue, property.properties, operation);
  } else if (property.dataType === "array") {
    if (property.of && Array.isArray(inputValue)) {
      value = inputValue.map((e2) => traverseValueProperty(e2, property.of, operation));
    } else if (property.oneOf && Array.isArray(inputValue)) {
      const typeField = ((_a = property.oneOf) == null ? void 0 : _a.typeField) ?? DEFAULT_ONE_OF_TYPE;
      const valueField = ((_b = property.oneOf) == null ? void 0 : _b.valueField) ?? DEFAULT_ONE_OF_VALUE;
      value = inputValue.map((e2) => {
        var _a2;
        if (e2 === null) return null;
        if (typeof e2 !== "object") return e2;
        const type = e2[typeField];
        const childProperty = (_a2 = property.oneOf) == null ? void 0 : _a2.properties[type];
        if (!type || !childProperty) return e2;
        return {
          [typeField]: type,
          [valueField]: traverseValueProperty(e2[valueField], childProperty, operation)
        };
      });
    } else {
      value = inputValue;
    }
  } else {
    value = operation(inputValue, property);
  }
  return value;
}
function enumToObjectEntries(enumValues) {
  if (Array.isArray(enumValues)) {
    return enumValues;
  } else {
    return Object.entries(enumValues).map(([id2, value]) => {
      if (typeof value === "string") {
        return {
          id: id2,
          label: value
        };
      } else {
        return {
          ...value,
          id: id2
        };
      }
    });
  }
}
function getLabelOrConfigFrom(enumValues, key) {
  if (key === null || key === void 0) return void 0;
  return enumValues.find((entry) => String(entry.id) === String(key));
}
function getColorScheme(enumValues, key) {
  const labelOrConfig = getLabelOrConfigFrom(enumValues, key);
  if (!(labelOrConfig == null ? void 0 : labelOrConfig.color)) return getColorSchemeForSeed(key.toString());
  if (typeof labelOrConfig === "object" && "color" in labelOrConfig) {
    if (typeof labelOrConfig.color === "string") return CHIP_COLORS[labelOrConfig.color];
    if (typeof labelOrConfig.color === "object") return labelOrConfig.color;
  }
  return void 0;
}
function isEnumValueDisabled(labelOrConfig) {
  return typeof labelOrConfig === "object" && labelOrConfig.disabled;
}
function buildEnumLabel(labelOrConfig) {
  if (labelOrConfig === void 0) return void 0;
  if (typeof labelOrConfig === "object") {
    return labelOrConfig.label;
  } else {
    return labelOrConfig;
  }
}
var resolveCollection = ({
  collection,
  path,
  entityId,
  values,
  previousValues,
  userConfigPersistence,
  propertyConfigs,
  ignoreMissingFields = false,
  authController
}) => {
  const collectionOverride = userConfigPersistence == null ? void 0 : userConfigPersistence.getCollectionConfig(path);
  const storedProperties = getValueInPath(collectionOverride, "properties");
  const defaultValues = getDefaultValuesFor(collection.properties);
  const usedValues = values ?? defaultValues;
  const usedPreviousValues = previousValues ?? values ?? defaultValues;
  const resolvedProperties = Object.entries(collection.properties).map(([key, propertyOrBuilder]) => {
    const childResolvedProperty = resolveProperty({
      propertyKey: key,
      propertyOrBuilder,
      values: usedValues,
      previousValues: usedPreviousValues,
      path,
      entityId,
      propertyConfigs,
      ignoreMissingFields,
      authController
    });
    if (!childResolvedProperty) return {};
    return {
      [key]: childResolvedProperty
    };
  }).filter((a2) => a2 !== null).reduce((a2, b2) => ({
    ...a2,
    ...b2
  }), {});
  const properties = mergeDeep2(resolvedProperties, storedProperties);
  const cleanedProperties = Object.entries(properties).filter(([_, property]) => Boolean(property == null ? void 0 : property.dataType)).map(([id2, property]) => ({
    [id2]: property
  })).reduce((a2, b2) => ({
    ...a2,
    ...b2
  }), {});
  return {
    ...collection,
    properties: cleanedProperties,
    originalCollection: collection
  };
};
function resolveProperty({
  propertyOrBuilder,
  fromBuilder = false,
  ignoreMissingFields = false,
  ...props
}) {
  if (typeof propertyOrBuilder === "object" && "resolved" in propertyOrBuilder) {
    return propertyOrBuilder;
  }
  let resolvedProperty = null;
  if (!propertyOrBuilder) {
    return null;
  } else if (isPropertyBuilder(propertyOrBuilder)) {
    const path = props.path;
    if (!path) throw Error("Trying to resolve a property builder without specifying the entity path");
    const usedPropertyValue = props.propertyKey ? getIn(props.values, props.propertyKey) : void 0;
    const result = propertyOrBuilder({
      ...props,
      path,
      propertyValue: usedPropertyValue,
      values: props.values ?? {},
      previousValues: props.previousValues ?? props.values ?? {}
    });
    if (!result) {
      return null;
    }
    resolvedProperty = resolveProperty({
      ...props,
      propertyOrBuilder: result,
      fromBuilder: true,
      ignoreMissingFields
    });
  } else {
    const property = propertyOrBuilder;
    if (property.dataType === "map" && property.properties) {
      const properties = resolveProperties({
        ignoreMissingFields,
        ...props,
        properties: property.properties
      });
      resolvedProperty = {
        ...property,
        resolved: true,
        fromBuilder,
        properties
      };
    } else if (property.dataType === "array") {
      resolvedProperty = resolveArrayProperty({
        property,
        fromBuilder,
        ignoreMissingFields,
        ...props
      });
    } else if ((property.dataType === "string" || property.dataType === "number") && property.enumValues) {
      resolvedProperty = resolvePropertyEnum(property, fromBuilder);
    }
  }
  if (!resolvedProperty) {
    resolvedProperty = {
      ...propertyOrBuilder,
      resolved: true,
      fromBuilder
    };
  }
  if (resolvedProperty.propertyConfig && !isDefaultFieldConfigId(resolvedProperty.propertyConfig)) {
    const cmsFields = props.propertyConfigs;
    if (!cmsFields && !ignoreMissingFields) {
      throw Error(`Trying to resolve a property with key '${resolvedProperty.propertyConfig}' that inherits from a custom property config but no custom property configs were provided. Use the property 'propertyConfigs' in your app config to provide them`);
    }
    const customField = cmsFields == null ? void 0 : cmsFields[resolvedProperty.propertyConfig];
    if (!customField) {
      console.warn(`Trying to resolve a property with key '${resolvedProperty.propertyConfig}' that inherits from a custom property config but no custom property config with that key was found. Check the 'propertyConfigs' in your app config`);
      console.warn("Available property configs", cmsFields);
      return null;
    }
    if (customField.property) {
      const configPropertyOrBuilder = customField.property;
      if ("propertyConfig" in configPropertyOrBuilder) {
        delete configPropertyOrBuilder.propertyConfig;
      }
      const customFieldProperty = resolveProperty({
        propertyOrBuilder: configPropertyOrBuilder,
        ignoreMissingFields,
        ...props
      });
      if (customFieldProperty) {
        resolvedProperty = mergeDeep2(customFieldProperty, resolvedProperty);
      }
    }
  }
  return resolvedProperty ? {
    ...resolvedProperty,
    resolved: true
  } : null;
}
function getArrayResolvedProperties({
  propertyKey,
  propertyValue,
  property,
  ...props
}) {
  const of = property.of;
  return Array.isArray(propertyValue) ? propertyValue.map((v, index2) => {
    return resolveProperty({
      propertyKey: `${propertyKey}.${index2}`,
      propertyOrBuilder: of,
      ...props,
      index: index2
    });
  }).filter((e2) => Boolean(e2)) : [];
}
function resolveArrayProperty({
  propertyKey,
  property,
  ignoreMissingFields = false,
  ...props
}) {
  var _a;
  const propertyValue = propertyKey ? getIn(props.values, propertyKey) : void 0;
  if (property.of) {
    if (Array.isArray(property.of)) {
      return {
        ...property,
        resolved: true,
        fromBuilder: props.fromBuilder,
        resolvedProperties: property.of.map((p3, index2) => {
          return resolveProperty({
            propertyKey: `${propertyKey}.${index2}`,
            propertyOrBuilder: p3,
            ignoreMissingFields,
            ...props,
            index: index2
          });
        })
      };
    } else {
      const of = property.of;
      const resolvedProperties = getArrayResolvedProperties({
        propertyValue,
        propertyKey,
        property,
        ignoreMissingFields,
        ...props
      });
      const ofProperty = resolveProperty({
        propertyOrBuilder: of,
        ignoreMissingFields,
        ...props
      });
      if (!ofProperty && !ignoreMissingFields) throw Error("When using a property builder as the 'of' prop of an ArrayProperty, you must return a valid child property");
      return {
        ...property,
        resolved: true,
        fromBuilder: props.fromBuilder,
        of: ofProperty,
        resolvedProperties
      };
    }
  } else if (property.oneOf) {
    const typeField = ((_a = property.oneOf) == null ? void 0 : _a.typeField) ?? DEFAULT_ONE_OF_TYPE;
    const resolvedProperties = Array.isArray(propertyValue) ? propertyValue.map((v, index2) => {
      var _a2;
      const type = v && v[typeField];
      const childProperty = (_a2 = property.oneOf) == null ? void 0 : _a2.properties[type];
      if (!type || !childProperty) return null;
      return resolveProperty({
        propertyKey: `${propertyKey}.${index2}`,
        propertyOrBuilder: childProperty,
        ignoreMissingFields,
        ...props
      });
    }).filter((e2) => Boolean(e2)) : [];
    const properties = resolveProperties({
      propertyKey,
      properties: property.oneOf.properties,
      ignoreMissingFields,
      ...props
    });
    return {
      ...property,
      resolved: true,
      oneOf: {
        ...property.oneOf,
        properties
      },
      fromBuilder: props.fromBuilder,
      resolvedProperties
    };
  } else if (!property.Field) {
    throw Error("The array property needs to declare an 'of' or a 'oneOf' property, or provide a custom `Field`");
  } else {
    return {
      ...property,
      resolved: true,
      fromBuilder: props.fromBuilder
    };
  }
}
function resolveProperties({
  propertyKey,
  properties,
  ignoreMissingFields,
  ...props
}) {
  return Object.entries(properties).map(([key, property]) => {
    const childResolvedProperty = resolveProperty({
      propertyKey: propertyKey ? `${propertyKey}.${key}` : void 0,
      propertyOrBuilder: property,
      ignoreMissingFields,
      ...props
    });
    if (!childResolvedProperty) return {};
    return {
      [key]: childResolvedProperty
    };
  }).filter((a2) => a2 !== null).reduce((a2, b2) => ({
    ...a2,
    ...b2
  }), {});
}
function resolvePropertyEnum(property, fromBuilder) {
  var _a;
  if (typeof property.enumValues === "object") {
    return {
      ...property,
      resolved: true,
      enumValues: ((_a = enumToObjectEntries(property.enumValues)) == null ? void 0 : _a.filter((value) => value && (value.id || value.id === 0) && value.label)) ?? [],
      fromBuilder: fromBuilder ?? false
    };
  }
  return property;
}
function resolveEnumValues(input) {
  if (typeof input === "object") {
    return Object.entries(input).map(([id2, value]) => typeof value === "string" ? {
      id: id2,
      label: value
    } : value);
  } else if (Array.isArray(input)) {
    return input;
  } else {
    return void 0;
  }
}
function resolveEntityView(entityView, contextEntityViews) {
  if (typeof entityView === "string") {
    return contextEntityViews == null ? void 0 : contextEntityViews.find((entry) => entry.key === entityView);
  } else {
    return entityView;
  }
}
function resolvedSelectedEntityView(customViews, customizationController, selectedTab, canEdit) {
  const resolvedEntityViews = customViews ? customViews.map((e2) => resolveEntityView(e2, customizationController.entityViews)).filter((e2) => Boolean(e2)) : [];
  const selectedEntityView = resolvedEntityViews.find((e2) => e2.key === selectedTab);
  const selectedSecondaryForm = customViews && resolvedEntityViews.filter((e2) => e2.includeActions).find((e2) => e2.key === selectedTab);
  return {
    resolvedEntityViews,
    selectedEntityView,
    selectedSecondaryForm
  };
}
function getNavigationEntriesFromPath(props) {
  const {
    path,
    collections = [],
    currentFullPath
  } = props;
  const subpaths = removeInitialAndTrailingSlashes(path).split("/");
  const subpathCombinations = getCollectionPathsCombinations(subpaths);
  const result = [];
  for (let i2 = 0; i2 < subpathCombinations.length; i2++) {
    const subpathCombination = subpathCombinations[i2];
    let collection;
    collection = collections && collections.find((entry) => entry.id === subpathCombination);
    if (!collection) {
      collection = collections && collections.find((entry) => entry.path === subpathCombination);
    }
    if (collection) {
      const pathOrAlias = collection.id ?? collection.path;
      const collectionPath = currentFullPath && currentFullPath.length > 0 ? currentFullPath + "/" + pathOrAlias : pathOrAlias;
      result.push({
        type: "collection",
        id: collection.id,
        path: collectionPath,
        fullPath: collectionPath,
        collection
      });
      const restOfThePath = removeInitialAndTrailingSlashes(removeInitialAndTrailingSlashes(path).replace(subpathCombination, ""));
      const nextSegments = restOfThePath.length > 0 ? restOfThePath.split("/") : [];
      if (nextSegments.length > 0) {
        const entityId = nextSegments[0];
        const fullPath = collectionPath + "/" + entityId;
        result.push({
          type: "entity",
          entityId,
          path: collectionPath,
          fullPath,
          parentCollection: collection
        });
        if (nextSegments.length > 1) {
          const newPath = nextSegments.slice(1).join("/");
          if (!collection) {
            throw Error("collection not found resolving path: " + collection);
          }
          const entityViews = collection.entityViews;
          const customView = entityViews && entityViews.map((entry) => resolveEntityView(entry, props.contextEntityViews)).filter(Boolean).find((entry) => entry.key === newPath);
          if (customView) {
            result.push({
              type: "custom_view",
              path: collectionPath,
              entityId,
              fullPath: fullPath + "/" + customView.key,
              view: customView
            });
          } else if (collection.subcollections) {
            result.push(...getNavigationEntriesFromPath({
              path: newPath,
              collections: collection.subcollections,
              currentFullPath: fullPath,
              contextEntityViews: props.contextEntityViews
            }));
          }
        }
      }
      break;
    }
  }
  return result;
}
function sortProperties(properties, propertiesOrder) {
  try {
    const propertiesKeys = Object.keys(properties);
    const allPropertiesOrder = propertiesOrder ?? propertiesKeys;
    return allPropertiesOrder.map((key) => {
      if (properties[key]) {
        const property = properties[key];
        if (!isPropertyBuilder(property) && (property == null ? void 0 : property.dataType) === "map" && property.properties) {
          return {
            [key]: {
              ...property,
              properties: sortProperties(property.properties, property.propertiesOrder)
            }
          };
        } else {
          return {
            [key]: property
          };
        }
      } else {
        return void 0;
      }
    }).filter((a2) => a2 !== void 0).reduce((a2, b2) => ({
      ...a2,
      ...b2
    }), {});
  } catch (e2) {
    console.error("Error sorting properties", e2);
    return properties;
  }
}
function resolveDefaultSelectedView(defaultSelectedView, params) {
  if (!defaultSelectedView) {
    return void 0;
  } else if (typeof defaultSelectedView === "string") {
    return defaultSelectedView;
  } else {
    return defaultSelectedView(params);
  }
}
var applyPermissionsFunctionIfEmpty = (collections, permissionsBuilder) => {
  return collections.map((collection) => {
    if (collection.permissions) {
      return collection;
    }
    return {
      ...collection,
      permissions: permissionsBuilder
    };
  });
};
var kebabCaseRegex = /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g;
var toKebabCase = (str) => {
  const regExpMatchArray = str.match(kebabCaseRegex);
  if (!regExpMatchArray) return "";
  return regExpMatchArray.map((x) => x.toLowerCase()).join("-");
};
var snakeCaseRegex = /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g;
var toSnakeCase = (str) => {
  const regExpMatchArray = str.match(snakeCaseRegex);
  if (!regExpMatchArray) return "";
  return regExpMatchArray.map((x) => x.toLowerCase()).join("_");
};
function randomString2(strLength = 5) {
  return Math.random().toString(36).slice(2, 2 + strLength);
}
function randomColor() {
  return Math.floor(Math.random() * 16777215).toString(16);
}
function slugify(text, separator = "_", lowercase = true) {
  if (!text) return "";
  const from2 = "ãàáäâẽèéëêìíïîõòóöôùúüûñç·/_,:;-";
  const to = `aaaaaeeeeeiiiiooooouuuunc${separator}${separator}${separator}${separator}${separator}${separator}${separator}`;
  for (let i2 = 0, l2 = from2.length; i2 < l2; i2++) {
    text = text.replace(new RegExp(from2.charAt(i2), "g"), to.charAt(i2));
  }
  text = text.toString().replace(/\s+/g, separator).replace(/&/g, separator).replace(/[^\w\\-]+/g, "").replace(new RegExp("\\" + separator + "\\" + separator + "+", "g"), separator).trim().replace(/^\s+|\s+$/g, "");
  return lowercase ? text.toLowerCase() : text;
}
function unslugify(slug) {
  if (!slug) return "";
  if (slug.includes("-") || slug.includes("_") || !slug.includes(" ")) {
    const result = slug.replace(/[-_]/g, " ");
    return result.replace(/\w\S*/g, function(txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1);
    }).trim();
  } else {
    return slug.trim();
  }
}
var defaultDateFormat = "MMMM dd, yyyy, HH:mm:ss";
var COLLECTION_PATH_SEPARATOR = "::";
function stripCollectionPath(path) {
  return segmentsToStrippedPath(fullPathToCollectionSegments(path));
}
function segmentsToStrippedPath(paths) {
  if (paths.length === 1) return paths[0];
  return paths.reduce((a2, b2) => `${a2}${COLLECTION_PATH_SEPARATOR}${b2}`);
}
function fullPathToCollectionSegments(path) {
  return path.split("/").filter((e2, i2) => i2 % 2 === 0);
}
function serializeRegExp(input) {
  if (!input) return "";
  return input.toString();
}
function hydrateRegExp(input) {
  if (!input) return void 0;
  const fragments = input.match(/\/(.*?)\/([a-z]*)?$/i);
  if (fragments) {
    return new RegExp(fragments[1], fragments[2] || "");
  } else {
    return new RegExp(input, "");
  }
}
function isValidRegExp(input) {
  const fullRegexp = input.match(/\/((?![*+?])(?:[^\r\n[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*])+)\/((?:g(?:im?|mi?)?|i(?:gm?|mg?)?|m(?:gi?|ig?)?)?)/);
  if (fullRegexp) return true;
  const simpleRegexp = input.match(/((?![*+?])(?:[^\r\n[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*])+)/);
  return !!simpleRegexp;
}
var reservedKeys = ["edit", "copy", "delete"];
function mergeEntityActions(currentActions, newActions) {
  const updatedActions = [];
  currentActions.forEach((action) => {
    const newAction = newActions.find((a2) => a2.key === action.key);
    if (newAction) {
      const mergedAction = {
        ...action,
        ...newAction
      };
      updatedActions.push(mergedAction);
    } else {
      updatedActions.push(action);
    }
  });
  newActions.forEach((action) => {
    if (!currentActions.find((a2) => a2.key === action.key) && (!action.key || !reservedKeys.includes(action.key))) {
      updatedActions.push(action);
    }
  });
  return updatedActions;
}
function useDebouncedCallback(value, callback, immediate2, t0) {
  const $ = (0, import_react_compiler_runtime3.c)(9);
  const timeoutMs = t0 === void 0 ? 300 : t0;
  const pendingUpdate = import_react14.default.useRef(false);
  let t1;
  if ($[0] !== callback) {
    t1 = () => {
      callback();
      pendingUpdate.current = false;
    };
    $[0] = callback;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const performUpdate = t1;
  const handlerRef = import_react14.default.useRef(void 0);
  let t2;
  if ($[2] !== immediate2 || $[3] !== performUpdate || $[4] !== timeoutMs) {
    t2 = () => {
      pendingUpdate.current = true;
      clearTimeout(handlerRef.current);
      handlerRef.current = setTimeout(performUpdate, timeoutMs);
      return () => {
        if (immediate2) {
          performUpdate();
        }
      };
    };
    $[2] = immediate2;
    $[3] = performUpdate;
    $[4] = timeoutMs;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== immediate2 || $[7] !== value) {
    t3 = [immediate2, value];
    $[6] = immediate2;
    $[7] = value;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  import_react14.default.useEffect(t2, t3);
}
function isReferenceProperty(authController, propertyOrBuilder, fields) {
  var _a;
  const resolvedProperty = resolveProperty({
    propertyKey: "ignore",
    // TODO
    propertyOrBuilder,
    propertyConfigs: fields,
    authController
  });
  if (!resolvedProperty) return null;
  if (resolvedProperty.dataType === "reference") {
    return true;
  }
  if (resolvedProperty.dataType === "array") {
    if (Array.isArray(resolvedProperty.of)) return false;
    else return ((_a = resolvedProperty.of) == null ? void 0 : _a.dataType) === "reference";
  }
  return false;
}
function getIdIcon(size2) {
  return (0, import_jsx_runtime2.jsx)(CircleIcon, { size: size2 });
}
function getIconForWidget(widget, size2) {
  const Icon2 = (widget == null ? void 0 : widget.Icon) ?? CircleIcon;
  return (0, import_jsx_runtime2.jsx)(Icon2, { size: size2 });
}
function getIconForProperty(property, size2 = "small", fields = {}) {
  if (isPropertyBuilder(property)) {
    return (0, import_jsx_runtime2.jsx)(FunctionsIcon, { size: size2 });
  } else {
    const widget = getFieldConfig(property, fields);
    return getIconForWidget(widget, size2);
  }
}
function getColorForProperty(property, fields) {
  if (isPropertyBuilder(property)) {
    return "#888";
  } else {
    const widget = getFieldConfig(property, fields);
    return (widget == null ? void 0 : widget.color) ?? "#666";
  }
}
function getPropertyInPath(properties, path) {
  if (typeof properties === "object") {
    if (path in properties) {
      return properties[path];
    }
    if (path.includes(".")) {
      const pathSegments = path.split(".");
      const childProperty = properties[pathSegments[0]];
      if (typeof childProperty === "object" && childProperty.dataType === "map" && childProperty.properties) {
        return getPropertyInPath(childProperty.properties, pathSegments.slice(1).join("."));
      }
    }
  }
  return void 0;
}
function getResolvedPropertyInPath(properties, path) {
  if (typeof properties === "object") {
    if (path in properties) {
      return properties[path];
    }
    if (path.includes(".")) {
      const pathSegments = path.split(".");
      const childProperty = properties[pathSegments[0]];
      if (childProperty.dataType === "map" && childProperty.properties) {
        return getResolvedPropertyInPath(childProperty.properties, pathSegments.slice(1).join("."));
      }
    }
  }
  return void 0;
}
function getBracketNotation(path) {
  return path.replace(/\.([^.]*)/g, "[$1]");
}
function getPropertiesWithPropertiesOrder(properties, propertiesOrder) {
  if (!propertiesOrder) return properties;
  const result = {};
  propertiesOrder.filter(Boolean).forEach((path) => {
    const property = getPropertyInPath(properties, path);
    if (typeof property === "object" && property.dataType === "map" && property.properties) {
      result[path] = {
        ...property,
        properties: getPropertiesWithPropertiesOrder(property.properties, property.propertiesOrder ?? [])
      };
    }
    if (property) {
      result[path] = property;
    }
  });
  return result;
}
function getDefaultPropertiesOrder(collection) {
  if (collection.propertiesOrder) return collection.propertiesOrder;
  return [...Object.keys(collection.properties), ...(collection.additionalFields ?? []).map((field) => field.key)];
}
var DEFAULT_PERMISSIONS = {
  read: true,
  edit: true,
  create: true,
  delete: true
};
function resolvePermissions(collection, authController, path, entity) {
  const permission = collection.permissions;
  if (permission === void 0) {
    return DEFAULT_PERMISSIONS;
  } else if (typeof permission === "object") {
    return permission;
  } else if (typeof permission === "function") {
    const pathSegments = fullPathToCollectionSegments(path);
    return permission({
      entity,
      path,
      user: authController.user,
      authController,
      collection,
      pathSegments
    });
  }
  console.error("Permissions:", permission);
  throw Error("New type of permission added and not mapped");
}
function canEditEntity(collection, authController, path, entity) {
  var _a;
  return ((_a = resolvePermissions(collection, authController, path, entity)) == null ? void 0 : _a.edit) ?? DEFAULT_PERMISSIONS.edit;
}
function canCreateEntity(collection, authController, path, entity) {
  var _a;
  if (collection.collectionGroup) return false;
  return ((_a = resolvePermissions(collection, authController, path, entity)) == null ? void 0 : _a.create) ?? DEFAULT_PERMISSIONS.create;
}
function canDeleteEntity(collection, authController, path, entity) {
  var _a;
  return ((_a = resolvePermissions(collection, authController, path, entity)) == null ? void 0 : _a.delete) ?? DEFAULT_PERMISSIONS.delete;
}
var iconSynonyms = {
  abc: "alphabet character font letter symbol text type",
  access_alarm: "clock time",
  access_alarms: "clock time",
  accessibility: "accessible body handicap help human people person user",
  accessibility_new: "accessible arms body handicap help human people person user",
  accessible: "accessibility body handicap help human people person user wheelchair",
  accessible_forward: "accessibility body handicap help human people person wheelchair",
  access_time: "clock time",
  account_balance: "bank bill building card cash coin commerce court credit currency dollars finance money online payment structure temple transaction",
  account_balance_wallet: "bank bill card cash coin commerce credit currency dollars finance money online payment transaction",
  account_box: "avatar face human people person profile square thumbnail user",
  account_circle: "avatar face human people person profile thumbnail user",
  account_tree: "analytics chart connect data diagram flow infographic measure metrics process project sitemap square statistics structure tracking",
  ac_unit: "air cold conditioner freeze snowflake temperature weather winter",
  adb: "android bridge debug",
  add: "+ create item new plus symbol",
  add_alarm: "clock plus time",
  add_alert: "+ active alarm announcement bell callout chime information new notifications notify plus reminder ring sound symbol",
  add_a_photo: "+ camera lens new photography picture plus symbol",
  add_box: "create new plus square symbol",
  add_business: "+ bill building card cash coin commerce company credit currency dollars market money new online payment plus retail shopping storefront symbol",
  add_card: "+ bill cash coin commerce cost credit currency dollars finance money new online payment plus price shopping symbol",
  add_chart: "+ analytics bars data diagram infographic measure metrics new plus statistics symbol tracking",
  add_circle: "+ create new plus",
  add_circle_outline: "+ create new plus",
  add_comment: "+ bubble chat communicate feedback message new plus speech symbol",
  add_ic_call: "+ cell contact device hardware mobile new plus symbol telephone",
  add_link: "attach clip new plus symbol",
  add_location: "+ destination direction gps maps new pin place plus stop symbol",
  add_location_alt: "+ destination direction maps new pin place plus stop symbol",
  add_moderator: "+ certified new plus privacy private protection security shield symbol verified",
  add_photo_alternate: "+ image landscape mountains new photography picture plus symbol",
  add_road: "+ destination direction highway maps new plus stop street symbol traffic",
  add_shopping_cart: "card cash checkout coin commerce credit currency dollars money online payment plus",
  add_task: "+ approve check circle completed increase mark ok plus select tick yes",
  add_to_drive: "+ app backup cloud data files folders gdrive google plus recovery storage",
  add_to_home_screen: "Android add arrow cell device hardware iOS mobile phone tablet to up",
  add_to_photos: "collection image landscape mountains photography picture plus",
  add_to_queue: "+ Android backlog chrome desktop device display hardware iOS lineup mac monitor new plus screen symbol television watch web window",
  adf_scanner: "document feeder machine office",
  adjust: "alter center circles control dot edit filter fix image mix move setting slider sort switch target tune",
  admin_panel_settings: "account avatar certified face human people person privacy private profile protection security shield user verified",
  ad_units: "Android banner cell device hardware iOS mobile notifications phone tablet top",
  agriculture: "automobile cars cultivation farm harvest maps tractor transport travel truck vehicle",
  air: "blowing breeze flow wave weather wind",
  airlines: "airplane airport flight transportation travel trip",
  airline_seat_flat: "bed body business class first human people person rest sleep travel",
  airline_seat_flat_angled: "bed body business class first human people person rest sleep travel",
  airline_seat_individual_suite: "bed body business class first human people person rest sleep travel",
  airline_seat_legroom_extra: "body feet human people person sitting space travel",
  airline_seat_legroom_normal: "body feet human people person sitting space travel",
  airline_seat_legroom_reduced: "body feet human people person sitting space travel",
  airline_seat_recline_extra: "body feet human legroom people person sitting space travel",
  airline_seat_recline_normal: "body extra feet human legroom people person sitting space travel",
  airline_stops: "arrow destination direction layover location maps place transportation travel trip",
  airplanemode_active: "flight flying on signal",
  airplanemode_inactive: "airport disabled enabled flight flying maps offline slash transportation travel",
  airplane_ticket: "airport boarding flight fly maps pass transportation travel",
  airplay: "apple arrow cast connect control desktop device display monitor screen signal television tv",
  airport_shuttle: "automobile bus cars commercial delivery direction maps mini public transportation travel truck van vehicle",
  alarm: "alart bell clock countdown date notification schedule time",
  alarm_add: "+ alart bell clock countdown date new notification plus schedule symbol time",
  alarm_off: "alart bell clock disabled duration enabled notification slash stop timer watch",
  alarm_on: "alart bell checkmark clock disabled duration enabled notification off ready slash start timer watch",
  album: "artist audio bvb cd computer data disk file music play record sound storage track vinyl",
  align_horizontal_center: "alignment format layout lines paragraph rules style text",
  align_horizontal_left: "alignment format layout lines paragraph rules style text",
  align_horizontal_right: "alignment format layout lines paragraph rules style text",
  align_vertical_bottom: "alignment format layout lines paragraph rules style text",
  align_vertical_center: "alignment format layout lines paragraph rules style text",
  align_vertical_top: "alignment format layout lines paragraph rules style text",
  all_inbox: "Inbox delivered delivery email letter message post send",
  all_inclusive: "endless forever infinite infinity loop mobius neverending strip sustainability sustainable",
  all_out: "arrows circle directional expand shape",
  alternate_email: "@ address contact tag",
  alt_route: "alternate alternative arrows direction maps navigation options other routes split symbol",
  analytics: "assessment bar chart data diagram infographic measure metrics statistics tracking",
  anchor: "google logo",
  android: "brand character logo mascot operating system toy",
  animation: "circles film motion movement movie moving sequence video",
  announcement: "! alert attention balloon bubble caution chat comment communicate danger error exclamation feedback important mark message news notification speech symbol warning",
  aod: "Android always device display hardware homescreen iOS mobile phone tablet",
  apartment: "accommodation architecture building city company estate flat home house office places real residence residential shelter units workplace",
  api: "developer development enterprise software",
  app_blocking: "Android applications cancel cell device hardware iOS mobile phone stopped tablet",
  app_registration: "apps edit pencil register",
  approval: "apply approvals approve certificate certification disapproval drive file impression ink mark postage stamp",
  apps: "all applications circles collection components dots grid homescreen icons interface squares ui ux",
  app_settings_alt: "Android applications cell device gear hardware iOS mobile phone tablet",
  app_shortcut: "bookmarked favorite highlight important mobile saved software special star",
  apps_outage: "all applications circles collection components dots grid interface squares ui ux",
  architecture: "art compass design drawing engineering geometric tool",
  archive: "inbox mail store",
  arrow_back: "application components direction interface left navigation previous screen ui ux website",
  arrow_back_ios: "application chevron components direction interface left navigation previous screen ui ux website",
  arrow_back_ios_new: "application chevron components direction interface left navigation previous screen ui ux website",
  arrow_circle_down: "direction navigation",
  arrow_circle_up: "direction navigation",
  arrow_downward: "application components direction interface navigation screen ui ux website",
  arrow_drop_down: "application components direction interface navigation screen ui ux website",
  arrow_drop_down_circle: "application components direction interface navigation screen ui ux website",
  arrow_drop_up: "application components direction interface navigation screen ui ux website",
  arrow_forward: "application arrows components direction interface navigation right screen ui ux website",
  arrow_forward_ios: "application chevron components direction interface navigation next right screen ui ux website",
  arrow_left: "application backstack backward components direction interface navigation previous screen ui ux website",
  arrow_right: "application components continue direction forward interface navigation screen ui ux website",
  arrow_right_alt: "arrows direction east navigation pointing shape",
  arrow_upward: "application components direction interface navigation screen submit ui ux website",
  article: "clarify document file news page paper text writing",
  art_track: "album artist audio display format image insert music photography picture sound tracks",
  aspect_ratio: "expand image monitor resize resolution scale screen square",
  assessment: "analytics bars chart data diagram infographic measure metrics report statistics tracking",
  assignment: "article clipboard document task text writing",
  assignment_ind: "account clipboard document face people person profile task user",
  assignment_late: "! alert announcement attention caution clipboard danger document error exclamation important mark notification symbol task warning",
  assignment_return: "arrow back clipboard document left point retun task",
  assignment_returned: "arrow clipboard document down point task",
  assignment_turned_in: "approve checkmark clipboard complete document done finished ok select task tick validate verified yes",
  assistant: "bubble chat comment communicate feedback message recommendation speech star suggestion twinkle",
  assistant_direction: "destination location maps navigate navigation pin place right stop",
  assistant_photo: "flag recommendation smart star suggestion",
  assured_workload: "compliance confidential federal government regulatory secure sensitive",
  atm: "alphabet automated bill card cart cash character coin commerce credit currency dollars font letter machine money online payment shopping symbol teller text type",
  attach_email: "attachment clip compose envelop letter link message send",
  attach_file: "add item link mail media paperclip",
  attachment: "compose file image item link paperclip",
  attach_money: "bill card cash coin commerce cost credit currency dollars finance online payment price profit sale symbol",
  attractions: "amusement entertainment ferris fun maps park places wheel",
  attribution: "attribute body copyright copywriter human people person",
  audio_file: "document key music note sound track",
  audiotrack: "key music note sound",
  auto_awesome: "adjust editing enhance filter image photography photos setting stars",
  auto_awesome_mosaic: "adjust collage editing enhance filter grid image layout photographs photography photos pictures setting",
  auto_awesome_motion: "adjust animation collage editing enhance filter image live photographs photography photos pictures setting video",
  auto_delete: "bin can clock date garbage remove schedule time trash",
  auto_fix_high: "adjust editing enhance erase magic modify pen stars tool wand",
  auto_fix_normal: "edit erase magic modify stars wand",
  auto_fix_off: "disabled edit enabled erase magic modify on slash stars wand",
  autofps_select: "A alphabet character font frame frequency letter per rate seconds symbol text type",
  auto_graph: "analytics chart data diagram infographic line measure metrics stars statistics tracking",
  auto_mode: "around arrows direction inprogress loading navigation nest refresh renew rotate turn",
  autorenew: "around arrows cached direction inprogress loader loading navigation pending refresh rotate status turn",
  auto_stories: "audiobook flipping pages reading story",
  av_timer: "clock countdown duration minutes seconds stopwatch",
  baby_changing_station: "babies bathroom body children father human infant kids mother newborn people person toddler wc young",
  backpack: "bookbag knapsack storage travel",
  backspace: "arrow cancel clear correct delete erase remove",
  backup: "arrow cloud data drive files folders point storage submit upload",
  backup_table: "drive files folders format layout stack storage",
  badge: "account avatar card certified employee face human identification name people person profile security user work",
  bakery_dining: "bread breakfast brunch croissant food",
  balance: "equal equilibrium equity impartiality justice parity stability. steadiness symmetry",
  balcony: "architecture doors estate home house maps outside place real residence residential stay terrace window",
  ballot: "bullet bulllet election list point poll vote",
  bar_chart: "analytics anlytics data diagram infographic measure metrics statistics tracking",
  batch_prediction: "bulb idea light",
  bathroom: "closet home house place plumbing shower sprinkler wash water wc",
  bathtub: "bathing bathroom clean home hotel human person shower travel",
  battery_alert: "! attention caution cell charge danger error exclamation important mark mobile notification power symbol warning",
  battery_charging_full: "cell charge lightening lightning mobile power thunderbolt",
  battery_full: "cell charge mobile power",
  battery_saver: "+ add charge charging new plus power symbol",
  battery_std: "cell charge mobile plus power standard",
  battery_unknown: "? assistance cell charge help information mark mobile power punctuation question support symbol",
  beach_access: "parasol places summer sunny umbrella",
  bed: "bedroom double full furniture home hotel house king night pillows queen rest size sleep",
  bedroom_baby: "babies children home horse house infant kid newborn rocking toddler young",
  bedroom_child: "children furniture home hotel house kid night pillows rest size sleep twin young",
  bedroom_parent: "double full furniture home hotel house king master night pillows queen rest sizem sleep",
  bedtime: "nightime sleep",
  bedtime_off: "nightime sleep",
  beenhere: "approve archive bookmark checkmark complete done favorite label library reading remember ribbon save select tag tick validate verified yes",
  bento: "box dinner food lunch meal restaurant takeout",
  bike_scooter: "automobile cars maps transportation vehicle vespa",
  biotech: "chemistry laboratory microscope research science technology test",
  blender: "appliance cooking electric juicer kitchen machine vitamix",
  blinds_closed: "cover curtains nest shutter sunshade",
  block: "allowed avoid banned cancel close disable entry exit not prohibited quit remove stop",
  bloodtype: "donate droplet emergency hospital medicine negative positive water",
  bluetooth: "cast connection device network paring streaming symbol wireless",
  bluetooth_audio: "connection device music signal sound symbol",
  bluetooth_connected: "cast connection device network paring streaming symbol wireless",
  bluetooth_disabled: "cast connection device enabled network offline paring slash streaming symbol wireless",
  bluetooth_drive: "automobile cars cast connection device maps paring streaming symbol transportation travel vehicle wireless",
  bluetooth_searching: "connection device network paring symbol wireless",
  blur_circular: "circle dots editing effect enhance filter",
  blur_linear: "dots editing effect enhance filter",
  blur_off: "disabled dots editing effect enabled enhance on slash",
  blur_on: "disabled dots editing effect enabled enhance filter off slash",
  bolt: "electric energy fast flash lightning power thunderbolt",
  book: "blog bookmark favorite label library reading remember ribbon save tag",
  bookmark: "archive favorite follow label library reading remember ribbon save tag",
  bookmark_add: "+ favorite plus remember ribbon save symbol",
  bookmark_added: "approve check complete done favorite remember save select tick validate verified yes",
  bookmark_border: "archive favorite label library outline reading remember ribbon save tag",
  bookmark_remove: "delete favorite minus remember ribbon save subtract",
  bookmarks: "favorite label layers library multiple reading remember ribbon save stack tag",
  book_online: "Android admission appointment cell device event hardware iOS mobile pass phone reservation tablet ticket",
  border_all: "doc editing editor spreadsheet stroke text type writing",
  border_bottom: "doc editing editor spreadsheet stroke text type writing",
  border_clear: "doc editing editor spreadsheet stroke text type writing",
  border_color: "all create doc editing editor marker pencil spreadsheet stroke text type writing",
  border_horizontal: "doc editing editor spreadsheet stroke text type writing",
  border_inner: "doc editing editor spreadsheet stroke text type writing",
  border_left: "doc editing editor spreadsheet stroke text type writing",
  border_outer: "doc editing editor spreadsheet stroke text type writing",
  border_right: "doc editing editor spreadsheet stroke text type writing",
  border_style: "color doc editing editor spreadsheet stroke text type writing",
  border_top: "doc editing editor spreadsheet stroke text type writing",
  border_vertical: "doc editing editor spreadsheet stroke text type writing",
  boy: "body gender human male people person social symbol",
  branding_watermark: "components copyright design emblem format identity interface layout logo screen stamp ui ux website window",
  breakfast_dining: "bakery bread butter food toast",
  brightness_1: "circle control crescent cresent level moon screen",
  brightness_2: "circle control crescent cresent level moon night screen",
  brightness_3: "circle control crescent cresent level moon night screen",
  brightness_4: "circle control crescent cresent dark level moon night screen sun",
  brightness_5: "circle control crescent cresent level moon screen sun",
  brightness_6: "circle control crescent cresent level moon screen sun",
  brightness_7: "circle control crescent cresent level light moon screen sun",
  brightness_auto: "A control display level mobile monitor phone screen",
  brightness_high: "auto control mobile monitor phone",
  brightness_low: "auto control mobile monitor phone",
  brightness_medium: "auto control mobile monitor phone",
  broken_image: "corrupt error landscape mountains photography picture torn",
  browser_not_supported: "disabled enabled internet off on page screen slash website www",
  browser_updated: "Android arrow chrome desktop device display download hardware iOS mac monitor screen web window",
  brunch_dining: "breakfast champagne champaign drink food lunch meal",
  brush: "art design draw editing painting tool",
  bubble_chart: "analytics bars data diagram infographic measure metrics statistics tracking",
  bug_report: "animal file fix insect issue problem testing ticket virus warning",
  build: "adjust fix repair spanner tool wrench",
  build_circle: "adjust fix repair tool wrench",
  bungalow: "architecture cottage estate home house maps place real residence residential stay traveling",
  burst_mode: "image landscape mountains multiple photography picture",
  bus_alert: "! attention automobile cars caution danger error exclamation important maps mark notification symbol transportation vehicle warning",
  business: "address apartment architecture building company estate flat home office place real residence residential shelter structure",
  business_center: "baggage briefcase places purse suitcase work",
  cabin: "architecture camping cottage estate home house log maps place real residence residential stay traveling wood",
  cable: "connection device electronics usb wire",
  cached: "around arrows inprogress loader loading refresh reload renew rotate",
  cake: "baked birthday candles celebration dessert food frosting party pastries pastry pie social sweet",
  calculate: "+ - = calculator count finance math",
  calendar_today: "date event month remember reminder schedule week",
  calendar_view_day: "date event format grid layout month remember reminder schedule today week",
  calendar_view_month: "date event format grid layout schedule today",
  calendar_view_week: "date event format grid layout month schedule today",
  call: "cell contact device hardware mobile talk telephone",
  call_end: "cell contact device hardware mobile talk telephone",
  call_made: "arrow device mobile",
  call_merge: "arrow device mobile",
  call_missed: "arrow device mobile",
  call_missed_outgoing: "arrow device mobile",
  call_received: "arrow device mobile",
  call_split: "arrow device mobile",
  call_to_action: "alert bar components cta design information interface layout message notification screen ui ux website window",
  camera: "album aperture lens photography picture record screenshot shutter",
  camera_alt: "image photography picture",
  camera_enhance: "important lens photography picture quality special star",
  camera_front: "body human lens mobile person phone photography portrait selfie",
  camera_indoor: "architecture building estate filming home house image inside motion nest picture place real residence residential shelter videography",
  camera_outdoor: "architecture building estate filming home house image motion nest outside picture place real residence residential shelter videography",
  camera_rear: "front lens mobile phone photography picture portrait selfie",
  camera_roll: "film image library photography",
  cameraswitch: "arrows flip rotate swap view",
  campaign: "alert announcement loud megaphone microphone notification speaker",
  cancel: "circle close cross disable exit status stop",
  cancel_presentation: "close device exit no quit remove screen share slide stop website window",
  cancel_schedule_send: "email no quit remove share stop x",
  candlestick_chart: "analytics data diagram finance infographic measure metrics statistics tracking",
  card_giftcard: "account balance bill cart cash certificate coin commerce creditcard currency dollars money online payment present shopping",
  card_membership: "bill bookmark cash certificate coin commerce cost creditcard currency dollars finance loyalty money online payment shopping subscription",
  card_travel: "bill cash coin commerce cost creditcard currency dollars finance membership miles money online payment trip",
  carpenter: "building construction cutting handyman repair saw tool",
  car_rental: "automobile cars key maps transportation vehicle",
  car_repair: "automobile cars maps transportation vehicle",
  cases: "baggage briefcase business purse suitcase",
  casino: "dice dots entertainment gamble gambling games luck places",
  cast: "Android airplay chromecast connect desktop device display hardware iOS mac monitor screencast streaming television tv web window wireless",
  cast_connected: "Android airplay chromecast desktop device display hardware iOS mac monitor screencast streaming television tv web window wireless",
  cast_for_education: "Android airplay chrome connect desktop device display hardware iOS learning lessons mac monitor screencast streaming teaching television tv web window wireless",
  category: "categories circle collection items product sort square triangle",
  celebration: "activity birthday event fun party",
  cell_tower: "broadcast casting network signal transmitting wireless",
  cell_wifi: "connection data internet mobile network phone service signal wireless",
  center_focus_strong: "camera image lens photography zoom",
  center_focus_weak: "camera image lens photography zoom",
  chair: "comfort couch decoration furniture home house living lounging loveseat room seating sofa",
  chair_alt: "cahir furniture home house kitchen lounging seating table",
  chalet: "architecture cottage estate home house maps place real residence residential stay traveling",
  change_circle: "around arrows direction navigation rotate",
  change_history: "shape triangle",
  charging_station: "Android battery cell device electric hardware iOS lightning mobile phone tablet thunderbolt",
  chat: "bubble comment communicate feedback message speech talk text",
  chat_bubble: "comment communicate feedback message speech talk text",
  chat_bubble_outline: "comment communicate feedback message speech talk text",
  check: "checkmark complete confirm correct done enter okay purchased select success tick yes",
  check_box: "approved button checkmark component control form ok selected selection square success tick toggle ui yes",
  check_box_outline_blank: "button checkmark component control deselected empty form selection square tick toggle ui",
  check_circle: "approve checkmark complete done download finished ok select success tick upload validate verified yes",
  check_circle_outline: "approve checkmark complete done finished ok select success tick validate verified yes",
  checkroom: "check closet clothes coat hanger",
  chevron_left: "arrows back direction triangle",
  chevron_right: "arrows direction forward triangle",
  child_care: "babies baby children face infant kids newborn toddler young",
  child_friendly: "baby care carriage children infant kid newborn stroller toddler young",
  chrome_reader_mode: "text",
  circle: "bullet button dot full geometry moon period radio",
  circle_notifications: "active alarm alert bell chime notify reminder ring sound",
  class: "archive bookmark category favorite item label library reading remember ribbon save tag",
  clean_hands: "bacteria disinfect germs gesture sanitizer",
  cleaning_services: "dust sweep",
  clear: "allowed back cancel correct cross delete disable erase exit not times",
  clear_all: "delete document erase format lines list notifications wipe",
  close: "allowed cancel cross disable exit not status stop times",
  closed_caption: "accessible alphabet character decoder font language letter media movies subtitles symbol text tv type",
  closed_caption_disabled: "accessible alphabet character decoder enabled font language letter media movies off slash subtitles symbol text tv type",
  closed_caption_off: "accessible alphabet character decoder font language letter media movies outline subtitles symbol text tv type",
  close_fullscreen: "action arrows collapse direction minimize",
  cloud: "connection internet network sky upload weather",
  cloud_circle: "application backup connection drive files folders internet network sky storage upload",
  cloud_done: "application approve backup checkmark complete connection drive files folders internet network ok select sky storage tick upload validate verified yes",
  cloud_download: "application arrow backup connection drive files folders internet network sky storage upload",
  cloud_off: "application backup connection disabled drive enabled files folders internet network offline sky slash storage upload",
  cloud_queue: "connection internet network sky upload",
  cloud_sync: "application around backup connection drive files folders inprogress internet loading network refresh renew rotate sky storage turn upload",
  cloud_upload: "application arrow backup connection download drive files folders internet network sky storage",
  co2: "carbon dioxide gas",
  code: "brackets css developer engineering html parenthesis platform",
  code_off: "brackets css developer disabled enabled engineering html on platform slash",
  coffee: "beverage cup drink mug plate set tea",
  coffee_maker: "appliances beverage cup drink machine mug",
  collections: "album gallery image landscape library mountains photography picture stack",
  collections_bookmark: "album archive favorite gallery label library reading remember ribbon save stack tag",
  colorize: "color dropper extract eye picker pipette tool",
  color_lens: "art paint pallet",
  comment: "bubble chat communicate document feedback message note outline speech",
  comment_bank: "archive bookmark bubble cchat communicate favorite label library message remember ribbon save speech tag",
  comments_disabled: "bubble chat communicate enabled feedback message offline on slash speech",
  commit: "accomplish bind circle dedicate execute line perform pledge",
  commute: "automobile car direction maps public train transportation trip vehicle",
  compare: "adjustment editing edits enhance fix images photography photos scan settings",
  compare_arrows: "collide directional facing left pointing pressure push right together",
  compass_calibration: "connection internet location maps network refresh service signal wifi wireless",
  compress: "arrows collide pressure push together",
  computer: "Android chrome desktop device hardware iOS laptop mac monitor pc web window",
  confirmation_number: "admission entertainment event ticket",
  connected_tv: "Android airplay chrome desktop device display hardware iOS mac monitor screencast streaming television web window wireless",
  connecting_airports: "airplanes flight transportation travel trip",
  connect_without_contact: "communicating distance people signal socialize",
  construction: "build carpenter equipment fix hammer improvement industrial industry repair tools wrench",
  contactless: "applepay bluetooth cash connection connectivity credit device finance payment signal tap transaction wifi wireless",
  contact_mail: "account address avatar communicate email face human information message people person profile user",
  contact_page: "account avatar data document drive face folders human people person profile sheet slide storage user writing",
  contact_phone: "account avatar call communicate face human information message mobile number people person profile user",
  contacts: "account address avatar call cell face human information mobile number people person phone profile user",
  contact_support: "? alert announcement bubble chat comment communicate help information mark message punctuation speech symbol vquestion",
  content_copy: "copy document duplicate file multiple past",
  content_cut: "cut document file past scissors trim",
  content_paste: "clipboard copy cut document file multiple",
  content_paste_go: "clipboard disabled document enabled file slash",
  content_paste_off: "clipboard disabled document enabled file slash",
  content_paste_search: "clipboard document file find trace track",
  contrast: "black editing effect filter grayscale images photography pictures settings white",
  control_camera: "adjust arrows center direction left move right",
  control_point: "+ add circle plus",
  control_point_duplicate: "+ add circle multiple new plus symbol",
  co_present: "arrow co-present presentation screen share slides togather website",
  copy_all: "content cut document file multiple page paper past",
  copyright: "alphabet character circle emblem font legal letter owner symbol text",
  coronavirus: "19 bacteria covid disease germs illness sick social",
  corporate_fare: "architecture building business estate organization place real residence residential shelter",
  cottage: "architecture beach estate home house lake lodge maps place real residence residential stay traveling",
  countertops: "home house kitchen sink table",
  create: "compose editing input item new pencil write writing",
  create_new_folder: "+ add data directory document drive file plus sheet slide storage symbol",
  credit_card: "bill cash charge coin commerce cost creditcard currency dollars finance information money online payment price shopping symbol",
  credit_card_off: "charge commerce cost disabled enabled finance money online payment slash",
  credit_score: "approve bill card cash check coin commerce complete cost currency dollars done finance loan mark money ok online payment select symbol tick validate verified yes",
  crib: "babies baby bassinet bed children cradle infant kid newborn sleeping toddler",
  crop: "adjustments area editing frame images photos rectangle settings size square",
  crop_din: "adjustments area editing frame images photos picture rectangle settings size square",
  crop_free: "adjustments barcode editing focus frame image photos qrcode settings size square zoom",
  crop_landscape: "adjustments area editing frame images photos picture settings size square",
  crop_original: "adjustments area editing frame images photos picture settings size square",
  crop_portrait: "adjustments area editing frame images photos picture rectangle settings size square",
  crop_rotate: "adjustments area arrows editing frame images photos settings size turn",
  crop_square: "adjustments area editing frame images photos rectangle settings size",
  css: "alphabet brackets character code developer engineering font html letter platform symbol text type",
  currency_exchange: "360 around arrows cash coin commerce direction dollars inprogress money pay renew rotate sync turn universal",
  currency_franc: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_lira: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_pound: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_ruble: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_rupee: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_yen: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  currency_yuan: "bill card cash coin commerce cost credit dollars finance money online payment price shopping symbol",
  curtains: "blinds cover nest open shutter sunshade",
  curtains_closed: "blinds cover nest shutter sunshade",
  dangerous: "broken fix no sign stop update warning wrong",
  dark_mode: "application device interface moon night silent theme ui ux website",
  dashboard: "cards format layout rectangle shapes square website",
  dashboard_customize: "cards format layout rectangle shapes square website",
  data_saver_off: "analytics bars chart diagram donut infographic measure metrics ring statistics tracking",
  data_saver_on: "+ add analytics chart diagram infographic measure metrics new plus ring statistics symbol tracking",
  data_thresholding: "hidden privacy thresold",
  data_usage: "analytics chart circle diagram infographic measure metrics statistics tracking",
  date_range: "agenda calendar event month remember reminder schedule time today week",
  deblur: "adjust editing enhance face image lines photography sharpen",
  deck: "chairs furniture garden home house outdoors outside patio social terrace umbrella yard",
  dehaze: "adjust editing enhance image lines photography remove",
  delete: "bin garbage junk recycle remove trashcan",
  delete_forever: "bin cancel exit garbage junk recycle remove trashcan",
  delete_outline: "bin can garbage remove trash",
  delete_sweep: "bin garbage junk recycle remove trashcan",
  density_large: "horizontal lines rules",
  density_medium: "horizontal lines rules",
  density_small: "horizontal lines rules",
  departure_board: "automobile bus cars clock maps public schedule time transportation travel vehicle",
  description: "article bill data document drive file folders invoice item notes page paper sheet slide text writing",
  desktop_access_disabled: "Android apple chrome device display enabled hardware iOS mac monitor offline pc screen slash web window",
  desktop_mac: "Android apple chrome device display hardware iOS monitor pc screen web window",
  desktop_windows: "Android chrome device display hardware iOS mac monitor pc screen television tv web",
  details: "editing enhance image photography sharpen triangle",
  developer_board: "computer development devkit hardware microchip processor",
  developer_board_off: "computer development disabled enabled hardware microchip on processor slash",
  developer_mode: "Android bracket cell code development device engineer hardware iOS mobile phone tablet",
  device_hub: "Android circle computer desktop hardware iOS laptop mobile monitor phone square tablet triangle watch wearable web",
  devices: "Android computer desktop hardware iOS laptop mobile monitor phone tablet watch wearable web",
  devices_other: "Android cell chrome desktop gadget hardware iOS ipad mac mobile monitor phone smartwatch tablet vr wearables window",
  device_thermostat: "celsius fahrenheit temperature thermometer",
  device_unknown: "? Android assistance cell hardware help iOS information mark mobile phone punctuation question support symbol tablet",
  dialer_sip: "alphabet call cell character contact device font hardware initiation internet letter mobile over protocol routing session symbol telephone text type voice",
  dialpad: "buttons call contact device dots mobile numbers phone",
  diamond: "fashion gems jewelry logo retail valuables",
  difference: "compare content copy cut document duplicate file multiple past",
  dining: "cafeteria cutlery diner eating fork room spoon",
  dinner_dining: "breakfast food fork lunch meal restaurant spaghetti utensils",
  directions: "arrow maps naviate right route sign traffic",
  directions_bike: "bicycle human maps person public route transportation",
  directions_boat: "automobile cars ferry maps public transportation vehicle",
  directions_boat_filled: "automobile cars ferry maps public transportation vehicle",
  directions_bus: "automobile cars maps public transportation vehicle",
  directions_bus_filled: "automobile cars maps public transportation vehicle",
  directions_car: "automobile cars maps public transportation vehicle",
  directions_car_filled: "automobile cars maps public transportation vehicle",
  directions_off: "arrow disabled enabled maps right route sign slash traffic",
  directions_railway: "automobile cars maps public train transportation vehicle",
  directions_railway_filled: "automobile cars maps public train transportation vehicle",
  directions_run: "body health human jogging maps people person route running walk",
  directions_subway: "automobile cars maps public rail train transportation vehicle",
  directions_subway_filled: "automobile cars maps public rail train transportation vehicle",
  directions_transit: "automobile cars maps metro public rail subway train transportation vehicle",
  directions_transit_filled: "automobile cars maps public rail subway train transportation vehicle",
  directions_walk: "body human jogging maps people person route run",
  dirty_lens: "camera photography picture splat",
  disabled_by_default: "box cancel close exit no quit remove square stop",
  disc_full: "! alert attention caution cd danger error exclamation important mark music notification storage symbol vinyl warning",
  display_settings: "Android application change chrome desktop details device gear hardware iOS information mac monitor options personal screen service web window",
  dns: "address bars domain information ip list lookup name network server system",
  dock: "Android cell charger charging connector device hardware iOS mobile phone power station tablet",
  document_scanner: "article data drive file folders notes page paper sheet slide text writing",
  do_disturb: "cancel close denied deny remove silence stop",
  do_disturb_alt: "cancel close denied deny remove silence stop",
  do_disturb_off: "cancel close denied deny disabled enabled on remove silence slash stop",
  do_disturb_on: "cancel close denied deny disabled enabled off remove silence slash stop",
  domain: "apartment architecture building business estate home place real residence residential shelter web www",
  domain_add: "+ apartment architecture building business estate home new place plus real residence residential shelter symbol web www",
  domain_disabled: "apartment architecture building business company enabled estate home internet maps office offline on place real residence residential slash website",
  domain_verification: "application approve check complete design desktop done interface internet layout mark ok screen select tick ui ux validate verified website window www yes",
  done: "approve checkmark complete finished ok select success tick validate verified yes",
  done_all: "approve checkmark complete finished layers multiple ok select stack success tick validate verified yes",
  done_outline: "all approve checkmark complete finished ok select success tick validate verified yes",
  do_not_disturb: "cancel close denied deny remove silence stop",
  do_not_disturb_alt: "cancel close denied deny remove silence stop",
  do_not_disturb_off: "cancel close denied deny disabled enabled on remove silence slash stop",
  do_not_disturb_on: "cancel close denied deny disabled enabled off remove silence slash stop",
  do_not_disturb_on_total_silence: "busy mute on quiet total",
  do_not_step: "boot disabled enabled feet foot off on shoe slash sneaker",
  do_not_touch: "disabled enabled fingers gesture hand off on slash",
  donut_large: "analytics chart circle complete data diagram infographic inprogress, measure metrics pie statistics tracking",
  donut_small: "analytics chart circle data diagram infographic inprogress measure metrics pie statistics tracking",
  door_back: "closed doorway entrance exit home house",
  doorbell: "alarm home house ringing",
  door_front: "closed doorway entrance exit home house",
  door_sliding: "automatic doorway double entrance exit glass home house two",
  double_arrow: "arrows chevron direction multiple navigation right",
  downhill_skiing: "athlete athletic body entertainment exercise hobby human people person ski snow social sports travel winter",
  download: "arrow downloads drive install upload",
  download_done: "arrows check downloads drive installed ok tick upload",
  download_for_offline: "arrow circle for install offline upload",
  downloading: "arrow circle downloads install pending progress upload",
  drafts: "document email envelope file letter message read",
  drag_handle: "application components design interface layout lines menu move screen ui ux website window",
  drag_indicator: "application circles components design dots drop interface layout mobile monitor move phone screen shape shift tablet ui ux website window",
  drive_eta: "automobile cars destination direction estimate maps public transportation travel trip vehicle",
  drive_file_move: "arrows data direction document folders right sheet side slide storage",
  drive_file_rename_outline: "compose create draft editing input pencil write writing",
  drive_folder_upload: "arrow data document file sheet slide storage",
  dry: "air bathroom dryer fingers gesture hand wc",
  dry_cleaning: "hanger hotel laundry places service towel",
  duo: "call chat conference device video",
  dvr: "Android audio chrome computer desktop device display electronic hardware iOS laptop list mac monitor recorder screen tv video web window",
  dynamic_feed: "layer live multiple post refresh update",
  dynamic_form: "code electric fast lightning lists questionnaire thunderbolt",
  earbuds: "accessory audio earphone headphone listen music sound",
  earbuds_battery: "accessory audio charging earphone headphone listen music sound",
  east: "arrow directional maps navigation right",
  edgesensor_high: "Android cell device hardware iOS mobile move phone sensitivity tablet vibrate",
  edgesensor_low: "Android cell device hardware iOS mobile move phone sensitivity tablet vibrate",
  edit: "compose create editing input new pencil write writing",
  edit_attributes: "approve attribution check complete done mark ok select tick validate verified yes",
  edit_location: "destination direction gps maps pencil pin place stop write",
  edit_location_alt: "pencil pin",
  edit_notifications: "active alarm alert bell chime compose create draft editing input new notify pencil reminder ring sound write writing",
  edit_off: "compose create disabled draft editing enabled input new offline on pencil slash write writing",
  edit_road: "destination direction highway maps pencil street traffic",
  egg: "breakfast brunch food",
  egg_alt: "breakfast brunch food",
  eject: "arrow disc drive dvd player remove triangle up usb",
  elderly: "body cane human old people person senior",
  elderly_woman: "body cane female gender girl human lady old people person senior social symbol women",
  electrical_services: "charge cord plug power wire",
  electric_bike: "automobile cars electricity maps scooter transportation travel vehicle vespa",
  electric_bolt: "energy fast lightning nest thunderbolt",
  electric_car: "automobile cars electricity maps transportation travel vehicle",
  electric_meter: "energy fast lightning measure nest thunderbolt usage voltage volts",
  electric_moped: "automobile bike cars maps scooter transportation travel vehicle vespa",
  electric_rickshaw: "automobile cars india maps transportation truck vehicle",
  electric_scooter: "automobile bike cars maps transportation vehicle vespa",
  elevator: "body down human people person up",
  email: "envelope letter message note post receive send write",
  e_mobiledata: "alphabet font letter text type",
  emoji_emotions: "emoticon expressions face feelings glad happiness happy like mood person pleased smiley smiling social survey",
  emoji_events: "achievement award chalice champion cup first prize reward sport trophy winner",
  emoji_food_beverage: "coffee cup dring drink mug plate set tea",
  emoji_nature: "animal bee daisy flower honey insect ladybug petals spring summer",
  emoji_objects: "creative idea lamp lightbulb solution thinking",
  emoji_people: "arm body greeting human person social wave waving",
  emoji_symbols: "ampersand character hieroglyph music note percent sign",
  emoji_transportation: "architecture automobile building cars commute company direction estate maps office place public real residence residential shelter travel vehicle",
  energy_savings_leaf: "eco leaves nest usage",
  engineering: "body cogs cogwheel construction fixing gears hat helmet human maintenance people person setting worker",
  enhanced_encryption: "+ add locked new password plus privacy private protection safety secure security symbol",
  equalizer: "adjustment analytics chart data graph measure metrics music noise sound static statistics tracking volume",
  error: "! alert announcement attention caution circle danger exclamation feedback important mark notification problem symbol warning",
  error_outline: "! alert announcement attention caution circle danger exclamation feedback important mark notification problem symbol warning",
  escalator: "down staircase up",
  escalator_warning: "body child human kid parent people person",
  euro: "bill card cash coin commerce cost credit currency dollars euros finance money online payment price profit shopping symbol",
  euro_symbol: "bill card cash coin commerce cost credit currency dollars finance money online payment price profit",
  event: "agenda calendar date item mark month range remember reminder today week",
  event_available: "agenda approve calendar check complete done item mark ok schedule select tick time validate verified yes",
  event_busy: "agenda calendar cancel close date exit item no remove schedule stop time unavailable",
  event_note: "agenda calendar date item schedule text time writing",
  event_repeat: "around calendar date day inprogress loading month refresh renew rotate schedule turn",
  event_seat: "assigned bench chair furniture reservation row section sit",
  ev_station: "automobile cars charge charging electricity filling fuel gasoline maps places power station transportation vehicle",
  exit_to_app: "application arrow back components design export interface layout leave login logout mobile monitor move output phone pointing quit register right screen signin signout signup tablet ux website window",
  expand: "arrows compress enlarge grow move push together",
  expand_circle_down: "arrows chevron collapse direction expandable list more",
  expand_less: "arrows chevron collapse direction expandable list up",
  expand_more: "arrows chevron collapse direction down expandable list",
  explicit: "adult alphabet character content font language letter media movies music parent rating supervision symbol text type",
  explore: "compass destination direction east location maps needle north south travel west",
  explore_off: "compass destination direction disabled east enabled location maps needle north slash south travel west",
  exposure: "add brightness contrast editing effect image minus photography picture plus settings subtract",
  extension: "add-ons app extended game item jigsaw piece plugin puzzle shape",
  extension_off: "disabled enabled extended jigsaw piece puzzle shape slash",
  face: "account avatar emoji eyes human login logout people person profile recognition security social thumbnail unlock user",
  face_retouching_natural: "editing effect emoji emotion faces image photography settings star tag",
  face_retouching_off: "disabled editing effect emoji emotion enabled faces image natural photography settings slash tag",
  fact_check: "approve complete done list mark ok select tick validate verified yes",
  factory: "industry manufacturing warehouse",
  family_restroom: "bathroom children father kids mother parents wc",
  fastfood: "drink hamburger maps meal places",
  fast_forward: "control ff media music play speed time tv video",
  fast_rewind: "back control media music play speed time tv video",
  favorite: "appreciate health heart like love remember save shape success",
  favorite_border: "health heart like love outline remember save shape success",
  fax: "machine office phone send",
  featured_play_list: "audio collection highlighted item music playlist recommended",
  featured_video: "advertisement advertisment highlighted item play recommended watch,advertised",
  feed: "article headline information newspaper public social timeline",
  feedback: "! alert announcement attention bubble caution chat comment communicate danger error exclamation important mark message notification speech symbol warning",
  female: "gender girl lady social symbol woman women",
  fence: "backyard barrier boundaries boundary home house protection",
  festival: "circus event local maps places tent tour travel",
  fiber_dvr: "alphabet character digital electronics font letter network recorder symbol text tv type video",
  fiber_manual_record: "circle dot play watch",
  fiber_new: "alphabet character font letter network symbol text type",
  fiber_pin: "alphabet character font letter network symbol text type",
  fiber_smart_record: "circle dot play watch",
  file_copy: "bill clone content cut document duplicate invoice item multiple page past",
  file_download: "arrows downloads drive export install upload",
  file_download_done: "arrows check downloads drive installed tick upload",
  file_download_off: "arrow disabled drive enabled export install on save slash upload",
  file_open: "arrow document drive left page paper",
  file_present: "clip data document drive folders note paper reminder sheet slide storage writing",
  file_upload: "arrows download drive export",
  filter: "editing effect image landscape mountains photography picture settings",
  filter_1: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_2: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_3: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_4: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_5: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_6: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_7: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_8: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_9: "digit editing effect images multiple number photography pictures settings stack symbol",
  filter_9_plus: "+ digit editing effect images multiple number photography pictures settings stack symbol",
  filter_alt: "edit funnel options refine sift",
  filter_alt_off: "[offline] disabled edit funnel options refine sift slash",
  filter_b_and_w: "black contrast editing effect grayscale images photography pictures settings white",
  filter_center_focus: "camera dot edit image photography picture",
  filter_drama: "camera cloud editing effect image photography picture sky",
  filter_frames: "boarders border camera center editing effect filters focus image options photography picture",
  filter_hdr: "camera editing effect image mountains photography picture",
  filter_list: "lines organize sort",
  filter_list_off: "[offline] alt disabled edit options refine sift slash",
  filter_none: "multiple stack",
  filter_tilt_shift: "blur center editing effect focus images photography pictures",
  filter_vintage: "editing effect flower images photography pictures",
  find_in_page: "data document drive file folders glass look magnifying paper search see sheet slide writing",
  find_replace: "around arrows glass inprogress loading look magnifying refresh renew rotate search see",
  fingerprint: "biometrics identification identity reader thumbprint touchid verification",
  fire_extinguisher: "emergency water",
  fireplace: "chimney flame home house living pit room warm winter",
  first_page: "arrow back chevron left rewind",
  fitness_center: "athlete dumbbell exercise gym health hobby places sport weights workout",
  fit_screen: "enlarge format layout reduce scale size",
  flag: "country goal mark nation report start",
  flag_circle: "country goal mark nation report round start",
  flaky: "approve check close complete contrast done exit mark no ok options select stop tick verified yes",
  flare: "bright editing effect images lensflare light photography pictures shine sparkle star sun",
  flash_auto: "camera electric fast lightning thunderbolt",
  flashlight_off: "disabled enabled on slash",
  flashlight_on: "disabled enabled off slash",
  flash_off: "camera disabled electric enabled fast lightning on slash thunderbolt",
  flash_on: "camera disabled electric enabled fast lightning off slash thunderbolt",
  flatware: "cafeteria cutlery diner dining eating fork room spoon",
  flight: "airplane airport flying transportation travel trip",
  flight_class: "airplane business first seat transportation travel trip window",
  flight_land: "airplane airport arrival arriving flying landing transportation travel",
  flight_takeoff: "airplane airport departed departing flying landing transportation travel",
  flip: "editing image orientation scanning",
  flip_camera_android: "center editing front image mobile orientation rear reverse rotate turn",
  flip_camera_ios: "android editing front image mobile orientation rear reverse rotate turn",
  flip_to_back: "arrangement format front layout move order sort",
  flip_to_front: "arrangement back format layout move order sort",
  flutter_dash: "bird mascot",
  fmd_bad: "! alert attention caution danger destination direction error exclamation important location maps mark notification pin place symbol warning",
  fmd_good: "destination direction location maps pin place stop",
  folder: "data directory document drive file folders sheet slide storage",
  folder_delete: "bin can data document drive file folders garbage remove sheet slide storage trash",
  folder_off: "[online] data disabled document drive enabled file folders sheet slash slide storage",
  folder_open: "data directory document drive file folders sheet slide storage",
  folder_shared: "account collaboration data directory document drive face human people person profile sheet slide storage team user",
  folder_special: "bookmark data directory document drive favorite file highlight important marked saved shape sheet slide star storage",
  folder_zip: "compress data document drive file folders open sheet slide storage",
  follow_the_signs: "arrow body directional human people person right social",
  font_download: "A alphabet character letter square symbol text type",
  font_download_off: "alphabet character disabled enabled letter slash square symbol text type",
  food_bank: "architecture building charity eat estate fork house knife meal place real residence residential shelter utensils",
  forest: "jungle nature plantation plants trees woodland",
  fork_left: "arrows directions maps navigation path route sign traffic",
  fork_right: "arrows directions maps navigation path route sign traffic",
  format_align_center: "alignment doc editing editor lines spreadsheet text type writing",
  format_align_justify: "alignment density doc editing editor extra lines small spreadsheet text type writing",
  format_align_left: "alignment doc editing editor lines spreadsheet text type writing",
  format_align_right: "alignment doc editing editor lines spreadsheet text type writing",
  format_bold: "B alphabet character doc editing editor font letter spreadsheet styles symbol text type writing",
  format_clear: "T alphabet character disabled doc editing editor enabled font letter off slash spreadsheet style symbol text type writing",
  format_color_fill: "bucket doc editing editor paint spreadsheet style text type writing",
  format_color_reset: "clear disabled doc droplet editing editor enabled fill liquid off on paint slash spreadsheet style text type water writing",
  format_color_text: "doc editing editor fill paint spreadsheet style type writing",
  format_indent_decrease: "alignment doc editing editor indentation paragraph spreadsheet text type writing",
  format_indent_increase: "alignment doc editing editor indentation paragraph spreadsheet text type writing",
  format_italic: "alphabet character doc editing editor font letter spreadsheet style symbol text type writing",
  format_line_spacing: "alignment doc editing editor spreadsheet text type writing",
  format_list_bulleted: "alignment doc editing editor notes spreadsheet task text todo type writing",
  format_list_numbered: "alignment digit doc editing editor notes spreadsheet symbol task text todo type writing",
  format_list_numbered_rtl: "alignment digit doc editing editor notes spreadsheet symbol task text todo type writing",
  format_overline: "alphabet character doc editing editor font letter spreadsheet style symbol text type under writing",
  format_paint: "brush color doc editing editor fill paintroller spreadsheet style text type writing",
  format_quote: "doc editing editor quotation spreadsheet text type writing",
  format_shapes: "alphabet character color doc editing editor fill font letter paint spreadsheet style symbol text type writing",
  format_size: "alphabet character color doc editing editor fill font letter paint spreadsheet style symbol text type writing",
  format_strikethrough: "alphabet character doc editing editor font letter spreadsheet style symbol text type writing",
  format_textdirection_l_to_r: "alignment doc editing editor ltr paragraph spreadsheet type writing",
  format_textdirection_r_to_l: "alignment doc editing editor paragraph rtl spreadsheet type writing",
  format_underlined: "alphabet character doc editing editor font letter spreadsheet style symbol text type writing",
  forum: "bubble chat comment communicate community conversation feedback hub messages speech talk",
  forward: "arrow mail message playback right sent",
  forward_10: "arrow circle controls digit fast music number play rotate seconds speed symbol time video",
  forward_30: "arrow circle controls digit fast music number rotate seconds speed symbol time video",
  forward_5: "10 arrow circle controls digit fast music number rotate seconds speed symbol time video",
  forward_to_inbox: "arrow email envelop letter message send",
  foundation: "architecture base basis building construction estate home house real residential",
  free_breakfast: "beverage cafe coffee cup drink mug tea",
  fullscreen: "adjust application components interface size ui ux view website",
  fullscreen_exit: "adjust application components interface size ui ux view website",
  functions: "average calculate count doc editing editor math sigma spreadsheet style sum text type writing",
  gamepad: "buttons console controller device gaming playstation video",
  games: "adjust arrows controller direction dpad gaming left move nintendo playstation right xbox",
  garage: "automobile automotive cars direction maps transportation travel vehicle",
  gas_meter: "droplet energy measure nest usage water",
  gavel: "agreement contract court document government hammer judge law mallet official police rules terms",
  gesture: "drawing finger gestures hand line motion",
  get_app: "arrows downloads export install play pointing retrieve upload",
  gif: "alphabet animated animation bitmap character font format graphics interchange letter symbol text type",
  gif_box: "alphabet animated animation bitmap character font format graphics interchange letter symbol text type",
  girl: "body female gender human lady people person social symbol woman women",
  gite: "architecture estate home hostel house maps place real residence residential stay traveling",
  g_mobiledata: "alphabet character font letter network service symbol text type",
  golf_course: "athlete athletic ball club entertainment flag golfer golfing hobby hole places putt sports",
  gpp_bad: "cancel certified close error exit no privacy private protection remove security shield sim stop verified",
  gpp_good: "certified check ok pass security shield sim tick",
  gpp_maybe: "! alert attention caution certified danger error exclamation important mark notification privacy private protection security shield sim symbol verified warning",
  gps_fixed: "destination direction location maps pin place pointer stop tracking",
  gps_not_fixed: "destination direction disabled enabled fixed location maps not off online place pointer slash tracking",
  gps_off: "destination direction disabled enabled fixed location maps not offline place pointer slash tracking",
  grade: "achievement important likes marked rated rating reward saved shape special star",
  gradient: "color editing effect filter images photography pictures",
  grading: "approve check complete document done feedback grade mark ok reviewed select tick validate verified writing yes",
  grain: "dots editing effect filter images photography pictures",
  graphic_eq: "audio equalizer music recording sound voice",
  grass: "backyard fodder ground home lawn plant turf",
  grid_goldenratio: "layout lines space",
  grid_off: "collage disabled enabled image layout on slash view",
  grid_on: "collage disabled enabled image layout off sheet slash view",
  grid_view: "application blocks components dashboard design interface layout screen square tiles ui ux website window",
  group: "accounts committee face family friends humans network people persons profiles social team users",
  group_add: "accounts committee face family friends humans increase more network people persons plus profiles social team users",
  group_remove: "accounts committee face family friends humans network people persons profiles social team users",
  groups: "body club collaboration crowd gathering human meeting people person social teams",
  group_work: "alliance circle collaboration film partnership reel teamwork together",
  g_translate: "emblem google language logo mark speaking speech translator words",
  hail: "body human people person pick public stop taxi transportation",
  handyman: "build construction fix hammer repair screwdriver tools",
  hardware: "break construction hammer nail repair tool",
  hd: "alphabet character definition display font high letter movies quality resolution screen symbol text tv type video",
  hdr_auto: "A alphabet camera character circle dynamic font high letter photo range symbol text type",
  hdr_auto_select: "+ A alphabet camera character circle dynamic font high letter photo range symbol text type",
  hdr_enhanced_select: "add alphabet character dynamic font high letter plus range symbol text type",
  hdr_off: "alphabet character disabled dynamic enabled enhance font high letter range select slash symbol text type",
  hdr_off_select: "alphabet camera character circle disabled dynamic enabled font high letter photo range slash symbol text type",
  hdr_on: "add alphabet character dynamic enhance font high letter plus range select symbol text type",
  hdr_on_select: "+ alphabet camera character circle dynamic font high letter photo range symbol text type",
  hdr_plus: "+ add alphabet character circle dynamic enhance font high letter range select symbol text type",
  hdr_strong: "circles dots dynamic enhance high range",
  hdr_weak: "circles dots dynamic enhance high range",
  headphones: "accessory audio device earphone headset listen music sound",
  headphones_battery: "accessory audio charging device earphone headset listen music sound",
  headset: "accessory audio device earbuds earmuffs earphone headphones listen music sound",
  headset_mic: "accessory audio chat device earphone headphones listen music sound talk",
  headset_off: "accessory audio chat device disabled earphone enabled headphones listen mic music slash sound talk",
  healing: "bandage bandaid editing emergency fix health hospital image medicine",
  health_and_safety: "+ add certified plus privacy private protection security shield symbol verified",
  hearing: "accessibility accessible aid handicap help impaired listen sound volume",
  hearing_disabled: "accessibility accessible aid enabled handicap help impaired listen off on slash sound volume",
  heart_broken: "break core crush health nucleus split",
  heat_pump: "air conditioner cool energy furnance nest usage",
  height: "arrows color doc down editing editor fill format paint resize spreadsheet stretch style text type up writing",
  help: "? alert announcement assistance circle information mark punctuation question shape support symbol",
  help_center: "? assistance information mark punctuation question support symbol",
  help_outline: "? alert announcement assistance circle information mark punctuation question shape support symbol",
  hevc: "alphabet character coding efficiency font high letter symbol text type video",
  hexagon: "shape sides six",
  hide_image: "disabled enabled landscape mountains off on photography picture slash",
  hide_source: "circle disabled enabled offline on shape slash",
  highlight: "color doc editing editor emphasize fill flashlight format marker paint spreadsheet style text type writing",
  highlight_off: "cancel circle clear click close delete disable exit focus no quit remove stop target times",
  high_quality: "alphabet character definition display font hq letter movies resolution screen symbol text tv type",
  hiking: "backpacking bag climbing duffle mountain social sports stick trail travel walking",
  history: "arrow backwards clock date refresh renew reverse revert rotate schedule time turn undo",
  history_edu: "document education feather letter paper pen quill school tools write writing",
  history_toggle_off: "clock date schedule time",
  hls: "alphabet character developer engineering font letter platform symbol text type",
  hls_off: "[offline] alphabet character developer disabled enabled engineering font letter platform slash symbol text type",
  h_mobiledata: "alphabet character font letter network service symbol text type",
  holiday_village: "architecture beach camping cottage estate home house lake lodge maps place real residence residential stay traveling vacation",
  home: "address application--house architecture building components design estate homepage interface layout place real residence residential screen shelter structure unit ux website window",
  home_max: "device gadget hardware internet iot nest smart things",
  home_mini: "Internet device gadget hardware iot nest smart things",
  home_repair_service: "equipment fix kit mechanic repairing toolbox tools workshop",
  home_work: "architecture building estate house office place real residence residential shelter",
  horizontal_rule: "gmail line novitas",
  horizontal_split: "bars format layout lines stacked",
  hotel: "bed body human people person sleep stay travel trip",
  hot_tub: "bathing bathroom bathtub hotel human jacuzzi person shower spa steam travel water",
  hourglass_bottom: "countdown half loading minutes time waiting",
  hourglass_disabled: "clock countdown empty enabled loading minutes off on slash time waiting",
  hourglass_empty: "countdown loading minutes start time waiting",
  hourglass_full: "countdown loading minutes time waiting",
  hourglass_top: "countdown half loading minutes time waiting",
  house: "architecture building estate family homepage places real residence residential shelter",
  houseboat: "architecture beach estate floating home maps place real residence residential sea stay traveling vacation",
  house_siding: "architecture building construction estate exterior facade home real residential",
  how_to_reg: "approve ballot check complete done election mark ok poll register registration select tick to validate verified vote yes",
  how_to_vote: "ballot election poll",
  h_plus_mobiledata: "+ alphabet character font letter network service symbol text type",
  html: "alphabet brackets character code css developer engineering font letter platform symbol text type",
  http: "alphabet character font internet letter network symbol text transfer type url website",
  https: "connection encrypt internet key locked network password privacy private protection safety secure security ssl web",
  hub: "center connection core focal network nucleus point topology",
  hvac: "air conditioning heating ventilation",
  icecream: "dessert food snack",
  ice_skating: "athlete athletic entertainment exercise hobby shoe skates social sports travel",
  image: "disabled enabled frame hide landscape mountains off on photography picture slash",
  image_aspect_ratio: "photography picture rectangle square",
  image_not_supported: "disabled enabled landscape mountains off on photography picture slash",
  image_search: "find glass landscape look magnifying mountains photography picture see",
  imagesearch_roller: "art paint",
  important_devices: "Android cell computer desktop hardware iOS mobile monitor phone star tablet web",
  import_contacts: "address book friends information magazine open",
  import_export: "arrows direction down explort up",
  inbox: "archive email incoming message",
  indeterminate_check_box: "application button components control design form interface minus screen selected selection square toggle ui undetermined ux website",
  info: "about alert announcement announcment assistance bubble circle details help information service support",
  input: "arrow box download login move right",
  insert_chart: "analytics barchart bars data diagram infographic measure metrics statistics tracking",
  insert_chart_outlined: "analytics bars data diagram infographic measure metrics statistics tracking",
  insert_comment: "add bubble chat feedback message",
  insert_drive_file: "bill document format invoice item sheet slide",
  insert_emoticon: "account emoji face happy human like people person profile sentiment smiley user",
  insert_invitation: "agenda calendar date event mark month range remember reminder today week",
  insert_link: "add anchor attach clip file mail media",
  insert_page_break: "document file paper",
  insert_photo: "image landscape mountains photography picture wallpaper",
  insights: "analytics bars chart data diagram infographic measure metrics stars statistics tracking",
  install_desktop: "Android chrome device display fix hardware iOS mac monitor place pwa screen web window",
  install_mobile: "Android cell device hardware iOS phone pwa tablet",
  integration_instructions: "brackets clipboard code css developer document engineering html platform",
  interests: "circle heart shapes social square triangle",
  interpreter_mode: "language microphone person speaking symbol",
  inventory: "archive box buy check clipboard document e-commerce file list organize packages product purchase shop stock store supply",
  invert_colors: "droplet editing hue inverted liquid palette tone water",
  invert_colors_off: "disabled droplet enabled hue inverted liquid offline opacity palette slash tone water",
  ios_share: "arrows button direction export internet link send sharing social up website",
  iron: "appliance clothes electric ironing machine object",
  iso: "add editing effect image minus photography picture plus sensor shutter speed subtract",
  javascript: "alphabet brackets character code css developer engineering font html letter platform symbol text type",
  join_full: "circle combine command left outter right sql",
  join_inner: "circle command matching sql values",
  join_left: "circle command matching sql values",
  join_right: "circle command matching sql values",
  kayaking: "athlete athletic body canoe entertainment exercise hobby human lake paddle paddling people person rafting river row social sports summer travel water",
  key: "blackout password restricted secret unlock",
  keyboard: "computer device hardware input keypad letter office text type",
  keyboard_alt: "computer device hardware input keypad letter office text type",
  keyboard_arrow_down: "arrows chevron open",
  keyboard_arrow_left: "arrows chevron",
  keyboard_arrow_right: "arrows chevron open start",
  keyboard_arrow_up: "arrows chevron submit",
  keyboard_backspace: "arrow left",
  keyboard_capslock: "arrow up",
  keyboard_command_key: "button command control key",
  keyboard_control_key: "control key",
  keyboard_double_arrow_down: "arrows direction multiple navigation",
  keyboard_double_arrow_left: "arrows direction multiple navigation",
  keyboard_double_arrow_right: "arrows direction multiple navigation",
  keyboard_double_arrow_up: "arrows direction multiple navigation",
  keyboard_hide: "arrow computer device down hardware input keypad text",
  keyboard_option_key: "alt key modifier",
  keyboard_return: "arrow back left",
  keyboard_tab: "arrow next right",
  keyboard_voice: "microphone noise recorder speaker",
  key_off: "[offline] disabled enabled on password slash unlock",
  king_bed: "bedroom double furniture home hotel house night pillows queen rest sleep",
  kitchen: "appliance cabinet cold food freezer fridge home house ice places refrigerator storage",
  kitesurfing: "athlete athletic beach body entertainment exercise hobby human people person social sports travel water",
  label: "badge favorite indent item library mail remember save stamp sticker tag",
  label_important: "badge favorite important. indent item library mail remember save stamp sticker tag wing",
  label_off: "disabled enabled favorite indent library mail on remember save slash stamp sticker tag wing",
  lan: "computer connection data internet network service",
  landscape: "image mountains nature photography picture",
  language: "country earth globe i18n internet l10n planet website world www",
  laptop: "Android chrome computer connect desktop device display hardware iOS link mac monitor smart tv web windows",
  laptop_chromebook: "Android chromebook device display hardware iOS mac monitor screen web window",
  laptop_mac: "Android apple chrome device display hardware iOS monitor screen web window",
  laptop_windows: "Android chrome device display hardware iOS mac monitor screen web",
  last_page: "application arrow chevron components end forward interface right screen ui ux website",
  launch: "application arrow box components core interface internal new open screen ui ux website window",
  layers: "arrange disabled enabled interaction maps off overlay pages slash stack",
  layers_clear: "arrange delete disabled enabled interaction maps off overlay pages slash",
  leaderboard: "analytics bars chart data diagram infographic measure metrics statistics tracking",
  leak_add: "connection data link network service signals synce wireless",
  leak_remove: "connection data disabled enabled link network offline service signals slash synce wireless",
  legend_toggle: "analytics chart data diagram infographic measure metrics monitoring stackdriver statistics tracking",
  lens: "circle full geometry moon",
  lens_blur: "camera dim dot effect foggy fuzzy image photo soften",
  library_add: "+ collection layers multiple music new plus save stacked symbol video",
  library_add_check: "approve collection complete done layers mark multiple music ok select stacked tick validate verified video yes",
  library_books: "add album audio collection reading",
  library_music: "add album audio collection song sounds",
  light: "bulb ceiling hanging inside interior lamp lighting pendent room",
  lightbulb: "alert announcement idea information learning mode",
  lightbulb_circle: "alert announcement idea information",
  light_mode: "brightness day device lighting morning mornng sky sunny",
  linear_scale: "application components design interface layout measure menu screen slider ui ux website window",
  line_axis: "dash horizontal stroke vertical",
  line_style: "dash dotted editor rule spacing",
  line_weight: "editor height size spacing style thickness",
  link: "anchor chain clip connection external hyperlink linked links multimedia unlisted url",
  linked_camera: "connection lens network photography picture signals sync wireless",
  link_off: "anchor attached chain clip connection disabled enabled linked links multimedia slash unlink url",
  liquor: "alcohol bar bottle club cocktail drink food party store wine",
  list: "editor file format index menu options playlist task todo",
  list_alt: "box contained editor format lines reorder sheet stacked task title todo",
  live_help: "? alert announcement assistance bubble chat comment communicate faq information mark message punctuation question speech support symbol",
  live_tv: "Android antennas chrome desktop device hardware iOS mac monitor movie play stream television web window",
  living: "chair comfort couch decoration furniture home house lounging loveseat room seating sofa",
  local_activity: "event star things ticket",
  local_airport: "airplane flight flying transportation travel trip",
  local_atm: "bill card cart cash coin commerce credit currency dollars financial money online payment price profit shopping symbol",
  local_bar: "alcohol bottle club cocktail drink food liquor martini wine",
  local_cafe: "bottle coffee cup drink food mug restaurant tea",
  local_car_wash: "automobile cars maps transportation travel vehicle",
  local_convenience_store: "-- 24 bill building business card cash coin commerce company credit currency dollars maps market money new online payment plus shopping storefront symbol",
  local_dining: "cutlery eat food fork knife meal restaurant spoon",
  local_drink: "cup droplet glass liquid park water",
  local_fire_department: "911 firefighter flame hot",
  local_florist: "flower shop",
  local_gas_station: "auto car filling fuel gasoline oil station vehicle",
  local_grocery_store: "market shop",
  local_hospital: "911 aid cross doctor emergency first health medical medicine plus",
  local_hotel: "bed body human people person sleep stay travel trip",
  local_laundry_service: "cleaning clothing dryer hotel washer",
  local_library: "book community learning person read",
  local_mall: "bill building business buy card cart cash coin commerce credit currency dollars handbag money online payment shopping storefront",
  local_offer: "deal discount price shopping store tag",
  local_parking: "alphabet auto car character font garage letter symbol text type vehicle",
  local_pharmacy: "911 aid cross emergency first food hospital medicine places",
  local_phone: "booth call telecommunication",
  local_pizza: "drink fastfood meal",
  local_police: "911 badge law officer protection security shield",
  local_post_office: "delivery email envelop letter message package parcel postal send stamp",
  local_printshop: "draft fax ink machine office paper printer send",
  local_see: "camera lens photography picture",
  local_shipping: "automobile cars delivery letter mail maps office package parcel postal semi send shopping stamp transportation truck vehicle",
  local_taxi: "automobile cab call cars direction lyft maps public transportation uber vehicle yellow",
  location_city: "apartments architecture buildings business company estate home landscape place real residence residential shelter town urban",
  location_disabled: "destination direction enabled maps off pin place pointer slash stop tracking",
  location_off: "destination direction disabled enabled gps maps pin place room slash stop",
  location_on: "destination direction disabled enabled gps maps off pin place room slash stop",
  location_searching: "destination direction maps pin place pointer stop tracking",
  lock: "connection key locked logout padlock password privacy private protection safety secure security signout",
  lock_clock: "date locked password privacy private protection safety schedule secure security time",
  lock_open: "connection key login padlock password privacy private protection register safety secure security signin signup unlocked",
  lock_reset: "around inprogress loading locked password privacy private protection refresh renew rotate safety secure security turn",
  login: "access application arrow components design enter interface left screen ui ux website",
  logo_dev: "dev.to",
  logout: "application arrow components design exit interface leave login right screen ui ux website",
  looks: "circle half rainbow",
  looks_3: "digit numbers square symbol",
  looks_4: "digit numbers square symbol",
  looks_5: "digit numbers square symbol",
  looks_6: "digit numbers square symbol",
  looks_one: "1 digit numbers square symbol",
  looks_two: "2 digit numbers square symbol",
  loop: "around arrows direction inprogress loader loading music navigation refresh renew repeat rotate turn",
  loupe: "+ add details focus glass magnifying new plus symbol",
  low_priority: "arrange arrow backward bottom list move order task todo",
  loyalty: "badge card credit heart love membership miles points program sale subscription tag travel trip",
  lte_mobiledata: "alphabet character font internet letter network speed symbol text type wifi wireless",
  lte_plus_mobiledata: "+ alphabet character font internet letter network speed symbol text type wifi wireless",
  luggage: "airport baggage carry flight hotel on suitcase travel trip",
  lunch_dining: "breakfast dinner drink fastfood hamburger meal",
  lyrics: "audio bubble chat comment communicate feedback key message music note song sound speech track",
  mail: "email envelope inbox letter message send",
  mail_lock: "email envelop letter locked message password privacy private protection safety secure security send",
  mail_outline: "email envelope letter message note post receive send write",
  male: "boy gender man social symbol",
  man: "boy gender male social symbol",
  manage_accounts: "change details face gear options people person profile service-human settings user",
  manage_search: "glass history magnifying text",
  map: "destination direction location maps pin place route stop travel",
  maps_home_work: "building house office",
  maps_ugc: "+ add bubble comment communicate feedback message new plus speech symbol",
  margin: "design layout padding size square",
  mark_as_unread: "envelop letter mail postal receive send",
  mark_chat_read: "approve bubble check comment communicate complete done message ok select sent speech tick verified yes",
  mark_chat_unread: "bubble circle comment communicate message notification speech",
  mark_email_read: "approve check complete done envelop letter message note ok select send sent tick yes",
  mark_email_unread: "check circle envelop letter message note notification send",
  markunread: "email envelope letter message send",
  markunread_mailbox: "deliver envelop letter postal postbox receive send",
  masks: "air cover covid face hospital medical pollution protection respirator sick social",
  maximize: "application components design interface line screen shape ui ux website",
  media_bluetooth_off: "connection connectivity device disabled enabled music note offline paring signal slash symbol wireless",
  media_bluetooth_on: "connection connectivity device disabled enabled music note off online paring signal slash symbol wireless",
  mediation: "alternative arrows compromise direction dots negotiation party right structure",
  medical_services: "aid bag briefcase emergency first kit medicine",
  medication: "doctor drug emergency hospital medicine pharmacy pills prescription",
  meeting_room: "building doorway entrance home house interior logout office open places signout",
  memory: "card chip digital micro processor sd storage",
  menu: "application components hamburger interface lines playlist screen ui ux website",
  menu_book: "dining food meal page restaurant",
  menu_open: "application arrow chevron components hamburger interface left lines screen ui ux website",
  merge: "arrows directions maps navigation path route sign traffic",
  merge_type: "arrow combine direction format text",
  message: "bubble chat comment communicate feedback speech talk text",
  mic: "hearing microphone noise record search sound speech voice",
  mic_external_off: "audio disabled enabled microphone slash sound voice",
  mic_external_on: "audio disabled enabled microphone off slash sound voice",
  mic_none: "hearing microphone noise record sound voice",
  mic_off: "audio disabled enabled hearing microphone noise recording slash sound voice",
  microwave: "appliance cooking electric heat home house kitchen machine",
  military_tech: "army award badge honor medal merit order privilege prize rank reward ribbon soldier star status trophy winner",
  minimize: "application components design interface line screen shape ui ux website",
  missed_video_call: "arrow camera filming hardware image motion picture record videography",
  mms: "bubble chat comment communicate feedback image landscape message mountains multimedia photography picture speech",
  mobiledata_off: "arrow disabled down enabled internet network on slash speed up wifi wireless",
  mobile_friendly: "Android approve cell check complete device done hardware iOS mark ok phone select tablet tick validate verified yes",
  mobile_off: "Android cell device disabled enabled hardware iOS phone silence slash tablet",
  mobile_screen_share: "Android arrow cell device hardware iOS mirror monitor phone screencast streaming tablet tv wireless",
  mode: "compose create draft draw edit pencil write",
  mode_comment: "bubble chat comment communicate feedback message mode speech",
  mode_edit: "compose create draft draw pencil write",
  mode_edit_outline: "compose create draft draw pencil write",
  model_training: "arrow bulb idea inprogress light loading refresh renew restore reverse rotate",
  mode_night: "dark disturb moon sleep weather",
  mode_of_travel: "arrow destination direction location maps pin place stop transportation trip",
  mode_standby: "disturb power sleep target",
  monetization_on: "bill card cash circle coin commerce cost credit currency dollars finance money online payment price profit sale shopping symbol",
  money: "100 bill card cash coin commerce cost credit currency digit dollars finance number online payment price profit shopping symbol",
  money_off: "bill card cart cash coin commerce credit currency disabled dollars enabled finance money online payment price profit shopping slash symbol",
  money_off_csred: "bill card cart cash coin commerce credit currency disabled dollars enabled online payment shopping slash symbol",
  monitor: "Android chrome device display hardware iOS mac screen web window",
  monitor_weight: "body device diet health scale smart",
  monochrome_photos: "black camera image photography picture white",
  mood: "emoji emoticon emotions expressions face feelings glad happiness happy like person pleased smiley smiling social survey",
  mood_bad: "disappointment dislike emoji emoticon emotions expressions face feelings person rating smiley social survey unhappiness unhappy unpleased unsmile unsmiling",
  more: "3 archive badge bookmark dots etc favorite indent label remember save stamp sticker tab tag three",
  more_horiz: "3 application components dots etc horizontal interface ios pending screen status three ui ux website",
  more_time: "+ add clock date new plus schedule symbol",
  more_vert: "3 android application components dots etc interface screen three ui ux vertical website",
  motion_photos_auto: "A alphabet animation automatic character circle font gif letter live symbol text type video",
  motion_photos_off: "animation circle disabled enabled slash video",
  mouse: "click computer cursor device hardware wireless",
  move_down: "arrow direction jump navigation transfer",
  move_to_inbox: "archive arrow down email envelop incoming letter message move send to",
  move_up: "arrow direction jump navigation transfer",
  movie: "cinema film media screen show slate tv video watch",
  movie_creation: "clapperboard film movies slate video",
  movie_filter: "clapperboard creation film movies slate stars video",
  moving: "arrow direction navigation travel up",
  mp: "alphabet character font image letter megapixel photography pixels quality resolution symbol text type",
  multiline_chart: "analytics bars data diagram infographic line measure metrics multiple statistics tracking",
  multiple_stop: "arrows directions dots left maps navigation right",
  museum: "architecture attraction building estate event exhibition explore local palces places real see shop store tour",
  music_note: "audiotrack key sound",
  music_off: "audiotrack disabled enabled key note on slash sound",
  music_video: "band mv recording screen tv watch",
  my_location: "destination direction maps navigation pin place point stop",
  nat: "communication",
  nature: "forest outdoor outside park tree wilderness",
  nature_people: "activity body forest human outdoor outside park person tree wilderness",
  navigate_before: "arrows direction left",
  navigate_next: "arrows direction right",
  navigation: "arrow destination direction location maps pin place point stop",
  nearby_error: "! alert attention caution danger exclamation important mark notification symbol warning",
  nearby_off: "disabled enabled on slash",
  near_me: "arrow destination direction location maps navigation pin place point stop",
  near_me_disabled: "destination direction enabled location maps navigation off pin place point slash",
  nest_cam_wired_stand: "camera filming hardware image motion picture videography",
  network_cell: "cellular data internet mobile phone speed wifi wireless",
  network_check: "connection internet meter signal speed tick wifi wireless",
  network_locked: "alert available cellular connection data error internet mobile not privacy private protection restricted safety secure security service signal warning wifi wireless",
  network_wifi: "cellular data internet mobile phone speed wireless",
  new_releases: "! alert announcement attention burst caution danger error exclamation important mark notification star symbol warning",
  newspaper: "article data document drive file folders magazine media notes page sheet slide text writing",
  next_plan: "arrow circle right",
  next_week: "arrow baggage briefcase business suitcase",
  nfc: "communication data field mobile near wireless",
  nightlife: "alcohol bar bottle club cocktail dance drink food glass liquor music note wine",
  nightlight: "dark disturb mode moon sleep weather",
  nightlight_round: "dark half mode moon",
  night_shelter: "architecture bed building estate homeless house place real sleep",
  nights_stay: "cloud crescent dark mode moon phases silence silent sky time weather",
  no_accounts: "avatar disabled enabled face human offline people person profile slash thumbnail unavailable unidentifiable unknown user",
  no_backpack: "accessory bookbag knapsack travel",
  no_drinks: "alcohol beverage bottle cocktail food liquor wine",
  no_encryption: "disabled enabled lock off password safety security slash",
  no_encryption_gmailerrorred: "disabled enabled locked off slash",
  no_flash: "camera disabled enabled image lightning off on photography picture slash thunderbolt",
  no_food: "disabled drink enabled fastfood hamburger meal off on slash",
  no_luggage: "baggage carry disabled enabled off on slash suitcase travel",
  no_meals: "dining disabled eat enabled food fork knife off restaurant slash spoon utensils",
  no_meeting_room: "building disabled doorway enabled entrance home house interior office on open places slash",
  no_photography: "camera disabled enabled image off on picture slash",
  nordic_walking: "athlete athletic body entertainment exercise hiking hobby human people person social sports travel walker",
  north: "arrow directional maps navigation up",
  north_east: "arrow maps navigation noth right up",
  north_west: "arrow directional left maps navigation up",
  no_sim: "camera card device eject insert memory phone storage",
  no_stroller: "baby care carriage children disabled enabled infant kid newborn off on parents slash toddler young",
  not_accessible: "accessibility body handicap help human person wheelchair",
  note: "bookmark message paper",
  note_add: "+ -doc create data document drive file folders new page paper plus sheet slide symbol writing",
  note_alt: "clipboard document file memo page paper writing",
  notes: "comment document text write writing",
  notification_add: "+ active alarm alert bell chime notifications notify plus reminder ring sound symbol",
  notification_important: "! active alarm alert announcement attention bell caution chime danger error exclamation feedback mark notifications notify problem reminder ring sound symbol warning",
  notifications: "active alarm alert bell chime notify reminder ring sound",
  notifications_active: "alarm alert bell chime notify reminder ringing sound",
  notifications_none: "alarm alert bell notify reminder ring sound",
  notifications_off: "active alarm alert bell chime disabled enabled notify offline reminder ring slash sound",
  notifications_paused: "--- active alarm aleet alert bell chime ignore notify pause quiet reminder ring sleep snooze sound zzz",
  not_interested: "allowed banned cancel circle close disabled dislike exit interested not off prohibited quit remove stop",
  not_listed_location: "? assistance destination direction help information maps pin place punctuation questionmark stop support symbol",
  no_transfer: "automobile bus cars direction disabled enabled maps off public slash transportation vehicle",
  not_started: "circle media pause play video",
  offline_bolt: "circle electric fast flash lightning spark thunderbolt",
  offline_pin: "approve checkmark circle complete done ok select tick validate verified yes",
  offline_share: "Android arrow cell connect device direction hardware iOS link mobile multiple phone right tablet",
  oil_barrel: "droplet gasoline nest water",
  ondemand_video: "Android chrome desktop device hardware iOS mac monitor play television tv web window",
  on_device_training: "arrow bulb call cell contact hardware idea inprogress light loading mobile model refresh renew restore reverse rotate telephone",
  online_prediction: "bulb connection idea light network signal wireless",
  opacity: "color droplet hue inverted liquid palette tone water",
  open_in_browser: "arrow box new up website window",
  open_in_full: "action arrows expand grow move",
  open_in_new: "application arrow box components interface screen ui ux website window",
  open_in_new_off: "arrow box disabled enabled export on slash window",
  open_with: "arrows directional expand move",
  other_houses: "architecture cottage estate home maps place real residence residential stay traveling",
  outbound: "arrow circle directional right up",
  outbox: "mail send sent",
  outdoor_grill: "barbecue barbeque bbq charcoal cooking home house outside",
  outlet: "connecter electricity plug power",
  outlined_flag: "country goal mark nation report start",
  padding: "design layout margin size square",
  pages: "article gplus paper post star",
  pageview: "document find glass magnifying paper search",
  paid: "circle currency money payment transaction",
  palette: "art colors filters paint",
  panorama: "angle image mountains photography picture view wide",
  panorama_fish_eye: "angle circle image photography picture wide",
  panorama_horizontal: "angle image photography picture wide",
  panorama_photosphere: "angle horizontal image photography picture wide",
  panorama_vertical: "angle image photography picture wide",
  panorama_wide_angle: "image photography picture",
  pan_tool: "drag fingers gesture hands human move scan stop touch wait",
  paragliding: "athlete athletic body entertainment exercise fly hobby human parachute people person skydiving social sports travel",
  park: "attraction fresh local nature outside plant tree",
  party_mode: "camera lens photography picture",
  password: "key login pin security star unlock",
  pattern: "key login password pin security star unlock",
  pause: "controls media music pending player status video wait",
  pause_circle: "controls media music video",
  pause_circle_filled: "controls media music pending status video wait",
  pause_circle_outline: "controls media music pending status video wait",
  pause_presentation: "application desktop device pending screen share slides status wait website window www",
  payment: "bill cash charge coin commerce cost creditcard currency dollars finance financial information money online price shopping symbol",
  payments: "bill card cash coin commerce cost credit currency dollars finance layer money multiple online price shopping symbol",
  pedal_bike: "automobile bicycle cars direction human maps public route scooter transportation vehicle vespa",
  pending: "circle dots loading progress waiting",
  pending_actions: "clipboard clock date document remember schedule time",
  pentagon: "five shape sides",
  people: "accounts committee community face family friends group humans network persons profiles social team users",
  people_alt: "accounts committee face family friends group humans network persons profiles social team users",
  people_outline: "accounts committee face family friends group humans network persons profiles social team users",
  percent: "math number symbol",
  perm_camera_mic: "image microphone min photography picture speaker",
  perm_contact_calendar: "account agenda date face human information people person profile schedule time user",
  perm_data_setting: "cellular configure gear information network settings wifi wireless",
  perm_device_information: "Android alert announcement cell hardware iOS important mobile phone tablet",
  perm_identity: "account avatar face human information people person profile save, thumbnail user",
  perm_media: "collection data directories document file folders images landscape mountains photography picture save storage",
  perm_phone_msg: "bubble call cell chat comment communicate contact device message mobile recording save speech telephone voice",
  perm_scan_wifi: "alert announcement connection information internet network service signal wireless",
  person: "account avatar face human people profile user",
  person_add: "+ account avatar face friend human new people plus profile symbol user",
  person_add_alt: "+ account face human people plus profile user",
  person_add_disabled: "+ account enabled face human new offline people plus profile slash symbol user",
  personal_video: "Android cam chrome desktop device hardware iOS mac monitor television tv web window",
  person_off: "account avatar disabled enabled face human people profile slash user",
  person_outline: "account avatar face human people profile user",
  person_pin: "account avatar destination direction face gps human location maps people place profile stop user",
  person_pin_circle: "account destination direction face gps human location maps people place profile stop user",
  person_remove: "account avatar delete face human minus people profile unfriend user",
  person_search: "account avatar face find glass human look magnifying people profile user",
  pest_control: "bug exterminator insects",
  pest_control_rodent: "exterminator mice",
  pets: "animal cat claw dog hand paw",
  phishing: "fishing fraud hook scam",
  phone: "call cell chat contact device hardware mobile telephone text",
  phone_android: "cell device hardware iOS mobile tablet",
  phone_bluetooth_speaker: "call cell connection connectivity contact device hardware mobile signal symbol telephone wireless",
  phone_callback: "arrow cell contact device down hardware mobile telephone",
  phone_disabled: "call cell contact device enabled hardware mobile offline slash telephone",
  phone_enabled: "call cell contact device hardware mobile telephone",
  phone_forwarded: "arrow call cell contact device direction hardware mobile right telephone",
  phone_iphone: "Android apple cell device hardware iOS mobile tablet",
  phonelink: "Android chrome computer connect desktop device hardware iOS mac mobile sync tablet web windows",
  phonelink_erase: "Android cancel cell close connection device exit hardware iOS mobile no remove stop tablet",
  phonelink_lock: "Android cell connection device erase hardware iOS locked mobile password privacy private protection safety secure security tablet",
  phonelink_off: "Android chrome computer connect desktop device disabled enabled hardware iOS mac mobile slash sync tablet web windows",
  phonelink_ring: "Android cell connection data device hardware iOS mobile network service signal tablet wireless",
  phonelink_setup: "Android call chat device hardware iOS information mobile settings tablet text",
  phone_locked: "call cell contact device hardware mobile password privacy private protection safety secure security telephone",
  phone_missed: "arrow call cell contact device hardware mobile telephone",
  phone_paused: "call cell contact device hardware mobile telephone wait",
  photo: "image mountains photography picture",
  photo_album: "archive bookmark image label library mountains photography picture ribbon save tag",
  photo_camera: "image photography picture",
  photo_camera_back: "image landscape mountains photography picture rear",
  photo_camera_front: "account face human image people person photography picture portrait profile user",
  photo_filter: "filters image photography picture stars",
  photo_library: "album image mountains photography picture",
  photo_size_select_actual: "image mountains photography picture",
  photo_size_select_large: "adjust album editing image library mountains photography picture",
  photo_size_select_small: "adjust album editing image large library mountains photography picture",
  php: "alphabet brackets character code css developer engineering font html letter platform symbol text type",
  piano: "instrument keyboard keys musical social",
  piano_off: "disabled enabled instrument keyboard keys musical on slash social",
  picture_as_pdf: "alphabet character document file font image letter multiple photography symbol text type",
  picture_in_picture: "cropped overlap photo position shape",
  picture_in_picture_alt: "cropped overlap photo position shape",
  pie_chart: "analytics bars data diagram infographic measure metrics statistics tracking",
  pie_chart_outline: "analytics bars data diagram infographic measure metrics statistics tracking",
  pin: "1 2 3 digit key login logout number password pattern security star symbol unlock",
  pinch: "arrows compress direction finger grasp hand navigation nip squeeze tweak",
  pin_drop: "destination direction gps location maps navigation place stop",
  pivot_table_chart: "analytics arrows bars data diagram direction drive editing grid infographic measure metrics rotate sheet statistics tracking",
  place: "destination direction location maps navigation pin point stop",
  plagiarism: "document find glass look magnifying page paper search see",
  play_arrow: "controls media music player start video",
  play_circle: "arrow controls media music video",
  play_disabled: "controls enabled media music off slash video",
  play_for_work: "arrow circle down google half",
  play_lesson: "audio bookmark digital ebook lesson multimedia play reading ribbon",
  playlist_add: "+ collection music new plus symbol task todo",
  playlist_add_check: "approve checkmark collection complete done music ok select task tick todo validate verified yes",
  playlist_add_check_circle: "album artist audio cd collection mark music record sound track",
  playlist_add_circle: "album artist audio cd check collection mark music record sound track",
  playlist_play: "arow arrow collection music",
  playlist_remove: "- collection minus music",
  plumbing: "build construction fix handyman repair tools wrench",
  plus_one: "1 add digit increase number symbol",
  podcasts: "broadcast casting network signal transmitting wireless",
  point_of_sale: "checkout cost machine merchant money payment pos retail system transaction",
  policy: "certified find glass legal look magnifying privacy private protection search security see shield verified",
  poll: "analytics barchart bars data diagram infographic measure metrics statistics survey tracking vote",
  pool: "athlete athletic beach body entertainment exercise hobby human ocean people person places sea sports swimming water",
  portable_wifi_off: "connected connection data device disabled enabled internet network offline service signal slash usage wireless",
  portrait: "account face human people person photo picture profile user",
  post_add: "+ data document drive file folders item page paper plus sheet slide text writing",
  power: "charge cord electrical online outlet plug socket",
  power_input: "dc lines supply",
  power_off: "charge cord disabled electrical enabled on outlet plug slash",
  power_settings_new: "information off save shutdown",
  precision_manufacturing: "arm automatic chain conveyor crane factory industry machinery mechanical production repairing robot supply warehouse",
  pregnant_woman: "baby birth body female human lady maternity mom mother people person user women",
  present_to_all: "arrow presentation screen share slides website",
  preview: "design eye layout reveal screen see show website window www",
  price_change: "arrows bill card cash coin commerce cost credit currency dollars down finance money online payment shopping symbol up",
  price_check: "approve bill card cash coin commerce complete cost credit currency dollars done finance mark money ok online payment select shopping symbol tick validate verified yes",
  print: "draft fax ink machine office paper printer send",
  print_disabled: "enabled off on paper printer slash",
  priority_high: "! alert attention caution danger error exclamation important mark notification symbol warning",
  privacy_tip: "alert announcement announcment assistance certified details help information private protection security service shield support verified",
  production_quantity_limits: "! alert attention bill card cart cash caution coin commerce credit currency danger dollars error exclamation important mark money notification online payment shopping symbol warning",
  propane: "gas nest",
  propane_tank: "bbq gas grill nest",
  psychology: "behavior body brain cognitive function gear head human intellectual mental mind people person preferences psychiatric science settings social therapy thinking thoughts",
  public: "country earth global globe language map network planet social space web world",
  public_off: "disabled earth enabled global globe map network on planet slash social space web world",
  publish: "arrow cloud file import submit upload",
  published_with_changes: "approve arrows check complete done inprogress loading mark ok refresh renew replace rotate select tick validate verified yes",
  push_pin: "location marker place remember save",
  qr_code: "barcode camera media product quick response smartphone urls",
  qr_code_2: "barcode camera media product quick response smartphone urls",
  qr_code_scanner: "barcode camera media product quick response smartphone urls",
  query_builder: "clock date hour minute save schedule time",
  query_stats: "analytics chart data diagram find glass infographic line look magnifying measure metrics search see statistics tracking",
  question_answer: "bubble chat comment communicate conversation converse feedback message speech talk",
  question_mark: "? assistance help information mark punctuation question support symbol",
  queue: "add collection layers multiple music playlist stack stream video",
  queue_music: "add collection playlist stream",
  queue_play_next: "+ add arrow collection desktop device display hardware monitor music new playlist plus screen steam symbol tv video",
  quickreply: "bubble chat comment communicate fast lightning message speech thunderbolt",
  quiz: "? assistance faq help information mark punctuation question support symbol test",
  radar: "detect military near network position scan",
  radio: "antenna audio device frequency hardware listen media music player signal tune",
  radio_button_checked: "application bullet circle components design form interface off point record screen selected toggle ui ux website",
  radio_button_unchecked: "bullet circle deselected form off point record toggle",
  railway_alert: "! attention automobile bike cars caution danger direction error exclamation important maps mark notification public scooter subway symbol train transportation vehicle vespa warning",
  ramen_dining: "breakfast dinner drink fastfood lunch meal noodles restaurant",
  ramp_left: "arrows directions maps navigation path route sign traffic",
  ramp_right: "arrows directions maps navigation path route sign traffic",
  rate_review: "chat comment feedback message pencil stars write",
  raw_off: "alphabet character disabled enabled font image letter original photography slash symbol text type",
  raw_on: "alphabet character disabled enabled font image letter off original photography slash symbol text type",
  read_more: "arrow text",
  receipt: "bill credit invoice paper payment sale transaction",
  receipt_long: "bill check document list paperwork record store transaction",
  recent_actors: "account avatar cards carousel contacts face human layers list people person profile thumbnail user",
  recommend: "approved circle confirm favorite gesture hand like reaction social support thumbs well",
  record_voice_over: "account face human people person profile recording sound speaking speech transcript user",
  rectangle: "four parallelograms polygons quadrilaterals recangle shape sides",
  redeem: "bill cart cash certificate coin commerce credit currency dollars giftcard money online payment present shopping",
  redo: "arrow backward forward next repeat rotate undo",
  reduce_capacity: "arrow body covid decrease down human people person social",
  refresh: "around arrows direction inprogress loading navigation refresh renew right rotate turn",
  remember_me: "Android avatar device hardware human iOS identity mobile people person phone profile tablet user",
  remove: "can delete line minus negative substract subtract trash",
  remove_circle: "allowed banned block can delete disable minus negative not substract trash",
  remove_circle_outline: "allowed banned block can delete disable minus negative not substract trash",
  remove_done: "approve check complete disabled enabled finished mark multiple off ok select slash tick yes",
  remove_from_queue: "collection desktop device display hardware list monitor screen steam television",
  remove_moderator: "certified disabled enabled off privacy private protection security shield slash verified",
  remove_red_eye: "iris looking preview see sight vision",
  remove_road: "- cancel close destination direction exit highway maps minus new no stop street symbol traffic",
  remove_shopping_cart: "card cash checkout coin commerce credit currency disabled dollars enabled off online payment slash tick",
  reorder: "format lines list stacked",
  repeat: "arrows controls media music video",
  repeat_on: "arrows controls media music video",
  repeat_one: "1 arrows controls digit media music number symbol video",
  repeat_one_on: "arrows controls digit media music number symbol video",
  replay: "arrows controls music refresh reload renew repeat retry rewind undo video",
  replay_10: "arrows controls digit music number refresh renew repeat rewind symbol ten video",
  replay_30: "arrows controls digit music number refresh renew repeat rewind symbol thirty video",
  replay_5: "arrows controls digit five music number refresh renew repeat rewind symbol video",
  replay_circle_filled: "arrows controls music refresh renew repeat video",
  reply: "arrow backward left mail message send share",
  reply_all: "arrows backward group left mail message multiple send share",
  report: "! alert attention caution danger error exclamation important mark notification octagon symbol warning",
  report_gmailerrorred: "! alert attention caution danger exclamation important mark notification octagon symbol warning",
  report_off: "! alert attention caution danger disabled enabled error exclamation important mark notification octagon offline slash symbol warning",
  report_problem: "! alert announcement attention caution danger error exclamation feedback important mark notification symbol triangle warning",
  request_quote: "bill card cash coin commerce cost credit currency dollars finance money online payment price shopping symbol",
  reset_tv: "arrow device hardware monitor television",
  restart_alt: "around arrow inprogress loading reboot refresh renew repeat reset",
  restaurant: "breakfast cutlery dining dinner eat food fork knife local lunch meal places spoon utensils",
  restaurant_menu: "book dining eat food fork knife local meal spoon",
  restore: "arrow backwards clock date history refresh renew reverse rotate schedule time turn undo",
  restore_from_trash: "arrow backwards can clock date delete garbage history refresh remove renew reverse rotate schedule time turn up",
  restore_page: "arrow data doc file history paper refresh rotate sheet storage undo web",
  reviews: "bubble chat comment communicate feedback message rate rating recommendation speech",
  rice_bowl: "dinner food lunch meal restaurant",
  ring_volume: "calling cell contact device hardware incoming mobile ringer sound telephone",
  r_mobiledata: "alphabet character font letter symbol text type",
  rocket: "spaceship",
  rocket_launch: "spaceship takeoff",
  roller_shades: "blinds cover curtains nest open shutter sunshade",
  roller_shades_closed: "blinds cover curtains nest shutter sunshade",
  roofing: "architecture building chimney construction estate home house real residence residential service shelter",
  room: "destination direction gps location maps marker pin place spot stop",
  room_preferences: "building doorway entrance gear home house interior office open settings",
  room_service: "alert bell concierge delivery hotel notify",
  rotate_90_degrees_ccw: "arrows direction editing image photo turn",
  rotate_90_degrees_cw: "arrows ccw direction editing image photo turn",
  rotate_left: "around arrow circle direction inprogress loading refresh reload renew reset turn",
  rotate_right: "around arrow circle direction inprogress loading refresh renew turn",
  roundabout_left: "arrows directions maps navigation path route sign traffic",
  roundabout_right: "arrows directions maps navigation path route sign traffic",
  rounded_corner: "adjust edit shape square transform",
  route: "directions maps path sign traffic",
  router: "box cable connection device hardware internet network signal wifi",
  rowing: "activity boat body canoe human people person sports water",
  rss_feed: "application blog connection data internet network service signal website wifi wireless",
  rsvp: "alphabet character font invitation invite letter plaît respond répondez sil symbol text type vous",
  rtt: "call real rrt text time",
  rule: "approve check done incomplete line mark missing no ok select tick validate verified wrong x yes",
  rule_folder: "approve cancel check close complete data document done drive exit file mark no ok remove select sheet slide storage tick validate verified yes",
  run_circle: "body exercise human people person running",
  running_with_errors: "! alert attention caution danger duration exclamation important mark notification processing symbol time warning",
  rv_hookup: "arrow attach automobile automotive back cars connect direction left maps public right trailer transportation travel truck van vehicle",
  safety_divider: "apart distance separate social space",
  sailing: "entertainment fishing hobby ocean sailboat sea social sports travel water",
  sanitizer: "bacteria bottle clean covid disinfect germs pump",
  satellite: "bluetooth connection connectivity data device image internet landscape location maps mountains network photography picture scan service signal symbol wifi wireless--",
  satellite_alt: "alternative artificial communication space station television",
  save: "data diskette document drive file floppy multimedia storage write",
  save_alt: "arrow diskette document down file floppy multimedia write",
  save_as: "compose create data disk document draft drive editing file floppy input multimedia pencil storage write writing",
  saved_search: "find glass important look magnifying marked see star",
  savings: "bank bill card cash coin commerce cost credit currency dollars finance money online payment piggy symbol",
  scale: "measure monitor weight",
  scanner: "copy device hardware machine",
  scatter_plot: "analytics bars chart circles data diagram dot infographic measure metrics statistics tracking",
  schedule: "calendar clock date mark save time",
  schedule_send: "calendar clock date email letter remember share time",
  schema: "analytics chart data diagram flow infographic measure metrics statistics tracking",
  school: "academy achievement cap class college education graduation hat knowledge learning university",
  science: "beaker chemical chemistry experiment flask glass laboratory research tube",
  score: "2k alphabet analytics bars character chart data diagram digit font infographic letter measure metrics number statistics symbol text tracking type",
  screen_lock_landscape: "Android device hardware iOS mobile phone rotate security tablet",
  screen_lock_portrait: "Android device hardware iOS mobile phone rotate security tablet",
  screen_lock_rotation: "Android arrow device hardware iOS mobile phone rotate tablet turn",
  screen_rotation: "Android arrow device hardware iOS mobile phone rotate tablet turn",
  screen_search_desktop: "Android arrow device hardware iOS lock monitor rotate web",
  screen_share: "Android arrow cast chrome device display hardware iOS laptop mac mirror monitor steam streaming web window",
  screenshot: "Android cell crop device hardware iOS mobile phone tablet",
  screenshot_monitor: "Android chrome desktop device display hardware iOS mac screengrab web window",
  sd: "alphabet camera card character data device digital drive flash font image letter memory photo secure symbol text type",
  sd_card: "camera digital memory photos secure storage",
  sd_card_alert: "! attention camera caution danger digital error exclamation important mark memory notification photos secure storage symbol warning",
  sd_storage: "camera card data digital memory microsd secure",
  search: "filter find glass look magnifying see up",
  search_off: "cancel close disabled enabled find glass look magnifying on see slash stop x",
  security: "certified privacy private protection shield verified",
  security_update: "Android arrow device download hardware iOS mobile phone tablet",
  security_update_good: "Android checkmark device hardware iOS mobile ok phone tablet tick",
  security_update_warning: "! Android alert attention caution danger device download error exclamation hardware iOS important mark mobile notification phone symbol tablet",
  segment: "alignment fonts format lines list paragraph part piece rules style text",
  select_all: "selection square tool",
  self_improvement: "body calm care chi human meditate meditation people person relax sitting wellbeing yoga zen",
  sell: "bill card cart cash coin commerce credit currency dollars money online payment price shopping tag",
  send: "chat email message paper plane reply right share telegram",
  send_and_archive: "arrow download email letter save share",
  send_time_extension: "deliver dispatch envelop mail message schedule",
  send_to_mobile: "Android arrow device export forward hardware iOS phone right share tablet",
  sensors: "connection network scan signal wireless",
  sensors_off: "connection disabled enabled network scan signal slash wireless",
  sentiment_dissatisfied: "angry disappointed dislike emoji emoticon emotions expressions face feelings frown mood person sad smiley survey unhappy unsatisfied upset",
  sentiment_neutral: "emotionless emotions expressions face feelings indifference mood okay person survey",
  sentiment_satisfied: "emoji emoticon emotions expressions face feelings glad happiness happy like mood person pleased smiley smiling survey",
  sentiment_satisfied_alt: "account emoji face happy human people person profile smile user",
  sentiment_very_dissatisfied: "angry disappointed dislike emoji emoticon emotions expressions face feelings mood person sad smiley sorrow survey unhappy unsatisfied upset",
  sentiment_very_satisfied: "emoji emoticon emotions expressions face feelings glad happiness happy like mood person pleased smiley smiling survey",
  set_meal: "chopsticks dinner fish food lunch restaurant teishoku",
  settings: "application change details gear information options personal service",
  settings_accessibility: "body details human information people personal preferences profile user",
  settings_applications: "change details gear information options personal save service",
  settings_backup_restore: "arrow backwards history refresh reverse rotate time undo",
  settings_bluetooth: "connection connectivity device network signal symbol wifi",
  settings_brightness: "dark filter light mode sun",
  settings_cell: "Android cellphone device hardware iOS mobile tablet",
  settings_ethernet: "arrows brackets computer connection connectivity dots internet network parenthesis wifi",
  settings_input_antenna: "airplay arrows computer connection connectivity dots internet network screencast stream wifi wireless",
  settings_input_component: "audio av cables connection connectivity internet plugs points video wifi",
  settings_input_composite: "cable component connection connectivity plugs points",
  settings_input_hdmi: "cable connection connectivity definition high plugin points video wire",
  settings_input_svideo: "cable connection connectivity definition plugin plugs points standard svideo,",
  settings_overscan: "arrows expand image photo picture",
  settings_phone: "call cell contact device hardware mobile telephone",
  settings_power: "information off save shutdown",
  settings_remote: "bluetooth connection connectivity control device signal wifi wireless",
  settings_suggest: "change details gear options recommendation service suggestion system",
  settings_system_daydream: "backup cloud drive storage",
  settings_voice: "microphone recorder speaker",
  share: "android connect contect link multimedia multiple network options send shared sharing social",
  share_location: "destination direction gps maps pin place stop tracking",
  shield: "certified privacy private protection secure security verified",
  shop: "arrow bag bill briefcase buy card cart cash coin commerce credit currency dollars google money online payment play purchase shopping store",
  shop_2: "add arrow buy cart google play purchase shopping",
  shopping_bag: "bill business buy card cart cash coin commerce credit currency dollars money online payment storefront",
  shopping_basket: "add bill buy card cart cash checkout coin commerce credit currency dollars money online payment purchase",
  shopping_cart: "add bill buy card cash checkout coin commerce credit currency dollars money online payment purchase",
  shopping_cart_checkout: "arrow cash coin commerce currency dollars money online payment right",
  shop_two: "add arrow briefcase buy cart google play purchase shopping",
  shortcut: "arrow direction forward right",
  short_text: "brief comment document lines note write writing",
  show_chart: "analytics bars chart data diagram infographic line measure metrics presentation show statistics stock tracking",
  shower: "bathroom closet home house place plumbing sprinkler wash water wc",
  shuffle: "arrows controls music random video",
  shuffle_on: "arrows controls music random video",
  shutter_speed: "aperture camera duration image lens photography photos picture setting stop timer watch",
  sick: "covid discomfort emotions expressions face feelings fever flu ill mood pain person survey upset",
  signal_cellular_0_bar: "data internet mobile network phone speed wifi wireless",
  signal_cellular_4_bar: "data internet mobile network phone speed wifi wireless",
  signal_cellular_alt: "analytics bar chart data diagram infographic internet measure metrics mobile network phone statistics tracking wifi wireless",
  signal_cellular_connected_no_internet_0_bar: "! alert attention caution danger data error exclamation important mark mobile network notification phone symbol warning wifi wireless",
  signal_cellular_connected_no_internet_4_bar: "! alert attention caution danger data error exclamation important mark mobile network notification phone symbol warning wifi wireless",
  signal_cellular_nodata: "internet mobile network offline phone quit wifi wireless x",
  signal_cellular_no_sim: "camera card chip device disabled enabled memory network offline phone slash storage",
  signal_cellular_null: "data internet mobile network phone wifi wireless",
  signal_cellular_off: "data disabled enabled internet mobile network offline phone slash wifi wireless",
  signal_wifi_bad: "bar cancel cellular close data exit internet mobile network no phone quit remove stop wireless",
  signal_wifi_off: "cellular data disabled enabled internet mobile network phone slash speed wireless",
  signal_wifi_statusbar_null: "cellular data internet mobile network phone speed wireless",
  signpost: "arrow direction left maps right signal signs street traffic",
  sim_card: "camera chip device memory network phone storage",
  sim_card_alert: "! attention camera caution danger digital error exclamation important mark memory notification photos sd secure storage symbol warning",
  sim_card_download: "arrow camera chip device memory phone storage",
  single_bed: "bedroom double furniture home hotel house king night pillows queen rest sleep twin",
  sip: "alphabet call character dialer font initiation internet letter over phone protocol routing session symbol text type voice",
  skateboarding: "athlete athletic body entertainment exercise hobby human people person skateboarder social sports",
  skip_next: "arrow back controls forward music play previous transport video",
  skip_previous: "arrow backward controls forward music next play transport video",
  sledding: "athlete athletic body entertainment exercise hobby human people person sledge snow social sports travel winter",
  slideshow: "movie photos play presentation square video view",
  slow_motion_video: "arrow circle controls music play speed time",
  smart_button: "action auto components composer function interface special stars ui ux website",
  smart_display: "airplay chrome connect device screencast stream television tv video wireless",
  smartphone: "Android call cell chat device hardware iOS mobile tablet text",
  smart_screen: "Android airplay cell connect device hardware iOS mobile phone screencast stream tablet video",
  smart_toy: "games robot",
  smoke_free: "cigarette disabled enabled never no off places prohibited slash smoking tobacco warning zone",
  smoking_rooms: "allowed cigarette places smoke tobacco zone",
  sms: "3 bubble chat comment communication conversation dots message more service speech three",
  sms_failed: "! alert attention bubbles caution chat comment communication conversation danger error exclamation important mark message notification service speech symbol warning",
  snippet_folder: "data document drive file sheet slide storage",
  snooze: "alarm bell clock duration notification set timer watch",
  snowboarding: "athlete athletic body entertainment exercise hobby human people person social sports travel winter",
  snowmobile: "automobile car direction skimobile social sports transportation travel vehicle winter",
  snowshoeing: "body human people person sports travel walking winter",
  soap: "bathroom clean fingers gesture hand wash wc",
  social_distance: "6 apart body ft human people person space",
  solar_power: "eco energy heat nest sunny",
  sort: "filter find lines list organize",
  sort_by_alpha: "alphabetize az by character font letters list order organize symbol text type",
  soup_kitchen: "breakfast brunch dining food lunch meal",
  source: "code composer content creation data document file folder mode storage view",
  south: "arrow directional down maps navigation",
  south_america: "america continent landscape place region south",
  south_east: "arrow directional down maps navigation right",
  south_west: "arrow directional down left maps navigation",
  spa: "aromatherapy flower healthcare leaf massage meditation nature petals places relax wellbeing wellness",
  space_bar: "keyboard line",
  speaker: "audio box electronic loud music sound stereo system video",
  speaker_group: "audio box electronic loud multiple music sound stereo system video",
  speaker_notes: "bubble cards chat comment communicate format list message speech text",
  speaker_notes_off: "bubble cards chat comment communicate disabled enabled format list message on slash speech text",
  speaker_phone: "Android cell device hardware iOS mobile sound tablet volume",
  speed: "arrow clock controls dial fast gauge measure motion music slow speedometer test velocity video",
  spellcheck: "alphabet approve character checkmark edit font letter ok processor select symbol text tick type word write yes",
  splitscreen: "grid layout multitasking two",
  spoke: "connection network radius",
  sports: "athlete athletic basketball blowing coach entertainment exercise game hobby instrument live referee soccer social sound trophy warning whistle",
  sports_bar: "alcohol beer drink liquor pint places pub",
  sports_baseball: "athlete athletic entertainment exercise game hobby social",
  sports_basketball: "athlete athletic entertainment exercise game hobby social",
  sports_cricket: "athlete athletic ball bat entertainment exercise game hobby social",
  sports_esports: "controller entertainment gamepad gaming hobby online playstation social video xbox",
  sports_football: "american athlete athletic entertainment exercise game hobby social",
  sports_golf: "athlete athletic ball club entertainment exercise game golfer golfing hobby social",
  sports_handball: "athlete athletic body entertainment exercise game hobby human people person social",
  sports_hockey: "athlete athletic entertainment exercise game hobby ice social sticks",
  sports_kabaddi: "athlete athletic body combat entertainment exercise fighting game hobby human judo martial people person social wrestle wrestling",
  sports_martial_arts: "athlete athletic entertainment exercise hobby human karate people person social",
  sports_mma: "arts athlete athletic boxing combat entertainment exercise fighting game glove hobby martial mixed social",
  sports_motorsports: "athlete athletic automobile bike drive driving entertainment helmet hobby motorcycle protect social vehicle",
  sports_rugby: "athlete athletic ball entertainment exercise game hobby social",
  sports_score: "destination flag goal",
  sports_soccer: "athlete athletic entertainment exercise football game hobby social",
  sports_tennis: "athlete athletic ball bat entertainment exercise game hobby racket social",
  sports_volleyball: "athlete athletic entertainment exercise game hobby social",
  square: "draw four quadrangle shape sides",
  square_foot: "construction feet inches length measurement ruler school set tools",
  ssid_chart: "graph lines network wifi",
  stacked_bar_chart: "analytics chart-chart data diagram infographic measure metrics statistics tracking",
  stacked_line_chart: "analytics data diagram infographic measure metrics statistics tracking",
  stadium: "activity amphitheater arena coliseum event local star things ticket",
  stairs: "down staircase up",
  star: "best bookmark favorite highlight ranking rate rating save toggle",
  star_border: "best bookmark favorite highlight outline ranking rate rating save toggle",
  star_half: "0.5 1/2 achievement bookmark favorite highlight important marked ranking rate rating reward saved shape special toggle",
  star_outline: "bookmark favorite half highlight ranking rate rating save toggle",
  star_rate: "achievement bookmark favorite highlight important marked ranking rating reward saved shape special",
  stars: "achievement bookmark circle favorite highlight important like love marked ranking rate rating reward saved shape special",
  start: "arrow keyboard next right",
  stay_current_landscape: "Android device hardware iOS mobile phone tablet",
  stay_current_portrait: "Android device hardware iOS mobile phone tablet",
  stay_primary_landscape: "Android current device hardware iOS mobile phone tablet",
  stay_primary_portrait: "Android current device hardware iOS mobile phone tablet",
  sticky_note_2: "bookmark message paper text writing",
  stop: "arrow controls music pause player square video",
  stop_circle: "controls music pause play square video",
  stop_screen_share: "Android arrow cast chrome device disabled display enabled hardware iOS laptop mac mirror monitor offline slash steam streaming web window",
  storage: "computer database drive memory network server",
  store: "bill building business buy card cash coin company credit currency dollars e-commerce market money online payment purchase shopping storefront",
  storefront: "business buy cafe commerce market merchant places restaurant retail sell shopping stall",
  store_mall_directory: "building",
  storm: "forecast hurricane temperature twister weather wind",
  straight: "arrows directions maps navigation path route sign traffic up",
  straighten: "length measurement piano ruler size",
  stream: "cast connected feed live network signal wireless",
  streetview: "gps location maps",
  strikethrough_s: "alphabet character cross doc editing editor font letter out spreadsheet styles symbol text type writing",
  stroller: "baby care carriage children infant kid newborn toddler young",
  style: "booklet cards filters options tags",
  subdirectory_arrow_left: "arrow down navigation",
  subdirectory_arrow_right: "arrow down navigation",
  subject: "alignment document email full justify lines list note text writing",
  subscript: "2 doc editing editor gmail novitas spreadsheet style symbol text writing",
  subscriptions: "enroll media order playlist queue signup subscribe youtube",
  subtitles: "accessibility accessible captions character closed decoder language media movies translate tv",
  subtitles_off: "accessibility accessible caption closed disabled enabled language slash translate video",
  subway: "automobile bike cars maps metro rail scooter train transportation travel tunnel underground vehicle vespa",
  summarize: "document list menu note report summary",
  superscript: "2 doc editing editor gmail novitas spreadsheet style symbol text writing",
  supervised_user_circle: "account avatar control face human parental parents people person profile supervisor",
  supervisor_account: "administrator avatar control face human parental parents people person profile supervised user",
  support: "assist help lifebuoy rescue safety",
  support_agent: "care customer face headphone person representative service",
  surfing: "athlete athletic beach body entertainment exercise hobby human people person sea social sports summer water",
  surround_sound: "audio circle signal speaker system volume volumn wireless",
  swap_calls: "arrows device direction mobile share",
  swap_horiz: "arrows back direction forward horizontal",
  swap_horizontal_circle: "arrows back direction forward",
  swap_vert: "arrows back direction down navigation up vertical",
  swap_vertical_circle: "arrows back direction down horizontal up",
  swipe: "arrows fingers gesture hands touch",
  swipe_down: "arrows direction disable enable finger hands hit navigation strike swing swpie take",
  swipe_down_alt: "arrows direction disable enable finger hands hit navigation strike swing swpie take",
  swipe_left: "arrows finger hand hit navigation reject strike swing take",
  swipe_left_alt: "arrows finger hand hit navigation reject strike swing take",
  swipe_right: "accept arrows direction finger hands hit navigation strike swing swpie take",
  swipe_right_alt: "accept arrows direction finger hands hit navigation strike swing swpie take",
  swipe_up: "arrows direction disable enable finger hands hit navigation strike swing swpie take",
  swipe_up_alt: "arrows direction disable enable finger hands hit navigation strike swing swpie take",
  swipe_vertical: "arrows direction finger hands hit navigation strike swing swpie take verticle",
  switch_access_shortcut: "arrows direction navigation new north star symbol up",
  switch_access_shortcut_add: "+ arrows direction navigation new north plus star symbol up",
  switch_account: "choices face human multiple options people person profile social user",
  switch_camera: "arrows photography picture",
  switch_left: "arrows directional navigation toggle",
  switch_right: "arrows directional navigation toggle",
  switch_video: "arrows camera photography videos",
  sync: "360 around arrows direction inprogress loading refresh renew rotate turn",
  sync_alt: "arrows horizontal internet technology update wifi",
  sync_disabled: "360 around arrows direction enabled inprogress loading off refresh renew rotate slash turn",
  sync_lock: "around arrows locked password privacy private protection renew rotate safety secure security turn",
  sync_problem: "! 360 alert around arrows attention caution danger direction error exclamation important inprogress loading mark notification refresh renew rotate symbol turn warning",
  system_security_update: "Android arrow cell device down hardware iOS mobile phone tablet",
  system_security_update_good: "Android approve cell check complete device done hardware iOS mark mobile ok phone select tablet tick validate verified yes",
  system_security_update_warning: "! Android alert attention caution cell danger device error exclamation hardware iOS important mark mobile notification phone symbol tablet",
  system_update: "Android arrows cell device direction download hardware iOS install mobile phone tablet",
  system_update_alt: "arrow download export",
  tab: "browser computer documents folder internet tabs website windows",
  table_chart: "analytics bars data diagram grid infographic measure metrics statistics tracking",
  table_rows: "grid layout lines stacked",
  tablet: "Android device hardware iOS ipad mobile web",
  tablet_android: "device hardware iOS ipad mobile web",
  tablet_mac: "Android apple device hardware iOS ipad mac mobile tablet web",
  table_view: "format grid group layout multiple",
  tab_unselected: "browser computer documents folder internet tabs website windows",
  tag: "hashtag key media number pound social trend",
  tag_faces: "emoji emotion happy satisfied smile",
  takeout_dining: "box container delivery food meal restaurant",
  tap_and_play: "Android cell connection device hardware iOS internet mobile network nfc phone signal tablet to wifi wireless",
  tapas: "appetizer brunch dinner food lunch restaurant snack",
  task: "approve check complete data document done drive file folders mark ok page paper select sheet slide tick validate verified writing yes",
  task_alt: "approve check circle complete done mark ok select tick validate verified yes",
  taxi_alert: "! attention automobile cab cars caution danger direction error exclamation important lyft maps mark notification public symbol transportation uber vehicle warning yellow",
  terminal: "application code emulator program software",
  terrain: "geography landscape mountain",
  text_decrease: "- alphabet character font letter minus remove resize subtract symbol type",
  text_fields: "T add alphabet character font input letter symbol type",
  text_format: "A alphabet character font letter square style symbol type",
  text_increase: "+ add alphabet character font letter new plus resize symbol type",
  text_rotate_up: "A alphabet arrow character field font letter move symbol type",
  text_rotate_vertical: "A alphabet arrow character down field font letter move symbol type verticle",
  text_rotation_angledown: "A alphabet arrow character field font letter move rotate symbol type",
  text_rotation_angleup: "A alphabet arrow character field font letter move rotate symbol type",
  text_rotation_down: "A alphabet arrow character field font letter move rotate symbol type",
  text_rotation_none: "A alphabet arrow character field font letter move rotate symbol type",
  textsms: "bubble chat comment communicate dots feedback message speech",
  text_snippet: "data document file notes storage writing",
  texture: "diagonal lines pattern stripes",
  theater_comedy: "broadway event movie musical places show standup tour watch",
  theaters: "film media movies photography showtimes video watch",
  thermostat: "forecast temperature weather",
  thermostat_auto: "A celsius fahrenheit temperature thermometer",
  thumb_down: "dislike downvote favorite fingers gesture hands ranking rate rating reject up",
  thumb_down_alt: "bad decline disapprove dislike feedback hand hate negative no reject social veto vote",
  thumb_down_off_alt: "bad decline disapprove dislike favorite feedback filled fingers gesture hands hate negative no ranking rate rating reject sad social veto vote",
  thumbs_up_down: "dislike favorite fingers gesture hands rate rating vote",
  thumb_up: "approve dislike down favorite fingers gesture hands ranking rate rating success upvote",
  thumb_up_alt: "agreed approved confirm correct favorite feedback good hand happy like okay positive satisfaction social success vote yes",
  thumb_up_off_alt: "agreed approved confirm correct favorite feedback fingers gesture good hands happy like okay positive ranking rate rating satisfaction social vote yes",
  timelapse: "duration motion photo timer video",
  timeline: "analytics chart data graph history line movement points tracking trending zigzag zigzap",
  timer: "alarm alart bell clock disabled duration enabled notification off slash stopwatch wait",
  timer_10: "digits duration numbers seconds",
  timer_10_select: "alphabet camera character digit font letter number seconds symbol text type",
  timer_3: "digits duration numbers seconds",
  timer_3_select: "alphabet camera character digit font letter number seconds symbol text type",
  timer_off: "alarm alart bell clock disabled duration enabled notification slash stopwatch",
  time_to_leave: "automobile cars destination direction drive estimate eta maps public transportation travel trip vehicle",
  tips_and_updates: "alert announcement electricity idea information lamp lightbulb stars",
  title: "T alphabet character font header letter subject symbol text type",
  toc: "content format lines list reorder stacked table text titles",
  today: "agenda calendar date event mark month range remember reminder schedule time week",
  toggle_off: "application components configuration control design disable inable inactive interface selection settings slider switch ui ux website",
  toggle_on: "application components configuration control design disable inable inactive interface off selection settings slider switch ui ux website",
  token: "badge hexagon mark shield sign symbol",
  toll: "bill booth card cash circles coin commerce credit currency dollars highway money online payment ticket",
  tonality: "circle editing filter image photography picture",
  topic: "data document drive file folder sheet slide storage",
  tornado: "crisis disaster natural rain storm weather wind",
  touch_app: "arrow command fingers gesture hand press swipe tap",
  tour: "destination flag places travel visit",
  toys: "car fan games kids windmill",
  track_changes: "bullseye circle evolve lines movement radar rotate shift target",
  traffic: "direction light maps signal street",
  train: "automobile cars direction maps public rail subway transportation vehicle",
  tram: "automobile cars direction maps public rail subway train transportation vehicle",
  transfer_within_a_station: "arrows body direction human left maps people person public right route stop transit transportation vehicle walk",
  transform: "adjust crop editing image photo picture",
  transgender: "female lgbt neutral neutrual social symbol",
  transit_enterexit: "arrow direction maps navigation route transportation",
  translate: "alphabet language letter speaking speech text translator words",
  travel_explore: "earth find glass global globe look magnifying map network planet search see social space web world",
  trending_down: "analytics arrow change chart data diagram infographic measure metrics movement rate rating sale statistics tracking",
  trending_flat: "arrow change chart data graph metric movement rate right tracking",
  trending_up: "analytics arrow change chart data diagram infographic measure metrics movement rate rating statistics tracking",
  trip_origin: "circle departure",
  try: "bookmark bubble chat comment communicate favorite feedback highlight important marked message saved shape special speech star",
  tty: "call cell contact deaf device hardware impaired mobile speech talk telephone text",
  tune: "adjust editing options settings sliders",
  tungsten: "electricity indoor lamp lightbulb setting",
  turned_in: "archive bookmark favorite item label library reading remember ribbon save submit tag",
  turned_in_not: "archive bookmark favorite item label library outline reading remember ribbon save submit tag",
  turn_left: "arrows directions maps navigation path route sign traffic",
  turn_right: "arrows directions maps navigation path route sign traffic",
  turn_sharp_left: "arrows directions maps navigation path route sign traffic",
  turn_sharp_right: "arrows directions maps navigation path route sign traffic",
  turn_slight_left: "arrows directions maps navigation path right route sign traffic",
  turn_slight_right: "arrows directions maps navigation path route sharp sign traffic",
  tv: "device display linear living monitor room screencast stream television video wireless",
  tv_off: "Android chrome desktop device disabled enabled hardware iOS mac monitor slash television web window",
  two_wheeler: "automobile bicycle cars direction maps moped motorbike motorcycle public ride riding scooter transportation travel twom vehicle wheeler wheels",
  umbrella: "beach protection rain sunny",
  unarchive: "arrow inbox mail store undo up",
  undo: "arrow backward mail previous redo repeat rotate",
  unfold_less: "arrows chevron collapse direction expandable inward list navigation up",
  unfold_more: "arrows chevron collapse direction down expandable list navigation",
  unpublished: "approve check circle complete disabled done enabled mark off ok select slash tick validate verified yes",
  unsubscribe: "cancel close email envelop esubscribe message newsletter off remove send",
  upcoming: "alarm calendar mail message notification",
  update: "arrow backwards clock forward future history load refresh reverse rotate schedule time",
  update_disabled: "arrow backwards clock enabled forward history load off on refresh reverse rotate schedule slash time",
  upgrade: "arrow export instal line replace update",
  upload: "arrows download drive",
  upload_file: "arrow data document download drive folders page paper sheet slide writing",
  usb: "cable connection device wire",
  usb_off: "cable connection device wire",
  u_turn_left: "arrows directions maps navigation path route sign traffic u-turn",
  u_turn_right: "arrows directions maps navigation path route sign traffic u-turn",
  vaccines: "aid covid doctor drug emergency hospital immunity injection medical medication medicine needle pharmacy sick syringe vaccination vial",
  verified: "approve badge burst check complete done mark ok select star tick validate yes",
  verified_user: "approve audit certified checkmark complete done ok privacy private protection security select shield tick validate yes",
  vertical_align_bottom: "alignment arrow doc down editing editor spreadsheet text type writing",
  vertical_align_center: "alignment arrow doc down editing editor spreadsheet text type up writing",
  vertical_align_top: "alignment arrow doc editing editor spreadsheet text type up writing",
  vertical_shades: "blinds cover curtains nest open shutter sunshade",
  vertical_shades_closed: "blinds cover curtains nest roller shutter sunshade",
  vertical_split: "design format grid layout paragraph text website writing",
  vibration: "Android alert cell device hardware iOS mobile mode motion notification phone silence silent tablet vibrate",
  video_call: "+ add camera chat conference filming hardware image motion new picture plus screen symbol videography",
  videocam: "camera chat conference filming hardware image motion picture screen videography",
  video_camera_back: "image landscape mountains photography picture rear",
  video_camera_front: "account face human image people person photography picture profile user",
  videocam_off: "camera chat conference disabled enabled filming hardware image motion offline picture screen slash videography",
  video_file: "camera document filming hardware image motion picture videography",
  videogame_asset: "console controller device gamepad gaming nintendo playstation xbox",
  videogame_asset_off: "console controller device disabled enabled gamepad gaming playstation slash",
  video_label: "device item screen window",
  video_library: "arrow collection play",
  video_settings: "change details gear information options play screen service window",
  video_stable: "filming recording setting stability taping",
  view_agenda: "blocks cards design format grid layout website,stacked",
  view_array: "blocks design format grid layout website",
  view_carousel: "banner blocks cards design format grid images layout website",
  view_column: "blocks design format grid layout vertical website",
  view_comfy: "grid layout pattern squares",
  view_comfy_alt: "cozy design format layout web",
  view_compact: "grid layout pattern squares",
  view_compact_alt: "dense design format layout web",
  view_cozy: "comfy design format layout web",
  view_day: "blocks calendar cards carousel design format grid layout website week",
  view_headline: "blocks design format grid layout paragraph text website",
  view_in_ar: "3d augmented cube daydream headset reality square vr",
  view_kanban: "grid layout pattern squares",
  view_list: "blocks design format grid layout lines reorder stacked title website",
  view_module: "blocks design format grid layout reorder squares stacked title website",
  view_quilt: "blocks design format grid layout reorder squares stacked title website",
  view_sidebar: "design format grid layout web",
  view_stream: "blocks design format grid layout lines list reorder stacked title website",
  view_timeline: "grid layout pattern squares",
  view_week: "bars blocks columns day design format grid layout website",
  vignette: "border editing effect filter gradient image photography setting",
  villa: "architecture beach estate home house maps place real residence residential stay traveling vacation",
  visibility: "eye on password preview reveal see shown visability",
  visibility_off: "disabled enabled eye hidden invisible on password reveal see show slash view visability",
  voice_chat: "bubble camera comment communicate facetime feedback message speech video",
  voicemail: "call device message missed mobile phone recording",
  voice_over_off: "account disabled enabled face human people person profile recording slash speaking speech transcript user",
  volume_down: "audio av control music quieter shh soft sound speaker tv",
  volume_mute: "audio control music sound speaker tv",
  volume_off: "audio av control disabled enabled low music mute slash sound speaker tv",
  volume_up: "audio control music sound speaker tv",
  volunteer_activism: "donation fingers gesture giving hands heart love sharing",
  vpn_key: "login network passcode password register security signin signup unlock",
  vpn_key_off: "[offline] disabled enabled network on passcode password slash unlock",
  vpn_lock: "earth globe locked network password privacy private protection safety secure security virtual world",
  vrpano: "angle image landscape mountains panorama photography picture view wide",
  wallpaper: "background image landscape photography picture",
  warehouse: "garage industry manufacturing storage",
  warning: "! alert announcement attention caution danger error exclamation feedback important mark notification problem symbol triangle",
  warning_amber: "! alert attention caution danger error exclamation important mark notification symbol triangle",
  wash: "bathroom clean fingers gesture hand wc",
  watch: "Android clock gadget iOS smartwatch time vr wearables web wristwatch",
  watch_later: "clock date hour minute schedule time",
  watch_off: "Android clock close gadget iOS shut time vr wearables web wristwatch",
  water: "aqua beach lake ocean river waves weather",
  water_damage: "architecture building droplet estate house leak plumbing real residence residential shelter",
  waterfall_chart: "analytics bar data diagram infographic measure metrics statistics tracking",
  waves: "beach lake ocean pool river sea swim water",
  wb_auto: "A W alphabet automatic balance character editing font image letter photography symbol text type white wp",
  wb_cloudy: "balance editing white wp",
  wb_incandescent: "balance bright editing lamp lightbulb lighting settings white wp",
  wb_iridescent: "balance bright editing lighting settings white wp",
  wb_shade: "balance house lighting white",
  wb_sunny: "balance bright lighting weather white",
  wc: "bathroom closet female gender man person restroom toilet unisex wash water women",
  web: "blocks browser internet page screen website www",
  web_asset: "-website application browser design desktop download image interface internet layout screen ui ux video window www",
  web_asset_off: "browser disabled enabled internet on screen slash webpage website windows www",
  webhook: "api developer development enterprise software",
  weekend: "chair couch furniture home living lounge relax room seat",
  west: "arrow directional left maps navigation",
  whatshot: "arrow circle direction fire frames round trending",
  wheelchair_pickup: "accessibility accessible body handicap help human person",
  where_to_vote: "approve ballot check complete destination direction done election location maps mark ok pin place poll select stop tick validate verified yes",
  widgets: "app blocks box menu setting squares ui",
  wifi: "connection data internet network scan service signal wireless",
  wifi_calling: "cell connection connectivity contact device hardware mobile signal telephone wireless",
  wifi_calling_3: "cellular data internet mobile network phone speed wireless",
  wifi_channel: "(scan) [cellular connection data internet mobile] network service signal wireless",
  wifi_find: "(scan) [cellular connection data detect discover glass internet look magnifying mobile] network notice search service signal wireless",
  wifi_lock: "cellular connection data internet locked mobile network password privacy private protection safety secure security service signal wireless",
  wifi_off: "connection data disabled enabled internet network offline scan service signal slash wireless",
  wifi_password: "(scan) [cellular connection data internet lock mobile] network secure service signal wireless",
  wifi_protected_setup: "around arrows rotate",
  wifi_tethering: "cellular connection data internet mobile network phone scan service signal speed wireless",
  wifi_tethering_off: "cellular connection data disabled enabled internet mobile network offline phone scan service signal slash speed wireless",
  window: "close glass grid home house interior layout outside",
  wind_power: "eco energy nest windy",
  wine_bar: "alcohol cocktail cup drink glass liquor",
  work: "-briefcase baggage business job suitcase",
  work_history: "arrow backwards baggage briefcase business clock date job refresh renew reverse rotate schedule suitcase time turn",
  work_off: "baggage briefcase business disabled enabled job on slash suitcase",
  work_outline: "baggage briefcase business job suitcase",
  workspace_premium: "certification degree ecommerce guarantee medal permit ribbon verification",
  workspaces: "circles collaboration dot filled group team",
  wrap_text: "arrow doc editing editor spreadsheet type write writing",
  wrong_location: "cancel close destination direction exit maps no pin place quit remove stop",
  wysiwyg: "composer mode screen software system text view visibility website window",
  yard: "backyard flower garden home house nature pettle plants",
  youtube_searched_for: "arrow backwards find glass history inprogress loading look magnifying refresh renew restore reverse rotate see yt",
  zoom_in: "bigger find glass grow look magnifier magnifying plus scale search see size",
  zoom_in_map: "arrows destination location maps move place stop",
  zoom_out: "find glass look magnifier magnifying minus negative scale search see size smaller",
  zoom_out_map: "arrows destination location maps move place stop"
};
var map3 = iconKeys.map((importName) => {
  const iconSynonym = importName in iconSynonyms ? iconSynonyms[importName] : "";
  return {
    key: importName,
    synonyms: iconSynonym
  };
});
var iconsSearch = new Fuse(map3, {
  isCaseSensitive: false,
  shouldSort: true,
  ignoreLocation: true,
  distance: 0,
  keys: ["key", "synonyms"]
});
function hashString(str) {
  let hash22 = 0;
  let i2;
  let chr;
  for (i2 = 0; i2 < str.length; i2++) {
    chr = str.charCodeAt(i2);
    hash22 = (hash22 << 5) - hash22 + chr;
    hash22 |= 0;
  }
  return Math.abs(hash22);
}
function getIcon(iconKey, className, color) {
  if (!iconKey) return void 0;
  iconKey = slugify(iconKey);
  if (!(iconKey in iconKeysMap)) {
    return void 0;
  }
  return iconKey in iconKeysMap ? (0, import_jsx_runtime2.jsx)(Icon, { iconKey, size: "medium", className, color }) : void 0;
}
var IconForView = import_react14.default.memo(function IconForView2(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(14);
  const {
    collectionOrView,
    className,
    color,
    size: t1
  } = t0;
  const size2 = t1 === void 0 ? "medium" : t1;
  if (!collectionOrView) {
    let t22;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t22 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
      $[0] = t22;
    } else {
      t22 = $[0];
    }
    return t22;
  }
  let t2;
  if ($[1] !== className || $[2] !== collectionOrView.icon || $[3] !== color) {
    t2 = getIcon(collectionOrView.icon, className, color);
    $[1] = className;
    $[2] = collectionOrView.icon;
    $[3] = color;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const icon = t2;
  if ((collectionOrView == null ? void 0 : collectionOrView.icon) && icon) {
    return icon;
  }
  const t3 = ("singularName" in collectionOrView ? collectionOrView.singularName : void 0) ?? collectionOrView.name;
  let t4;
  if ($[5] !== t3) {
    t4 = slugify(t3);
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let slugName = t4;
  let key;
  if (slugName in iconKeysMap) {
    key = slugName;
  }
  if (!key) {
    let t52;
    if ($[7] !== collectionOrView.path) {
      t52 = slugify(collectionOrView.path);
      $[7] = collectionOrView.path;
      $[8] = t52;
    } else {
      t52 = $[8];
    }
    slugName = t52;
    if (slugName in iconKeysMap) {
      key = slugName;
    }
  }
  const iconsCount = coolIconKeys.length;
  if (!key) {
    key = coolIconKeys[hashString(collectionOrView.path) % iconsCount];
  }
  let t5;
  if ($[9] !== className || $[10] !== color || $[11] !== key || $[12] !== size2) {
    t5 = (0, import_jsx_runtime2.jsx)(Icon, { iconKey: key, size: size2, className, color });
    $[9] = className;
    $[10] = color;
    $[11] = key;
    $[12] = size2;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  return t5;
}, (prevProps, nextProps) => {
  var _a, _b;
  return (0, import_react_fast_compare2.default)((_a = prevProps.collectionOrView) == null ? void 0 : _a.icon, (_b = nextProps.collectionOrView) == null ? void 0 : _b.icon) && (0, import_react_fast_compare2.default)(prevProps.color, nextProps.color);
});
var iconKeysMap = iconKeys.reduce((acc, key) => {
  acc[key] = key;
  return acc;
}, {});
function plural(word, amount) {
  if (amount !== void 0 && amount === 1) {
    return word;
  }
  const plurals = {
    "(quiz)$": "$1zes",
    "^(ox)$": "$1en",
    "([m|l])ouse$": "$1ice",
    "(matr|vert|ind)ix|ex$": "$1ices",
    "(x|ch|ss|sh)$": "$1es",
    "([^aeiouy]|qu)y$": "$1ies",
    "(hive)$": "$1s",
    "(?:([^f])fe|([lr])f)$": "$1$2ves",
    "(shea|lea|loa|thie)f$": "$1ves",
    sis$: "ses",
    "([ti])um$": "$1a",
    "(tomat|potat|ech|her|vet)o$": "$1oes",
    "(bu)s$": "$1ses",
    "(alias)$": "$1es",
    "(octop)us$": "$1i",
    "(ax|test)is$": "$1es",
    "(us)$": "$1es",
    "([^s]+)$": "$1s"
  };
  const irregular = {
    move: "moves",
    foot: "feet",
    goose: "geese",
    sex: "sexes",
    child: "children",
    man: "men",
    tooth: "teeth",
    person: "people"
  };
  const uncountable = ["sheep", "fish", "deer", "moose", "series", "species", "money", "rice", "information", "equipment", "bison", "cod", "offspring", "pike", "salmon", "shrimp", "swine", "trout", "aircraft", "hovercraft", "spacecraft", "sugar", "tuna", "you", "wood"];
  if (uncountable.indexOf(word.toLowerCase()) >= 0) {
    return word;
  }
  for (const w in irregular) {
    const pattern = new RegExp(`${w}$`, "i");
    const replace3 = irregular[w];
    if (pattern.test(word)) {
      return word.replace(pattern, replace3);
    }
  }
  for (const reg in plurals) {
    const pattern = new RegExp(reg, "i");
    if (pattern.test(word)) {
      return word.replace(pattern, plurals[reg]);
    }
  }
  return word;
}
function singular(word, amount) {
  if (amount !== void 0 && amount !== 1) {
    return word;
  }
  const singulars = {
    "(quiz)zes$": "$1",
    "(matr)ices$": "$1ix",
    "(vert|ind)ices$": "$1ex",
    "^(ox)en$": "$1",
    "(alias)es$": "$1",
    "(octop|vir)i$": "$1us",
    "(cris|ax|test)es$": "$1is",
    "(shoe)s$": "$1",
    "(o)es$": "$1",
    "(bus)es$": "$1",
    "([m|l])ice$": "$1ouse",
    "(x|ch|ss|sh)es$": "$1",
    "(m)ovies$": "$1ovie",
    "(s)eries$": "$1eries",
    "([^aeiouy]|qu)ies$": "$1y",
    "([lr])ves$": "$1f",
    "(tive)s$": "$1",
    "(hive)s$": "$1",
    "(li|wi|kni)ves$": "$1fe",
    "(shea|loa|lea|thie)ves$": "$1f",
    "(^analy)ses$": "$1sis",
    "((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$": "$1$2sis",
    "([ti])a$": "$1um",
    "(n)ews$": "$1ews",
    "(h|bl)ouses$": "$1ouse",
    "(corpse)s$": "$1",
    "(us)es$": "$1",
    s$: ""
  };
  const irregular = {
    move: "moves",
    foot: "feet",
    goose: "geese",
    sex: "sexes",
    child: "children",
    man: "men",
    tooth: "teeth",
    person: "people"
  };
  const uncountable = ["sheep", "fish", "deer", "moose", "series", "species", "money", "rice", "information", "equipment", "bison", "cod", "offspring", "pike", "salmon", "shrimp", "swine", "trout", "aircraft", "hovercraft", "spacecraft", "sugar", "tuna", "you", "wood"];
  if (uncountable.indexOf(word.toLowerCase()) >= 0) {
    return word;
  }
  for (const w in irregular) {
    const pattern = new RegExp(`${irregular[w]}$`, "i");
    if (pattern.test(word)) {
      return word.replace(pattern, w);
    }
  }
  for (const reg in singulars) {
    const pattern = new RegExp(reg, "i");
    if (pattern.test(word)) {
      return word.replace(pattern, singulars[reg]);
    }
  }
  return word;
}
function getEntityPreviewKeys(authController, targetCollection, fields, previewProperties, limit = 3) {
  var _a;
  const allProperties = Object.keys(targetCollection.properties);
  let listProperties = previewProperties == null ? void 0 : previewProperties.filter((p3) => allProperties.includes(p3));
  if (!listProperties && targetCollection.previewProperties) {
    listProperties = (_a = targetCollection.previewProperties) == null ? void 0 : _a.filter((p3) => allProperties.includes(p3));
  }
  if (listProperties && listProperties.length > 0) {
    return listProperties;
  } else {
    listProperties = allProperties;
    return listProperties.filter((key) => {
      const propertyOrBuilder = targetCollection.properties[key];
      return propertyOrBuilder && !isPropertyBuilder(propertyOrBuilder) && !isReferenceProperty(authController, propertyOrBuilder, fields);
    }).slice(0, limit);
  }
}
function getEntityTitlePropertyKey(collection, propertyConfigs) {
  if (collection.titleProperty) {
    return collection.titleProperty;
  }
  for (const key in collection.properties) {
    const property = collection.properties[key];
    if (!isPropertyBuilder(property)) {
      const field = getFieldConfig(property, propertyConfigs);
      if ((field == null ? void 0 : field.key) === "text_field") {
        return key;
      }
    }
  }
  return void 0;
}
function getEntityImagePreviewPropertyKey(collection) {
  var _a, _b, _c, _d, _e;
  for (const key in collection.properties) {
    const property = collection.properties[key];
    if (property.dataType === "string" && ((_b = (_a = property.storage) == null ? void 0 : _a.acceptedFiles) == null ? void 0 : _b.includes("image/*"))) {
      return key;
    }
  }
  for (const key in collection.properties) {
    const property = collection.properties[key];
    if (property.dataType === "array" && ((_c = property.of) == null ? void 0 : _c.dataType) === "string" && ((_e = (_d = property.of.storage) == null ? void 0 : _d.acceptedFiles) == null ? void 0 : _e.includes("image/*"))) {
      return key;
    }
  }
  return void 0;
}
function flattenObject(obj, parentKey = "") {
  if (!obj) return obj;
  return Object.keys(obj).reduce((flatObj, key) => {
    const newKey = parentKey ? `${parentKey}.${key}` : key;
    if (typeof obj[key] === "object" && obj[key] !== null) {
      if (Array.isArray(obj[key])) {
        obj[key].forEach((item, index2) => {
          Object.assign(flatObj, flattenObject(item, `${newKey}[${index2}]`));
        });
      } else {
        Object.assign(flatObj, flattenObject(obj[key], newKey));
      }
    } else {
      flatObj[newKey] = obj[key];
    }
    return flatObj;
  }, {});
}
function getArrayValuesCount(array2) {
  return array2.reduce((acc, obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        acc[key] = Math.max(acc[key] || 0, value.length);
      }
      if (typeof value === "object" && value !== null) {
        const nested = getArrayValuesCount([value]);
        Object.entries(nested).forEach(([nestedKey, nestedCount]) => {
          const compoundKey = `${key}.${nestedKey}`;
          acc[compoundKey] = Math.max(acc[compoundKey] || 0, nestedCount);
        });
      }
    });
    return acc;
  }, {});
}
function makePropertiesEditable(properties) {
  Object.keys(properties).forEach((key) => {
    const property = properties[key];
    if (property) {
      property.editable = true;
      if (property.dataType === "map" && property.properties) {
        makePropertiesEditable(property.properties);
      }
    }
  });
  return properties;
}
function makePropertiesNonEditable(properties) {
  return Object.entries(properties).reduce((acc, [key, property]) => {
    if (!isPropertyBuilder(property) && property.dataType === "map" && property.properties) {
      const updated = {
        ...property,
        properties: makePropertiesNonEditable(property.properties)
      };
      acc[key] = updated;
    }
    if (isPropertyBuilder(property)) {
      acc[key] = property;
    } else {
      acc[key] = {
        ...property,
        editable: false
      };
    }
    return acc;
  }, {});
}
function applyModifyFunction(modifyCollection, collection, parentPaths) {
  if (modifyCollection) {
    const modified = modifyCollection({
      collection,
      parentPaths
    });
    const resCollection = modified ?? collection;
    if (resCollection.subcollections) {
      resCollection.subcollections = resCollection.subcollections.map((subcollection) => {
        return applyModifyFunction(modifyCollection, subcollection, [...parentPaths, collection.path]);
      });
    }
    return resCollection;
  } else {
    return collection;
  }
}
function joinCollectionLists(targetCollections, sourceCollections, parentPaths = [], modifyCollection) {
  const updatedCollections = (sourceCollections ?? []).map((sourceCol) => {
    const targetCol = targetCollections == null ? void 0 : targetCollections.find((collection) => {
      return collection.id === sourceCol.id;
    });
    if (!targetCol) {
      return applyModifyFunction(modifyCollection, sourceCol, parentPaths);
    } else {
      return mergeCollection(targetCol, sourceCol, parentPaths, modifyCollection);
    }
  });
  const sourceCollectionIds = updatedCollections.map((c22) => c22.id);
  const resultStoredCollections = targetCollections.filter((col) => {
    return !sourceCollectionIds.includes(col.id);
  }).map((col) => {
    if (modifyCollection) {
      return applyModifyFunction(modifyCollection, col, parentPaths);
    } else {
      return col;
    }
  });
  return [...updatedCollections, ...resultStoredCollections];
}
function mergeCollection(target, source, parentPaths = [], modifyCollection) {
  const subcollectionsMerged = joinCollectionLists((target == null ? void 0 : target.subcollections) ?? [], (source == null ? void 0 : source.subcollections) ?? [], [...parentPaths, target.path], modifyCollection);
  const propertiesMerged = {
    ...target.properties
  };
  Object.keys(source.properties).forEach((key) => {
    const property = target.properties[key];
    if (property) propertiesMerged[key] = mergePropertyOrBuilder(property, source.properties[key]);
    else propertiesMerged[key] = source.properties[key];
  });
  const mergedCollection = mergeDeep2(target, source, true);
  const targetPropertiesOrder = getCollectionKeys(target);
  const sourcePropertiesOrder = getCollectionKeys(source);
  const mergedPropertiesOrder = [.../* @__PURE__ */ new Set([...sourcePropertiesOrder, ...targetPropertiesOrder])];
  const mergedEntityViews = [.../* @__PURE__ */ new Set([...target.entityViews ?? [], ...source.entityViews ?? []])];
  let resultCollection = {
    ...mergedCollection,
    subcollections: subcollectionsMerged,
    properties: sortProperties(propertiesMerged, mergedPropertiesOrder),
    propertiesOrder: mergedPropertiesOrder,
    entityViews: mergedEntityViews
  };
  if (modifyCollection) {
    const modifiedCollection = modifyCollection({
      collection: resultCollection,
      parentPaths
    });
    if (modifiedCollection) resultCollection = modifiedCollection;
  }
  resultCollection["merged"] = true;
  return resultCollection;
}
function mergePropertyOrBuilder(target, source) {
  if (isPropertyBuilder(source)) {
    return source;
  } else if (isPropertyBuilder(target)) {
    return target;
  } else {
    const mergedProperty = mergeDeep2(target, source);
    const targetEditable = Boolean(target.editable);
    const sourceEditable = Boolean(source.editable);
    if (source.dataType === "map" && source.properties) {
      const targetProperties = "properties" in target ? target.properties : {};
      const sourceProperties = "properties" in source ? source.properties : {};
      const targetPropertiesOrder = "propertiesOrder" in target && target.propertiesOrder ? target.propertiesOrder : Object.keys(targetProperties);
      const sourcePropertiesOrder = "propertiesOrder" in source && source.propertiesOrder ? source.propertiesOrder : "properties" in source ? Object.keys(source.properties) : [];
      const mergedPropertiesOrder = [.../* @__PURE__ */ new Set([...targetPropertiesOrder, ...sourcePropertiesOrder])];
      const mergedProperties = {
        ...targetProperties
      };
      Object.keys(source.properties).forEach((key) => {
        const property = targetProperties[key];
        if (property) mergedProperties[key] = mergePropertyOrBuilder(property, sourceProperties[key]);
      });
      return {
        ...mergedProperty,
        editable: targetEditable && sourceEditable,
        properties: mergedProperties,
        propertiesOrder: mergedPropertiesOrder
      };
    }
    return {
      ...mergedProperty,
      editable: targetEditable && sourceEditable
    };
  }
}
function getCollectionKeys(collection) {
  var _a;
  if (collection.propertiesOrder && collection.propertiesOrder.length > 0) {
    const propertiesOrder = collection.propertiesOrder;
    if (collection.additionalFields) {
      collection.additionalFields.forEach((field) => {
        if (!propertiesOrder.includes(field.key)) {
          propertiesOrder.push(field.key);
        }
      });
    }
    return propertiesOrder;
  }
  return [...Object.keys(collection.properties), ...(_a = collection.additionalFields ?? []) == null ? void 0 : _a.map((f) => f.key)];
}
function buildCollection(collection) {
  return collection;
}
function buildProperty(property) {
  return property;
}
function buildProperties(properties) {
  return properties;
}
function buildPropertiesOrBuilder(propertiesOrBuilder) {
  return propertiesOrBuilder;
}
function buildEnumValues(enumValues) {
  return enumValues;
}
function buildEnumValueConfig(enumValueConfig) {
  return enumValueConfig;
}
function buildEntityCallbacks(callbacks) {
  return callbacks;
}
function buildAdditionalFieldDelegate(additionalFieldDelegate) {
  return additionalFieldDelegate;
}
function buildFieldConfig(propertyConfig) {
  return propertyConfig;
}
function printChanged(props, prev, path = "", depth = 0, maxDepth = 10) {
  if (depth > maxDepth) {
    return;
  }
  if (props && prev && typeof props === "object" && typeof prev === "object") {
    Object.keys(props).forEach((key) => {
      printChanged(props[key], prev[key], path + "." + key, depth + 1, maxDepth);
    });
  } else if (props !== prev) {
    console.log("Changed props:", path);
  }
}
function useTraceUpdate(props, t0) {
  const $ = (0, import_react_compiler_runtime3.c)(3);
  const maxDepth = t0 === void 0 ? 3 : t0;
  const prev = (0, import_react14.useRef)(props);
  let t1;
  if ($[0] !== maxDepth || $[1] !== props) {
    t1 = () => {
      console.log("Changed props:");
      printChanged(props, prev.current, "", 0, maxDepth);
      prev.current = props;
    };
    $[0] = maxDepth;
    $[1] = props;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  (0, import_react14.useEffect)(t1);
}
async function resolveStorageFilenameString({
  input,
  storage,
  values,
  entityId,
  path,
  property,
  file,
  propertyKey
}) {
  let result;
  if (typeof input === "function") {
    result = await input({
      path,
      entityId,
      values,
      property,
      file,
      storage,
      propertyKey
    });
    if (!result) console.warn("Storage callback returned empty result. Using default name value");
  } else {
    result = replacePlaceholders({
      file,
      input,
      entityId,
      propertyKey,
      path
    });
  }
  if (!result) result = randomString2() + "_" + file.name;
  return result;
}
function resolveStoragePathString({
  input,
  storage,
  values,
  entityId,
  path,
  property,
  file,
  propertyKey
}) {
  let result;
  if (typeof input === "function") {
    result = input({
      path,
      entityId,
      values,
      property,
      file,
      storage,
      propertyKey
    });
    if (!result) console.warn("Storage callback returned empty result. Using default name value");
  } else {
    result = replacePlaceholders({
      file,
      input,
      entityId,
      propertyKey,
      path
    });
  }
  if (!result) result = randomString2() + "_" + file.name;
  return result;
}
function replacePlaceholders({
  file,
  input,
  entityId,
  propertyKey,
  path
}) {
  const ext = file.name.split(".").pop();
  let result = input.replace("{entityId}", entityId).replace("{propertyKey}", propertyKey).replace("{rand}", randomString2()).replace("{file}", file.name).replace("{file.type}", file.type);
  if (path) {
    result = result.replace("{path}", path);
  }
  if (ext) {
    result = result.replace("{file.ext}", ext);
    const name = file.name.replace(`.${ext}`, "");
    result = result.replace("{file.name}", name);
  }
  if (!result) result = randomString2() + "_" + file.name;
  return result;
}
var CONTAINER_FULL_WIDTH = "100vw";
var ADDITIONAL_TAB_WIDTH = "55vw";
var FORM_CONTAINER_WIDTH = "768px";
var DataSourceContext = import_react14.default.createContext({});
var useDataSource = (collection) => {
  const defaultDataSource = (0, import_react14.useContext)(DataSourceContext);
  return defaultDataSource;
};
var NavigationContext2 = import_react14.default.createContext({});
var useNavigationController = () => {
  return (0, import_react14.useContext)(NavigationContext2);
};
var useAuthController = () => {
  return (0, import_react14.useContext)(AuthControllerContext);
};
var SideDialogsControllerContext = import_react14.default.createContext({});
var useSideDialogsController = () => {
  return (0, import_react14.useContext)(SideDialogsControllerContext);
};
var SideEntityControllerContext = import_react14.default.createContext({});
var useSideEntityController = () => {
  return (0, import_react14.useContext)(SideEntityControllerContext);
};
var StorageSourceContext = import_react14.default.createContext({});
var useStorageSource = (collection) => {
  var _a;
  const defaultStorageSource = (0, import_react14.useContext)(StorageSourceContext);
  if ((_a = collection == null ? void 0 : collection.overrides) == null ? void 0 : _a.storageSource) {
    return collection.overrides.storageSource;
  }
  return defaultStorageSource;
};
var useSnackbarController = () => {
  const {
    enqueueSnackbar: enqueueSnackbar2,
    closeSnackbar: closeSnackbar2
  } = useSnackbar();
  const open = (0, import_react14.useCallback)((props) => {
    const {
      type,
      message: message2,
      autoHideDuration
    } = props;
    enqueueSnackbar2({
      message: message2,
      variant: type,
      autoHideDuration
    });
  }, []);
  const close2 = (0, import_react14.useCallback)(() => {
    closeSnackbar2();
  }, []);
  return (0, import_react14.useMemo)(() => ({
    open,
    close: close2
  }), [open, close2]);
};
var UserConfigurationPersistenceContext = import_react14.default.createContext(void 0);
var useUserConfigurationPersistence = () => {
  return (0, import_react14.useContext)(UserConfigurationPersistenceContext);
};
var DialogsControllerContext = import_react14.default.createContext({});
var DialogsProvider = (t0) => {
  const $ = (0, import_react_compiler_runtime3.c)(16);
  const {
    children
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const [dialogEntries, setDialogEntries] = (0, import_react14.useState)(t1);
  const dialogEntriesRef = (0, import_react14.useRef)(dialogEntries);
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (newPanels) => {
      dialogEntriesRef.current = newPanels;
      setDialogEntries(newPanels);
    };
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const updateDialogEntries = t2;
  let t3;
  if ($[2] !== dialogEntries.length) {
    t3 = () => {
      if (dialogEntries.length === 0) {
        return;
      }
      const updatedPanels = [...dialogEntriesRef.current.slice(0, -1)];
      updateDialogEntries(updatedPanels);
    };
    $[2] = dialogEntries.length;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const close2 = t3;
  let t4;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (dialogEntry) => {
      const updatedPanels_0 = [...dialogEntriesRef.current, dialogEntry];
      updateDialogEntries(updatedPanels_0);
      return {
        closeDialog: () => {
          const updatedPanels_1 = dialogEntriesRef.current.filter((e2) => e2.key !== dialogEntry.key);
          updateDialogEntries(updatedPanels_1);
        }
      };
    };
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  const open = t4;
  let t5;
  if ($[5] !== close2) {
    t5 = {
      open,
      close: close2
    };
    $[5] = close2;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  let t6;
  if ($[7] !== close2 || $[8] !== dialogEntries) {
    let t72;
    if ($[10] !== close2) {
      t72 = (entry, i2) => (0, import_jsx_runtime2.jsx)(entry.Component, { open: true, closeDialog: close2, ...entry.props }, `dialog_${i2}`);
      $[10] = close2;
      $[11] = t72;
    } else {
      t72 = $[11];
    }
    t6 = dialogEntries.map(t72);
    $[7] = close2;
    $[8] = dialogEntries;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[12] !== children || $[13] !== t5 || $[14] !== t6) {
    t7 = (0, import_jsx_runtime2.jsxs)(DialogsControllerContext.Provider, { value: t5, children: [
      children,
      t6
    ] });
    $[12] = children;
    $[13] = t5;
    $[14] = t6;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  return t7;
};
var useDialogsController = () => {
  return (0, import_react14.useContext)(DialogsControllerContext);
};
var CustomizationControllerContext = import_react14.default.createContext({});
var useCustomizationController = () => {
  return (0, import_react14.useContext)(CustomizationControllerContext);
};
var AnalyticsContext = import_react14.default.createContext({});
var useAnalyticsController = () => {
  return (0, import_react14.useContext)(AnalyticsContext);
};
var useFireCMSContext = () => {
  const authController = useAuthController();
  const sideDialogsController = useSideDialogsController();
  const sideEntityController = useSideEntityController();
  const navigation = useNavigationController();
  const dataSource = useDataSource();
  const storageSource = useStorageSource();
  const snackbarController = useSnackbarController();
  const userConfigPersistence = useUserConfigurationPersistence();
  const dialogsController = useDialogsController();
  const customizationController = useCustomizationController();
  const analyticsController = useAnalyticsController();
  const fireCMSContextRef = import_react14.default.useRef({
    authController,
    sideDialogsController,
    sideEntityController,
    navigation,
    dataSource,
    storageSource,
    snackbarController,
    userConfigPersistence,
    dialogsController,
    customizationController,
    analyticsController
  });
  (0, import_react14.useEffect)(() => {
    fireCMSContextRef.current = {
      authController,
      sideDialogsController,
      sideEntityController,
      navigation,
      dataSource,
      storageSource,
      snackbarController,
      userConfigPersistence,
      dialogsController,
      customizationController,
      analyticsController
    };
  }, [authController, dialogsController, navigation, sideDialogsController]);
  return fireCMSContextRef.current;
};
function useCollectionFetch(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(26);
  const {
    path: inputPath,
    collection,
    filterValues,
    sortBy,
    itemCount,
    searchString
  } = t0;
  const dataSource = useDataSource();
  const navigationController = useNavigationController();
  let t1;
  if ($[0] !== inputPath || $[1] !== navigationController) {
    t1 = navigationController.resolveIdsFrom(inputPath);
    $[0] = inputPath;
    $[1] = navigationController;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const path = t1;
  const sortByProperty = sortBy ? sortBy[0] : void 0;
  const currentSort = sortBy ? sortBy[1] : void 0;
  const context = useFireCMSContext();
  let t2;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = [];
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const [data, setData] = (0, import_react14.useState)(t2);
  const [dataLoading, setDataLoading] = (0, import_react14.useState)(false);
  const [dataLoadingError, setDataLoadingError] = (0, import_react14.useState)();
  const [noMoreToLoad, setNoMoreToLoad] = (0, import_react14.useState)(false);
  let t3;
  if ($[4] !== collection || $[5] !== context || $[6] !== currentSort || $[7] !== dataSource || $[8] !== filterValues || $[9] !== itemCount || $[10] !== path || $[11] !== searchString || $[12] !== sortByProperty) {
    t3 = () => {
      setDataLoading(true);
      const onEntitiesUpdate = async (entities) => {
        var _a;
        if ((_a = collection.callbacks) == null ? void 0 : _a.onFetch) {
          try {
            entities = await Promise.all(entities.map((entity) => collection.callbacks.onFetch({
              collection,
              path,
              entity,
              context
            })));
          } catch (t42) {
            const e2 = t42;
            console.error(e2);
          }
        }
        setDataLoading(false);
        setDataLoadingError(void 0);
        setData(entities.map(_temp$s));
        setNoMoreToLoad(!itemCount || entities.length < itemCount);
      };
      const onError = (error2) => {
        console.error("ERROR", error2);
        setDataLoading(false);
        setData([]);
        setDataLoadingError(error2);
      };
      if (dataSource.listenCollection) {
        return dataSource.listenCollection({
          path,
          collection,
          onUpdate: onEntitiesUpdate,
          onError,
          searchString,
          filter: filterValues,
          limit: itemCount,
          startAfter: void 0,
          orderBy: sortByProperty,
          order: currentSort
        });
      } else {
        dataSource.fetchCollection({
          path,
          collection,
          searchString,
          filter: filterValues,
          limit: itemCount,
          startAfter: void 0,
          orderBy: sortByProperty,
          order: currentSort
        }).then(onEntitiesUpdate).catch(onError);
        return _temp2$e;
      }
    };
    $[4] = collection;
    $[5] = context;
    $[6] = currentSort;
    $[7] = dataSource;
    $[8] = filterValues;
    $[9] = itemCount;
    $[10] = path;
    $[11] = searchString;
    $[12] = sortByProperty;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  let t4;
  if ($[14] !== currentSort || $[15] !== filterValues || $[16] !== itemCount || $[17] !== path || $[18] !== searchString || $[19] !== sortByProperty) {
    t4 = [path, itemCount, currentSort, sortByProperty, filterValues, searchString];
    $[14] = currentSort;
    $[15] = filterValues;
    $[16] = itemCount;
    $[17] = path;
    $[18] = searchString;
    $[19] = sortByProperty;
    $[20] = t4;
  } else {
    t4 = $[20];
  }
  (0, import_react14.useEffect)(t3, t4);
  let t5;
  if ($[21] !== data || $[22] !== dataLoading || $[23] !== dataLoadingError || $[24] !== noMoreToLoad) {
    t5 = {
      data,
      dataLoading,
      dataLoadingError,
      noMoreToLoad
    };
    $[21] = data;
    $[22] = dataLoading;
    $[23] = dataLoadingError;
    $[24] = noMoreToLoad;
    $[25] = t5;
  } else {
    t5 = $[25];
  }
  return t5;
}
function _temp2$e() {
}
function _temp$s(e_0) {
  return {
    ...e_0
  };
}
var CACHE = {};
function useEntityFetch(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(18);
  const {
    path: inputPath,
    entityId,
    collection,
    databaseId,
    useCache: t1
  } = t0;
  const useCache = t1 === void 0 ? false : t1;
  const dataSource = useDataSource();
  const navigationController = useNavigationController();
  let t2;
  if ($[0] !== inputPath || $[1] !== navigationController) {
    t2 = navigationController.resolveIdsFrom(inputPath);
    $[0] = inputPath;
    $[1] = navigationController;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const path = t2;
  const context = useFireCMSContext();
  const [entity, setEntity] = (0, import_react14.useState)();
  const [dataLoading, setDataLoading] = (0, import_react14.useState)(true);
  const [dataLoadingError, setDataLoadingError] = (0, import_react14.useState)();
  let t3;
  if ($[3] !== collection || $[4] !== context || $[5] !== dataSource || $[6] !== databaseId || $[7] !== entityId || $[8] !== path || $[9] !== useCache) {
    t3 = () => {
      setDataLoading(true);
      const onEntityUpdate = async (updatedEntity) => {
        var _a;
        if (((_a = collection.callbacks) == null ? void 0 : _a.onFetch) && updatedEntity) {
          try {
            updatedEntity = await collection.callbacks.onFetch({
              collection,
              path,
              entity: updatedEntity,
              context
            });
          } catch (t42) {
            const e2 = t42;
            console.error(e2);
          }
        }
        CACHE[`${path}/${entityId}`] = updatedEntity;
        setEntity(updatedEntity);
        setDataLoading(false);
        setDataLoadingError(void 0);
      };
      const onError = (error2) => {
        console.error("ERROR fetching entity", error2);
        setDataLoading(false);
        setEntity(void 0);
        setDataLoadingError(error2);
      };
      if (entityId && useCache && CACHE[`${path}/${entityId}`]) {
        setEntity(CACHE[`${path}/${entityId}`]);
        setDataLoading(false);
        setDataLoadingError(void 0);
        return _temp$r;
      } else {
        if (entityId && path && collection) {
          if (dataSource.listenEntity) {
            return dataSource.listenEntity({
              path,
              entityId,
              databaseId,
              collection,
              onUpdate: onEntityUpdate,
              onError
            });
          } else {
            dataSource.fetchEntity({
              path,
              entityId,
              databaseId,
              collection
            }).then(onEntityUpdate).catch(onError);
            return _temp2$d;
          }
        } else {
          onEntityUpdate(void 0);
          return _temp3$4;
        }
      }
    };
    $[3] = collection;
    $[4] = context;
    $[5] = dataSource;
    $[6] = databaseId;
    $[7] = entityId;
    $[8] = path;
    $[9] = useCache;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  let t4;
  if ($[11] !== entityId || $[12] !== path) {
    t4 = [entityId, path];
    $[11] = entityId;
    $[12] = path;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  (0, import_react14.useEffect)(t3, t4);
  let t5;
  if ($[14] !== dataLoading || $[15] !== dataLoadingError || $[16] !== entity) {
    t5 = {
      entity,
      dataLoading,
      dataLoadingError
    };
    $[14] = dataLoading;
    $[15] = dataLoadingError;
    $[16] = entity;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  return t5;
}
function _temp3$4() {
}
function _temp2$d() {
}
function _temp$r() {
}
async function saveEntityWithCallbacks({
  collection,
  path,
  entityId,
  values,
  previousValues,
  status,
  dataSource,
  context,
  onSaveSuccess,
  onSaveFailure,
  onPreSaveHookError,
  onSaveSuccessHookError
}) {
  if (status !== "new" && !entityId) {
    throw new Error("Entity id must be specified when updating an existing entity");
  }
  let updatedValues;
  const customizationController = context.customizationController;
  const resolvedPath = context.navigation.resolveIdsFrom(path);
  const callbacks = collection.callbacks;
  if (callbacks == null ? void 0 : callbacks.onPreSave) {
    try {
      const resolvedCollection = resolveCollection({
        collection,
        path,
        values: previousValues,
        entityId,
        propertyConfigs: customizationController.propertyConfigs,
        authController: context.authController
      });
      updatedValues = await callbacks.onPreSave({
        collection: resolvedCollection,
        path,
        resolvedPath,
        entityId,
        values,
        previousValues,
        status,
        context
      });
    } catch (e2) {
      console.error(e2);
      if (onPreSaveHookError) onPreSaveHookError(e2);
      return;
    }
  } else {
    updatedValues = values;
  }
  console.debug("Saving entity", {
    entityId,
    updatedValues,
    collection
  });
  return dataSource.saveEntity({
    collection,
    path: resolvedPath,
    entityId,
    values: updatedValues,
    previousValues,
    status
  }).then((entity) => {
    try {
      if (callbacks == null ? void 0 : callbacks.onSaveSuccess) {
        const resolvedCollection = resolveCollection({
          collection,
          path,
          values: updatedValues,
          entityId,
          propertyConfigs: customizationController.propertyConfigs,
          authController: context.authController
        });
        callbacks.onSaveSuccess({
          collection: resolvedCollection,
          path,
          resolvedPath,
          entityId: entity.id,
          values: updatedValues,
          previousValues,
          status,
          context
        });
      }
    } catch (e2) {
      if (onSaveSuccessHookError) onSaveSuccessHookError(e2);
    }
    if (onSaveSuccess) onSaveSuccess(entity);
  }).catch((e2) => {
    console.error("!!!", e2);
    if (callbacks == null ? void 0 : callbacks.onSaveFailure) {
      const resolvedCollection = resolveCollection({
        collection,
        path,
        values: updatedValues,
        entityId,
        propertyConfigs: customizationController.propertyConfigs,
        authController: context.authController
      });
      callbacks.onSaveFailure({
        collection: resolvedCollection,
        path,
        resolvedPath,
        entityId,
        values: updatedValues,
        previousValues,
        status,
        context
      });
    }
    if (onSaveFailure) onSaveFailure(e2);
  });
}
async function deleteEntityWithCallbacks({
  dataSource,
  entity,
  collection,
  callbacks,
  onDeleteSuccess,
  onDeleteFailure,
  onPreDeleteHookError,
  onDeleteSuccessHookError,
  context
}) {
  console.debug("Deleting entity", entity.path, entity.id);
  const entityDeleteProps = {
    entity,
    collection,
    entityId: entity.id,
    path: entity.path,
    context
  };
  if (callbacks == null ? void 0 : callbacks.onPreDelete) {
    try {
      await callbacks.onPreDelete(entityDeleteProps);
    } catch (e2) {
      console.error(e2);
      if (onPreDeleteHookError) onPreDeleteHookError(entity, e2);
      return false;
    }
  }
  return dataSource.deleteEntity({
    entity,
    collection
  }).then(() => {
    onDeleteSuccess && onDeleteSuccess(entity);
    try {
      if (callbacks == null ? void 0 : callbacks.onDelete) {
        callbacks.onDelete(entityDeleteProps);
      }
      return true;
    } catch (e2) {
      if (onDeleteSuccessHookError) onDeleteSuccessHookError(entity, e2);
      return false;
    }
  }).catch((e2) => {
    if (onDeleteFailure) onDeleteFailure(entity, e2);
    return false;
  });
}
function resolveNavigationFrom({
  path,
  context
}) {
  const dataSource = context.dataSource;
  const navigation = context.navigation;
  if (!navigation) {
    throw Error("Calling resolveNavigationFrom, but main navigation has not yet been initialised");
  }
  const navigationEntries = getNavigationEntriesFromPath({
    path,
    collections: navigation.collections ?? []
  });
  const resultPromises = navigationEntries.map((entry) => {
    if (entry.type === "collection") {
      return Promise.resolve(entry);
    } else if (entry.type === "entity") {
      const collection = navigation.getCollection(entry.path);
      if (!collection) {
        throw Error(`No collection defined in the navigation for the entity with path ${entry.path}`);
      }
      return dataSource.fetchEntity({
        path: entry.path,
        entityId: entry.entityId,
        collection
      }).then((entity) => {
        if (!entity) return void 0;
        return {
          ...entry,
          entity
        };
      });
    } else if (entry.type === "custom_view") {
      return Promise.resolve(entry);
    } else {
      throw Error("Unmapped element in useEntitiesFromPath");
    }
  }).filter((v) => Boolean(v));
  return Promise.all(resultPromises);
}
function useResolvedNavigationFrom(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(9);
  const {
    path
  } = t0;
  const context = useFireCMSContext();
  const [data, setData] = (0, import_react14.useState)();
  const [dataLoading, setDataLoading] = (0, import_react14.useState)(false);
  const [dataLoadingError, setDataLoadingError] = (0, import_react14.useState)();
  let t1;
  let t2;
  if ($[0] !== context || $[1] !== path) {
    t1 = () => {
      const navigation = context.navigation;
      if (navigation) {
        setDataLoading(true);
        setDataLoadingError(void 0);
        resolveNavigationFrom({
          path,
          context
        }).then(setData).catch((e2) => setDataLoadingError(e2)).finally(() => setDataLoading(false));
      }
    };
    t2 = [path, context];
    $[0] = context;
    $[1] = path;
    $[2] = t1;
    $[3] = t2;
  } else {
    t1 = $[2];
    t2 = $[3];
  }
  (0, import_react14.useEffect)(t1, t2);
  if (!context.navigation) {
    let t32;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = {
        dataLoading: true
      };
      $[4] = t32;
    } else {
      t32 = $[4];
    }
    return t32;
  }
  let t3;
  if ($[5] !== data || $[6] !== dataLoading || $[7] !== dataLoadingError) {
    t3 = {
      data,
      dataLoading,
      dataLoadingError
    };
    $[5] = data;
    $[6] = dataLoading;
    $[7] = dataLoadingError;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  return t3;
}
var useModeController = () => {
  return (0, import_react14.useContext)(ModeControllerContext);
};
var useClipboard = (options2) => {
  const {
    onSuccess,
    onError,
    disableClipboardAPI = false,
    copiedDuration
  } = options2 || {};
  const ref2 = (0, import_react14.useRef)(null);
  const [isCoppied, setIsCoppied] = (0, import_react14.useState)(false);
  const [clipboard, setClipbaord] = (0, import_react14.useState)("");
  (0, import_react14.useEffect)(() => {
    if (copiedDuration) setTimeout(() => setIsCoppied(false), copiedDuration);
  }, [isCoppied]);
  const isSupported = () => navigator.clipboard !== void 0;
  const handleError = (0, import_react14.useCallback)((error2) => {
    if (onError) onError(error2);
    else throw new Error(error2);
  }, [onError]);
  const handleSuccess = (0, import_react14.useCallback)((text) => {
    if (onSuccess) onSuccess(text);
    setIsCoppied(true);
    setClipbaord(text);
  }, [onSuccess]);
  const copyToClipboard = (0, import_react14.useCallback)((text_0) => {
    navigator.clipboard.writeText(text_0).then(() => handleSuccess(text_0)).catch((err) => {
      handleError(err);
      setIsCoppied(false);
    });
  }, [handleError, handleSuccess]);
  const clearClipboard = () => {
    if (isSupported()) {
      navigator.clipboard.writeText("");
    }
  };
  const copy2 = (text_1) => action("copy", typeof text_1 === "object" ? void 0 : text_1);
  const cut2 = () => action("cut");
  const action = (0, import_react14.useCallback)((operation = "copy", text_2) => {
    const element = ref2.current;
    const isInput = element && (element.tagName === "INPUT" || element.tagName === "TEXTAREA");
    const input = ref2.current;
    if (isSupported() && !disableClipboardAPI) {
      if (text_2) {
        copyToClipboard(text_2);
      } else if (element) {
        if (isInput) {
          copyToClipboard(input.value);
          if (operation === "cut") {
            input.value = "";
          }
        } else {
          copyToClipboard(element.innerText);
        }
      } else {
        handleError("Both the ref & text were undefined");
      }
    }
  }, [disableClipboardAPI, copyToClipboard, handleError]);
  return {
    ref: ref2,
    isCoppied,
    clipboard,
    clearClipboard,
    isSupported,
    copy: copy2,
    cut: cut2
  };
};
var breakpoints2 = {
  xs: 0,
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536,
  "3xl": 1920
};
var isLargeLayoutGlobal = checkLargeLayout("lg");
var listeners = [];
var notifyListeners = () => {
  listeners.forEach((listener) => listener(isLargeLayoutGlobal));
};
if (typeof window !== "undefined") window.addEventListener("resize", () => {
  const newIsLargeLayout = checkLargeLayout("lg");
  if (newIsLargeLayout !== isLargeLayoutGlobal) {
    isLargeLayoutGlobal = newIsLargeLayout;
    notifyListeners();
  }
});
var useLargeLayout = () => {
  const $ = (0, import_react_compiler_runtime3.c)(2);
  const [isLargeLayout, setIsLargeLayout] = (0, import_react14.useState)(isLargeLayoutGlobal);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => {
      const listener = (newIsLargeLayout) => {
        setIsLargeLayout(newIsLargeLayout);
      };
      listeners.push(listener);
      setIsLargeLayout(isLargeLayoutGlobal);
      return () => {
        const index2 = listeners.indexOf(listener);
        if (index2 > -1) {
          listeners.splice(index2, 1);
        }
      };
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  (0, import_react14.useEffect)(t0, t1);
  return isLargeLayout;
};
function checkLargeLayout(breakpoint = "lg") {
  if (typeof window === "undefined") return false;
  return window.matchMedia(`(min-width: ${breakpoints2[breakpoint] + 1}px)`).matches;
}
function ErrorTooltip(props) {
  const $ = (0, import_react_compiler_runtime3.c)(2);
  let t0;
  if ($[0] !== props) {
    t0 = (0, import_jsx_runtime2.jsx)(Tooltip, { ...props, tooltipClassName: "!text-red-500 bg-red-50", children: props.children });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function ErrorView(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(11);
  const {
    title,
    error: error2,
    tooltip
  } = t0;
  const component = error2 instanceof Error ? error2.message : error2;
  console.warn("ErrorView", error2);
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (0, import_jsx_runtime2.jsx)(ErrorIcon, { className: "mx-2", size: "small", color: "error" });
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== title) {
    t2 = title && (0, import_jsx_runtime2.jsx)(Typography, { variant: "body2", className: "font-medium", children: title });
    $[1] = title;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== component) {
    t3 = (0, import_jsx_runtime2.jsx)(Typography, { variant: "body2", children: component });
    $[3] = component;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== t2 || $[6] !== t3) {
    t4 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center m-2", children: [
      t1,
      (0, import_jsx_runtime2.jsxs)("div", { className: "pl-4", children: [
        t2,
        t3
      ] })
    ] });
    $[5] = t2;
    $[6] = t3;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const body = t4;
  if (tooltip) {
    let t5;
    if ($[8] !== body || $[9] !== tooltip) {
      t5 = (0, import_jsx_runtime2.jsx)(ErrorTooltip, { title: tooltip, children: body });
      $[8] = body;
      $[9] = tooltip;
      $[10] = t5;
    } else {
      t5 = $[10];
    }
    return t5;
  }
  return body;
}
function EmptyValue() {
  const $ = (0, import_react_compiler_runtime3.c)(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (0, import_jsx_runtime2.jsx)("div", { className: "rounded-full bg-surface-200 bg-opacity-30 dark:bg-opacity-20 w-5 h-2 inline-block" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
var SMALL_THUMBNAIL = 40;
var MEDIUM_THUMBNAIL = 100;
var LARGE_THUMBNAIL = 200;
function getThumbnailMeasure(size2) {
  if (size2 === "small") return SMALL_THUMBNAIL;
  else if (size2 === "medium") return MEDIUM_THUMBNAIL;
  else if (size2 === "large") return LARGE_THUMBNAIL;
  else throw Error("Thumbnail size not mapped");
}
function getPreviewSizeFrom(size2) {
  switch (size2) {
    case "xs":
    case "s":
      return "small";
    case "m":
      return "medium";
    case "l":
    case "xl":
      return "large";
    default:
      throw Error("Missing mapping value in getPreviewSizeFrom: " + size2);
  }
}
function ImagePreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(26);
  const {
    size: size2,
    url
  } = t0;
  let t1;
  let t2;
  if ($[0] !== size2) {
    t2 = getThumbnailMeasure(size2);
    $[0] = size2;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  t1 = t2;
  const imageSize = t1;
  if (size2 === "small") {
    const t32 = "tiny_image_preview_" + url;
    let t42;
    if ($[2] !== imageSize) {
      t42 = {
        position: "relative",
        objectFit: "cover",
        width: imageSize,
        height: imageSize,
        maxHeight: "100%"
      };
      $[2] = imageSize;
      $[3] = t42;
    } else {
      t42 = $[3];
    }
    let t52;
    if ($[4] !== t32 || $[5] !== t42 || $[6] !== url) {
      t52 = (0, import_jsx_runtime2.jsx)("img", { src: url, className: "rounded-md", style: t42 }, t32);
      $[4] = t32;
      $[5] = t42;
      $[6] = url;
      $[7] = t52;
    } else {
      t52 = $[7];
    }
    return t52;
  }
  let t3;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = {
      maxWidth: "100%",
      maxHeight: "100%"
    };
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const imageStyle = t3;
  let t4;
  if ($[9] !== imageSize) {
    t4 = {
      width: imageSize,
      height: imageSize
    };
    $[9] = imageSize;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  const t5 = "image_preview_" + url;
  let t6;
  if ($[11] !== url) {
    t6 = (0, import_jsx_runtime2.jsx)("img", { src: url, className: "rounded-md", style: imageStyle });
    $[11] = url;
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  let t7;
  if ($[13] !== url) {
    t7 = navigator && (0, import_jsx_runtime2.jsx)(Tooltip, { asChild: true, title: "Copy url to clipboard", side: "bottom", children: (0, import_jsx_runtime2.jsx)(IconButton, { variant: "filled", size: "small", onClick: (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      return navigator.clipboard.writeText(url);
    }, children: (0, import_jsx_runtime2.jsx)(ContentCopyIcon, { className: "text-surface-700 dark:text-surface-300", size: "smallest" }) }) });
    $[13] = url;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime2.jsx)(OpenInNewIcon, { className: "text-surface-700 dark:text-surface-300", size: "smallest" });
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] !== url) {
    t9 = (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Open image in new tab", side: "bottom", children: (0, import_jsx_runtime2.jsx)(IconButton, { className: "invisible group-hover:visible", variant: "filled", component: "a", href: url, rel: "noopener noreferrer", target: "_blank", size: "small", onClick: _temp$q, children: t8 }) });
    $[16] = url;
    $[17] = t9;
  } else {
    t9 = $[17];
  }
  let t10;
  if ($[18] !== t7 || $[19] !== t9) {
    t10 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-row gap-2 absolute bottom-[-4px] right-[-4px] invisible group-hover:visible", children: [
      t7,
      t9
    ] });
    $[18] = t7;
    $[19] = t9;
    $[20] = t10;
  } else {
    t10 = $[20];
  }
  let t11;
  if ($[21] !== t10 || $[22] !== t4 || $[23] !== t5 || $[24] !== t6) {
    t11 = (0, import_jsx_runtime2.jsxs)("div", { className: "relative flex items-center justify-center max-w-full max-h-full group", style: t4, children: [
      t6,
      t10
    ] }, t5);
    $[21] = t10;
    $[22] = t4;
    $[23] = t5;
    $[24] = t6;
    $[25] = t11;
  } else {
    t11 = $[25];
  }
  return t11;
}
function _temp$q(e_0) {
  return e_0.stopPropagation();
}
function UrlComponentPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(31);
  const {
    url,
    previewType,
    size: size2,
    hint,
    interactive: t1
  } = t0;
  const interactive = t1 === void 0 ? true : t1;
  if (!previewType) {
    if (!url || !url.trim()) {
      let t22;
      if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
        t22 = (0, import_jsx_runtime2.jsx)(EmptyValue, {});
        $[0] = t22;
      } else {
        t22 = $[0];
      }
      return t22;
    }
    let t2;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = (0, import_jsx_runtime2.jsx)(OpenInNewIcon, { size: "small" });
      $[1] = t2;
    } else {
      t2 = $[1];
    }
    let t3;
    if ($[2] !== url) {
      t3 = (0, import_jsx_runtime2.jsxs)("a", { className: "flex gap-4 break-words items-center font-medium text-primary visited:text-primary dark:visited:text-primary dark:text-primary", href: url, rel: "noopener noreferrer", onMouseDown: _temp$p, target: "_blank", children: [
        t2,
        url
      ] });
      $[2] = url;
      $[3] = t3;
    } else {
      t3 = $[3];
    }
    return t3;
  }
  if (previewType === "image") {
    let t2;
    if ($[4] !== size2 || $[5] !== url) {
      t2 = (0, import_jsx_runtime2.jsx)(ImagePreview, { url, size: size2 });
      $[4] = size2;
      $[5] = url;
      $[6] = t2;
    } else {
      t2 = $[6];
    }
    return t2;
  } else {
    if (previewType === "audio") {
      let t2;
      if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
        t2 = (0, import_jsx_runtime2.jsx)("code", { children: "audio" });
        $[7] = t2;
      } else {
        t2 = $[7];
      }
      let t3;
      if ($[8] !== url) {
        t3 = (0, import_jsx_runtime2.jsxs)("audio", { controls: true, className: "max-w-100%", src: url, children: [
          "Your browser does not support the",
          t2,
          " element."
        ] });
        $[8] = url;
        $[9] = t3;
      } else {
        t3 = $[9];
      }
      return t3;
    } else {
      if (previewType === "video") {
        let t2;
        if ($[10] !== interactive || $[11] !== size2 || $[12] !== url) {
          t2 = (0, import_jsx_runtime2.jsx)(VideoPreview, { size: size2, src: url, interactive });
          $[10] = interactive;
          $[11] = size2;
          $[12] = url;
          $[13] = t2;
        } else {
          t2 = $[13];
        }
        return t2;
      } else {
        let t2;
        if ($[14] !== size2) {
          t2 = getThumbnailMeasure(size2);
          $[14] = size2;
          $[15] = t2;
        } else {
          t2 = $[15];
        }
        let t3;
        if ($[16] !== size2) {
          t3 = getThumbnailMeasure(size2);
          $[16] = size2;
          $[17] = t3;
        } else {
          t3 = $[17];
        }
        let t4;
        if ($[18] !== t2 || $[19] !== t3) {
          t4 = {
            width: t2,
            height: t3
          };
          $[18] = t2;
          $[19] = t3;
          $[20] = t4;
        } else {
          t4 = $[20];
        }
        let t5;
        if ($[21] === Symbol.for("react.memo_cache_sentinel")) {
          t5 = (0, import_jsx_runtime2.jsx)(DescriptionIcon, { className: "text-surface-700 dark:text-surface-300" });
          $[21] = t5;
        } else {
          t5 = $[21];
        }
        let t6;
        if ($[22] !== hint) {
          t6 = hint && (0, import_jsx_runtime2.jsx)(Typography, { className: "max-w-full truncate rtl text-left", variant: "caption", children: hint });
          $[22] = hint;
          $[23] = t6;
        } else {
          t6 = $[23];
        }
        let t7;
        if ($[24] !== t4 || $[25] !== t6 || $[26] !== url) {
          t7 = (0, import_jsx_runtime2.jsxs)("a", { href: url, rel: "noopener noreferrer", target: "_blank", onClick: _temp2$c, className: "flex flex-col items-center justify-center", style: t4, children: [
            t5,
            t6
          ] });
          $[24] = t4;
          $[25] = t6;
          $[26] = url;
          $[27] = t7;
        } else {
          t7 = $[27];
        }
        let t8;
        if ($[28] !== hint || $[29] !== t7) {
          t8 = (0, import_jsx_runtime2.jsx)(Tooltip, { title: hint, children: t7 });
          $[28] = hint;
          $[29] = t7;
          $[30] = t8;
        } else {
          t8 = $[30];
        }
        return t8;
      }
    }
  }
}
function _temp2$c(e_0) {
  return e_0.stopPropagation();
}
function _temp$p(e2) {
  e2.preventDefault();
}
function VideoPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(13);
  const {
    size: size2,
    src,
    interactive
  } = t0;
  let t1;
  if (size2 === "small") {
    t1 = "140px";
  } else {
    if (size2 === "medium") {
      t1 = "240px";
    } else {
      if (size2 === "large") {
        t1 = "100%";
      } else {
        throw new Error("Invalid size");
      }
    }
  }
  const imageSize = t1;
  let t2;
  if ($[0] !== interactive) {
    t2 = {
      controls: interactive
    };
    $[0] = interactive;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const videoProps = t2;
  let t3;
  if ($[2] !== imageSize) {
    t3 = {
      position: "relative",
      objectFit: "cover",
      width: imageSize,
      minWidth: "140px",
      maxHeight: "100%"
    };
    $[2] = imageSize;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const t4 = !interactive;
  let t5;
  if ($[4] !== t4) {
    t5 = cls("max-w-100% rounded", {
      "pointer-events-none": t4
    });
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== src) {
    t6 = (0, import_jsx_runtime2.jsx)("source", { src });
    $[6] = src;
    $[7] = t6;
  } else {
    t6 = $[7];
  }
  let t7;
  if ($[8] !== t3 || $[9] !== t5 || $[10] !== t6 || $[11] !== videoProps) {
    t7 = (0, import_jsx_runtime2.jsx)("video", { style: t3, ...videoProps, className: t5, children: t6 });
    $[8] = t3;
    $[9] = t5;
    $[10] = t6;
    $[11] = videoProps;
    $[12] = t7;
  } else {
    t7 = $[12];
  }
  return t7;
}
function SkeletonPropertyComponent(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(27);
  const {
    property,
    size: size2
  } = t0;
  if (!property) {
    console.error("No property assigned for skeleton component", property, size2);
  }
  let content;
  if (property.dataType === "string") {
    const stringProperty = property;
    if (stringProperty.url) {
      let t1;
      if ($[0] !== size2 || $[1] !== stringProperty) {
        t1 = renderUrlComponent(stringProperty, size2);
        $[0] = size2;
        $[1] = stringProperty;
        $[2] = t1;
      } else {
        t1 = $[2];
      }
      content = t1;
    } else {
      if (stringProperty.storage) {
        let t1;
        if ($[3] !== size2) {
          t1 = renderSkeletonImageThumbnail(size2);
          $[3] = size2;
          $[4] = t1;
        } else {
          t1 = $[4];
        }
        content = t1;
      } else {
        let t1;
        if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
          t1 = renderSkeletonText();
          $[5] = t1;
        } else {
          t1 = $[5];
        }
        content = t1;
      }
    }
  } else {
    if (property.dataType === "array") {
      const arrayProperty = property;
      if (arrayProperty.of) {
        if (Array.isArray(arrayProperty.of)) {
          let t1;
          if ($[6] !== arrayProperty.of) {
            t1 = arrayProperty.of.map(_temp$o);
            $[6] = arrayProperty.of;
            $[7] = t1;
          } else {
            t1 = $[7];
          }
          let t2;
          if ($[8] !== t1) {
            t2 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
              t1,
              " "
            ] });
            $[8] = t1;
            $[9] = t2;
          } else {
            t2 = $[9];
          }
          content = t2;
        } else {
          if (arrayProperty.of.dataType === "map" && arrayProperty.of.properties) {
            let t1;
            if ($[10] !== arrayProperty.of.previewProperties || $[11] !== arrayProperty.of.properties || $[12] !== size2) {
              t1 = renderArrayOfMaps(arrayProperty.of.properties, size2, arrayProperty.of.previewProperties);
              $[10] = arrayProperty.of.previewProperties;
              $[11] = arrayProperty.of.properties;
              $[12] = size2;
              $[13] = t1;
            } else {
              t1 = $[13];
            }
            content = t1;
          } else {
            if (arrayProperty.of.dataType === "string") {
              if (arrayProperty.of.enumValues) {
                let t1;
                if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
                  t1 = renderArrayEnumTableCell();
                  $[14] = t1;
                } else {
                  t1 = $[14];
                }
                content = t1;
              } else {
                if (arrayProperty.of.storage) {
                  let t1;
                  if ($[15] !== arrayProperty.of) {
                    t1 = renderGenericArrayCell(arrayProperty.of);
                    $[15] = arrayProperty.of;
                    $[16] = t1;
                  } else {
                    t1 = $[16];
                  }
                  content = t1;
                } else {
                  let t1;
                  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
                    t1 = renderArrayOfStrings();
                    $[17] = t1;
                  } else {
                    t1 = $[17];
                  }
                  content = t1;
                }
              }
            } else {
              let t1;
              if ($[18] !== arrayProperty.of) {
                t1 = renderGenericArrayCell(arrayProperty.of);
                $[18] = arrayProperty.of;
                $[19] = t1;
              } else {
                t1 = $[19];
              }
              content = t1;
            }
          }
        }
      }
    } else {
      if (property.dataType === "map") {
        const t1 = property;
        let t2;
        if ($[20] !== size2 || $[21] !== t1) {
          t2 = renderMap(t1, size2);
          $[20] = size2;
          $[21] = t1;
          $[22] = t2;
        } else {
          t2 = $[22];
        }
        content = t2;
      } else {
        if (property.dataType === "date") {
          let t1;
          if ($[23] === Symbol.for("react.memo_cache_sentinel")) {
            t1 = renderSkeletonText();
            $[23] = t1;
          } else {
            t1 = $[23];
          }
          content = t1;
        } else {
          if (property.dataType === "reference") {
            let t1;
            if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
              t1 = renderReference();
              $[24] = t1;
            } else {
              t1 = $[24];
            }
            content = t1;
          } else {
            if (property.dataType === "boolean") {
              let t1;
              if ($[25] === Symbol.for("react.memo_cache_sentinel")) {
                t1 = renderSkeletonText();
                $[25] = t1;
              } else {
                t1 = $[25];
              }
              content = t1;
            } else {
              let t1;
              if ($[26] === Symbol.for("react.memo_cache_sentinel")) {
                t1 = renderSkeletonText();
                $[26] = t1;
              } else {
                t1 = $[26];
              }
              content = t1;
            }
          }
        }
      }
    }
  }
  return content || null;
}
function _temp$o(p3, i2) {
  return renderGenericArrayCell(p3, i2);
}
function renderMap(property, size2) {
  if (!property.properties) return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  let mapPropertyKeys;
  if (size2 === "large") {
    mapPropertyKeys = Object.keys(property.properties);
  } else {
    mapPropertyKeys = property.previewProperties || Object.keys(property.properties);
    if (size2 === "medium") mapPropertyKeys = mapPropertyKeys.slice(0, 3);
    else if (size2 === "small") mapPropertyKeys = mapPropertyKeys.slice(0, 1);
  }
  if (size2 !== "large") return (0, import_jsx_runtime2.jsx)("div", { className: "w-full flex flex-col space-y-4", children: mapPropertyKeys.map((key, index2) => (0, import_jsx_runtime2.jsx)("div", { children: property.properties && property.properties[key] && (0, import_jsx_runtime2.jsx)(SkeletonPropertyComponent, { property: property.properties[key], size: "medium" }) }, `map_${key}`)) });
  return (0, import_jsx_runtime2.jsx)("table", { className: "table-auto", children: (0, import_jsx_runtime2.jsx)("tbody", { children: mapPropertyKeys && mapPropertyKeys.map((key, index2) => {
    return (0, import_jsx_runtime2.jsxs)("tr", { className: "border-b last:border-b-0", children: [
      (0, import_jsx_runtime2.jsx)("th", { className: "align-top", style: {
        width: "30%"
      }, children: (0, import_jsx_runtime2.jsx)("p", { className: "text-xs text-secondary", children: property.properties[key].name }) }, `table-cell-title--${key}`),
      (0, import_jsx_runtime2.jsx)("th", { style: {
        width: "70%"
      }, children: property.properties && property.properties[key] && (0, import_jsx_runtime2.jsx)(SkeletonPropertyComponent, { property: property.properties[key], size: "medium" }) }, `table-cell-${key}`)
    ] }, `map_preview_table__${index2}`);
  }) }) });
}
function renderArrayOfMaps(properties, size2, previewProperties) {
  let tableProperties = previewProperties;
  if (!tableProperties || !tableProperties.length) {
    tableProperties = Object.keys(properties);
    if (size2) tableProperties = tableProperties.slice(0, 3);
  }
  return (0, import_jsx_runtime2.jsx)("table", { className: "table-auto", children: (0, import_jsx_runtime2.jsx)("tbody", { children: [0, 1, 2].map((value, index2) => {
    return (0, import_jsx_runtime2.jsx)("tr", { children: tableProperties && tableProperties.map((key) => (0, import_jsx_runtime2.jsx)("th", { children: (0, import_jsx_runtime2.jsx)(SkeletonPropertyComponent, { property: properties[key], size: "medium" }) }, `table-cell-${key}`)) }, `table_${value}_${index2}`);
  }) }) });
}
function renderArrayOfStrings() {
  return (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2", children: [0, 1].map((value, index2) => renderSkeletonText(index2)) });
}
function renderArrayEnumTableCell() {
  return (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2", children: [0, 1].map((value, index2) => (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: renderSkeletonText(index2) })) });
}
function renderGenericArrayCell(property, index2 = 0) {
  return (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2", children: [0, 1].map((value, index22) => (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsx)(SkeletonPropertyComponent, { property, size: "medium" }, `i_${index22}`) })) }, "array_index_" + index2);
}
function renderSkeletonImageThumbnail(size2) {
  const imageSize = size2 === "small" ? 40 : size2 === "medium" ? 100 : 200;
  return (0, import_jsx_runtime2.jsx)(Skeleton, { width: imageSize, height: imageSize });
}
function renderReference() {
  return (0, import_jsx_runtime2.jsx)(Skeleton, { width: 200, height: 100 });
}
function renderUrlComponent(property, size2 = "large") {
  if (typeof property.url === "boolean") {
    return (0, import_jsx_runtime2.jsxs)("div", { style: {
      display: "flex"
    }, children: [
      renderSkeletonIcon(),
      renderSkeletonText()
    ] });
  }
  return renderUrlFile(size2);
}
function renderUrlFile(size2) {
  return (0, import_jsx_runtime2.jsx)("div", { className: `w-${getThumbnailMeasure(size2)} h-${getThumbnailMeasure(size2)}`, children: renderSkeletonIcon() });
}
function renderSkeletonText(index2, width = 120) {
  return (0, import_jsx_runtime2.jsx)(Skeleton, { width }, `skeleton_${index2}`);
}
function renderSkeletonCaptionText(index2) {
  return (0, import_jsx_runtime2.jsx)(Skeleton, { height: 20 });
}
function renderSkeletonIcon() {
  return (0, import_jsx_runtime2.jsx)(Skeleton, { width: 24, height: 24 });
}
var StorageThumbnail = import_react14.default.memo(StorageThumbnailInternal, areEqual$1);
function areEqual$1(prevProps, nextProps) {
  return prevProps.size === nextProps.size && prevProps.storagePathOrDownloadUrl === nextProps.storagePathOrDownloadUrl && prevProps.storeUrl === nextProps.storeUrl && prevProps.interactive === nextProps.interactive;
}
var URL_CACHE = {};
function StorageThumbnailInternal(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(12);
  const {
    interactive,
    storagePathOrDownloadUrl,
    size: size2
  } = t0;
  const [, setError] = import_react14.default.useState(void 0);
  const storage = useStorageSource();
  const [downloadConfig, setDownloadConfig] = import_react14.default.useState(URL_CACHE[storagePathOrDownloadUrl]);
  let t1;
  if ($[0] !== storage || $[1] !== storagePathOrDownloadUrl) {
    t1 = () => {
      if (!storagePathOrDownloadUrl) {
        return;
      }
      let unmounted;
      unmounted = false;
      storage.getDownloadURL(storagePathOrDownloadUrl).then(function(downloadConfig_0) {
        if (!unmounted) {
          setDownloadConfig(downloadConfig_0);
          URL_CACHE[storagePathOrDownloadUrl] = downloadConfig_0;
        }
      }).catch(setError);
      return () => {
        unmounted = true;
      };
    };
    $[0] = storage;
    $[1] = storagePathOrDownloadUrl;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== storagePathOrDownloadUrl) {
    t2 = [storagePathOrDownloadUrl];
    $[3] = storagePathOrDownloadUrl;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  (0, import_react14.useEffect)(t1, t2);
  if (!storagePathOrDownloadUrl) {
    return null;
  }
  const filetype = (downloadConfig == null ? void 0 : downloadConfig.metadata) ? getFiletype(downloadConfig == null ? void 0 : downloadConfig.metadata.contentType) : void 0;
  const previewType = (filetype == null ? void 0 : filetype.startsWith("image")) ? "image" : (filetype == null ? void 0 : filetype.startsWith("video")) ? "video" : (filetype == null ? void 0 : filetype.startsWith("audio")) ? "audio" : "file";
  if (downloadConfig == null ? void 0 : downloadConfig.fileNotFound) {
    let t32;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = (0, import_jsx_runtime2.jsx)(ErrorView, { error: "File not found" });
      $[5] = t32;
    } else {
      t32 = $[5];
    }
    return t32;
  }
  let t3;
  if ($[6] !== downloadConfig || $[7] !== interactive || $[8] !== previewType || $[9] !== size2 || $[10] !== storagePathOrDownloadUrl) {
    t3 = (downloadConfig == null ? void 0 : downloadConfig.url) ? (0, import_jsx_runtime2.jsx)(UrlComponentPreview, { previewType, url: downloadConfig.url, interactive, size: size2, hint: storagePathOrDownloadUrl }) : renderSkeletonImageThumbnail(size2);
    $[6] = downloadConfig;
    $[7] = interactive;
    $[8] = previewType;
    $[9] = size2;
    $[10] = storagePathOrDownloadUrl;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
}
function getFiletype(input) {
  if (input.startsWith("image")) return "image/*";
  else if (input.startsWith("video")) return "video/*";
  else if (input.startsWith("audio")) return "audio/*";
  else if (input.startsWith("application")) return "application/*";
  else if (input.startsWith("text")) return "text/*";
  else if (input.startsWith("font")) return "font/*";
  else return input;
}
function EnumValuesChip(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(11);
  const {
    enumValues,
    enumKey,
    size: size2,
    className,
    children
  } = t0;
  if (!enumValues) {
    return null;
  }
  let label;
  let t1;
  if ($[0] !== enumKey || $[1] !== enumValues) {
    const enumValuesConfig = enumToObjectEntries(enumValues);
    const enumValue = enumKey !== void 0 ? getLabelOrConfigFrom(enumValuesConfig, enumKey) : void 0;
    label = buildEnumLabel(enumValue);
    t1 = getColorScheme(enumValuesConfig, enumKey);
    $[0] = enumKey;
    $[1] = enumValues;
    $[2] = label;
    $[3] = t1;
  } else {
    label = $[2];
    t1 = $[3];
  }
  const colorScheme = t1;
  const t2 = !label;
  const t3 = !children && (label !== void 0 ? label : String(enumKey));
  let t4;
  if ($[4] !== children || $[5] !== className || $[6] !== colorScheme || $[7] !== size2 || $[8] !== t2 || $[9] !== t3) {
    t4 = (0, import_jsx_runtime2.jsxs)(Chip, { className, colorScheme, error: t2, outlined: false, size: size2, children: [
      children,
      t3
    ] });
    $[4] = children;
    $[5] = className;
    $[6] = colorScheme;
    $[7] = size2;
    $[8] = t2;
    $[9] = t3;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  return t4;
}
function StringPropertyPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(20);
  const {
    propertyKey,
    value,
    property,
    size: size2
  } = t0;
  if (property.enumValues) {
    const enumKey = value;
    let t1;
    if ($[0] !== property) {
      t1 = resolvePropertyEnum(property);
      $[0] = property;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    const resolvedProperty = t1;
    let t2;
    if ($[2] !== enumKey || $[3] !== resolvedProperty.enumValues || $[4] !== size2) {
      t2 = (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey, enumValues: resolvedProperty.enumValues, size: size2 });
      $[2] = enumKey;
      $[3] = resolvedProperty.enumValues;
      $[4] = size2;
      $[5] = t2;
    } else {
      t2 = $[5];
    }
    return t2;
  } else {
    if (property.previewAsTag) {
      const t1 = propertyKey ?? "";
      let t2;
      if ($[6] !== t1) {
        t2 = getColorSchemeForSeed(t1);
        $[6] = t1;
        $[7] = t2;
      } else {
        t2 = $[7];
      }
      const colorScheme = t2;
      let t3;
      if ($[8] !== colorScheme || $[9] !== size2 || $[10] !== value) {
        t3 = (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(Chip, { colorScheme, size: size2, children: value }) });
        $[8] = colorScheme;
        $[9] = size2;
        $[10] = value;
        $[11] = t3;
      } else {
        t3 = $[11];
      }
      return t3;
    } else {
      if (property.url) {
        const t1 = typeof property.url === "string" ? property.url : void 0;
        let t2;
        if ($[12] !== size2 || $[13] !== t1 || $[14] !== value) {
          t2 = (0, import_jsx_runtime2.jsx)(UrlComponentPreview, { size: size2, url: value, previewType: t1 });
          $[12] = size2;
          $[13] = t1;
          $[14] = value;
          $[15] = t2;
        } else {
          t2 = $[15];
        }
        return t2;
      } else {
        if (!value) {
          let t12;
          if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
            t12 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
            $[16] = t12;
          } else {
            t12 = $[16];
          }
          return t12;
        }
        let t1;
        if ($[17] !== size2 || $[18] !== value) {
          const lines = value.split("\n");
          t1 = value && value.includes("\n") ? (0, import_jsx_runtime2.jsx)("div", { className: cls("overflow-x-scroll", size2 === "small" ? "text-sm" : ""), children: lines.map((str, index2) => (0, import_jsx_runtime2.jsxs)(import_react14.default.Fragment, { children: [
            (0, import_jsx_runtime2.jsx)("span", { children: str }),
            index2 !== lines.length - 1 && (0, import_jsx_runtime2.jsx)("br", {})
          ] }, `string_preview_${index2}`)) }) : size2 === "small" ? (0, import_jsx_runtime2.jsx)("span", { className: "text-sm", children: value }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: value });
          $[17] = size2;
          $[18] = value;
          $[19] = t1;
        } else {
          t1 = $[19];
        }
        return t1;
      }
    }
  }
}
function ArrayPropertyPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(13);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== authController || $[1] !== customizationController.propertyConfigs || $[2] !== inputProperty || $[3] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs,
      authController
    });
    $[0] = authController;
    $[1] = customizationController.propertyConfigs;
    $[2] = inputProperty;
    $[3] = propertyKey;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const property = t1;
  if (!property.of) {
    throw Error(`You need to specify an 'of' prop (or specify a custom field) in your array property ${propertyKey}`);
  }
  if (property.dataType !== "array") {
    throw Error("Picked wrong preview component ArrayPreview");
  }
  const values = value;
  if (!values) {
    return null;
  }
  const childSize = size2 === "medium" ? "medium" : "small";
  let t2;
  if ($[5] !== childSize || $[6] !== property.of || $[7] !== property.resolvedProperties || $[8] !== propertyKey || $[9] !== values) {
    t2 = values && values.map((value_0, index2) => {
      const of = property.resolvedProperties[index2] ?? property.resolvedProperties[index2] ?? (Array.isArray(property.of) ? property.of[index2] : property.of);
      return of ? (0, import_jsx_runtime2.jsx)(import_react14.default.Fragment, { children: (0, import_jsx_runtime2.jsx)("div", { className: cls(defaultBorderMixin, "m-1 border-b last:border-b-0"), children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey, value: value_0, property: of, size: childSize }) }) }) }, "preview_array_" + index2) : null;
    });
    $[5] = childSize;
    $[6] = property.of;
    $[7] = property.resolvedProperties;
    $[8] = propertyKey;
    $[9] = values;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  let t3;
  if ($[11] !== t2) {
    t3 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2", children: t2 });
    $[11] = t2;
    $[12] = t3;
  } else {
    t3 = $[12];
  }
  return t3;
}
function EntityPreview({
  actions,
  disabled,
  hover,
  collection: collectionProp,
  previewProperties,
  onClick,
  size: size2,
  includeId = true,
  includeEntityLink = true,
  entity
}) {
  const authController = useAuthController();
  const analyticsController = useAnalyticsController();
  const sideEntityController = useSideEntityController();
  const customizationController = useCustomizationController();
  const navigationController = useNavigationController();
  const collection = collectionProp ?? navigationController.getCollection(entity.path);
  if (!collection) {
    throw Error(`Couldn't find the corresponding collection view for the path: ${entity.path}`);
  }
  const resolvedCollection = React8.useMemo(() => resolveCollection({
    collection,
    path: entity.path,
    values: entity.values,
    propertyConfigs: customizationController.propertyConfigs,
    authController
  }), [collection]);
  const listProperties = (0, import_react14.useMemo)(() => getEntityPreviewKeys(authController, resolvedCollection, customizationController.propertyConfigs, previewProperties, size2 === "medium" || size2 === "large" ? 3 : 1), [previewProperties, resolvedCollection, size2]);
  const titleProperty = getEntityTitlePropertyKey(resolvedCollection, customizationController.propertyConfigs);
  const imagePropertyKey = getEntityImagePreviewPropertyKey(resolvedCollection);
  const imageProperty = imagePropertyKey ? resolvedCollection.properties[imagePropertyKey] : void 0;
  const usedImageProperty = imageProperty && "of" in imageProperty ? imageProperty.of : imageProperty;
  const restProperties = listProperties.filter((p3) => p3 !== titleProperty && p3 !== imagePropertyKey);
  const imageValue = imagePropertyKey ? getValueInPath(entity.values, imagePropertyKey) : void 0;
  const usedImageValue = imageProperty !== void 0 ? "of" in imageProperty ? (imageValue ?? []).length > 0 ? imageValue[0] : void 0 : imageValue : void 0;
  return (0, import_jsx_runtime2.jsxs)(EntityPreviewContainer, { onClick: disabled ? void 0 : onClick, hover: disabled ? void 0 : hover, size: size2, children: [
    (0, import_jsx_runtime2.jsxs)("div", { className: cls("flex w-10 h-10 ml-1 mr-2 shrink-0", size2 === "small" ? "my-0.5" : "m-2 self-start"), children: [
      usedImageProperty && usedImageValue && (0, import_jsx_runtime2.jsx)(PropertyPreview, { property: usedImageProperty, propertyKey: imagePropertyKey, size: "small", value: usedImageValue }),
      (!usedImageProperty || !usedImageValue) && (0, import_jsx_runtime2.jsx)(IconForView, { collectionOrView: collection, color: "primary", size: size2, className: "m-auto p-1" })
    ] }),
    (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-col grow-1 w-full m-1 shrink-1", style: {
      "maxWidth": "calc(100% - 96px)"
    }, children: [
      size2 !== "small" && includeId && (entity ? (0, import_jsx_runtime2.jsx)("div", { className: "block whitespace-nowrap overflow-hidden truncate", children: (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", color: "disabled", className: "font-mono", children: entity.id }) }) : (0, import_jsx_runtime2.jsx)(Skeleton, {})),
      titleProperty && (0, import_jsx_runtime2.jsx)("div", { className: "truncate my-0.5 text-sm font-medium", children: entity ? (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey: titleProperty, value: getValueInPath(entity.values, titleProperty), property: resolvedCollection.properties[titleProperty], size: "large" }) : (0, import_jsx_runtime2.jsx)(SkeletonPropertyComponent, { property: resolvedCollection.properties[titleProperty], size: "large" }) }),
      restProperties && restProperties.map((key) => {
        const childProperty = resolvedCollection.properties[key];
        if (!childProperty) return null;
        return (0, import_jsx_runtime2.jsx)("div", { className: cls("truncate", restProperties.length > 1 ? "my-0.5" : "my-0"), children: entity ? (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey: key, value: getValueInPath(entity.values, key), property: childProperty, size: "small" }) : (0, import_jsx_runtime2.jsx)(SkeletonPropertyComponent, { property: childProperty, size: "small" }) }, "ref_prev_" + key);
      })
    ] }),
    entity && includeEntityLink && (0, import_jsx_runtime2.jsx)(Tooltip, { title: `See details for ${entity.id}`, className: "shrink-0", children: (0, import_jsx_runtime2.jsx)(IconButton, { color: "inherit", size: "medium", className: size2 !== "small" ? "self-start" : "", onClick: (e2) => {
      var _a;
      e2.stopPropagation();
      (_a = analyticsController.onAnalyticsEvent) == null ? void 0 : _a.call(analyticsController, "entity_click_from_reference", {
        path: entity.path,
        entityId: entity.id
      });
      sideEntityController.open({
        entityId: entity.id,
        path: entity.path,
        collection,
        updateUrl: true
      });
    }, children: (0, import_jsx_runtime2.jsx)(KeyboardTabIcon, { size: "medium" }) }) }),
    actions
  ] });
}
var EntityPreviewContainer = React8.forwardRef((t0, ref2) => {
  const $ = (0, import_react_compiler_runtime3.c)(26);
  let children;
  let className;
  let hover;
  let onClick;
  let props;
  let size2;
  let style3;
  let t1;
  if ($[0] !== t0) {
    ({
      children,
      hover,
      onClick,
      size: size2,
      style: style3,
      className,
      fullwidth: t1,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = className;
    $[3] = hover;
    $[4] = onClick;
    $[5] = props;
    $[6] = size2;
    $[7] = style3;
    $[8] = t1;
  } else {
    children = $[1];
    className = $[2];
    hover = $[3];
    onClick = $[4];
    props = $[5];
    size2 = $[6];
    style3 = $[7];
    t1 = $[8];
  }
  const fullwidth = t1 === void 0 ? true : t1;
  let t2;
  if ($[9] !== style3) {
    t2 = {
      ...style3,
      tabindex: 0
    };
    $[9] = style3;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const t3 = fullwidth ? "w-full" : "";
  const t4 = hover ? "hover:bg-surface-accent-50 dark:hover:bg-surface-800 group-hover:bg-surface-accent-50 dark:group-hover:bg-surface-800" : "";
  const t5 = size2 === "small" ? "p-1" : "px-2 py-1";
  const t6 = onClick ? "cursor-pointer" : "";
  let t7;
  if ($[11] !== className || $[12] !== t3 || $[13] !== t4 || $[14] !== t5 || $[15] !== t6) {
    t7 = cls("bg-white dark:bg-surface-900", "min-h-[42px]", t3, "items-center", t4, t5, "flex border rounded-lg", t6, defaultBorderMixin, className);
    $[11] = className;
    $[12] = t3;
    $[13] = t4;
    $[14] = t5;
    $[15] = t6;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  let t8;
  if ($[17] !== onClick) {
    t8 = (event) => {
      if (onClick) {
        event.preventDefault();
        onClick(event);
      }
    };
    $[17] = onClick;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  let t9;
  if ($[19] !== children || $[20] !== props || $[21] !== ref2 || $[22] !== t2 || $[23] !== t7 || $[24] !== t8) {
    t9 = (0, import_jsx_runtime2.jsx)("div", { ref: ref2, style: t2, className: t7, onClick: t8, ...props, children });
    $[19] = children;
    $[20] = props;
    $[21] = ref2;
    $[22] = t2;
    $[23] = t7;
    $[24] = t8;
    $[25] = t9;
  } else {
    t9 = $[25];
  }
  return t9;
});
EntityPreviewContainer.displayName = "EntityPreviewContainer";
var ReferencePreview = function ReferencePreview2(props) {
  const $ = (0, import_react_compiler_runtime3.c)(10);
  const reference2 = props.reference;
  if (!(typeof reference2 === "object" && "isEntityReference" in reference2 && reference2.isEntityReference())) {
    console.warn("Reference preview received value of type", typeof reference2);
    const t02 = props.onClick;
    const t1 = props.size;
    let t2;
    if ($[0] !== reference2) {
      t2 = JSON.stringify(reference2);
      $[0] = reference2;
      $[1] = t2;
    } else {
      t2 = $[1];
    }
    let t3;
    if ($[2] !== t2) {
      t3 = (0, import_jsx_runtime2.jsx)(ErrorView, { error: "Unexpected value. Click to edit", tooltip: t2 });
      $[2] = t2;
      $[3] = t3;
    } else {
      t3 = $[3];
    }
    let t4;
    if ($[4] !== props.onClick || $[5] !== props.size || $[6] !== t3) {
      t4 = (0, import_jsx_runtime2.jsx)(EntityPreviewContainer, { onClick: t02, size: t1, children: t3 });
      $[4] = props.onClick;
      $[5] = props.size;
      $[6] = t3;
      $[7] = t4;
    } else {
      t4 = $[7];
    }
    return t4;
  }
  let t0;
  if ($[8] !== props) {
    t0 = (0, import_jsx_runtime2.jsx)(ReferencePreviewInternal, { ...props });
    $[8] = props;
    $[9] = t0;
  } else {
    t0 = $[9];
  }
  return t0;
};
function ReferencePreviewInternal(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(16);
  const {
    disabled,
    reference: reference2,
    previewProperties,
    size: size2,
    hover,
    onClick,
    includeEntityLink: t1,
    includeId: t2
  } = t0;
  const includeEntityLink = t1 === void 0 ? true : t1;
  const includeId = t2 === void 0 ? true : t2;
  const customizationController = useCustomizationController();
  const navigationController = useNavigationController();
  let t3;
  if ($[0] !== navigationController || $[1] !== reference2.path) {
    t3 = navigationController.getCollection(reference2.path);
    $[0] = navigationController;
    $[1] = reference2.path;
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  const collection = t3;
  if (!collection) {
    if ((_a = customizationController.components) == null ? void 0 : _a.missingReference) {
      let t42;
      if ($[3] !== customizationController.components.missingReference || $[4] !== reference2.path) {
        t42 = (0, import_jsx_runtime2.jsx)(customizationController.components.missingReference, { path: reference2.path });
        $[3] = customizationController.components.missingReference;
        $[4] = reference2.path;
        $[5] = t42;
      } else {
        t42 = $[5];
      }
      return t42;
    } else {
      throw Error(`Couldn't find the corresponding collection view for the path: ${reference2.path}`);
    }
  }
  let t4;
  if ($[6] !== collection || $[7] !== disabled || $[8] !== hover || $[9] !== includeEntityLink || $[10] !== includeId || $[11] !== onClick || $[12] !== previewProperties || $[13] !== reference2 || $[14] !== size2) {
    t4 = (0, import_jsx_runtime2.jsx)(ReferencePreviewExisting, { reference: reference2, collection, previewProperties, size: size2, disabled, includeEntityLink, includeId, onClick, hover });
    $[6] = collection;
    $[7] = disabled;
    $[8] = hover;
    $[9] = includeEntityLink;
    $[10] = includeId;
    $[11] = onClick;
    $[12] = previewProperties;
    $[13] = reference2;
    $[14] = size2;
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  return t4;
}
function ReferencePreviewExisting(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(35);
  const {
    reference: reference2,
    collection,
    previewProperties,
    size: size2,
    disabled,
    includeEntityLink,
    includeId,
    onClick,
    hover
  } = t0;
  let t1;
  if ($[0] !== collection || $[1] !== reference2.id || $[2] !== reference2.path) {
    t1 = {
      path: reference2.path,
      entityId: reference2.id,
      collection,
      useCache: true
    };
    $[0] = collection;
    $[1] = reference2.id;
    $[2] = reference2.path;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const {
    entity,
    dataLoading
  } = useEntityFetch(t1);
  if (entity) {
    referencesCache.set(reference2.pathWithId, entity);
  }
  let t2;
  if ($[4] !== entity || $[5] !== reference2.pathWithId) {
    t2 = entity ?? referencesCache.get(reference2.pathWithId);
    $[4] = entity;
    $[5] = reference2.pathWithId;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const usedEntity = t2;
  let body;
  if (!reference2) {
    let t32;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = (0, import_jsx_runtime2.jsx)(ErrorView, { error: "Reference not set" });
      $[7] = t32;
    } else {
      t32 = $[7];
    }
    body = t32;
  } else {
    if (usedEntity && !usedEntity.values) {
      let t32;
      if ($[8] !== reference2.path) {
        t32 = (0, import_jsx_runtime2.jsx)(ErrorView, { error: "Reference does not exist", tooltip: reference2.path });
        $[8] = reference2.path;
        $[9] = t32;
      } else {
        t32 = $[9];
      }
      body = t32;
    }
  }
  if (body) {
    const t32 = disabled ? void 0 : onClick;
    const t4 = disabled ? void 0 : hover;
    let t5;
    if ($[10] !== body || $[11] !== size2 || $[12] !== t32 || $[13] !== t4) {
      t5 = (0, import_jsx_runtime2.jsx)(EntityPreviewContainer, { onClick: t32, hover: t4, size: size2, children: body });
      $[10] = body;
      $[11] = size2;
      $[12] = t32;
      $[13] = t4;
      $[14] = t5;
    } else {
      t5 = $[14];
    }
    return t5;
  }
  if (dataLoading && !usedEntity) {
    const t32 = disabled ? void 0 : onClick;
    const t4 = disabled ? void 0 : hover;
    let t5;
    if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
      t5 = (0, import_jsx_runtime2.jsx)(Skeleton, {});
      $[15] = t5;
    } else {
      t5 = $[15];
    }
    let t6;
    if ($[16] !== size2 || $[17] !== t32 || $[18] !== t4) {
      t6 = (0, import_jsx_runtime2.jsx)(EntityPreviewContainer, { onClick: t32, hover: t4, size: size2, children: t5 });
      $[16] = size2;
      $[17] = t32;
      $[18] = t4;
      $[19] = t6;
    } else {
      t6 = $[19];
    }
    return t6;
  }
  if (!usedEntity) {
    const t32 = disabled ? void 0 : onClick;
    const t4 = disabled ? void 0 : hover;
    let t5;
    if ($[20] === Symbol.for("react.memo_cache_sentinel")) {
      t5 = (0, import_jsx_runtime2.jsx)(ErrorView, { error: "Entity not found" });
      $[20] = t5;
    } else {
      t5 = $[20];
    }
    let t6;
    if ($[21] !== size2 || $[22] !== t32 || $[23] !== t4) {
      t6 = (0, import_jsx_runtime2.jsx)(EntityPreviewContainer, { onClick: t32, hover: t4, size: size2, children: t5 });
      $[21] = size2;
      $[22] = t32;
      $[23] = t4;
      $[24] = t6;
    } else {
      t6 = $[24];
    }
    return t6;
  }
  let t3;
  if ($[25] !== collection || $[26] !== disabled || $[27] !== hover || $[28] !== includeEntityLink || $[29] !== includeId || $[30] !== onClick || $[31] !== previewProperties || $[32] !== size2 || $[33] !== usedEntity) {
    t3 = (0, import_jsx_runtime2.jsx)(EntityPreview, { size: size2, previewProperties, disabled, entity: usedEntity, collection, onClick, includeEntityLink, includeId, hover });
    $[25] = collection;
    $[26] = disabled;
    $[27] = hover;
    $[28] = includeEntityLink;
    $[29] = includeId;
    $[30] = onClick;
    $[31] = previewProperties;
    $[32] = size2;
    $[33] = usedEntity;
    $[34] = t3;
  } else {
    t3 = $[34];
  }
  return t3;
}
var referencesCache = /* @__PURE__ */ new Map();
function ArrayOfReferencesPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(12);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== authController || $[1] !== customizationController.propertyConfigs || $[2] !== inputProperty || $[3] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs,
      authController
    });
    $[0] = authController;
    $[1] = customizationController.propertyConfigs;
    $[2] = inputProperty;
    $[3] = propertyKey;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const property = t1;
  if (Array.isArray(property == null ? void 0 : property.of)) {
    throw Error("Using array properties instead of single one in `of` in ArrayProperty");
  }
  if ((property == null ? void 0 : property.dataType) !== "array" || !property.of || property.of.dataType !== "reference") {
    throw Error("Picked wrong preview component ArrayOfReferencesPreview");
  }
  const childSize = size2 === "medium" ? "medium" : "small";
  let t2;
  if ($[5] !== childSize || $[6] !== property || $[7] !== propertyKey || $[8] !== value) {
    t2 = value && value.map((reference2, index2) => {
      const ofProperty = property.of;
      return (0, import_jsx_runtime2.jsx)("div", { className: "mt-1 mb-1 w-full", children: (0, import_jsx_runtime2.jsx)(ReferencePreview, { disabled: !ofProperty.path, previewProperties: ofProperty.previewProperties, size: childSize, reference: reference2, includeId: ofProperty.includeId, includeEntityLink: ofProperty.includeEntityLink }) }, `preview_array_ref_${propertyKey}_${index2}`);
    });
    $[5] = childSize;
    $[6] = property;
    $[7] = propertyKey;
    $[8] = value;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  let t3;
  if ($[10] !== t2) {
    t3 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col w-full", children: t2 });
    $[10] = t2;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
}
function ArrayOfStorageComponentsPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(12);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== authController || $[1] !== customizationController.propertyConfigs || $[2] !== inputProperty || $[3] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs,
      authController
    });
    $[0] = authController;
    $[1] = customizationController.propertyConfigs;
    $[2] = inputProperty;
    $[3] = propertyKey;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const property = t1;
  if (Array.isArray(property.of)) {
    throw Error("Using array properties instead of single one in `of` in ArrayProperty");
  }
  if (property.dataType !== "array" || !property.of || property.of.dataType !== "string") {
    throw Error("Picked wrong preview component ArrayOfStorageComponentsPreview");
  }
  const childSize = size2 === "medium" ? "medium" : "small";
  let t2;
  if ($[5] !== childSize || $[6] !== property.of || $[7] !== propertyKey || $[8] !== value) {
    t2 = value && value.map((v, index2) => (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey, value: v, property: property.of, size: childSize }) }, `preview_array_storage_${propertyKey}_${index2}`));
    $[5] = childSize;
    $[6] = property.of;
    $[7] = propertyKey;
    $[8] = value;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  let t3;
  if ($[10] !== t2) {
    t3 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-wrap gap-2", children: t2 });
    $[10] = t2;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  return t3;
}
function ArrayEnumPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(7);
  const {
    name,
    value,
    enumValues,
    size: size2
  } = t0;
  let t1;
  if ($[0] !== enumValues || $[1] !== name || $[2] !== size2 || $[3] !== value) {
    t1 = value && value.map((enumKey, index2) => (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey, enumValues, size: size2 !== "medium" ? "small" : "medium" }) }, `preview_array_ref_${name}_${index2}`));
    $[0] = enumValues;
    $[1] = name;
    $[2] = size2;
    $[3] = value;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-wrap gap-1.5", children: t1 });
    $[5] = t1;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  return t2;
}
function ArrayPropertyEnumPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(5);
  const {
    propertyKey,
    value,
    property,
    size: size2
  } = t0;
  if (property.dataType !== "array") {
    throw Error("Picked wrong preview component ArrayEnumPreview");
  }
  const ofProperty = property.of;
  if (!ofProperty.enumValues) {
    throw Error("Picked wrong preview component ArrayEnumPreview");
  }
  if (!value) {
    return null;
  }
  let t1;
  if ($[0] !== ofProperty.enumValues || $[1] !== propertyKey || $[2] !== size2 || $[3] !== value) {
    t1 = (0, import_jsx_runtime2.jsx)(ArrayEnumPreview, { name: propertyKey, value, enumValues: ofProperty.enumValues, size: size2 });
    $[0] = ofProperty.enumValues;
    $[1] = propertyKey;
    $[2] = size2;
    $[3] = value;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  return t1;
}
function ArrayOfStringsPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(14);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== authController || $[1] !== customizationController.propertyConfigs || $[2] !== inputProperty || $[3] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs,
      authController
    });
    $[0] = authController;
    $[1] = customizationController.propertyConfigs;
    $[2] = inputProperty;
    $[3] = propertyKey;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const property = t1;
  if (Array.isArray(property.of)) {
    throw Error("Using array properties instead of single one in `of` in ArrayProperty");
  }
  if (!property.of || property.dataType !== "array" || property.of.dataType !== "string") {
    throw Error("Picked wrong preview component ArrayOfStringsPreview");
  }
  if (value && !Array.isArray(value)) {
    const t22 = `Unexpected value: ${value}`;
    let t32;
    if ($[5] !== t22) {
      t32 = (0, import_jsx_runtime2.jsx)("div", { children: t22 });
      $[5] = t22;
      $[6] = t32;
    } else {
      t32 = $[6];
    }
    return t32;
  }
  const stringProperty = property.of;
  let t2;
  if ($[7] !== propertyKey || $[8] !== size2 || $[9] !== stringProperty || $[10] !== value) {
    t2 = value && value.map((v, index2) => (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(StringPropertyPreview, { propertyKey, property: stringProperty, value: v, size: size2 }) }) }, `preview_array_strings_${propertyKey}_${index2}`));
    $[7] = propertyKey;
    $[8] = size2;
    $[9] = stringProperty;
    $[10] = value;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  let t3;
  if ($[12] !== t2) {
    t3 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2", children: t2 });
    $[12] = t2;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  return t3;
}
function ArrayOneOfPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(15);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== authController || $[1] !== customizationController.propertyConfigs || $[2] !== inputProperty || $[3] !== propertyKey) {
    t1 = resolveArrayProperty({
      propertyKey,
      property: inputProperty,
      propertyConfigs: customizationController.propertyConfigs,
      authController
    });
    $[0] = authController;
    $[1] = customizationController.propertyConfigs;
    $[2] = inputProperty;
    $[3] = propertyKey;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  const property = t1;
  if ((property == null ? void 0 : property.dataType) !== "array") {
    throw Error("Picked wrong preview component ArrayPreview");
  }
  if (!(property == null ? void 0 : property.oneOf)) {
    throw Error(`You need to specify an 'of' or 'oneOf' prop (or specify a custom field) in your array property ${propertyKey}`);
  }
  const values = value;
  if (!values) {
    return null;
  }
  const childSize = size2 === "medium" ? "medium" : "small";
  const typeField = property.oneOf.typeField ?? DEFAULT_ONE_OF_TYPE;
  const valueField = property.oneOf.valueField ?? DEFAULT_ONE_OF_VALUE;
  const properties = property.oneOf.properties;
  let t2;
  if ($[5] !== childSize || $[6] !== properties || $[7] !== property.resolvedProperties || $[8] !== propertyKey || $[9] !== typeField || $[10] !== valueField || $[11] !== values) {
    t2 = values && values.map((value_0, index2) => (0, import_jsx_runtime2.jsx)(import_react14.default.Fragment, { children: (0, import_jsx_runtime2.jsx)("div", { className: cls(defaultBorderMixin, "m-1 border-b last:border-b-0 py-2"), children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: value_0 && (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey, value: value_0[valueField], property: property.resolvedProperties[index2] ?? properties[value_0[typeField]], size: childSize }) }) }) }, "preview_array_" + value_0 + "_" + index2));
    $[5] = childSize;
    $[6] = properties;
    $[7] = property.resolvedProperties;
    $[8] = propertyKey;
    $[9] = typeField;
    $[10] = valueField;
    $[11] = values;
    $[12] = t2;
  } else {
    t2 = $[12];
  }
  let t3;
  if ($[13] !== t2) {
    t3 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col", children: t2 });
    $[13] = t2;
    $[14] = t3;
  } else {
    t3 = $[14];
  }
  return t3;
}
function MapPropertyPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(15);
  const {
    value,
    property,
    size: size2
  } = t0;
  if (property.dataType !== "map") {
    throw Error("Picked wrong preview component MapPropertyPreview");
  }
  const mapProperty = property;
  if (!mapProperty.properties || Object.keys(mapProperty.properties ?? {}).length === 0) {
    let t12;
    if ($[0] !== value) {
      t12 = (0, import_jsx_runtime2.jsx)(KeyValuePreview, { value });
      $[0] = value;
      $[1] = t12;
    } else {
      t12 = $[1];
    }
    return t12;
  }
  if (!value) {
    return null;
  }
  let t1;
  if ($[2] !== mapProperty.properties) {
    t1 = Object.keys(mapProperty.properties);
    $[2] = mapProperty.properties;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const mapPropertyKeys = t1;
  if (size2 === "small") {
    let t22;
    if ($[4] !== mapProperty.name || $[5] !== mapProperty.properties || $[6] !== mapPropertyKeys || $[7] !== size2 || $[8] !== value) {
      t22 = (0, import_jsx_runtime2.jsx)("div", { className: "w-full flex flex-col space-y-1 md:space-y-2", children: mapPropertyKeys.map((key, index2) => (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey: key, value: value[key], property: mapProperty.properties[key], size: size2 }) }, "map_preview_" + mapProperty.name + key + index2) }, `map_${key}`)) });
      $[4] = mapProperty.name;
      $[5] = mapProperty.properties;
      $[6] = mapPropertyKeys;
      $[7] = size2;
      $[8] = value;
      $[9] = t22;
    } else {
      t22 = $[9];
    }
    return t22;
  }
  let t2;
  if ($[10] !== mapProperty.properties || $[11] !== mapPropertyKeys || $[12] !== size2 || $[13] !== value) {
    t2 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-1 w-full", children: mapPropertyKeys && mapPropertyKeys.map((key_0, index_0) => {
      const childProperty = mapProperty.properties[key_0];
      const isArrayOrMap = childProperty.dataType === "map" || childProperty === "array";
      return (0, import_jsx_runtime2.jsxs)("div", { className: cls(defaultBorderMixin, "last:border-b-0 border-b"), children: [
        (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-row pt-0.5 pb-0.5 gap-2", children: [
          (0, import_jsx_runtime2.jsx)("div", { className: "min-w-[140px] w-[25%] py-1", children: (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", className: "font-mono break-words", color: "secondary", children: childProperty.name }) }),
          (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow max-w-[75%]", children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: !isArrayOrMap && (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey: key_0, value: value[key_0], property: childProperty, size: size2 }) }) })
        ] }),
        isArrayOrMap && (0, import_jsx_runtime2.jsx)("div", { className: cls(defaultBorderMixin, "border-l pl-4 ml-2 my-2"), children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey: key_0, value: value[key_0], property: childProperty, size: size2 }) })
      ] }, `map_preview_table_${key_0}}`);
    }) });
    $[10] = mapProperty.properties;
    $[11] = mapPropertyKeys;
    $[12] = size2;
    $[13] = value;
    $[14] = t2;
  } else {
    t2 = $[14];
  }
  return t2;
}
function KeyValuePreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(5);
  const {
    value
  } = t0;
  if (typeof value !== "object") {
    return null;
  }
  if (!value) {
    let t12;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t12 = (0, import_jsx_runtime2.jsx)(EmptyValue, {});
      $[0] = t12;
    } else {
      t12 = $[0];
    }
    return t12;
  }
  let t1;
  if ($[1] !== value) {
    t1 = Object.entries(value).map(_temp$n);
    $[1] = value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-1 w-full", children: t1 });
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}
function _temp$n(t0) {
  const [key, childValue] = t0;
  return (0, import_jsx_runtime2.jsxs)("div", { className: cls(defaultBorderMixin, "last:border-b-0 border-b"), children: [
    (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-row pt-0.5 pb-0.5 gap-2", children: [
      (0, import_jsx_runtime2.jsx)("div", { className: "min-w-[140px] w-[25%] py-1", children: (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", className: "font-mono break-words", color: "secondary", children: key }) }, `table-cell-title-${key}-${key}`),
      (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow max-w-[75%]", children: childValue && (0, import_jsx_runtime2.jsx)(Typography, { children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: childValue.toString() }) }) })
    ] }),
    typeof childValue === "object" && (0, import_jsx_runtime2.jsx)("div", { className: cls(defaultBorderMixin, "border-l pl-4"), children: (0, import_jsx_runtime2.jsx)(KeyValuePreview, { value: childValue }) })
  ] }, `map_preview_table_${key}}`);
}
function DatePreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    date: date2
  } = t0;
  const customizationController = useCustomizationController();
  const dateUtilsLocale = (customizationController == null ? void 0 : customizationController.locale) ? locale_exports[customizationController == null ? void 0 : customizationController.locale] : void 0;
  const dateFormat = (customizationController == null ? void 0 : customizationController.dateTimeFormat) ?? defaultDateFormat;
  let t1;
  if ($[0] !== date2 || $[1] !== dateFormat || $[2] !== dateUtilsLocale) {
    t1 = date2 ? format2(date2, dateFormat, {
      locale: dateUtilsLocale
    }) : "";
    $[0] = date2;
    $[1] = dateFormat;
    $[2] = dateUtilsLocale;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const formattedDate = t1;
  let t2;
  if ($[4] !== formattedDate) {
    t2 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: formattedDate });
    $[4] = formattedDate;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
function BooleanPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(9);
  const {
    value,
    size: size2,
    property
  } = t0;
  let t1;
  if ($[0] !== size2 || $[1] !== value) {
    t1 = (0, import_jsx_runtime2.jsx)(Checkbox, { checked: value, padding: false, size: size2, color: "secondary" });
    $[0] = size2;
    $[1] = value;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  let t2;
  if ($[3] !== property.name || $[4] !== size2) {
    t2 = property.name && (0, import_jsx_runtime2.jsx)("span", { className: cls("text-text-secondary dark:text-text-secondary-dark", size2 === "small" ? "text-sm" : ""), children: property.name });
    $[3] = property.name;
    $[4] = size2;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== t1 || $[7] !== t2) {
    t3 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-row gap-2 items-center", children: [
      t1,
      t2
    ] });
    $[6] = t1;
    $[7] = t2;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  return t3;
}
function NumberPropertyPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(10);
  const {
    value,
    property,
    size: size2
  } = t0;
  if (property.enumValues) {
    const enumKey = value;
    let t1;
    if ($[0] !== property.enumValues) {
      t1 = enumToObjectEntries(property.enumValues);
      $[0] = property.enumValues;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    const enumValues = t1;
    if (!enumValues) {
      let t22;
      if ($[2] !== value) {
        t22 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: value });
        $[2] = value;
        $[3] = t22;
      } else {
        t22 = $[3];
      }
      return t22;
    }
    const t2 = size2 !== "medium" ? "small" : "medium";
    let t3;
    if ($[4] !== enumKey || $[5] !== enumValues || $[6] !== t2) {
      t3 = (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey, enumValues, size: t2 });
      $[4] = enumKey;
      $[5] = enumValues;
      $[6] = t2;
      $[7] = t3;
    } else {
      t3 = $[7];
    }
    return t3;
  } else {
    let t1;
    if ($[8] !== value) {
      t1 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: value });
      $[8] = value;
      $[9] = t1;
    } else {
      t1 = $[9];
    }
    return t1;
  }
}
var PropertyPreview = import_react14.default.memo(function PropertyPreview2(props) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(30);
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  let content;
  const {
    property: inputProperty,
    propertyKey,
    value,
    size: size2,
    height,
    width,
    interactive
  } = props;
  if ($[0] !== authController || $[1] !== customizationController.propertyConfigs || $[2] !== height || $[3] !== inputProperty || $[4] !== interactive || $[5] !== propertyKey || $[6] !== props || $[7] !== size2 || $[8] !== value || $[9] !== width) {
    const property = resolveProperty({
      propertyKey,
      propertyOrBuilder: inputProperty,
      propertyConfigs: customizationController.propertyConfigs,
      authController
    });
    if (property === null) {
      let t02;
      if ($[11] === Symbol.for("react.memo_cache_sentinel")) {
        t02 = (0, import_jsx_runtime2.jsx)(EmptyValue, {});
        $[11] = t02;
      } else {
        t02 = $[11];
      }
      content = t02;
    } else {
      if (property.Preview) {
        content = (0, import_react14.createElement)(property.Preview, {
          propertyKey,
          value,
          property,
          size: size2,
          height,
          width,
          customProps: property.customProps
        });
      } else {
        if (value === void 0 || value === null) {
          let t02;
          if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
            t02 = (0, import_jsx_runtime2.jsx)(EmptyValue, {});
            $[12] = t02;
          } else {
            t02 = $[12];
          }
          content = t02;
        } else {
          if (property.dataType === "string") {
            const stringProperty = property;
            if (typeof value === "string") {
              if (stringProperty.storage) {
                const filePath = stringProperty.storage.previewUrl ? stringProperty.storage.previewUrl(value) : value;
                const t02 = ((_a = property.storage) == null ? void 0 : _a.storeUrl) ?? false;
                let t1;
                if ($[13] !== filePath || $[14] !== interactive || $[15] !== props.size || $[16] !== t02) {
                  t1 = (0, import_jsx_runtime2.jsx)(StorageThumbnail, { interactive, storeUrl: t02, size: props.size, storagePathOrDownloadUrl: filePath });
                  $[13] = filePath;
                  $[14] = interactive;
                  $[15] = props.size;
                  $[16] = t02;
                  $[17] = t1;
                } else {
                  t1 = $[17];
                }
                content = t1;
              } else {
                if (stringProperty.url) {
                  if (typeof stringProperty.url === "boolean") {
                    let t02;
                    if ($[18] !== props.size || $[19] !== value) {
                      t02 = (0, import_jsx_runtime2.jsx)(UrlComponentPreview, { size: props.size, url: value });
                      $[18] = props.size;
                      $[19] = value;
                      $[20] = t02;
                    } else {
                      t02 = $[20];
                    }
                    content = t02;
                  } else {
                    if (typeof stringProperty.url === "string") {
                      content = (0, import_jsx_runtime2.jsx)(UrlComponentPreview, { size: props.size, url: value, interactive, previewType: stringProperty.url });
                    }
                  }
                } else {
                  if (stringProperty.markdown) {
                    let t02;
                    if ($[21] !== value) {
                      t02 = (0, import_jsx_runtime2.jsx)(Markdown, { source: value, size: "small" });
                      $[21] = value;
                      $[22] = t02;
                    } else {
                      t02 = $[22];
                    }
                    content = t02;
                  } else {
                    content = (0, import_jsx_runtime2.jsx)(StringPropertyPreview, { ...props, property: stringProperty, value });
                  }
                }
              }
            } else {
              content = buildWrongValueType(propertyKey, property.dataType, value);
            }
          } else {
            if (property.dataType === "array") {
              if (value instanceof Array) {
                const arrayProperty = property;
                if (!arrayProperty.of && !arrayProperty.oneOf) {
                  throw Error(`You need to specify an 'of' or 'oneOf' prop (or specify a custom field) in your array property ${propertyKey}`);
                }
                if (arrayProperty.of) {
                  if (Array.isArray(arrayProperty.of)) {
                    content = (0, import_jsx_runtime2.jsx)(ArrayPropertyPreview, { ...props, value, property });
                  } else {
                    if (arrayProperty.of.dataType === "reference") {
                      content = (0, import_jsx_runtime2.jsx)(ArrayOfReferencesPreview, { ...props, value, property });
                    } else {
                      if (arrayProperty.of.dataType === "string") {
                        if (arrayProperty.of.enumValues) {
                          content = (0, import_jsx_runtime2.jsx)(ArrayPropertyEnumPreview, { ...props, value, property });
                        } else {
                          if (arrayProperty.of.storage) {
                            content = (0, import_jsx_runtime2.jsx)(ArrayOfStorageComponentsPreview, { ...props, value, property });
                          } else {
                            content = (0, import_jsx_runtime2.jsx)(ArrayOfStringsPreview, { ...props, value, property });
                          }
                        }
                      } else {
                        if (arrayProperty.of.dataType === "number" && arrayProperty.of.enumValues) {
                          content = (0, import_jsx_runtime2.jsx)(ArrayPropertyEnumPreview, { ...props, value, property });
                        } else {
                          content = (0, import_jsx_runtime2.jsx)(ArrayPropertyPreview, { ...props, value, property });
                        }
                      }
                    }
                  }
                } else {
                  if (arrayProperty.oneOf) {
                    content = (0, import_jsx_runtime2.jsx)(ArrayOneOfPreview, { ...props, value, property });
                  }
                }
              } else {
                content = buildWrongValueType(propertyKey, property.dataType, value);
              }
            } else {
              if (property.dataType === "map") {
                if (typeof value === "object") {
                  content = (0, import_jsx_runtime2.jsx)(MapPropertyPreview, { ...props, property });
                } else {
                  content = buildWrongValueType(propertyKey, property.dataType, value);
                }
              } else {
                if (property.dataType === "date") {
                  if (value instanceof Date) {
                    let t02;
                    if ($[23] !== value) {
                      t02 = (0, import_jsx_runtime2.jsx)(DatePreview, { date: value });
                      $[23] = value;
                      $[24] = t02;
                    } else {
                      t02 = $[24];
                    }
                    content = t02;
                  } else {
                    content = buildWrongValueType(propertyKey, property.dataType, value);
                  }
                } else {
                  if (property.dataType === "reference") {
                    if (typeof property.path === "string") {
                      if (typeof value === "object" && "isEntityReference" in value && value.isEntityReference()) {
                        content = (0, import_jsx_runtime2.jsx)(ReferencePreview, { disabled: !property.path, previewProperties: property.previewProperties, includeId: property.includeId, includeEntityLink: property.includeEntityLink, size: props.size, reference: value });
                      } else {
                        content = buildWrongValueType(propertyKey, property.dataType, value);
                      }
                    } else {
                      let t02;
                      if ($[25] === Symbol.for("react.memo_cache_sentinel")) {
                        t02 = (0, import_jsx_runtime2.jsx)(EmptyValue, {});
                        $[25] = t02;
                      } else {
                        t02 = $[25];
                      }
                      content = t02;
                    }
                  } else {
                    if (property.dataType === "boolean") {
                      if (typeof value === "boolean") {
                        content = (0, import_jsx_runtime2.jsx)(BooleanPreview, { value, size: size2, property });
                      } else {
                        content = buildWrongValueType(propertyKey, property.dataType, value);
                      }
                    } else {
                      if (property.dataType === "number") {
                        if (typeof value === "number") {
                          content = (0, import_jsx_runtime2.jsx)(NumberPropertyPreview, { ...props, value, property });
                        } else {
                          content = buildWrongValueType(propertyKey, property.dataType, value);
                        }
                      } else {
                        let t02;
                        if ($[26] !== value) {
                          t02 = JSON.stringify(value);
                          $[26] = value;
                          $[27] = t02;
                        } else {
                          t02 = $[27];
                        }
                        content = t02;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    $[0] = authController;
    $[1] = customizationController.propertyConfigs;
    $[2] = height;
    $[3] = inputProperty;
    $[4] = interactive;
    $[5] = propertyKey;
    $[6] = props;
    $[7] = size2;
    $[8] = value;
    $[9] = width;
    $[10] = content;
  } else {
    content = $[10];
  }
  let t0;
  if ($[28] !== content) {
    t0 = content === void 0 || content === null || Array.isArray(content) && content.length === 0 ? (0, import_jsx_runtime2.jsx)(EmptyValue, {}) : content;
    $[28] = content;
    $[29] = t0;
  } else {
    t0 = $[29];
  }
  return t0;
}, import_react_fast_compare2.default);
function buildWrongValueType(name, dataType, value) {
  console.warn(`Unexpected value for property ${name}, of type ${dataType}`, value);
  return (0, import_jsx_runtime2.jsx)(ErrorView, { title: "Unexpected value", error: `${JSON.stringify(value)}` });
}
function ArrayOfMapsPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(14);
  const {
    propertyKey,
    value,
    property: inputProperty,
    size: size2
  } = t0;
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  const t1 = customizationController.propertyConfigs;
  let t2;
  let t3;
  let t4;
  if ($[0] !== authController || $[1] !== customizationController.propertyConfigs || $[2] !== inputProperty || $[3] !== propertyKey || $[4] !== size2 || $[5] !== value) {
    t4 = Symbol.for("react.early_return_sentinel");
    bb0: {
      const property = resolveArrayProperty({
        propertyKey,
        property: inputProperty,
        propertyConfigs: t1,
        authController
      });
      if (Array.isArray(property == null ? void 0 : property.of)) {
        throw Error("Using array properties instead of single one in `of` in ArrayProperty");
      }
      if ((property == null ? void 0 : property.dataType) !== "array" || !property.of || property.of.dataType !== "map") {
        throw Error("Picked wrong preview component ArrayOfMapsPreview");
      }
      const mapProperty = property.of;
      const properties = mapProperty.properties;
      if (!properties) {
        throw Error(`You need to specify a 'properties' prop (or specify a custom field) in your map property ${propertyKey}`);
      }
      const values = value;
      const previewProperties = mapProperty.previewProperties;
      if (!values) {
        t4 = null;
        break bb0;
      }
      let mapProperties;
      mapProperties = previewProperties;
      if (!mapProperties || !mapProperties.length) {
        mapProperties = Object.keys(properties);
        if (size2) {
          mapProperties = mapProperties.slice(0, 3);
        }
      }
      t3 = "table-auto text-xs";
      t2 = values && values.map((v, index2) => (0, import_jsx_runtime2.jsx)("div", { className: "border-b last:border-b-0 py-2", children: mapProperties && mapProperties.map((key) => (0, import_jsx_runtime2.jsx)("div", { className: "table-cell", children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey: key, value: v[key], property: properties[key], size: "small" }) }) }, `table-cell-${key}`)) }, `table_${v}_${index2}`));
    }
    $[0] = authController;
    $[1] = customizationController.propertyConfigs;
    $[2] = inputProperty;
    $[3] = propertyKey;
    $[4] = size2;
    $[5] = value;
    $[6] = t2;
    $[7] = t3;
    $[8] = t4;
  } else {
    t2 = $[6];
    t3 = $[7];
    t4 = $[8];
  }
  if (t4 !== Symbol.for("react.early_return_sentinel")) {
    return t4;
  }
  let t5;
  if ($[9] !== t2) {
    t5 = (0, import_jsx_runtime2.jsx)("div", { children: t2 });
    $[9] = t2;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== t3 || $[12] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)("div", { className: t3, children: t5 });
    $[11] = t3;
    $[12] = t5;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  return t6;
}
var AsyncPreviewComponent = React8.memo(function AsyncPreviewComponentInternal(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    builder
  } = t0;
  const [loading, setLoading] = (0, import_react14.useState)(true);
  const [result, setResult] = (0, import_react14.useState)(null);
  let t1;
  let t2;
  if ($[0] !== builder) {
    t1 = () => {
      let unmounted;
      unmounted = false;
      builder.then((res) => {
        if (!unmounted) {
          setLoading(false);
          setResult(res);
        }
      }).catch((error2) => {
        setLoading(false);
        console.error(error2);
      });
      return () => {
        unmounted = true;
      };
    };
    t2 = [builder];
    $[0] = builder;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  (0, import_react14.useEffect)(t1, t2);
  if (loading) {
    let t32;
    if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
      t32 = (0, import_jsx_runtime2.jsx)(Skeleton, {});
      $[3] = t32;
    } else {
      t32 = $[3];
    }
    return t32;
  }
  let t3;
  if ($[4] !== result) {
    t3 = (0, import_jsx_runtime2.jsx)(React8.Fragment, { children: result });
    $[4] = result;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
});
function EntityView({
  entity,
  collection,
  path,
  className
}) {
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  const resolvedCollection = (0, import_react14.useMemo)(() => resolveCollection({
    collection,
    path,
    entityId: entity.id,
    values: entity.values,
    propertyConfigs: customizationController.propertyConfigs,
    authController
  }), [collection, path, entity, customizationController.propertyConfigs]);
  const properties = resolvedCollection.properties;
  return (0, import_jsx_runtime2.jsx)("div", { className: "w-full " + className, children: (0, import_jsx_runtime2.jsxs)("div", { className: "w-full mb-4", children: [
    (0, import_jsx_runtime2.jsxs)("div", { className: cls(defaultBorderMixin, "flex justify-between py-2 border-b last:border-b-0"), children: [
      (0, import_jsx_runtime2.jsx)("div", { className: "flex items-center w-1/4", children: (0, import_jsx_runtime2.jsx)("span", { className: "pl-2 text-sm text-surface-600", children: "Id" }) }),
      (0, import_jsx_runtime2.jsxs)("div", { className: "flex-grow p-2 ml-2 w-3/4 text-surface-900 dark:text-white min-h-[56px] flex items-center", children: [
        (0, import_jsx_runtime2.jsx)("span", { className: "flex-grow mr-2", children: entity.id }),
        (customizationController == null ? void 0 : customizationController.entityLinkBuilder) && (0, import_jsx_runtime2.jsx)("a", { href: customizationController.entityLinkBuilder({
          entity
        }), rel: "noopener noreferrer", target: "_blank", children: (0, import_jsx_runtime2.jsx)(IconButton, { children: (0, import_jsx_runtime2.jsx)(OpenInNewIcon, { size: "small" }) }) })
      ] })
    ] }),
    Object.entries(properties).map(([key, property]) => {
      var _a;
      const value = (_a = entity.values) == null ? void 0 : _a[key];
      return (0, import_jsx_runtime2.jsxs)("div", { className: cls(defaultBorderMixin, "flex justify-between py-2 border-b last:border-b-0"), children: [
        (0, import_jsx_runtime2.jsx)("div", { className: "flex items-center w-1/4", children: (0, import_jsx_runtime2.jsx)("span", { className: "pl-2 text-sm text-surface-600", children: property.name }) }),
        (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow p-2 ml-2 w-3/4 text-surface-900 dark:text-white min-h-[56px] flex items-center", children: (0, import_jsx_runtime2.jsx)(
          PropertyPreview,
          {
            propertyKey: key,
            value,
            property,
            size: "medium"
          }
        ) })
      ] }, `reference_previews_${key}`);
    })
  ] }) });
}
function VirtualTableInput(props) {
  const $ = (0, import_react_compiler_runtime3.c)(22);
  const ref2 = import_react14.default.useRef(null);
  const {
    value,
    multiline,
    updateValue,
    focused
  } = props;
  const prevValue = (0, import_react14.useRef)(value);
  const [internalValue, setInternalValue] = (0, import_react14.useState)(value);
  const focusedState = (0, import_react14.useRef)(false);
  let t0;
  if ($[0] !== internalValue || $[1] !== value) {
    t0 = () => {
      if (prevValue.current !== value && value !== internalValue) {
        setInternalValue(value);
      }
      prevValue.current = value;
    };
    $[0] = internalValue;
    $[1] = value;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  let t1;
  if ($[3] !== value) {
    t1 = [value];
    $[3] = value;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  (0, import_react14.useEffect)(t0, t1);
  let t2;
  if ($[5] !== internalValue || $[6] !== updateValue || $[7] !== value) {
    t2 = () => {
      const emptyInitialValue = !value;
      if (emptyInitialValue && !internalValue) {
        return;
      }
      if (internalValue !== value) {
        prevValue.current = internalValue;
        updateValue(internalValue);
      }
    };
    $[5] = internalValue;
    $[6] = updateValue;
    $[7] = value;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const doUpdate = t2;
  useDebouncedCallback(internalValue, doUpdate, !focused, 2e3);
  let t3;
  let t4;
  if ($[9] !== focused) {
    t3 = () => {
      if (ref2.current && focused && !focusedState.current) {
        focusedState.current = true;
        ref2.current.focus({
          preventScroll: true
        });
        ref2.current.selectionStart = ref2.current.value.length;
        ref2.current.selectionEnd = ref2.current.value.length;
      } else {
        focusedState.current = focused;
      }
    };
    t4 = [focused, ref2];
    $[9] = focused;
    $[10] = t3;
    $[11] = t4;
  } else {
    t3 = $[10];
    t4 = $[11];
  }
  (0, import_react14.useEffect)(t3, t4);
  let t5;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = {
      padding: 0,
      margin: 0,
      width: "100%",
      color: "unset",
      fontWeight: "unset",
      lineHeight: 1.7142857,
      fontSize: "unset",
      fontFamily: "unset",
      background: "unset",
      border: "unset",
      resize: "none",
      outline: "none"
    };
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  const t6 = internalValue ?? "";
  let t7;
  if ($[13] !== multiline) {
    t7 = (evt) => {
      const newValue = evt.target.value;
      if (multiline || !newValue.endsWith("\n")) {
        setInternalValue(newValue);
      }
    };
    $[13] = multiline;
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = () => {
      focusedState.current = true;
    };
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] !== doUpdate) {
    t9 = () => {
      focusedState.current = false;
      doUpdate();
    };
    $[16] = doUpdate;
    $[17] = t9;
  } else {
    t9 = $[17];
  }
  let t10;
  if ($[18] !== t6 || $[19] !== t7 || $[20] !== t9) {
    t10 = (0, import_jsx_runtime2.jsx)(TextareaAutosize, { className: focusedDisabled, ref: ref2, style: t5, value: t6, onChange: t7, onFocus: t8, onBlur: t9 });
    $[18] = t6;
    $[19] = t7;
    $[20] = t9;
    $[21] = t10;
  } else {
    t10 = $[21];
  }
  return t10;
}
function VirtualTableSelect(props) {
  const $ = (0, import_react_compiler_runtime3.c)(19);
  const {
    enumValues,
    internalValue,
    disabled,
    small,
    focused,
    updateValue,
    multiple,
    valueType
  } = props;
  const validValue = Array.isArray(internalValue) && multiple || !Array.isArray(internalValue) && !multiple;
  const ref2 = import_react14.default.useRef(null);
  let t0;
  let t1;
  if ($[0] !== focused) {
    t0 = () => {
      var _a;
      if (ref2.current && focused) {
        (_a = ref2.current) == null ? void 0 : _a.focus({
          preventScroll: true
        });
      }
    };
    t1 = [focused, ref2];
    $[0] = focused;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  (0, import_react14.useEffect)(t0, t1);
  let t2;
  if ($[3] !== multiple || $[4] !== updateValue || $[5] !== valueType) {
    t2 = (updatedValue) => {
      console.trace("onChange");
      if (valueType === "number") {
        if (multiple) {
          const newValue = updatedValue.map(_temp$m);
          updateValue(newValue);
        } else {
          updateValue(parseFloat(updatedValue));
        }
      } else {
        if (valueType === "string") {
          if (!updatedValue) {
            updateValue(null);
          } else {
            updateValue(updatedValue);
          }
        } else {
          throw Error("Missing mapping in TableSelect");
        }
      }
    };
    $[3] = multiple;
    $[4] = updateValue;
    $[5] = valueType;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const onChange = t2;
  let t3;
  if ($[7] !== enumValues || $[8] !== small) {
    t3 = (enumKey) => (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey: String(enumKey), enumValues, size: small ? "small" : "medium" }, `${enumKey}`);
    $[7] = enumValues;
    $[8] = small;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  const renderValue = t3;
  let t4;
  if ($[10] !== disabled || $[11] !== enumValues || $[12] !== internalValue || $[13] !== multiple || $[14] !== onChange || $[15] !== renderValue || $[16] !== small || $[17] !== validValue) {
    t4 = multiple ? (0, import_jsx_runtime2.jsx)(MultiSelect, { inputRef: ref2, className: "w-full h-full p-0 bg-transparent", position: "item-aligned", disabled, includeClear: false, useChips: false, value: validValue ? internalValue.map(_temp2$b) : [], onValueChange: onChange, children: enumValues == null ? void 0 : enumValues.map((enumConfig) => (0, import_jsx_runtime2.jsx)(MultiSelectItem, { value: String(enumConfig.id), children: (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey: enumConfig.id, enumValues, size: small ? "small" : "medium" }) }, enumConfig.id)) }) : (0, import_jsx_runtime2.jsx)(Select, { inputRef: ref2, size: "large", fullWidth: true, className: "w-full h-full p-0 bg-transparent", position: "item-aligned", disabled, padding: false, value: validValue ? internalValue == null ? void 0 : internalValue.toString() : "", onValueChange: onChange, renderValue, children: enumValues == null ? void 0 : enumValues.map((enumConfig_0) => (0, import_jsx_runtime2.jsx)(SelectItem, { value: String(enumConfig_0.id), children: (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey: enumConfig_0.id, enumValues, size: small ? "small" : "medium" }) }, enumConfig_0.id)) });
    $[10] = disabled;
    $[11] = enumValues;
    $[12] = internalValue;
    $[13] = multiple;
    $[14] = onChange;
    $[15] = renderValue;
    $[16] = small;
    $[17] = validValue;
    $[18] = t4;
  } else {
    t4 = $[18];
  }
  return t4;
}
function _temp2$b(v_0) {
  return v_0.toString();
}
function _temp$m(v) {
  return parseFloat(v);
}
function VirtualTableNumberInput(props) {
  const {
    align,
    value,
    updateValue,
    focused
  } = props;
  const propStringValue = value && typeof value === "number" ? value.toString() : "";
  const [internalValue, setInternalValue] = (0, import_react14.useState)(propStringValue);
  const prevValue = (0, import_react14.useRef)(value);
  (0, import_react14.useEffect)(() => {
    if (prevValue.current !== value && String(value) !== internalValue) setInternalValue(value ? value.toString() : null);
    prevValue.current = value;
  }, [value]);
  const doUpdate = import_react14.default.useCallback(() => {
    if (internalValue !== propStringValue) {
      if (internalValue !== void 0 && internalValue !== null) {
        const numberValue = parseFloat(internalValue);
        if (isNaN(numberValue)) return;
        if (numberValue !== void 0 && numberValue !== null) updateValue(numberValue);
      } else {
        updateValue(null);
      }
    }
  }, [internalValue, value]);
  useDebouncedCallback(internalValue, doUpdate, !focused, 2e3);
  (0, import_react14.useEffect)(() => {
    if (!focused && propStringValue !== internalValue) setInternalValue(value !== void 0 && value !== null ? value.toString() : null);
  }, [value, focused]);
  const ref2 = import_react14.default.useRef(null);
  (0, import_react14.useEffect)(() => {
    if (ref2.current && focused) {
      ref2.current.focus({
        preventScroll: true
      });
    }
  }, [focused, ref2]);
  const regexp2 = /^-?[0-9]+[,.]?[0-9]*$/;
  return (0, import_jsx_runtime2.jsx)("input", { ref: ref2, className: cls("w-full text-right p-0 m-0 bg-transparent border-none resize-none outline-none font-normal leading-normal text-unset", focusedDisabled), style: {
    textAlign: align
  }, value: internalValue ?? "", onChange: (evt) => {
    const newValue = evt.target.value.replace(",", ".");
    if (newValue.length === 0) setInternalValue(null);
    if (regexp2.test(newValue) || newValue.startsWith("-")) setInternalValue(newValue);
  } });
}
function VirtualTableSwitch(props) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    internalValue,
    updateValue,
    focused
  } = props;
  const ref2 = import_react14.default.useRef(null);
  let t0;
  let t1;
  if ($[0] !== focused) {
    t0 = () => {
      if (ref2.current && focused) {
        ref2.current.focus({
          preventScroll: true
        });
      }
    };
    t1 = [focused, ref2];
    $[0] = focused;
    $[1] = t0;
    $[2] = t1;
  } else {
    t0 = $[1];
    t1 = $[2];
  }
  (0, import_react14.useEffect)(t0, t1);
  const t2 = Boolean(internalValue);
  let t3;
  if ($[3] !== t2 || $[4] !== updateValue) {
    t3 = (0, import_jsx_runtime2.jsx)(BooleanSwitch, { ref: ref2, size: "small", value: t2, onValueChange: updateValue });
    $[3] = t2;
    $[4] = updateValue;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  return t3;
}
function VirtualTableDateField(props) {
  const $ = (0, import_react_compiler_runtime3.c)(9);
  const {
    locale
  } = useCustomizationController();
  const {
    mode,
    internalValue,
    updateValue
  } = props;
  const t0 = internalValue ?? void 0;
  let t1;
  if ($[0] !== updateValue) {
    t1 = (dateValue) => updateValue(dateValue ?? null);
    $[0] = updateValue;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = cls("w-full h-full", focusedDisabled);
    t3 = cls("w-full h-full", focusedDisabled);
    $[2] = t2;
    $[3] = t3;
  } else {
    t2 = $[2];
    t3 = $[3];
  }
  let t4;
  if ($[4] !== locale || $[5] !== mode || $[6] !== t0 || $[7] !== t1) {
    t4 = (0, import_jsx_runtime2.jsx)(DateTimeField, { value: t0, onChange: t1, size: "large", invisible: true, inputClassName: t2, className: t3, mode, locale });
    $[4] = locale;
    $[5] = mode;
    $[6] = t0;
    $[7] = t1;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  return t4;
}
var ErrorBoundary2 = class extends import_react14.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  // eslint-disable-next-line n/handle-callback-err
  static getDerivedStateFromError(error2) {
    return {
      error: error2
    };
  }
  componentDidCatch(error2, errorInfo) {
    console.error(error2);
  }
  render() {
    var _a;
    if (this.state.error) {
      return (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-col m-2", children: [
        (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center m-2", children: [
          (0, import_jsx_runtime2.jsx)(ErrorIcon, { color: "error", size: "small" }),
          (0, import_jsx_runtime2.jsx)("div", { className: "ml-4", children: "Error" })
        ] }),
        (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", children: ((_a = this.state.error) == null ? void 0 : _a.message) ?? "See the error in the console" })
      ] });
    }
    return this.props.children;
  }
};
function useStorageUploadController({
  entityId,
  entityValues,
  path,
  value,
  property,
  propertyKey,
  storageSource,
  disabled,
  onChange
}) {
  const authController = useAuthController();
  const storage = property.dataType === "string" ? property.storage : property.dataType === "array" && property.of.dataType === "string" ? property.of.storage : void 0;
  const multipleFilesSupported = property.dataType === "array";
  if (!storage) throw Error("Storage meta must be specified");
  const processFile = storage == null ? void 0 : storage.processFile;
  const metadata = storage == null ? void 0 : storage.metadata;
  const size2 = multipleFilesSupported ? "medium" : "large";
  const compression = storage == null ? void 0 : storage.imageCompression;
  const internalInitialValue = getInternalInitialValue(multipleFilesSupported, value, metadata, size2);
  const [initialValue, setInitialValue] = (0, import_react14.useState)(value);
  const [internalValue, setInternalValue] = (0, import_react14.useState)(internalInitialValue);
  (0, import_react14.useEffect)(() => {
    if (!(0, import_react_fast_compare2.default)(initialValue, value)) {
      setInitialValue(value);
      setInternalValue(internalInitialValue);
    }
  }, [internalInitialValue, value, initialValue]);
  const resolvedProperty = resolveProperty({
    propertyOrBuilder: property,
    values: entityValues,
    authController
  });
  const fileNameBuilder = (0, import_react14.useCallback)(async (file) => {
    if (storage.fileName) {
      const fileName = await resolveStorageFilenameString({
        input: storage.fileName,
        storage,
        values: entityValues,
        entityId,
        path,
        property: resolvedProperty,
        file,
        propertyKey
      });
      if (!fileName || fileName.length === 0) {
        throw Error("You need to return a valid filename");
      }
      return fileName;
    }
    return randomString2() + "_" + file.name;
  }, [entityId, entityValues, path, resolvedProperty, propertyKey, storage]);
  const storagePathBuilder = (0, import_react14.useCallback)((file_0) => {
    return resolveStoragePathString({
      input: storage.storagePath,
      storage,
      values: entityValues,
      entityId,
      path,
      property: resolvedProperty,
      file: file_0,
      propertyKey
    }) ?? "/";
  }, [entityId, entityValues, path, resolvedProperty, propertyKey, storage]);
  const onFileUploadComplete = (0, import_react14.useCallback)(async (uploadedPath, entry, metadata_0) => {
    console.debug("onFileUploadComplete", uploadedPath, entry);
    let uploadPathOrDownloadUrl = uploadedPath;
    if (storage.storeUrl) {
      uploadPathOrDownloadUrl = (await storageSource.getDownloadURL(uploadedPath)).url;
    }
    if (storage.postProcess && uploadPathOrDownloadUrl) {
      uploadPathOrDownloadUrl = await storage.postProcess(uploadPathOrDownloadUrl);
    }
    if (!uploadPathOrDownloadUrl) {
      console.warn("uploadPathOrDownloadUrl is null");
      return;
    }
    let newValue;
    entry.storagePathOrDownloadUrl = uploadPathOrDownloadUrl;
    entry.metadata = metadata_0;
    newValue = [...internalValue];
    newValue = removeDuplicates2(newValue);
    setInternalValue(newValue);
    const fieldValue = newValue.filter((e2) => !!e2.storagePathOrDownloadUrl).map((e_0) => e_0.storagePathOrDownloadUrl);
    if (multipleFilesSupported) {
      onChange(fieldValue);
    } else {
      onChange(fieldValue ? fieldValue[0] : null);
    }
  }, [internalValue, multipleFilesSupported, onChange, storage, storageSource]);
  const onFilesAdded = (0, import_react14.useCallback)(async (acceptedFiles) => {
    if (!acceptedFiles.length || disabled) return;
    if (processFile) {
      try {
        acceptedFiles = await Promise.all(acceptedFiles.map(async (file_1) => {
          const processedFile = await processFile(file_1);
          if (!processedFile) {
            return file_1;
          }
          return processedFile;
        }));
      } catch (e_1) {
        console.error("Error processing file with custom code. Attempting to continue uploading.", e_1);
      }
    }
    let newInternalValue;
    if (multipleFilesSupported) {
      newInternalValue = [...internalValue, ...await Promise.all(acceptedFiles.map(async (file_2) => {
        if (compression && compressionFormat(file_2)) {
          file_2 = await resizeAndCompressImage(file_2, compression);
        }
        return {
          id: getRandomId$2(),
          file: file_2,
          fileName: await fileNameBuilder(file_2),
          metadata,
          size: size2
        };
      }))];
    } else {
      let file_3 = acceptedFiles[0];
      if (compression && compressionFormat(file_3)) {
        file_3 = await resizeAndCompressImage(file_3, compression);
      }
      newInternalValue = [{
        id: getRandomId$2(),
        file: file_3,
        fileName: await fileNameBuilder(file_3),
        metadata,
        size: size2
      }];
    }
    newInternalValue = removeDuplicates2(newInternalValue);
    setInternalValue(newInternalValue);
  }, [disabled, fileNameBuilder, internalValue, metadata, multipleFilesSupported, size2]);
  return {
    internalValue,
    setInternalValue,
    storage,
    fileNameBuilder,
    storagePathBuilder,
    onFileUploadComplete,
    onFilesAdded,
    multipleFilesSupported
  };
}
function getInternalInitialValue(multipleFilesSupported, value, metadata, size2) {
  let strings = [];
  if (multipleFilesSupported) {
    if (Array.isArray(value) && value.every((v) => typeof v === "string")) {
      strings = value ?? [];
    }
  } else {
    if (typeof value === "string") {
      strings = value ? [value] : [];
    }
  }
  return strings.map((entry) => ({
    id: getRandomId$2(),
    storagePathOrDownloadUrl: entry,
    metadata,
    size: size2
  }));
}
function removeDuplicates2(items2) {
  return items2.filter((item, i2) => {
    return (items2.map((v) => v.storagePathOrDownloadUrl).indexOf(item.storagePathOrDownloadUrl) === i2 || !item.storagePathOrDownloadUrl) && (items2.map((v) => v.file).indexOf(item.file) === i2 || !item.file);
  });
}
function getRandomId$2() {
  return Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER));
}
var supportedTypes = {
  "image/jpeg": "JPEG",
  "image/png": "PNG",
  "image/webp": "WEBP"
};
var compressionFormat = (file) => supportedTypes[file.type] ? supportedTypes[file.type] : null;
var defaultQuality = 100;
var resizeAndCompressImage = (file, compression) => new Promise((resolve) => {
  const inputQuality = compression.quality === void 0 ? defaultQuality : compression.quality;
  const quality = inputQuality >= 0 ? inputQuality <= 100 ? inputQuality : 100 : 100;
  const format22 = compressionFormat(file);
  if (!format22) {
    throw Error("resizeAndCompressImage: Unsupported image format");
  }
  import_react_image_file_resizer.default.imageFileResizer(file, compression.maxWidth || Number.MAX_VALUE, compression.maxHeight || Number.MAX_VALUE, format22, quality, 0, (file2) => resolve(file2), "file");
});
function StorageUploadProgress({
  storagePath,
  entry,
  metadata,
  onFileUploadComplete,
  imageSize,
  simple
}) {
  const storageSource = useStorageSource();
  const snackbarController = useSnackbarController();
  const [error2, setError] = import_react14.default.useState();
  const [loading, setLoading] = import_react14.default.useState(false);
  const mounted = import_react14.default.useRef(false);
  const uploading = import_react14.default.useRef(false);
  const upload = (0, import_react14.useCallback)((file, fileName) => {
    if (uploading.current) return;
    uploading.current = true;
    setError(void 0);
    setLoading(true);
    storageSource.uploadFile({
      file,
      fileName,
      path: storagePath,
      metadata
    }).then(async ({
      path
    }) => {
      console.debug("Upload successful", path);
      await onFileUploadComplete(path, entry, metadata);
      if (mounted.current) setLoading(false);
    }).catch((e2) => {
      console.warn("Upload error", e2);
      if (mounted.current) {
        setError(e2);
        setLoading(false);
        snackbarController.open({
          type: "error",
          message: "Error uploading file: " + e2.message
        });
      }
    }).finally(() => {
      uploading.current = false;
    });
  }, [entry, metadata, onFileUploadComplete, storageSource, storagePath]);
  import_react14.default.useEffect(() => {
    mounted.current = true;
    if (entry.file) upload(entry.file, entry.fileName);
    return () => {
      mounted.current = false;
    };
  }, [entry.file, entry.fileName, upload]);
  if (simple) {
    return (0, import_jsx_runtime2.jsx)("div", { className: `m-4 w-${imageSize} h-${imageSize}`, children: loading && (0, import_jsx_runtime2.jsx)(Skeleton, { className: `w-${imageSize} h-${imageSize}` }) });
  }
  return (0, import_jsx_runtime2.jsxs)("div", { className: cls(paperMixin, "relative m-4 border-box flex items-center justify-center", `min-w-[${imageSize}px] min-h-[${imageSize}px]`), children: [
    loading && (0, import_jsx_runtime2.jsx)(Skeleton, { className: "m-4 w-full h-full" }),
    error2 && (0, import_jsx_runtime2.jsx)(ErrorView, { title: "Error uploading file", error: error2 })
  ] });
}
function EntityTableCellActions({
  showError,
  disabled,
  showExpandIcon,
  selected,
  openPopup,
  children
}) {
  const ref2 = (0, import_react14.useRef)(null);
  const doOpenPopup = (0, import_react14.useCallback)(() => {
    var _a;
    if (openPopup) {
      const cellRect = ref2 && ((_a = ref2 == null ? void 0 : ref2.current) == null ? void 0 : _a.getBoundingClientRect());
      openPopup(cellRect);
    }
  }, []);
  const iconRef = (0, import_react14.useRef)();
  (0, import_react14.useEffect)(() => {
    if (iconRef.current && selected) {
      iconRef.current.focus({
        preventScroll: true
      });
    }
  }, [selected]);
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (showError || !disabled && showExpandIcon) && (0, import_jsx_runtime2.jsxs)("div", { ref: ref2, className: "absolute top-0.5 right-0.5 flex items-center", children: [
    selected && children,
    selected && !disabled && showExpandIcon && (0, import_jsx_runtime2.jsx)(IconButton, { ref: iconRef, color: "inherit", size: "small", onClick: doOpenPopup, children: (0, import_jsx_runtime2.jsxs)("svg", { fill: "#888", width: "20", height: "20", viewBox: "0 0 24 24", children: [
      (0, import_jsx_runtime2.jsx)("path", { className: "cls-2", d: "M20,5a1,1,0,0,0-1-1L14,4h0a1,1,0,0,0,0,2h2.57L13.29,9.29a1,1,0,0,0,0,1.42,1,1,0,0,0,1.42,0L18,7.42V10a1,1,0,0,0,1,1h0a1,1,0,0,0,1-1Z" }),
      (0, import_jsx_runtime2.jsx)("path", { className: "cls-2", d: "M10.71,13.29a1,1,0,0,0-1.42,0L6,16.57V14a1,1,0,0,0-1-1H5a1,1,0,0,0-1,1l0,5a1,1,0,0,0,1,1h5a1,1,0,0,0,0-2H7.42l3.29-3.29A1,1,0,0,0,10.71,13.29Z" })
    ] }) }),
    showError && (0, import_jsx_runtime2.jsx)(ErrorTooltip, { side: "left", title: showError.message, children: (0, import_jsx_runtime2.jsx)("div", { className: "flex items-center justify-center", style: {
      width: 32,
      height: 32
    }, children: (0, import_jsx_runtime2.jsx)(ErrorIcon, { size: "small", color: "error" }) }) })
  ] }) });
}
var dropZoneClasses$1 = "max-w-full box-border relative pt-[2px] items-center border border-transparent outline-none rounded-md duration-200 ease-[cubic-bezier(0.4,0,0.2,1)] focus:border-primary-solid";
var activeDropClasses$1 = "pt-0 border-2 border-solid";
var acceptDropClasses$1 = "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-2 border-solid border-green-500 bg-green-50 dark:bg-green-900";
var rejectDropClasses$1 = "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-2 border-solid border-red-500 bg-red-50 dark:bg-red-900";
function TableStorageUpload(props) {
  const $ = (0, import_react_compiler_runtime3.c)(27);
  const {
    propertyKey,
    error: error2,
    selected,
    openPopup,
    value,
    disabled,
    property,
    entity,
    path,
    previewSize,
    updateValue
  } = props;
  const storageSource = useStorageSource();
  let t0;
  if ($[0] !== disabled || $[1] !== entity.id || $[2] !== entity.values || $[3] !== path || $[4] !== property || $[5] !== propertyKey || $[6] !== storageSource || $[7] !== updateValue || $[8] !== value) {
    t0 = {
      entityValues: entity.values,
      entityId: entity.id,
      path,
      property,
      propertyKey,
      storageSource,
      onChange: updateValue,
      value,
      disabled
    };
    $[0] = disabled;
    $[1] = entity.id;
    $[2] = entity.values;
    $[3] = path;
    $[4] = property;
    $[5] = propertyKey;
    $[6] = storageSource;
    $[7] = updateValue;
    $[8] = value;
    $[9] = t0;
  } else {
    t0 = $[9];
  }
  const {
    internalValue,
    setInternalValue,
    onFilesAdded,
    storage,
    onFileUploadComplete,
    storagePathBuilder,
    multipleFilesSupported
  } = useStorageUploadController(t0);
  let t1;
  if ($[10] !== disabled || $[11] !== entity || $[12] !== error2 || $[13] !== internalValue || $[14] !== multipleFilesSupported || $[15] !== onFileUploadComplete || $[16] !== onFilesAdded || $[17] !== openPopup || $[18] !== previewSize || $[19] !== property || $[20] !== propertyKey || $[21] !== selected || $[22] !== setInternalValue || $[23] !== storage || $[24] !== storagePathBuilder || $[25] !== updateValue) {
    t1 = (0, import_jsx_runtime2.jsx)(StorageUpload$1, { internalValue, setInternalValue, name: propertyKey, disabled, autoFocus: false, openPopup, error: error2, selected, property, onChange: updateValue, entity, storagePathBuilder, storage, multipleFilesSupported, onFilesAdded, onFileUploadComplete, previewSize });
    $[10] = disabled;
    $[11] = entity;
    $[12] = error2;
    $[13] = internalValue;
    $[14] = multipleFilesSupported;
    $[15] = onFileUploadComplete;
    $[16] = onFilesAdded;
    $[17] = openPopup;
    $[18] = previewSize;
    $[19] = property;
    $[20] = propertyKey;
    $[21] = selected;
    $[22] = setInternalValue;
    $[23] = storage;
    $[24] = storagePathBuilder;
    $[25] = updateValue;
    $[26] = t1;
  } else {
    t1 = $[26];
  }
  return t1;
}
function StorageUpload$1(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(64);
  const {
    property,
    internalValue,
    openPopup,
    entity,
    selected,
    error: error2,
    multipleFilesSupported,
    previewSize: previewSizeInput,
    disabled,
    autoFocus,
    storage,
    onFilesAdded,
    onFileUploadComplete,
    storagePathBuilder
  } = t0;
  const previewSize = previewSizeInput;
  if (multipleFilesSupported) {
    const arrayProperty = property;
    if (Array.isArray(arrayProperty.of)) {
      throw Error("Using array properties instead of single one in `of` in ArrayProperty");
    }
    if (arrayProperty.of) {
      if (arrayProperty.of.dataType !== "string") {
        throw Error("Storage field using array must be of data type string");
      }
    } else {
      throw Error("Storage field using array must be of data type string");
    }
  }
  const metadata = storage == null ? void 0 : storage.metadata;
  const hasValue = Boolean(internalValue);
  const snackbarContext = useSnackbarController();
  let t1;
  if ($[0] !== storage.acceptedFiles) {
    t1 = storage.acceptedFiles ? storage.acceptedFiles.map(_temp$l).reduce(_temp2$a, {}) : void 0;
    $[0] = storage.acceptedFiles;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== snackbarContext || $[3] !== storage.maxSize) {
    t2 = (fileRejections, event) => {
      for (const fileRejection of fileRejections) {
        for (const error_0 of fileRejection.errors) {
          console.error("Error uploading file: ", error_0);
          if (error_0.code === "file-too-large") {
            snackbarContext.open({
              type: "error",
              message: `Error uploading file: File is larger than ${storage.maxSize} bytes`
            });
          } else {
            if (error_0.code === "file-invalid-type") {
              snackbarContext.open({
                type: "error",
                message: "Error uploading file: File type is not supported"
              });
            }
          }
        }
      }
    };
    $[2] = snackbarContext;
    $[3] = storage.maxSize;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== disabled || $[6] !== onFilesAdded || $[7] !== storage.maxSize || $[8] !== t1 || $[9] !== t2) {
    t3 = {
      accept: t1,
      disabled,
      maxSize: storage.maxSize,
      noClick: true,
      noKeyboard: true,
      onDrop: onFilesAdded,
      onDropRejected: t2
    };
    $[5] = disabled;
    $[6] = onFilesAdded;
    $[7] = storage.maxSize;
    $[8] = t1;
    $[9] = t2;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  const {
    open,
    getRootProps,
    getInputProps,
    isDragActive,
    isDragAccept,
    isDragReject
  } = useDropzone(t3);
  let t4;
  if ($[11] !== getRootProps) {
    t4 = getRootProps();
    $[11] = getRootProps;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  let rootProps;
  if ($[13] !== t4) {
    ({
      ...rootProps
    } = t4);
    $[13] = t4;
    $[14] = rootProps;
  } else {
    rootProps = $[14];
  }
  const helpText = multipleFilesSupported ? "Drag 'n' drop some files here, or click here to edit" : "Drag 'n' drop a file here, or click here edit";
  const renderProperty = multipleFilesSupported ? property.of : property;
  let t5;
  let t6;
  if ($[15] !== previewSize) {
    t6 = getThumbnailMeasure(previewSize);
    $[15] = previewSize;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  t5 = t6;
  const imageSize = t5;
  const showError = !disabled && error2;
  const t7 = `justify-${hasValue ? "start" : "center"}`;
  const t8 = isDragActive ? activeDropClasses$1 : "";
  const t9 = isDragAccept ? acceptDropClasses$1 : "";
  const t10 = isDragReject ? rejectDropClasses$1 : "";
  let t11;
  if ($[17] !== t10 || $[18] !== t7 || $[19] !== t8 || $[20] !== t9) {
    t11 = cls(dropZoneClasses$1, "relative w-full h-full flex", t7, t8, t9, t10);
    $[17] = t10;
    $[18] = t7;
    $[19] = t8;
    $[20] = t9;
    $[21] = t11;
  } else {
    t11 = $[21];
  }
  let t12;
  if ($[22] !== getInputProps) {
    t12 = getInputProps();
    $[22] = getInputProps;
    $[23] = t12;
  } else {
    t12 = $[23];
  }
  let t13;
  if ($[24] !== autoFocus || $[25] !== t12) {
    t13 = (0, import_jsx_runtime2.jsx)("input", { autoFocus, ...t12 });
    $[24] = autoFocus;
    $[25] = t12;
    $[26] = t13;
  } else {
    t13 = $[26];
  }
  let t14;
  if ($[27] !== entity || $[28] !== imageSize || $[29] !== internalValue || $[30] !== metadata || $[31] !== onFileUploadComplete || $[32] !== previewSize || $[33] !== renderProperty || $[34] !== storagePathBuilder) {
    let t152;
    if ($[36] !== entity || $[37] !== imageSize || $[38] !== metadata || $[39] !== onFileUploadComplete || $[40] !== previewSize || $[41] !== renderProperty || $[42] !== storagePathBuilder) {
      t152 = (entry, index2) => {
        let child;
        if (entry.storagePathOrDownloadUrl) {
          child = (0, import_jsx_runtime2.jsx)(TableStorageItemPreview, { property: renderProperty, value: entry.storagePathOrDownloadUrl, entity, size: previewSize }, `storage_preview_${index2}`);
        } else {
          if (entry.file) {
            child = (0, import_jsx_runtime2.jsx)(StorageUploadProgress, { entry, metadata, storagePath: storagePathBuilder(entry.file), onFileUploadComplete, imageSize, simple: true }, `storage_progress_${index2}`);
          }
        }
        return child;
      };
      $[36] = entity;
      $[37] = imageSize;
      $[38] = metadata;
      $[39] = onFileUploadComplete;
      $[40] = previewSize;
      $[41] = renderProperty;
      $[42] = storagePathBuilder;
      $[43] = t152;
    } else {
      t152 = $[43];
    }
    t14 = internalValue.map(t152);
    $[27] = entity;
    $[28] = imageSize;
    $[29] = internalValue;
    $[30] = metadata;
    $[31] = onFileUploadComplete;
    $[32] = previewSize;
    $[33] = renderProperty;
    $[34] = storagePathBuilder;
    $[35] = t14;
  } else {
    t14 = $[35];
  }
  let t15;
  if ($[44] !== helpText || $[45] !== internalValue || $[46] !== open) {
    t15 = !internalValue && (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow m-2 max-w-[200px]", onClick: open, children: (0, import_jsx_runtime2.jsx)(Typography, { className: "text-surface-400 dark:text-surface-600", variant: "body2", align: "center", children: helpText }) });
    $[44] = helpText;
    $[45] = internalValue;
    $[46] = open;
    $[47] = t15;
  } else {
    t15 = $[47];
  }
  const t16 = !disabled ? openPopup : void 0;
  let t17;
  if ($[48] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = (0, import_jsx_runtime2.jsx)(EditIcon, { size: "small", className: "text-surface-500" });
    $[48] = t17;
  } else {
    t17 = $[48];
  }
  let t18;
  if ($[49] !== open) {
    t18 = (0, import_jsx_runtime2.jsx)(IconButton, { color: "inherit", size: "small", onClick: open, children: t17 });
    $[49] = open;
    $[50] = t18;
  } else {
    t18 = $[50];
  }
  let t19;
  if ($[51] !== disabled || $[52] !== selected || $[53] !== showError || $[54] !== t16 || $[55] !== t18) {
    t19 = (0, import_jsx_runtime2.jsx)(EntityTableCellActions, { showError, disabled, showExpandIcon: true, selected, openPopup: t16, children: t18 });
    $[51] = disabled;
    $[52] = selected;
    $[53] = showError;
    $[54] = t16;
    $[55] = t18;
    $[56] = t19;
  } else {
    t19 = $[56];
  }
  let t20;
  if ($[57] !== rootProps || $[58] !== t11 || $[59] !== t13 || $[60] !== t14 || $[61] !== t15 || $[62] !== t19) {
    t20 = (0, import_jsx_runtime2.jsxs)("div", { ...rootProps, className: t11, children: [
      t13,
      t14,
      t15,
      t19
    ] });
    $[57] = rootProps;
    $[58] = t11;
    $[59] = t13;
    $[60] = t14;
    $[61] = t15;
    $[62] = t19;
    $[63] = t20;
  } else {
    t20 = $[63];
  }
  return t20;
}
function _temp2$a(a2, b2) {
  return {
    ...a2,
    ...b2
  };
}
function _temp$l(e2) {
  return {
    [e2]: []
  };
}
function TableStorageItemPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    property,
    value,
    size: size2
  } = t0;
  let t1;
  if ($[0] !== property || $[1] !== size2 || $[2] !== value) {
    t1 = value && (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey: "ignore", value, property, size: size2 }) });
    $[0] = property;
    $[1] = size2;
    $[2] = value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)("div", { className: "relative p-2 max-w-full", children: t1 });
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
function TableReferenceField(props) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(9);
  const customizationController = useCustomizationController();
  const navigationController = useNavigationController();
  const {
    path
  } = props;
  let t0;
  if ($[0] !== navigationController || $[1] !== path) {
    t0 = navigationController.getCollection(path);
    $[0] = navigationController;
    $[1] = path;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const collection = t0;
  if (!collection) {
    if ((_a = customizationController.components) == null ? void 0 : _a.missingReference) {
      let t12;
      if ($[3] !== customizationController.components.missingReference || $[4] !== path) {
        t12 = (0, import_jsx_runtime2.jsx)(customizationController.components.missingReference, { path });
        $[3] = customizationController.components.missingReference;
        $[4] = path;
        $[5] = t12;
      } else {
        t12 = $[5];
      }
      return t12;
    } else {
      throw Error(`Couldn't find the corresponding collection view for the path: ${path}`);
    }
  }
  let t1;
  if ($[6] !== collection || $[7] !== props) {
    t1 = (0, import_jsx_runtime2.jsx)(TableReferenceFieldInternal, { ...props, collection });
    $[6] = collection;
    $[7] = props;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  return t1;
}
var TableReferenceFieldInternal = import_react14.default.memo(function TableReferenceFieldInternal2(props) {
  const $ = (0, import_react_compiler_runtime3.c)(54);
  const {
    name,
    internalValue,
    updateValue,
    multiselect,
    path,
    size: size2,
    previewProperties,
    title,
    disabled,
    forceFilter,
    collection,
    includeId,
    includeEntityLink
  } = props;
  let t0;
  if ($[0] !== updateValue) {
    t0 = (entity) => {
      updateValue(entity ? getReferenceFrom(entity) : null);
    };
    $[0] = updateValue;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const onSingleEntitySelected = t0;
  let t1;
  if ($[2] !== updateValue) {
    t1 = (entities) => {
      updateValue(entities.map(_temp$k));
    };
    $[2] = updateValue;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const onMultipleEntitiesSelected = t1;
  let t2;
  if ($[4] !== internalValue) {
    t2 = internalValue ? Array.isArray(internalValue) ? internalValue.map(_temp2$9) : internalValue.id ? [internalValue.id] : [] : [];
    $[4] = internalValue;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const selectedEntityIds = t2;
  let t3;
  if ($[6] !== collection || $[7] !== forceFilter || $[8] !== multiselect || $[9] !== onMultipleEntitiesSelected || $[10] !== onSingleEntitySelected || $[11] !== path || $[12] !== selectedEntityIds) {
    t3 = {
      multiselect,
      path,
      collection,
      onMultipleEntitiesSelected,
      onSingleEntitySelected,
      selectedEntityIds,
      forceFilter
    };
    $[6] = collection;
    $[7] = forceFilter;
    $[8] = multiselect;
    $[9] = onMultipleEntitiesSelected;
    $[10] = onSingleEntitySelected;
    $[11] = path;
    $[12] = selectedEntityIds;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  const referenceDialogController = useReferenceDialog(t3);
  let t4;
  if ($[14] !== disabled || $[15] !== referenceDialogController) {
    t4 = () => {
      if (disabled) {
        return;
      }
      referenceDialogController.open();
    };
    $[14] = disabled;
    $[15] = referenceDialogController;
    $[16] = t4;
  } else {
    t4 = $[16];
  }
  const handleOpen = t4;
  const valueNotSet = !internalValue || Array.isArray(internalValue) && internalValue.length === 0;
  let t5;
  if ($[17] !== disabled || $[18] !== handleOpen || $[19] !== includeEntityLink || $[20] !== includeId || $[21] !== internalValue || $[22] !== path || $[23] !== previewProperties || $[24] !== size2) {
    t5 = () => {
      if (internalValue && !Array.isArray(internalValue) && internalValue.isEntityReference && internalValue.isEntityReference()) {
        return (0, import_jsx_runtime2.jsx)(ReferencePreview, { onClick: disabled ? void 0 : handleOpen, size: getPreviewSizeFrom(size2), reference: internalValue, hover: !disabled, disabled: !path, previewProperties, includeId, includeEntityLink });
      } else {
        return (0, import_jsx_runtime2.jsx)(EntityPreviewContainer, { onClick: disabled ? void 0 : handleOpen, size: getPreviewSizeFrom(size2), children: (0, import_jsx_runtime2.jsx)(ErrorView, { title: "Value is not a reference.", error: "Click to edit" }) });
      }
    };
    $[17] = disabled;
    $[18] = handleOpen;
    $[19] = includeEntityLink;
    $[20] = includeId;
    $[21] = internalValue;
    $[22] = path;
    $[23] = previewProperties;
    $[24] = size2;
    $[25] = t5;
  } else {
    t5 = $[25];
  }
  const buildSingleReferenceField = t5;
  let t6;
  if ($[26] !== disabled || $[27] !== handleOpen || $[28] !== includeEntityLink || $[29] !== includeId || $[30] !== internalValue || $[31] !== name || $[32] !== path || $[33] !== previewProperties) {
    t6 = () => {
      if (Array.isArray(internalValue)) {
        return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: internalValue.map((reference2, index2) => (0, import_jsx_runtime2.jsx)("div", { className: "w-full my-0.5", children: (0, import_jsx_runtime2.jsx)(ReferencePreview, { onClick: disabled ? void 0 : handleOpen, size: "small", reference: reference2, hover: !disabled, disabled: !path, previewProperties, includeId, includeEntityLink }) }, `preview_array_ref_${name}_${index2}`)) });
      } else {
        return (0, import_jsx_runtime2.jsx)(ErrorView, { error: "Data is not an array of references" });
      }
    };
    $[26] = disabled;
    $[27] = handleOpen;
    $[28] = includeEntityLink;
    $[29] = includeId;
    $[30] = internalValue;
    $[31] = name;
    $[32] = path;
    $[33] = previewProperties;
    $[34] = t6;
  } else {
    t6 = $[34];
  }
  const buildMultipleReferenceField = t6;
  if (!collection) {
    let t72;
    if ($[35] === Symbol.for("react.memo_cache_sentinel")) {
      t72 = (0, import_jsx_runtime2.jsx)(ErrorView, { error: "The specified collection does not exist" });
      $[35] = t72;
    } else {
      t72 = $[35];
    }
    return t72;
  }
  let t7;
  if ($[36] !== buildSingleReferenceField || $[37] !== internalValue || $[38] !== multiselect) {
    t7 = internalValue && !multiselect && buildSingleReferenceField();
    $[36] = buildSingleReferenceField;
    $[37] = internalValue;
    $[38] = multiselect;
    $[39] = t7;
  } else {
    t7 = $[39];
  }
  let t8;
  if ($[40] !== buildMultipleReferenceField || $[41] !== internalValue || $[42] !== multiselect) {
    t8 = internalValue && multiselect && buildMultipleReferenceField();
    $[40] = buildMultipleReferenceField;
    $[41] = internalValue;
    $[42] = multiselect;
    $[43] = t8;
  } else {
    t8 = $[43];
  }
  let t9;
  if ($[44] !== disabled || $[45] !== handleOpen || $[46] !== multiselect || $[47] !== title || $[48] !== valueNotSet) {
    t9 = valueNotSet && (0, import_jsx_runtime2.jsxs)(EntityPreviewContainer, { className: cls("px-3 py-2 text-sm font-medium flex items-center", multiselect ? "gap-4" : "gap-6", disabled ? "text-surface-accent-500" : "cursor-pointer text-text-secondary dark:text-text-secondary-dark hover:bg-surface-accent-50 dark:hover:bg-surface-800 group-hover:bg-surface-accent-50 dark:group-hover:bg-surface-800"), onClick: handleOpen, size: "medium", children: [
      (0, import_jsx_runtime2.jsx)(EditIcon, { size: "small", className: "ml-2 mr-1 text-surface-300 dark:text-surface-600" }),
      title
    ] });
    $[44] = disabled;
    $[45] = handleOpen;
    $[46] = multiselect;
    $[47] = title;
    $[48] = valueNotSet;
    $[49] = t9;
  } else {
    t9 = $[49];
  }
  let t10;
  if ($[50] !== t7 || $[51] !== t8 || $[52] !== t9) {
    t10 = (0, import_jsx_runtime2.jsxs)("div", { className: "w-full group", children: [
      t7,
      t8,
      t9
    ] });
    $[50] = t7;
    $[51] = t8;
    $[52] = t9;
    $[53] = t10;
  } else {
    t10 = $[53];
  }
  return t10;
}, import_react_fast_compare2.default);
function _temp$k(e2) {
  return getReferenceFrom(e2);
}
function _temp2$9(ref2) {
  return ref2.id;
}
addMethod(create7, "uniqueInArray", function(mapper = (a2) => a2, message2) {
  return this.test("uniqueInArray", message2, (values) => {
    return !values || values.length === new Set(values.map(mapper)).size;
  });
});
function getYupEntitySchema(entityId, properties, customFieldValidator) {
  const objectSchema = {};
  Object.entries(properties).forEach(([name, property]) => {
    objectSchema[name] = mapPropertyToYup({
      property,
      customFieldValidator,
      name,
      entityId
    });
  });
  return create6().shape(objectSchema);
}
function mapPropertyToYup(propertyContext) {
  const property = propertyContext.property;
  if (isPropertyBuilder(property)) {
    console.error("Error in property", propertyContext);
    throw Error("Trying to create a yup mapping from a property builder. Please use resolved properties only");
  }
  if (property.dataType === "string") {
    return getYupStringSchema(propertyContext);
  } else if (property.dataType === "number") {
    return getYupNumberSchema(propertyContext);
  } else if (property.dataType === "boolean") {
    return getYupBooleanSchema(propertyContext);
  } else if (property.dataType === "map") {
    return getYupMapObjectSchema(propertyContext);
  } else if (property.dataType === "array") {
    return getYupArraySchema(propertyContext);
  } else if (property.dataType === "date") {
    return getYupDateSchema(propertyContext);
  } else if (property.dataType === "geopoint") {
    return getYupGeoPointSchema(propertyContext);
  } else if (property.dataType === "reference") {
    return getYupReferenceSchema(propertyContext);
  }
  console.error("Unsupported data type in yup mapping", property);
  throw Error("Unsupported data type in yup mapping");
}
function getYupMapObjectSchema({
  property,
  entityId,
  customFieldValidator,
  name
}) {
  const objectSchema = {};
  const validation = property.validation;
  if (property.properties) Object.entries(property.properties).forEach(([childName, childProperty]) => {
    objectSchema[childName] = mapPropertyToYup({
      property: childProperty,
      parentProperty: property,
      customFieldValidator,
      name: `${name}[${childName}]`,
      entityId
    });
  });
  const shape = create6().shape(objectSchema);
  if (validation == null ? void 0 : validation.required) {
    return shape.required((validation == null ? void 0 : validation.requiredMessage) ? validation.requiredMessage : "Required").nullable(true);
  }
  return create6().shape(shape.fields).default(void 0).notRequired().nullable(true);
}
function getYupStringSchema({
  property,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  var _a;
  let collection = create3();
  const validation = property.validation;
  if (property.enumValues) {
    if (validation == null ? void 0 : validation.required) collection = collection.required((validation == null ? void 0 : validation.requiredMessage) ? validation.requiredMessage : "Required");
    const entries = enumToObjectEntries(property.enumValues);
    collection = collection.oneOf(((validation == null ? void 0 : validation.required) ? entries : [...entries, null]).map((enumValueConfig) => (enumValueConfig == null ? void 0 : enumValueConfig.id) ?? null)).nullable(true);
  }
  if (validation) {
    collection = validation.required ? collection.required((validation == null ? void 0 : validation.requiredMessage) ? validation.requiredMessage : "Required").nullable(true) : collection.notRequired().nullable(true);
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value, context) => customFieldValidator({
      name,
      property,
      parentProperty,
      value,
      entityId
    }));
    if (validation.min || validation.min === 0) collection = collection.min(validation.min, `${property.name} must be min ${validation.min} characters long`);
    if (validation.max || validation.max === 0) collection = collection.max(validation.max, `${property.name} must be max ${validation.max} characters long`);
    if (validation.matches) {
      const regExp = typeof validation.matches === "string" ? hydrateRegExp(validation.matches) : validation.matches;
      if (regExp) {
        collection = collection.matches(regExp, validation.matchesMessage ? {
          message: validation.matchesMessage
        } : void 0);
      }
    }
    if (validation.trim) collection = collection.trim();
    if (validation.lowercase) collection = collection.lowercase();
    if (validation.uppercase) collection = collection.uppercase();
    if (property.email) collection = collection.email(`${property.name} must be an email`);
    if (property.url) {
      if (!property.storage || ((_a = property.storage) == null ? void 0 : _a.storeUrl)) {
        collection = collection.url(`${property.name} must be a url`);
      } else {
        console.warn(`Property ${property.name} has a url validation but its storage configuration is not set to store urls`);
      }
    }
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function getYupNumberSchema({
  property,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  const validation = property.validation;
  let collection = create4().typeError("Must be a number");
  if (validation) {
    collection = validation.required ? collection.required(validation.requiredMessage ? validation.requiredMessage : "Required").nullable(true) : collection.notRequired().nullable(true);
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
      name,
      property,
      parentProperty,
      value,
      entityId
    }));
    if (validation.min || validation.min === 0) collection = collection.min(validation.min, `${property.name} must be higher or equal to ${validation.min}`);
    if (validation.max || validation.max === 0) collection = collection.max(validation.max, `${property.name} must be lower or equal to ${validation.max}`);
    if (validation.lessThan || validation.lessThan === 0) collection = collection.lessThan(validation.lessThan, `${property.name} must be higher than ${validation.lessThan}`);
    if (validation.moreThan || validation.moreThan === 0) collection = collection.moreThan(validation.moreThan, `${property.name} must be lower than ${validation.moreThan}`);
    if (validation.positive) collection = collection.positive(`${property.name} must be positive`);
    if (validation.negative) collection = collection.negative(`${property.name} must be negative`);
    if (validation.integer) collection = collection.integer(`${property.name} must be an integer`);
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function getYupGeoPointSchema({
  property,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let collection = create6();
  const validation = property.validation;
  if ((validation == null ? void 0 : validation.unique) && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
    name,
    property,
    parentProperty,
    value,
    entityId
  }));
  if (validation == null ? void 0 : validation.required) {
    collection = collection.required(validation.requiredMessage).nullable(true);
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function getYupDateSchema({
  property,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  if (property.autoValue) {
    return create6().nullable();
  }
  let collection = create5();
  const validation = property.validation;
  if (validation) {
    collection = validation.required ? collection.required((validation == null ? void 0 : validation.requiredMessage) ? validation.requiredMessage : "Required") : collection.notRequired();
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
      name,
      property,
      parentProperty,
      value,
      entityId
    }));
    if (validation.min) collection = collection.min(validation.min, `${property.name} must be after ${validation.min}`);
    if (validation.max) collection = collection.max(validation.max, `${property.name} must be before ${validation.min}`);
  } else {
    collection = collection.notRequired();
  }
  return collection.transform((v) => v instanceof Date ? v : null).nullable();
}
function getYupReferenceSchema({
  property,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let collection = create6();
  const validation = property.validation;
  if (validation) {
    collection = validation.required ? collection.required((validation == null ? void 0 : validation.requiredMessage) ? validation.requiredMessage : "Required").nullable(true) : collection.notRequired().nullable(true);
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
      name,
      property,
      parentProperty,
      value,
      entityId
    }));
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function getYupBooleanSchema({
  property,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let collection = create2();
  const validation = property.validation;
  if (validation) {
    collection = validation.required ? collection.required((validation == null ? void 0 : validation.requiredMessage) ? validation.requiredMessage : "Required").nullable(true) : collection.notRequired().nullable(true);
    if (validation.unique && customFieldValidator && name) collection = collection.test("unique", "This value already exists and should be unique", (value) => customFieldValidator({
      name,
      property,
      parentProperty,
      value,
      entityId
    }));
  } else {
    collection = collection.notRequired().nullable(true);
  }
  return collection;
}
function hasUniqueInArrayModifier(property) {
  var _a;
  if ((_a = property.validation) == null ? void 0 : _a.uniqueInArray) {
    return true;
  } else if (property.dataType === "map" && property.properties) {
    return Object.entries(property.properties).filter(([key, childProperty]) => {
      var _a2;
      return (_a2 = childProperty.validation) == null ? void 0 : _a2.uniqueInArray;
    });
  }
  return false;
}
function getYupArraySchema({
  property,
  parentProperty,
  customFieldValidator,
  name,
  entityId
}) {
  let arraySchema = create7();
  if (property.of) {
    if (Array.isArray(property.of)) {
      const yupProperties = property.of.map((p3, index2) => ({
        [`${name}[${index2}]`]: mapPropertyToYup({
          property: p3,
          parentProperty: property,
          entityId
        })
      })).reduce((a2, b2) => ({
        ...a2,
        ...b2
      }), {});
      return create7().of(create().test("Dynamic object validation", "Dynamic object validation error", (object2, context) => {
        const yupProperty = getValueInPath(yupProperties, context.path);
        return yupProperty.validate(object2);
      }));
    } else {
      arraySchema = arraySchema.of(mapPropertyToYup({
        property: property.of,
        parentProperty: property,
        entityId
      }));
      const arrayUniqueFields = hasUniqueInArrayModifier(property.of);
      if (arrayUniqueFields) {
        if (typeof arrayUniqueFields === "boolean") {
          arraySchema = arraySchema.uniqueInArray((v) => v, `${property.name} should have unique values within the array`);
        } else if (Array.isArray(arrayUniqueFields)) {
          arrayUniqueFields.forEach(([name2, childProperty]) => {
            arraySchema = arraySchema.uniqueInArray((v) => v && v[name2], `${property.name} → ${childProperty.name ?? name2}: should have unique values within the array`);
          });
        }
      }
    }
  }
  const validation = property.validation;
  if (validation) {
    arraySchema = validation.required ? arraySchema.required((validation == null ? void 0 : validation.requiredMessage) ? validation.requiredMessage : "Required").nullable(true) : arraySchema.notRequired().nullable(true);
    if (validation.min || validation.min === 0) arraySchema = arraySchema.min(validation.min, `${property.name} should be min ${validation.min} entries long`);
    if (validation.max) arraySchema = arraySchema.max(validation.max, `${property.name} should be max ${validation.max} entries long`);
  } else {
    arraySchema = arraySchema.notRequired().nullable(true);
  }
  return arraySchema;
}
function getRowHeight3(size2) {
  switch (size2) {
    case "xl":
      return 400;
    case "l":
      return 280;
    case "m":
      return 140;
    case "s":
      return 80;
    case "xs":
      return 54;
    default:
      throw Error("Missing mapping for collection size -> height");
  }
}
var TableCellInner = (t0) => {
  const $ = (0, import_react_compiler_runtime3.c)(12);
  const {
    justifyContent,
    scrollable,
    faded,
    fullHeight,
    children
  } = t0;
  const t1 = faded || scrollable;
  let t2;
  if ($[0] !== t1) {
    t2 = cls("flex flex-col max-h-full w-full", {
      "items-start": t1
    });
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const t3 = fullHeight ? "100%" : void 0;
  const t4 = scrollable ? "auto" : void 0;
  const t5 = faded ? "linear-gradient(to bottom, black 60%, transparent 100%)" : void 0;
  const t6 = faded ? "linear-gradient(to bottom, black 60%, transparent 100%)" : void 0;
  let t7;
  if ($[2] !== justifyContent || $[3] !== t3 || $[4] !== t4 || $[5] !== t5 || $[6] !== t6) {
    t7 = {
      justifyContent,
      height: t3,
      overflow: t4,
      WebkitMaskImage: t5,
      maskImage: t6
    };
    $[2] = justifyContent;
    $[3] = t3;
    $[4] = t4;
    $[5] = t5;
    $[6] = t6;
    $[7] = t7;
  } else {
    t7 = $[7];
  }
  let t8;
  if ($[8] !== children || $[9] !== t2 || $[10] !== t7) {
    t8 = (0, import_jsx_runtime2.jsx)("div", { className: t2, style: t7, children });
    $[8] = children;
    $[9] = t2;
    $[10] = t7;
    $[11] = t8;
  } else {
    t8 = $[11];
  }
  return t8;
};
var EntityTableCell = import_react14.default.memo(function EntityTableCell2(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(45);
  const {
    children,
    actions,
    size: size2,
    selected,
    disabled,
    disabledTooltip,
    saved,
    error: error2,
    align,
    allowScroll,
    removePadding,
    fullHeight,
    onSelect,
    width,
    hideOverflow: t1,
    showExpandIcon: t2
  } = t0;
  const hideOverflow = t1 === void 0 ? true : t1;
  const [measureRef, bounds] = j();
  const ref2 = (0, import_react14.useRef)(null);
  let t3;
  t3 = getRowHeight3(size2);
  const maxHeight = t3;
  const [onHover, setOnHover] = (0, import_react14.useState)(false);
  const [internalSaved, setInternalSaved] = (0, import_react14.useState)(saved);
  const showError = !disabled && Boolean(error2);
  let t4;
  let t5;
  if ($[0] !== saved) {
    t4 = () => {
      if (saved) {
        setInternalSaved(true);
      }
      const handler = setTimeout(() => {
        setInternalSaved(false);
      }, 800);
      return () => {
        clearTimeout(handler);
      };
    };
    t5 = [saved];
    $[0] = saved;
    $[1] = t4;
    $[2] = t5;
  } else {
    t4 = $[1];
    t5 = $[2];
  }
  (0, import_react14.useEffect)(t4, t5);
  let p3 = 0;
  if (!removePadding) {
    bb0: switch (size2) {
      case "l":
      case "xl": {
        p3 = 4;
        break bb0;
      }
      case "m": {
        p3 = 2;
        break bb0;
      }
      case "s":
      default: {
        p3 = 1;
      }
    }
  }
  let justifyContent;
  bb1: switch (align) {
    case "right": {
      justifyContent = "flex-end";
      break bb1;
    }
    case "center": {
      justifyContent = "center";
      break bb1;
    }
    case "left":
    default: {
      justifyContent = "flex-start";
    }
  }
  let t6;
  if ($[3] !== disabled || $[4] !== onSelect || $[5] !== selected) {
    t6 = () => {
      var _a;
      if (!onSelect) {
        return;
      }
      const cellRect = ref2 && ((_a = ref2 == null ? void 0 : ref2.current) == null ? void 0 : _a.getBoundingClientRect());
      if (disabled) {
        onSelect(void 0);
      } else {
        if (!selected && cellRect) {
          onSelect(cellRect);
        }
      }
    };
    $[3] = disabled;
    $[4] = onSelect;
    $[5] = selected;
    $[6] = t6;
  } else {
    t6 = $[6];
  }
  const onSelectCallback = t6;
  let t7;
  if ($[7] !== onSelectCallback) {
    t7 = (event) => {
      event.stopPropagation();
      event.preventDefault();
      onSelectCallback();
    };
    $[7] = onSelectCallback;
    $[8] = t7;
  } else {
    t7 = $[8];
  }
  const onFocus = t7;
  let t8;
  bb2: {
    if (bounds) {
      t8 = bounds.height > maxHeight;
      break bb2;
    }
    t8 = false;
  }
  const isOverflowing = t8;
  const isSelected = !showError && selected;
  const scrollable = !disabled && allowScroll && isOverflowing;
  const faded = !disabled && !allowScroll && isOverflowing;
  let t9;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = () => setOnHover(true);
    $[9] = t9;
  } else {
    t9 = $[9];
  }
  const setOnHoverTrue = t9;
  let t10;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = () => setOnHover(false);
    $[10] = t10;
  } else {
    t10 = $[10];
  }
  const setOnHoverFalse = t10;
  const borderClass = showError ? "border-red-500" : internalSaved ? "border-green-500" : isSelected ? "border-primary" : "border-transparent";
  const t11 = `flex relative h-full rounded-md p-${p3} border border-4  border-opacity-75`;
  const t12 = onHover && !disabled ? "bg-surface-50 dark:bg-surface-900" : "";
  const t13 = saved ? "bg-surface-100 bg-opacity-75 dark:bg-surface-800 dark:bg-opacity-75" : "";
  const t14 = hideOverflow ? "overflow-hidden" : "";
  const t15 = isSelected ? "bg-surface-50 dark:bg-surface-900" : "";
  let t16;
  if ($[11] !== borderClass || $[12] !== t11 || $[13] !== t12 || $[14] !== t13 || $[15] !== t14 || $[16] !== t15) {
    t16 = cls("transition-colors duration-100 ease-in-out", t11, t12, t13, t14, t15, borderClass);
    $[11] = borderClass;
    $[12] = t11;
    $[13] = t12;
    $[14] = t13;
    $[15] = t14;
    $[16] = t15;
    $[17] = t16;
  } else {
    t16 = $[17];
  }
  const t17 = disabled || !isOverflowing ? "center" : void 0;
  const t18 = width ?? "100%";
  let t19;
  if ($[18] !== align || $[19] !== justifyContent || $[20] !== t17 || $[21] !== t18) {
    t19 = {
      justifyContent,
      alignItems: t17,
      width: t18,
      textAlign: align
    };
    $[18] = align;
    $[19] = justifyContent;
    $[20] = t17;
    $[21] = t18;
    $[22] = t19;
  } else {
    t19 = $[22];
  }
  const t20 = selected || disabled ? void 0 : 0;
  const t21 = fullHeight && !faded && children;
  let t22;
  if ($[23] !== children || $[24] !== faded || $[25] !== fullHeight || $[26] !== justifyContent || $[27] !== measureRef || $[28] !== scrollable) {
    t22 = (!fullHeight || faded) && (0, import_jsx_runtime2.jsx)(TableCellInner, { fullHeight: fullHeight ?? false, justifyContent, scrollable: scrollable ?? false, faded, children: !fullHeight && (0, import_jsx_runtime2.jsx)("div", { ref: measureRef, style: {
      display: "flex",
      width: "100%",
      justifyContent,
      height: fullHeight ? "100%" : void 0
    }, children }) });
    $[23] = children;
    $[24] = faded;
    $[25] = fullHeight;
    $[26] = justifyContent;
    $[27] = measureRef;
    $[28] = scrollable;
    $[29] = t22;
  } else {
    t22 = $[29];
  }
  let t23;
  if ($[30] !== t21 || $[31] !== t22) {
    t23 = (0, import_jsx_runtime2.jsxs)(ErrorBoundary2, { children: [
      t21,
      t22
    ] });
    $[30] = t21;
    $[31] = t22;
    $[32] = t23;
  } else {
    t23 = $[32];
  }
  let t24;
  if ($[33] !== disabled || $[34] !== disabledTooltip || $[35] !== onHover) {
    t24 = disabled && onHover && disabledTooltip && (0, import_jsx_runtime2.jsx)("div", { className: "absolute top-1 right-1 text-xs", children: (0, import_jsx_runtime2.jsx)(Tooltip, { title: disabledTooltip, children: (0, import_jsx_runtime2.jsx)(DoNotDisturbOnIcon, { size: "smallest", color: "disabled", className: "text-surface-500" }) }) });
    $[33] = disabled;
    $[34] = disabledTooltip;
    $[35] = onHover;
    $[36] = t24;
  } else {
    t24 = $[36];
  }
  let t25;
  if ($[37] !== actions || $[38] !== onFocus || $[39] !== t16 || $[40] !== t19 || $[41] !== t20 || $[42] !== t23 || $[43] !== t24) {
    t25 = (0, import_jsx_runtime2.jsxs)("div", { className: t16, ref: ref2, style: t19, tabIndex: t20, onFocus, onMouseEnter: setOnHoverTrue, onMouseMove: setOnHoverTrue, onMouseLeave: setOnHoverFalse, children: [
      t23,
      actions,
      t24
    ] });
    $[37] = actions;
    $[38] = onFocus;
    $[39] = t16;
    $[40] = t19;
    $[41] = t20;
    $[42] = t23;
    $[43] = t24;
    $[44] = t25;
  } else {
    t25 = $[44];
  }
  return t25;
}, (a2, b2) => {
  return a2.error === b2.error && a2.value === b2.value && a2.disabled === b2.disabled && a2.saved === b2.saved && a2.allowScroll === b2.allowScroll && a2.align === b2.align && a2.size === b2.size && a2.disabledTooltip === b2.disabledTooltip && a2.width === b2.width && a2.showExpandIcon === b2.showExpandIcon && a2.removePadding === b2.removePadding && a2.fullHeight === b2.fullHeight && a2.selected === b2.selected;
});
var SelectableTableContext = import_react14.default.createContext({});
var useSelectableTableController = () => {
  return (0, import_react14.useContext)(SelectableTableContext);
};
function useClearRestoreValue(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    property,
    value,
    setValue
  } = t0;
  const clearedValueRef = (0, import_react14.useRef)(null);
  let t1;
  if ($[0] !== property.disabled || $[1] !== setValue || $[2] !== value) {
    t1 = () => {
      const shouldClearValueIfDisabled = typeof property.disabled === "object" && Boolean(property.disabled.clearOnDisabled);
      if (shouldClearValueIfDisabled) {
        if (value != null) {
          clearedValueRef.current = value;
          setValue(null);
        }
      } else {
        if (clearedValueRef.current) {
          setValue(clearedValueRef.current);
          clearedValueRef.current = null;
        }
      }
    };
    $[0] = property.disabled;
    $[1] = setValue;
    $[2] = value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== property) {
    t2 = [property];
    $[4] = property;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  (0, import_react14.useEffect)(t1, t2);
}
function isStorageProperty(property) {
  var _a, _b;
  if (property.dataType === "string" && property.markdown) return false;
  if (property.dataType === "string" && property.storage) return true;
  if (property.dataType === "array") {
    if (Array.isArray(property.of)) {
      return false;
    } else {
      return ((_a = property.of) == null ? void 0 : _a.dataType) === "string" && ((_b = property.of) == null ? void 0 : _b.storage);
    }
  }
  return false;
}
var PropertyTableCell = import_react14.default.memo(function PropertyTableCell2({
  propertyKey,
  customFieldValidator,
  value,
  property,
  align,
  width,
  height,
  path,
  entity,
  readonly,
  disabled: disabledProp,
  enablePopupIcon = true
}) {
  const {
    onValueChange,
    size: size2,
    selectedCell,
    select,
    setPopupCell
  } = useSelectableTableController();
  const selected = (selectedCell == null ? void 0 : selectedCell.propertyKey) === propertyKey && (selectedCell == null ? void 0 : selectedCell.entityPath) === entity.path && (selectedCell == null ? void 0 : selectedCell.entityId) === entity.id;
  const [internalValue, setInternalValue] = (0, import_react14.useState)(value);
  const internalValueRef = (0, import_react14.useRef)(value);
  const [error2, setError] = (0, import_react14.useState)();
  const [validationError, setValidationError] = (0, import_react14.useState)();
  const [saved, setSaved] = (0, import_react14.useState)(false);
  const onValueUpdated = (0, import_react14.useCallback)(() => {
    setSaved(true);
    setTimeout(() => {
      setSaved(false);
    }, 100);
  }, []);
  const customField = Boolean(property.Field);
  const customPreview = Boolean(property.Preview);
  const readOnlyProperty = isReadOnly(property);
  const disabledTooltip = typeof property.disabled === "object" ? property.disabled.disabledMessage : void 0;
  const disabled = readonly || disabledProp || Boolean(property.disabled);
  const validation = (0, import_react14.useMemo)(() => mapPropertyToYup({
    property,
    entityId: entity.id,
    customFieldValidator,
    name: propertyKey
  }), [entity.id, property, propertyKey]);
  (0, import_react14.useEffect)(() => {
    if (!(0, import_react_fast_compare2.default)(value, internalValueRef.current)) {
      setValidationError(void 0);
      setInternalValue(value);
      internalValueRef.current = value;
      onValueUpdated();
    }
  }, [onValueUpdated, value]);
  const saveValues = (value_0) => {
    if ((0, import_react_fast_compare2.default)(value_0, internalValueRef.current)) return;
    setSaved(false);
    validation.validate(value_0).then(() => {
      setValidationError(void 0);
      internalValueRef.current = value_0;
      if (onValueChange) {
        try {
          onValueChange({
            value: value_0,
            propertyKey,
            setError,
            onValueUpdated,
            data: entity
          });
        } catch (e2) {
          console.error("onValueChange error", e2);
          setError(e2);
        }
      }
    }).catch((e_0) => {
      setValidationError(e_0);
    });
  };
  (0, import_react14.useEffect)(() => {
    validation.validate(internalValue).then(() => setValidationError(void 0)).catch(setValidationError);
  }, [internalValue, validation, propertyKey, property, entity]);
  const updateValue = (newValue) => {
    let updatedValue;
    if (newValue === void 0) {
      updatedValue = null;
    } else {
      updatedValue = newValue;
    }
    setInternalValue(updatedValue);
    saveValues(updatedValue);
  };
  useClearRestoreValue({
    property,
    value: internalValue,
    setValue: updateValue
  });
  const onSelect = (0, import_react14.useCallback)((cellRect) => {
    if (!cellRect) {
      select(void 0);
    } else {
      select({
        width,
        height,
        entityPath: entity.path,
        entityId: entity.id,
        cellRect,
        propertyKey
      });
    }
  }, [entity, height, propertyKey, select, width]);
  const openPopup = (cellRect_0) => {
    if (!setPopupCell) return;
    if (!cellRect_0) {
      setPopupCell(void 0);
    } else {
      setPopupCell({
        width,
        height,
        entityPath: entity.path,
        entityId: entity.id,
        cellRect: cellRect_0,
        propertyKey
      });
    }
  };
  let innerComponent;
  let allowScroll = false;
  let showExpandIcon = false;
  let hideOverflow = true;
  let removePadding = false;
  let fullHeight = false;
  let includeActions = true;
  const showError = !disabled && error2;
  if (readonly || readOnlyProperty) {
    return (0, import_jsx_runtime2.jsx)(EntityTableCell, { size: size2, width, saved, value: internalValue, align: align ?? "left", fullHeight: false, disabledTooltip: disabledTooltip ?? (readOnlyProperty ? "Read only" : void 0), disabled: true, children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { width, height: getRowHeight3(size2), propertyKey, property, value: internalValue, size: getPreviewSizeFrom(size2) }) }, `${propertyKey}_${entity.path}_${entity.id}`);
  }
  if (!customField && (!customPreview || selected)) {
    const isAStorageProperty = isStorageProperty(property);
    if (isAStorageProperty) {
      innerComponent = (0, import_jsx_runtime2.jsx)(TableStorageUpload, { error: validationError ?? error2, disabled, focused: selected, selected, openPopup: setPopupCell ? openPopup : void 0, property, entity, path, value: internalValue, previewSize: getPreviewSizeFrom(size2), updateValue, propertyKey });
      includeActions = false;
      showExpandIcon = true;
      fullHeight = true;
      removePadding = true;
    } else if (selected && property.dataType === "number") {
      const numberProperty = property;
      if (numberProperty.enumValues) {
        innerComponent = (0, import_jsx_runtime2.jsx)(VirtualTableSelect, { name: propertyKey, multiple: false, disabled, focused: selected, valueType: "number", small: getPreviewSizeFrom(size2) !== "medium", enumValues: numberProperty.enumValues, error: validationError ?? error2, internalValue, updateValue });
        fullHeight = true;
      } else {
        innerComponent = (0, import_jsx_runtime2.jsx)(VirtualTableNumberInput, { align, error: validationError ?? error2, focused: selected, disabled, value: internalValue, updateValue });
        allowScroll = true;
      }
    } else if (selected && property.dataType === "string") {
      const stringProperty = property;
      if (stringProperty.enumValues) {
        innerComponent = (0, import_jsx_runtime2.jsx)(VirtualTableSelect, { name: propertyKey, multiple: false, focused: selected, disabled, valueType: "string", small: getPreviewSizeFrom(size2) !== "medium", enumValues: stringProperty.enumValues, error: validationError ?? error2, internalValue, updateValue });
        fullHeight = true;
      } else if (stringProperty.markdown || !stringProperty.storage) {
        const multiline = Boolean(stringProperty.multiline) || Boolean(stringProperty.markdown);
        innerComponent = (0, import_jsx_runtime2.jsx)(VirtualTableInput, { error: validationError ?? error2, disabled, multiline, focused: selected, value: internalValue, updateValue });
        allowScroll = true;
      }
    } else if (property.dataType === "boolean") {
      innerComponent = (0, import_jsx_runtime2.jsx)(VirtualTableSwitch, { error: validationError ?? error2, disabled, focused: selected, internalValue, updateValue });
    } else if (property.dataType === "date") {
      innerComponent = (0, import_jsx_runtime2.jsx)(VirtualTableDateField, { name: propertyKey, error: validationError ?? error2, disabled, mode: property.mode, focused: selected, internalValue, updateValue });
      fullHeight = true;
      hideOverflow = false;
      allowScroll = false;
    } else if (property.dataType === "reference") {
      if (typeof property.path === "string") {
        innerComponent = (0, import_jsx_runtime2.jsx)(TableReferenceField, { name: propertyKey, internalValue, updateValue, disabled, size: size2, path: property.path, multiselect: false, previewProperties: property.previewProperties, includeId: property.includeId, includeEntityLink: property.includeEntityLink, title: property.name, forceFilter: property.forceFilter });
      }
      allowScroll = false;
    } else if (property.dataType === "array") {
      const arrayProperty = property;
      if (!arrayProperty.of && !arrayProperty.oneOf) {
        throw Error(`You need to specify an 'of' or 'oneOf' prop (or specify a custom field) in your array property ${propertyKey}`);
      }
      if (arrayProperty.of && !Array.isArray(arrayProperty.of)) {
        if (arrayProperty.of.dataType === "string" || arrayProperty.of.dataType === "number") {
          if (selected && arrayProperty.of.enumValues) {
            innerComponent = (0, import_jsx_runtime2.jsx)(VirtualTableSelect, { name: propertyKey, multiple: true, disabled, focused: selected, small: getPreviewSizeFrom(size2) !== "medium", valueType: arrayProperty.of.dataType, enumValues: arrayProperty.of.enumValues, error: validationError ?? error2, internalValue, updateValue });
            allowScroll = true;
            fullHeight = true;
            hideOverflow = false;
          }
        } else if (arrayProperty.of.dataType === "reference") {
          if (typeof arrayProperty.of.path === "string") {
            innerComponent = (0, import_jsx_runtime2.jsx)(TableReferenceField, { name: propertyKey, disabled, internalValue, updateValue, size: size2, multiselect: true, path: arrayProperty.of.path, previewProperties: arrayProperty.of.previewProperties, title: arrayProperty.name, forceFilter: arrayProperty.of.forceFilter, includeId: arrayProperty.of.includeId, includeEntityLink: arrayProperty.of.includeEntityLink });
          }
          allowScroll = false;
        }
      }
    }
  }
  if (!innerComponent) {
    allowScroll = false;
    showExpandIcon = enablePopupIcon && selected && !innerComponent && !disabled && !readOnlyProperty;
    innerComponent = (0, import_jsx_runtime2.jsx)(PropertyPreview, { width, height, propertyKey, value: internalValue, property, size: getPreviewSizeFrom(size2) });
  }
  return (0, import_jsx_runtime2.jsx)(EntityTableCell, { size: size2, width, onSelect, selected, disabled: disabled || readOnlyProperty, disabledTooltip: disabledTooltip ?? "Disabled", removePadding, fullHeight, saved, error: validationError ?? error2, align, allowScroll, showExpandIcon, value: internalValue, hideOverflow, actions: includeActions && (0, import_jsx_runtime2.jsx)(EntityTableCellActions, { showError, disabled, showExpandIcon, selected, openPopup: !disabled ? openPopup : void 0 }), children: innerComponent }, `cell_${propertyKey}_${entity.path}_${entity.id}`);
}, areEqual);
function areEqual(prevProps, nextProps) {
  return prevProps.height === nextProps.height && prevProps.propertyKey === nextProps.propertyKey && prevProps.align === nextProps.align && prevProps.width === nextProps.width && (0, import_react_fast_compare2.default)(prevProps.property, nextProps.property) && (0, import_react_fast_compare2.default)(prevProps.value, nextProps.value) && (0, import_react_fast_compare2.default)(prevProps.entity.id, nextProps.entity.id) && (0, import_react_fast_compare2.default)(prevProps.entity.values, nextProps.entity.values);
}
var LOCAL_STORAGE_PREFIX = "entity_cache::";
var entityCache = /* @__PURE__ */ new Map();
var isLocalStorageAvailable = typeof localStorage !== "undefined";
function customReplacer(key) {
  const value = this[key];
  if (value instanceof Date) {
    return {
      __type: "Date",
      value: value.toISOString()
    };
  }
  if (value instanceof EntityReference) {
    return {
      __type: "EntityReference",
      id: value.id,
      path: value.path
    };
  }
  if (value instanceof GeoPoint) {
    return {
      __type: "GeoPoint",
      latitude: value.latitude,
      longitude: value.longitude
    };
  }
  if (value instanceof Vector) {
    return {
      __type: "Vector",
      value: value.value
    };
  }
  return value;
}
function customReviver(key, value) {
  if (value && typeof value === "object" && "__type" in value) {
    switch (value.__type) {
      case "Date":
        return new Date(value.value);
      case "EntityReference":
        return new EntityReference(value.id, value.path);
      case "GeoPoint":
        return new GeoPoint(value.latitude, value.longitude);
      case "Vector":
        return new Vector(value.value);
      default:
        return value;
    }
  }
  return value;
}
if (isLocalStorageAvailable) {
  try {
    for (let i2 = 0; i2 < localStorage.length; i2++) {
      const fullKey = localStorage.key(i2);
      if (fullKey && fullKey.startsWith(LOCAL_STORAGE_PREFIX)) {
        const path = fullKey.substring(LOCAL_STORAGE_PREFIX.length);
        const entityString = localStorage.getItem(fullKey);
        if (entityString) {
          try {
            const entity = JSON.parse(entityString, customReviver);
            entityCache.set(path, entity);
          } catch (parseError) {
            console.error(`Failed to parse entity for path "${path}" from localStorage:`, parseError);
          }
        }
      }
    }
  } catch (error2) {
    console.error("Error accessing localStorage during initialization:", error2);
  }
}
function saveEntityToCache(path, data) {
  entityCache.set(path, data);
  if (isLocalStorageAvailable) {
    try {
      const key = LOCAL_STORAGE_PREFIX + path;
      const entityString = JSON.stringify(data, customReplacer);
      localStorage.setItem(key, entityString);
    } catch (error2) {
      console.error(`Failed to save entity for path "${path}" to localStorage:`, error2);
    }
  }
}
function getEntityFromCache(path) {
  if (entityCache.has(path)) {
    return entityCache.get(path);
  }
  if (isLocalStorageAvailable) {
    try {
      const key = LOCAL_STORAGE_PREFIX + path;
      const entityString = localStorage.getItem(key);
      if (entityString) {
        const entity = JSON.parse(entityString, customReviver);
        entityCache.set(path, entity);
        return entity;
      }
    } catch (error2) {
      console.error(`Failed to load entity for path "${path}" from localStorage:`, error2);
    }
  }
  return void 0;
}
function hasEntityInCache(path) {
  return entityCache.has(path);
}
function removeEntityFromCache(path) {
  console.debug("Removing entity from cache", path);
  entityCache.delete(path);
  if (isLocalStorageAvailable) {
    try {
      const key = LOCAL_STORAGE_PREFIX + path;
      localStorage.removeItem(key);
    } catch (error2) {
      console.error(`Failed to remove entity for path "${path}" from localStorage:`, error2);
    }
  }
}
var EntityCollectionRowActions = function EntityCollectionRowActions2({
  entity,
  collection,
  fullPath,
  width,
  frozen,
  isSelected,
  selectionEnabled,
  size: size2,
  highlightEntity,
  onCollectionChange,
  unhighlightEntity,
  actions = [],
  hideId,
  selectionController,
  openEntityMode
}) {
  const largeLayout = useLargeLayout();
  const context = useFireCMSContext();
  const onCheckedChange = (0, import_react14.useCallback)((checked) => {
    selectionController == null ? void 0 : selectionController.toggleEntitySelection(entity, checked);
  }, [entity, selectionController == null ? void 0 : selectionController.toggleEntitySelection]);
  const hasActions = actions.length > 0;
  const hasCollapsedActions = actions.some((a2) => a2.collapsed || a2.collapsed === void 0);
  const collapsedActions = actions.filter((a_0) => a_0.collapsed || a_0.collapsed === void 0);
  const uncollapsedActions = actions.filter((a_1) => a_1.collapsed === false);
  const hasDraft = hasEntityInCache(fullPath + "/" + entity.id);
  return (0, import_jsx_runtime2.jsxs)("div", { className: cls("h-full flex items-center justify-center flex-col bg-surface-50 dark:bg-surface-900 bg-opacity-90 dark:bg-opacity-90 z-10", frozen ? "sticky left-0" : ""), onClick: (0, import_react14.useCallback)((event) => {
    event.stopPropagation();
  }, []), style: {
    width,
    position: frozen ? "sticky" : "initial",
    left: frozen ? 0 : "initial",
    contain: "strict"
  }, children: [
    (hasActions || selectionEnabled) && (0, import_jsx_runtime2.jsxs)("div", { className: "w-34 flex justify-center", children: [
      uncollapsedActions.map((action, index2) => (0, import_jsx_runtime2.jsx)(Tooltip, { title: action.name, asChild: true, children: (0, import_jsx_runtime2.jsx)(IconButton, { onClick: (event_0) => {
        event_0.stopPropagation();
        action.onClick({
          entity,
          fullPath,
          collection,
          context,
          selectionController,
          highlightEntity,
          unhighlightEntity,
          onCollectionChange,
          openEntityMode: openEntityMode ?? (collection == null ? void 0 : collection.openEntityMode)
        });
      }, size: largeLayout ? "medium" : "small", children: action.icon }) }, index2)),
      hasCollapsedActions && (0, import_jsx_runtime2.jsx)(Menu, { trigger: (0, import_jsx_runtime2.jsx)(IconButton, { size: largeLayout ? "medium" : "small", children: (0, import_jsx_runtime2.jsx)(MoreVertIcon, {}) }), children: collapsedActions.map((action_0, index_0) => (0, import_jsx_runtime2.jsxs)(MenuItem, { onClick: (e2) => {
        e2.stopPropagation();
        action_0.onClick({
          entity,
          fullPath,
          collection,
          context,
          selectionController,
          highlightEntity,
          unhighlightEntity,
          onCollectionChange,
          openEntityMode: openEntityMode ?? (collection == null ? void 0 : collection.openEntityMode)
        });
      }, children: [
        action_0.icon,
        action_0.name
      ] }, index_0)) }),
      selectionEnabled && (0, import_jsx_runtime2.jsx)(Tooltip, { title: `Select ${entity.id}`, children: (0, import_jsx_runtime2.jsx)(Checkbox, { size: largeLayout ? "medium" : "small", checked: Boolean(isSelected), onCheckedChange }) })
    ] }),
    !hideId && size2 !== "xs" && (0, import_jsx_runtime2.jsxs)("div", { className: "w-[138px] overflow-hidden truncate font-mono text-xs text-text-secondary dark:text-text-secondary-dark max-w-full text-ellipsis px-2 align-center justify-center flex items-center gap-1", onClick: (event_1) => {
      event_1.stopPropagation();
    }, children: [
      hasDraft && (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Local unsaved changes", className: "inline", children: (0, import_jsx_runtime2.jsx)(Chip, { colorScheme: "orangeDarker", className: "p-0.5", children: (0, import_jsx_runtime2.jsx)(EditIcon, { size: 12 }) }) }),
      (0, import_jsx_runtime2.jsx)("span", { className: "min-w-0 truncate text-center", children: entity ? entity.id : (0, import_jsx_runtime2.jsx)(Skeleton, {}) })
    ] })
  ] });
};
function CollectionTableToolbar(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(30);
  const {
    actions,
    actionsStart,
    loading,
    onSizeChanged,
    onTextSearch,
    onTextSearchClick,
    size: size2,
    textSearchLoading,
    title
  } = t0;
  const searchInputRef = import_react14.default.useRef(null);
  const largeLayout = useLargeLayout();
  const searchLoading = import_react14.default.useRef(false);
  let t1;
  let t2;
  if ($[0] !== textSearchLoading) {
    t1 = () => {
      if (searchInputRef.current && searchLoading.current && !textSearchLoading) {
        searchInputRef.current.focus();
      }
      searchLoading.current = textSearchLoading ?? false;
    };
    t2 = [textSearchLoading];
    $[0] = textSearchLoading;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  (0, import_react14.useEffect)(t1, t2);
  const t3 = size2;
  let t4;
  if ($[3] !== onSizeChanged) {
    t4 = (v) => onSizeChanged(v);
    $[3] = onSizeChanged;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  let t5;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = ["xs", "s", "m", "l", "xl"].map(_temp2$8);
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== t3 || $[7] !== t4) {
    t6 = (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Table row size", side: "right", sideOffset: 4, children: (0, import_jsx_runtime2.jsx)(Select, { value: t3, className: "w-16 h-10", size: "small", onValueChange: t4, renderValue: _temp$j, children: t5 }) });
    $[6] = t3;
    $[7] = t4;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  const sizeSelect = t6;
  let t7;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = cls(defaultBorderMixin, "no-scrollbar min-h-[56px] overflow-x-auto px-2 md:px-4 bg-surface-50 dark:bg-surface-900 border-b flex flex-row justify-between items-center w-full");
    $[9] = t7;
  } else {
    t7 = $[9];
  }
  let t8;
  if ($[10] !== title) {
    t8 = title && (0, import_jsx_runtime2.jsx)("div", { className: "hidden lg:block", children: title });
    $[10] = title;
    $[11] = t8;
  } else {
    t8 = $[11];
  }
  let t9;
  if ($[12] !== actionsStart || $[13] !== sizeSelect || $[14] !== t8) {
    t9 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-2 md:mr-4 mr-2", children: [
      t8,
      sizeSelect,
      actionsStart
    ] });
    $[12] = actionsStart;
    $[13] = sizeSelect;
    $[14] = t8;
    $[15] = t9;
  } else {
    t9 = $[15];
  }
  let t10;
  if ($[16] !== largeLayout || $[17] !== loading) {
    t10 = largeLayout && (0, import_jsx_runtime2.jsx)("div", { className: "w-[22px] mr-4", children: loading && (0, import_jsx_runtime2.jsx)(CircularProgress, { size: "smallest" }) });
    $[16] = largeLayout;
    $[17] = loading;
    $[18] = t10;
  } else {
    t10 = $[18];
  }
  let t11;
  if ($[19] !== onTextSearch || $[20] !== onTextSearchClick || $[21] !== textSearchLoading) {
    t11 = (onTextSearch || onTextSearchClick) && (0, import_jsx_runtime2.jsx)(SearchBar, { inputRef: searchInputRef, loading: textSearchLoading, disabled: Boolean(onTextSearchClick), onClick: onTextSearchClick, onTextSearch: onTextSearchClick ? void 0 : onTextSearch, expandable: true }, "search-bar");
    $[19] = onTextSearch;
    $[20] = onTextSearchClick;
    $[21] = textSearchLoading;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  let t12;
  if ($[23] !== actions || $[24] !== t10 || $[25] !== t11) {
    t12 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-2", children: [
      t10,
      t11,
      actions
    ] });
    $[23] = actions;
    $[24] = t10;
    $[25] = t11;
    $[26] = t12;
  } else {
    t12 = $[26];
  }
  let t13;
  if ($[27] !== t12 || $[28] !== t9) {
    t13 = (0, import_jsx_runtime2.jsxs)("div", { className: t7, children: [
      t9,
      t12
    ] });
    $[27] = t12;
    $[28] = t9;
    $[29] = t13;
  } else {
    t13 = $[29];
  }
  return t13;
}
function _temp2$8(size_0) {
  return (0, import_jsx_runtime2.jsx)(SelectItem, { value: size_0, className: "w-12 font-medium text-center", children: size_0.toUpperCase() }, size_0);
}
function _temp$j(v_0) {
  return (0, import_jsx_runtime2.jsx)("div", { className: "font-medium", children: v_0.toUpperCase() });
}
function getTableCellAlignment(property) {
  if (property.dataType === "boolean") {
    return "center";
  } else if (property.dataType === "number") {
    if (property.enumValues) return "left";
    return "right";
  } else if (property.dataType === "date") {
    return "right";
  } else {
    return "left";
  }
}
function getTablePropertyColumnWidth(property) {
  if (property.columnWidth) {
    return property.columnWidth;
  }
  if (property.dataType === "string") {
    if (property.url) {
      return 280;
    } else if (property.storage) {
      return 160;
    } else if (property.enumValues) {
      return 200;
    } else if (property.multiline) {
      return 300;
    } else if (property.markdown) {
      return 300;
    } else if (property.email) {
      return 200;
    } else {
      return 200;
    }
  } else if (property.dataType === "array") {
    const arrayProperty = property;
    if (arrayProperty.of) {
      if (Array.isArray(property.of)) {
        return 300;
      } else {
        return getTablePropertyColumnWidth(arrayProperty.of);
      }
    } else {
      return 300;
    }
  } else if (property.dataType === "number") {
    if (property.enumValues) {
      return 200;
    }
    return 140;
  } else if (property.dataType === "map") {
    return 360;
  } else if (property.dataType === "date") {
    return 200;
  } else if (property.dataType === "reference") {
    return 220;
  } else if (property.dataType === "boolean") {
    return 140;
  } else {
    return 200;
  }
}
function getSubcollectionColumnId(collection) {
  return `subcollection:${collection.id ?? collection.path}`;
}
var COLLECTION_GROUP_PARENT_ID = "collectionGroupParent";
function useColumnIds(collection, includeSubcollections) {
  const $ = (0, import_react_compiler_runtime3.c)(5);
  let t0;
  bb0: {
    if (collection.propertiesOrder) {
      let propertyColumnConfigs;
      if ($[0] !== collection) {
        propertyColumnConfigs = hideAndExpandKeys(collection, collection.propertiesOrder);
        if (collection.collectionGroup) {
          propertyColumnConfigs.push({
            key: COLLECTION_GROUP_PARENT_ID,
            disabled: true
          });
        }
        $[0] = collection;
        $[1] = propertyColumnConfigs;
      } else {
        propertyColumnConfigs = $[1];
      }
      t0 = propertyColumnConfigs;
      break bb0;
    }
    let t1;
    if ($[2] !== collection || $[3] !== includeSubcollections) {
      t1 = getDefaultColumnKeys(collection, includeSubcollections);
      $[2] = collection;
      $[3] = includeSubcollections;
      $[4] = t1;
    } else {
      t1 = $[4];
    }
    t0 = t1;
  }
  return t0;
}
function hideAndExpandKeys(collection, keys2) {
  return keys2.flatMap((key) => {
    var _a;
    const property = collection.properties[key];
    if (property) {
      if (property.hideFromCollection) return [null];
      if (property.disabled && typeof property.disabled === "object" && property.disabled.hidden) return [null];
      if (property.dataType === "map" && property.spreadChildren && property.properties) {
        return getColumnKeysForProperty(property, key);
      }
      return [{
        key,
        disabled: Boolean(property.disabled) || Boolean(property.readOnly)
      }];
    }
    const additionalField = (_a = collection.additionalFields) == null ? void 0 : _a.find((field) => field.key === key);
    if (additionalField) {
      return [{
        key,
        disabled: true
      }];
    }
    if (collection.subcollections) {
      const subCollection = collection.subcollections.find((subCol) => getSubcollectionColumnId(subCol) === key);
      if (subCollection) {
        return [{
          key,
          disabled: true
        }];
      }
    }
    if (collection.collectionGroup && key === COLLECTION_GROUP_PARENT_ID) {
      return [{
        key,
        disabled: true
      }];
    }
    return [null];
  }).filter(Boolean);
}
function getDefaultColumnKeys(collection, includeSubCollections) {
  const propertyKeys = Object.keys(collection.properties);
  const additionalFields = collection.additionalFields ?? [];
  const subCollections = collection.subcollections ?? [];
  const columnIds = [...propertyKeys, ...additionalFields.map((field) => field.key)];
  if (includeSubCollections) {
    const subCollectionIds = subCollections.map((collection2) => getSubcollectionColumnId(collection2));
    columnIds.push(...subCollectionIds.filter((subColId) => !columnIds.includes(subColId)));
  }
  if (collection.collectionGroup) {
    columnIds.push(COLLECTION_GROUP_PARENT_ID);
  }
  return hideAndExpandKeys(collection, columnIds);
}
function getColumnKeysForProperty(property, key, disabled) {
  if (property.dataType === "map" && property.spreadChildren && property.properties) {
    return Object.entries(property.properties).flatMap(([childKey, childProperty]) => getColumnKeysForProperty(childProperty, `${key}.${childKey}`, disabled || Boolean(property.disabled) || Boolean(property.readOnly)));
  }
  return [{
    key,
    disabled: disabled || Boolean(property.disabled) || Boolean(property.readOnly)
  }];
}
function getFormFieldKeys(collection) {
  const propertyKeys = Object.keys(collection.properties);
  const additionalFields = collection.additionalFields ?? [];
  const allKeys = [...propertyKeys, ...additionalFields.map((field) => field.key)];
  if (collection.propertiesOrder) {
    return collection.propertiesOrder.filter((key) => allKeys.includes(key));
  }
  return allKeys;
}
function buildIdColumn(largeLayout) {
  return {
    key: "id_ewcfedcswdf3",
    width: largeLayout ? 160 : 130,
    title: "ID",
    resizable: false,
    frozen: largeLayout ?? false,
    headerAlign: "center",
    align: "center"
  };
}
function propertiesToColumns({
  properties,
  sortable,
  forceFilter,
  AdditionalHeaderWidget
}) {
  const disabledFilter = Boolean(forceFilter);
  return Object.entries(properties).flatMap(([key, property]) => getColumnKeysForProperty(property, key)).map(({
    key,
    disabled
  }) => {
    const property = getResolvedPropertyInPath(properties, key);
    if (!property) throw Error("Internal error: no property found in path " + key);
    const filterable = filterableProperty(property);
    return {
      key,
      align: getTableCellAlignment(property),
      icon: getIconForProperty(property, "small"),
      title: property.name ?? key,
      sortable,
      filter: !disabledFilter && filterable,
      width: getTablePropertyColumnWidth(property),
      resizable: true,
      custom: {
        resolvedProperty: property,
        disabled
      },
      AdditionalHeaderWidget: AdditionalHeaderWidget ? ({
        onHover
      }) => (0, import_jsx_runtime2.jsx)(AdditionalHeaderWidget, { property, propertyKey: key, onHover }) : void 0
    };
  });
}
function filterableProperty(property, partOfArray = false) {
  if (partOfArray) {
    return ["string", "number", "date", "reference"].includes(property.dataType);
  }
  if (property.dataType === "array") {
    if (property.of) return filterableProperty(property.of, true);
    else return false;
  }
  return ["string", "number", "boolean", "date", "reference", "array"].includes(property.dataType);
}
function CircularProgressCenter(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(10);
  let props;
  let text;
  if ($[0] !== t0) {
    ({
      text,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = props;
    $[2] = text;
  } else {
    props = $[1];
    text = $[2];
  }
  let t1;
  if ($[3] !== props) {
    t1 = (0, import_jsx_runtime2.jsx)(CircularProgress, { ...props });
    $[3] = props;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== text) {
    t2 = text && (0, import_jsx_runtime2.jsx)(Typography, { color: "secondary", variant: "caption", className: "text-center", children: text });
    $[5] = text;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== t1 || $[8] !== t2) {
    t3 = (0, import_jsx_runtime2.jsx)("div", { className: "flex w-full h-screen max-h-full max-w-full gap-4", children: (0, import_jsx_runtime2.jsxs)("div", { className: "m-auto flex flex-col gap-2 items-center", children: [
      t1,
      t2
    ] }) });
    $[7] = t1;
    $[8] = t2;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  return t3;
}
var VirtualTableHeader = import_react14.default.memo(function VirtualTableHeader2(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(57);
  const {
    resizeHandleRef,
    columnIndex,
    isResizingIndex,
    sort,
    onColumnSort,
    onFilterUpdate,
    filter,
    column,
    onClickResizeColumn,
    createFilterField: createFilterField2,
    AdditionalHeaderWidget
  } = t0;
  const [onHover, setOnHover] = (0, import_react14.useState)(false);
  const [openFilter, setOpenFilter] = import_react14.default.useState(false);
  const [hidden, setHidden] = import_react14.default.useState(false);
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (event) => {
      setOpenFilter(true);
    };
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const handleSettingsClick = t1;
  let t2;
  if ($[1] !== column || $[2] !== onFilterUpdate) {
    t2 = (filterForProperty, newOpenFilterState) => {
      onFilterUpdate(column, filterForProperty);
      if (newOpenFilterState !== void 0) {
        setOpenFilter(newOpenFilterState);
      }
    };
    $[1] = column;
    $[2] = onFilterUpdate;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const update2 = t2;
  const thisColumnIsResizing = isResizingIndex === columnIndex;
  const anotherColumnIsResizing = isResizingIndex !== columnIndex && isResizingIndex > 0;
  const hovered = !anotherColumnIsResizing && (onHover || thisColumnIsResizing);
  const t3 = column.frozen ? "sticky left-0 z-10" : "relative z-0";
  let t4;
  if ($[4] !== t3) {
    t4 = cls("flex py-0 px-3 h-full text-xs uppercase font-semibold relative select-none items-center bg-surface-50 dark:bg-surface-900", "text-text-secondary hover:text-text-primary dark:text-text-secondary-dark dark:hover:text-text-primary-dark", "hover:bg-surface-100 dark:hover:bg-surface-800 hover:bg-opacity-50 dark:hover:bg-opacity-50", t3);
    $[4] = t3;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  const t5 = column.frozen ? 0 : void 0;
  let t6;
  if ($[6] !== column.width || $[7] !== t5) {
    t6 = {
      left: t5,
      minWidth: column.width,
      maxWidth: column.width
    };
    $[6] = column.width;
    $[7] = t5;
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  let t7;
  let t8;
  let t9;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => setOnHover(true);
    t8 = () => setOnHover(true);
    t9 = () => setOnHover(false);
    $[9] = t7;
    $[10] = t8;
    $[11] = t9;
  } else {
    t7 = $[9];
    t8 = $[10];
    t9 = $[11];
  }
  const t10 = `flex items-center justify-${column.headerAlign} flex-row`;
  let t11;
  if ($[12] !== column.align) {
    t11 = {
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: 2,
      justifyContent: column.align
    };
    $[12] = column.align;
    $[13] = t11;
  } else {
    t11 = $[13];
  }
  let t12;
  if ($[14] !== column.title || $[15] !== t11) {
    t12 = (0, import_jsx_runtime2.jsx)("div", { className: "truncate -webkit-box w-full mx-1 overflow-hidden", style: t11, children: column.title });
    $[14] = column.title;
    $[15] = t11;
    $[16] = t12;
  } else {
    t12 = $[16];
  }
  let t13;
  if ($[17] !== column.icon || $[18] !== t10 || $[19] !== t12) {
    t13 = (0, import_jsx_runtime2.jsx)("div", { className: "overflow-hidden flex-grow", children: (0, import_jsx_runtime2.jsxs)("div", { className: t10, children: [
      column.icon,
      t12
    ] }) });
    $[17] = column.icon;
    $[18] = t10;
    $[19] = t12;
    $[20] = t13;
  } else {
    t13 = $[20];
  }
  let t14;
  if ($[21] !== AdditionalHeaderWidget || $[22] !== onHover || $[23] !== openFilter) {
    t14 = AdditionalHeaderWidget && (0, import_jsx_runtime2.jsx)(AdditionalHeaderWidget, { onHover: onHover || openFilter });
    $[21] = AdditionalHeaderWidget;
    $[22] = onHover;
    $[23] = openFilter;
    $[24] = t14;
  } else {
    t14 = $[24];
  }
  let t15;
  if ($[25] !== column.key || $[26] !== column.sortable || $[27] !== hovered || $[28] !== onColumnSort || $[29] !== onHover || $[30] !== openFilter || $[31] !== sort) {
    t15 = column.sortable && (sort || hovered || openFilter) && (0, import_jsx_runtime2.jsx)(Badge, { color: "secondary", invisible: !sort, children: (0, import_jsx_runtime2.jsxs)(IconButton, { size: "small", className: onHover || openFilter ? "bg-white dark:bg-surface-950" : void 0, onClick: () => {
      onColumnSort(column.key);
    }, children: [
      !sort && (0, import_jsx_runtime2.jsx)(ArrowUpwardIcon, {}),
      sort === "asc" && (0, import_jsx_runtime2.jsx)(ArrowUpwardIcon, {}),
      sort === "desc" && (0, import_jsx_runtime2.jsx)(ArrowUpwardIcon, { className: "rotate-180" })
    ] }) });
    $[25] = column.key;
    $[26] = column.sortable;
    $[27] = hovered;
    $[28] = onColumnSort;
    $[29] = onHover;
    $[30] = openFilter;
    $[31] = sort;
    $[32] = t15;
  } else {
    t15 = $[32];
  }
  let t16;
  if ($[33] !== t14 || $[34] !== t15) {
    t16 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t14,
      t15
    ] });
    $[33] = t14;
    $[34] = t15;
    $[35] = t16;
  } else {
    t16 = $[35];
  }
  let t17;
  if ($[36] !== column || $[37] !== createFilterField2 || $[38] !== filter || $[39] !== hidden || $[40] !== onHover || $[41] !== openFilter || $[42] !== update2) {
    t17 = column.filter && createFilterField2 && (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsx)(Badge, { color: "secondary", invisible: !filter, children: (0, import_jsx_runtime2.jsx)(Popover, { open: openFilter, onOpenChange: setOpenFilter, className: hidden ? "hidden" : void 0, modal: true, trigger: (0, import_jsx_runtime2.jsx)(IconButton, { className: onHover || openFilter ? "bg-white dark:bg-surface-950" : void 0, size: "small", onClick: handleSettingsClick, children: (0, import_jsx_runtime2.jsx)(FilterListIcon, { size: "small" }) }), children: (0, import_jsx_runtime2.jsx)(FilterForm, { column, filter, onHover, onFilterUpdate: update2, createFilterField: createFilterField2, hidden, setHidden }) }) }) });
    $[36] = column;
    $[37] = createFilterField2;
    $[38] = filter;
    $[39] = hidden;
    $[40] = onHover;
    $[41] = openFilter;
    $[42] = update2;
    $[43] = t17;
  } else {
    t17 = $[43];
  }
  let t18;
  if ($[44] !== column || $[45] !== columnIndex || $[46] !== hovered || $[47] !== onClickResizeColumn || $[48] !== resizeHandleRef) {
    t18 = column.resizable && (0, import_jsx_runtime2.jsx)("div", { ref: resizeHandleRef, className: cls("absolute h-full w-[6px] top-0 right-0 cursor-col-resize", hovered && "bg-surface-300 dark:bg-surface-700"), onMouseDown: onClickResizeColumn ? () => onClickResizeColumn(columnIndex, column) : void 0 });
    $[44] = column;
    $[45] = columnIndex;
    $[46] = hovered;
    $[47] = onClickResizeColumn;
    $[48] = resizeHandleRef;
    $[49] = t18;
  } else {
    t18 = $[49];
  }
  let t19;
  if ($[50] !== t13 || $[51] !== t16 || $[52] !== t17 || $[53] !== t18 || $[54] !== t4 || $[55] !== t6) {
    t19 = (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsxs)("div", { className: t4, style: t6, onMouseEnter: t7, onMouseMove: t8, onMouseLeave: t9, children: [
      t13,
      t16,
      t17,
      t18
    ] }) });
    $[50] = t13;
    $[51] = t16;
    $[52] = t17;
    $[53] = t18;
    $[54] = t4;
    $[55] = t6;
    $[56] = t19;
  } else {
    t19 = $[56];
  }
  return t19;
}, import_react_fast_compare2.default);
function FilterForm(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(33);
  const {
    column,
    onFilterUpdate,
    filter,
    createFilterField: createFilterField2,
    hidden,
    setHidden
  } = t0;
  const id2 = column.key;
  const [filterInternal, setFilterInternal] = (0, import_react14.useState)(filter);
  let t1;
  let t2;
  if ($[0] !== filter) {
    t1 = () => {
      setFilterInternal(filter);
    };
    t2 = [filter];
    $[0] = filter;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  (0, import_react14.useEffect)(t1, t2);
  if (!column.filter) {
    return null;
  }
  let t3;
  if ($[3] !== filterInternal || $[4] !== onFilterUpdate) {
    t3 = () => {
      onFilterUpdate(filterInternal, false);
    };
    $[3] = filterInternal;
    $[4] = onFilterUpdate;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const submit = t3;
  let t4;
  if ($[6] !== onFilterUpdate) {
    t4 = (e2) => {
      onFilterUpdate(void 0, false);
    };
    $[6] = onFilterUpdate;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const reset2 = t4;
  const filterIsSet = !!filter;
  let t5;
  if ($[8] !== column || $[9] !== createFilterField2 || $[10] !== filterInternal || $[11] !== hidden || $[12] !== id2 || $[13] !== setHidden) {
    t5 = createFilterField2({
      id: id2,
      filterValue: filterInternal,
      setFilterValue: setFilterInternal,
      column,
      hidden,
      setHidden
    });
    $[8] = column;
    $[9] = createFilterField2;
    $[10] = filterInternal;
    $[11] = hidden;
    $[12] = id2;
    $[13] = setHidden;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  const filterField = t5;
  if (!filterField) {
    return null;
  }
  let t6;
  if ($[15] !== submit) {
    t6 = (e_0) => {
      e_0.stopPropagation();
      e_0.preventDefault();
      submit();
    };
    $[15] = submit;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  let t7;
  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = cls(defaultBorderMixin, "py-4 px-6 typography-label border-b");
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  const t8 = column.title ?? id2;
  let t9;
  if ($[18] !== t8) {
    t9 = (0, import_jsx_runtime2.jsx)("div", { className: t7, children: t8 });
    $[18] = t8;
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  let t10;
  if ($[20] !== filterField) {
    t10 = filterField && (0, import_jsx_runtime2.jsx)("div", { className: "m-4", children: filterField });
    $[20] = filterField;
    $[21] = t10;
  } else {
    t10 = $[21];
  }
  const t11 = !filterIsSet;
  let t12;
  if ($[22] !== reset2 || $[23] !== t11) {
    t12 = (0, import_jsx_runtime2.jsx)(Button, { className: "mr-4", disabled: t11, variant: "text", color: "primary", type: "reset", "aria-label": "filter clear", onClick: reset2, children: "Clear" });
    $[22] = reset2;
    $[23] = t11;
    $[24] = t12;
  } else {
    t12 = $[24];
  }
  let t13;
  if ($[25] === Symbol.for("react.memo_cache_sentinel")) {
    t13 = (0, import_jsx_runtime2.jsx)(Button, { variant: "outlined", color: "primary", type: "submit", children: "Filter" });
    $[25] = t13;
  } else {
    t13 = $[25];
  }
  let t14;
  if ($[26] !== t12) {
    t14 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex justify-end m-4", children: [
      t12,
      t13
    ] });
    $[26] = t12;
    $[27] = t14;
  } else {
    t14 = $[27];
  }
  let t15;
  if ($[28] !== t10 || $[29] !== t14 || $[30] !== t6 || $[31] !== t9) {
    t15 = (0, import_jsx_runtime2.jsxs)("form", { noValidate: true, onSubmit: t6, className: "text-surface-900 dark:text-white", children: [
      t9,
      t10,
      t14
    ] });
    $[28] = t10;
    $[29] = t14;
    $[30] = t6;
    $[31] = t9;
    $[32] = t15;
  } else {
    t15 = $[32];
  }
  return t15;
}
var VirtualTableHeaderRow = ({
  columns,
  currentSort,
  onColumnSort,
  onFilterUpdate,
  sortByProperty,
  filter,
  onColumnResize,
  onColumnResizeEnd,
  createFilterField: createFilterField2,
  AddColumnComponent
}) => {
  const columnRefs = columns.map(() => (0, import_react14.createRef)());
  const [isResizing, setIsResizing] = (0, import_react14.useState)(-1);
  const adjustWidthColumn = (0, import_react14.useCallback)((index2, width, end3) => {
    const column = columns[index2];
    const minWidth = 100;
    const maxWidth = 800;
    const newWidth = width > maxWidth ? maxWidth : width < minWidth ? minWidth : width;
    const params = {
      width: newWidth,
      key: column.key,
      column: {
        ...column,
        width: newWidth
      }
    };
    if (!end3) onColumnResize(params);
    else onColumnResizeEnd(params);
  }, [columns, onColumnResize, onColumnResizeEnd]);
  const getEventNewWidth = (0, import_react14.useCallback)((e2) => {
    var _a, _b;
    if (isResizing >= 0) {
      const left2 = (_b = (_a = columnRefs[isResizing].current) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.getBoundingClientRect().left;
      if (!left2) return;
      return e2.clientX - left2;
    }
    return void 0;
  }, [columnRefs, isResizing]);
  const setCursorDocument = (0, import_react14.useCallback)((isResizing_0) => {
    document.body.style.cursor = isResizing_0 ? "col-resize" : "auto";
  }, []);
  const handleOnMouseMove = (0, import_react14.useCallback)((e_0) => {
    e_0.stopPropagation();
    e_0.preventDefault();
    const newWidth_0 = getEventNewWidth(e_0);
    if (newWidth_0) adjustWidthColumn(isResizing, newWidth_0, false);
  }, [adjustWidthColumn, getEventNewWidth, isResizing]);
  const handleOnMouseUp = (0, import_react14.useCallback)((e_1) => {
    e_1.stopPropagation();
    e_1.preventDefault();
    const newWidth_1 = getEventNewWidth(e_1);
    if (newWidth_1) adjustWidthColumn(isResizing, newWidth_1, true);
    setIsResizing(-1);
    setCursorDocument(false);
  }, [adjustWidthColumn, getEventNewWidth, isResizing, setCursorDocument]);
  const removeResizingListeners = (0, import_react14.useCallback)(() => {
    document.removeEventListener("mousemove", handleOnMouseMove);
    document.removeEventListener("mouseup", handleOnMouseUp);
  }, [handleOnMouseMove, handleOnMouseUp]);
  const attachResizeListeners = (0, import_react14.useCallback)(() => {
    document.addEventListener("mousemove", handleOnMouseMove);
    document.addEventListener("mouseup", handleOnMouseUp);
  }, [handleOnMouseMove, handleOnMouseUp]);
  (0, import_react14.useEffect)(() => {
    if (isResizing >= 0) {
      attachResizeListeners();
    } else {
      removeResizingListeners();
    }
    return () => {
      removeResizingListeners();
    };
  }, [attachResizeListeners, isResizing, removeResizingListeners]);
  const onClickResizeColumn = (0, import_react14.useCallback)((index_0) => {
    setIsResizing(index_0);
    setCursorDocument(true);
  }, [setCursorDocument]);
  return (0, import_jsx_runtime2.jsxs)("div", { className: cls(defaultBorderMixin, "z-20 sticky min-w-full flex w-fit flex-row top-0 left-0 h-12 border-b bg-surface-50 dark:bg-surface-900"), children: [
    columns.map((c22, columnIndex) => {
      const column_0 = columns[columnIndex];
      const filterForThisProperty = column_0 && filter && filter[column_0.key] ? filter[column_0.key] : void 0;
      return (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(VirtualTableHeader, { resizeHandleRef: columnRefs[columnIndex], columnIndex, isResizingIndex: isResizing, onFilterUpdate, filter: filterForThisProperty, sort: sortByProperty === column_0.key ? currentSort : void 0, onColumnSort, onClickResizeColumn, column: column_0, createFilterField: createFilterField2, AdditionalHeaderWidget: column_0.AdditionalHeaderWidget }) }, "header_" + column_0.key);
    }),
    AddColumnComponent && (0, import_jsx_runtime2.jsx)(AddColumnComponent, {})
  ] });
};
var VirtualTableRow = import_react14.default.memo(function VirtualTableRow2(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(17);
  const {
    rowData,
    rowIndex,
    children,
    onRowClick,
    rowHeight,
    style: style3,
    hoverRow,
    rowClassName
  } = t0;
  let t1;
  if ($[0] !== onRowClick || $[1] !== rowData || $[2] !== rowIndex) {
    t1 = (event) => {
      if (onRowClick) {
        onRowClick({
          rowData,
          rowIndex,
          event
        });
      }
    };
    $[0] = onRowClick;
    $[1] = rowData;
    $[2] = rowIndex;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const onClick = t1;
  let t2;
  if ($[4] !== hoverRow || $[5] !== onRowClick || $[6] !== rowClassName || $[7] !== rowData) {
    t2 = cls("flex min-w-full text-sm border-b border-surface-200 dark:border-surface-800 border-opacity-40 dark:border-opacity-40", rowClassName ? rowClassName(rowData) : "", {
      "hover:bg-opacity-95": hoverRow,
      "cursor-pointer": onRowClick
    });
    $[4] = hoverRow;
    $[5] = onRowClick;
    $[6] = rowClassName;
    $[7] = rowData;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  let t3;
  if ($[9] !== rowHeight || $[10] !== style3) {
    t3 = {
      ...style3,
      height: rowHeight,
      width: "fit-content"
    };
    $[9] = rowHeight;
    $[10] = style3;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  let t4;
  if ($[12] !== children || $[13] !== onClick || $[14] !== t2 || $[15] !== t3) {
    t4 = (0, import_jsx_runtime2.jsx)("div", { className: t2, onClick, style: t3, children });
    $[12] = children;
    $[13] = onClick;
    $[14] = t2;
    $[15] = t3;
    $[16] = t4;
  } else {
    t4 = $[16];
  }
  return t4;
}, import_react_fast_compare2.default);
var VirtualTableCell = import_react14.default.memo(function VirtualTableCell2(props) {
  return props.rowData && props.cellRenderer({
    cellData: props.cellData,
    rowData: props.rowData,
    rowIndex: props.rowIndex,
    isScrolling: false,
    column: props.column,
    columns: props.columns,
    columnIndex: props.columnIndex,
    width: props.column.width
  });
}, (a2, b2) => {
  return (0, import_react_fast_compare2.default)(a2.rowData, b2.rowData) && (0, import_react_fast_compare2.default)(a2.column, b2.column) && (0, import_react_fast_compare2.default)(a2.cellData, b2.cellData) && (0, import_react_fast_compare2.default)(a2.rowIndex, b2.rowIndex) && (0, import_react_fast_compare2.default)(a2.cellRenderer, b2.cellRenderer) && (0, import_react_fast_compare2.default)(a2.columnIndex, b2.columnIndex);
});
function useDebounceCallback(callback, delay) {
  const $ = (0, import_react_compiler_runtime3.c)(3);
  const timeoutRef = (0, import_react14.useRef)(null);
  let t0;
  if ($[0] !== callback || $[1] !== delay) {
    t0 = (...t1) => {
      const args = t1;
      if (timeoutRef.current !== null) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = window.setTimeout(() => {
        callback == null ? void 0 : callback(...args);
      }, delay);
    };
    $[0] = callback;
    $[1] = delay;
    $[2] = t0;
  } else {
    t0 = $[2];
  }
  const debouncedCallback = t0;
  return debouncedCallback;
}
var VirtualListContext = (0, import_react14.createContext)({});
VirtualListContext.displayName = "VirtualListContext";
var innerElementType = (0, import_react14.forwardRef)((t0, ref2) => {
  const $ = (0, import_react_compiler_runtime3.c)(7);
  let children;
  let rest;
  if ($[0] !== t0) {
    ({
      children,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = rest;
  } else {
    children = $[1];
    rest = $[2];
  }
  let t1;
  if ($[3] !== children || $[4] !== ref2 || $[5] !== rest) {
    t1 = (0, import_jsx_runtime2.jsx)(VirtualListContext.Consumer, { children: (virtualTableProps) => {
      const customView = virtualTableProps.customView;
      return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
        (0, import_jsx_runtime2.jsx)("div", { id: "virtual-table", style: {
          position: "relative",
          height: "100%"
        }, children: (0, import_jsx_runtime2.jsxs)("div", { ref: ref2, ...rest, style: {
          ...rest == null ? void 0 : rest.style,
          minHeight: "100%",
          position: "relative"
        }, children: [
          (0, import_jsx_runtime2.jsx)(VirtualTableHeaderRow, { ...virtualTableProps }),
          !customView && children
        ] }) }),
        customView && (0, import_jsx_runtime2.jsx)("div", { style: {
          position: "sticky",
          top: "48px",
          flexGrow: 1,
          height: "calc(100% - 48px)",
          marginTop: "calc(48px - 100vh)",
          left: 0
        }, children: customView })
      ] });
    } });
    $[3] = children;
    $[4] = ref2;
    $[5] = rest;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  return t1;
});
var VirtualTable = import_react14.default.memo(function VirtualTable2({
  data,
  onResetPagination,
  onEndReached,
  endOffset = 600,
  rowHeight = 54,
  columns: columnsProp,
  onRowClick,
  onColumnResize,
  filter: filterInput,
  checkFilterCombination,
  onFilterUpdate,
  sortBy,
  error: error2,
  emptyComponent,
  onSortByUpdate,
  onScroll: onScrollProp,
  loading,
  cellRenderer,
  hoverRow,
  createFilterField: createFilterField2,
  rowClassName,
  style: style3,
  className,
  endAdornment,
  AddColumnComponent,
  initialScroll = 0,
  debug
}) {
  const sortByProperty = sortBy ? sortBy[0] : void 0;
  const currentSort = sortBy ? sortBy[1] : void 0;
  const [columns, setColumns] = (0, import_react14.useState)(columnsProp);
  const tableRef = (0, import_react14.useRef)(null);
  const endReachCallbackThreshold = (0, import_react14.useRef)(0);
  const debouncedScroll = useDebounceCallback(onScrollProp, 200);
  (0, import_react14.useEffect)(() => {
    if (tableRef.current && initialScroll) {
      tableRef.current.scrollTo(0, initialScroll);
    }
  }, [tableRef, initialScroll]);
  (0, import_react14.useEffect)(() => {
    setColumns(columnsProp);
  }, [columnsProp]);
  const [_, setForceUpdate] = (0, import_react14.useState)(false);
  (0, import_react14.useEffect)(() => {
    if (tableRef.current) {
      const resizeObserver = new ResizeObserver(() => {
        setForceUpdate((prev) => !prev);
      });
      resizeObserver.observe(tableRef.current);
      return () => {
        if (tableRef.current) {
          resizeObserver.unobserve(tableRef.current);
        }
        resizeObserver.disconnect();
      };
    }
    return () => {
    };
  }, [tableRef]);
  const [measureRef, bounds] = j({
    debounce: 50,
    polyfill: ResizeObserver,
    scroll: true,
    // This is important for handling zooming in react-flow
    offsetSize: true
  });
  const onColumnResizeInternal = (0, import_react14.useCallback)((params) => {
    if (debug) console.log("onColumnResizeInternal", params);
    setColumns(columns.map((column) => column.key === params.column.key ? params.column : column));
  }, [columns]);
  const onColumnResizeEndInternal = (0, import_react14.useCallback)((params_0) => {
    if (debug) console.log("onColumnResizeEndInternal", params_0);
    setColumns(columns.map((column_0) => column_0.key === params_0.column.key ? params_0.column : column_0));
    if (onColumnResize) {
      onColumnResize(params_0);
    }
  }, [columns, onColumnResize]);
  const filterRef = (0, import_react14.useRef)();
  (0, import_react14.useEffect)(() => {
    if (debug) console.log("Filter updated", filterInput);
    filterRef.current = filterInput;
  }, [filterInput]);
  const scrollToTop = (0, import_react14.useCallback)(() => {
    var _a;
    if (debug) console.log("scrollToTop");
    endReachCallbackThreshold.current = 0;
    if (tableRef.current) {
      tableRef.current.scrollTo((_a = tableRef.current) == null ? void 0 : _a.scrollLeft, 0);
    }
  }, []);
  const onColumnSort = (0, import_react14.useCallback)((key) => {
    if (debug) console.log("onColumnSort", key);
    const isDesc = sortByProperty === key && currentSort === "desc";
    const isAsc = sortByProperty === key && currentSort === "asc";
    const newSort = isAsc ? "desc" : isDesc ? void 0 : "asc";
    const newSortProperty = isDesc ? void 0 : key;
    const filter = filterRef.current;
    const newSortBy = newSort && newSortProperty ? [newSortProperty, newSort] : void 0;
    if (filter) {
      if (checkFilterCombination && !checkFilterCombination(filter, newSortBy)) {
        if (onFilterUpdate) onFilterUpdate(void 0);
      }
    }
    if (onResetPagination) {
      onResetPagination();
    }
    if (onSortByUpdate) {
      onSortByUpdate(newSortBy);
    }
    scrollToTop();
  }, [checkFilterCombination, currentSort, onFilterUpdate, onResetPagination, onSortByUpdate, scrollToTop, sortByProperty]);
  const maxScroll = Math.max(((data == null ? void 0 : data.length) ?? 0) * rowHeight - bounds.height, 0);
  if (debug) console.log("maxScroll", maxScroll);
  const onEndReachedInternal = (0, import_react14.useCallback)((scrollOffset) => {
    if (debug) console.log("onEndReachedInternal", scrollOffset, endReachCallbackThreshold.current + endOffset);
    if (onEndReached && ((data == null ? void 0 : data.length) ?? 0) > 0 && scrollOffset > endReachCallbackThreshold.current + endOffset) {
      endReachCallbackThreshold.current = scrollOffset;
      onEndReached();
    }
  }, [data == null ? void 0 : data.length, onEndReached]);
  const onScroll = (0, import_react14.useCallback)(({
    scrollDirection,
    scrollOffset: scrollOffset_0,
    scrollUpdateWasRequested
  }) => {
    if (debug) console.log("onScroll", {
      scrollDirection,
      scrollOffset: scrollOffset_0,
      scrollUpdateWasRequested
    });
    if (onScrollProp) {
      debouncedScroll({
        scrollDirection,
        scrollOffset: scrollOffset_0,
        scrollUpdateWasRequested
      });
    }
    if (!scrollUpdateWasRequested && scrollOffset_0 >= maxScroll - endOffset) onEndReachedInternal(scrollOffset_0);
  }, [maxScroll, onEndReachedInternal]);
  const onFilterUpdateInternal = (0, import_react14.useCallback)((column_1, filterForProperty) => {
    if (debug) console.log("onFilterUpdateInternal", column_1, filterForProperty);
    endReachCallbackThreshold.current = 0;
    const filter_0 = filterRef.current;
    let newFilterValue = filter_0 ? {
      ...filter_0
    } : {};
    if (!filterForProperty) {
      delete newFilterValue[column_1.key];
    } else {
      newFilterValue[column_1.key] = filterForProperty;
    }
    const newSortBy_0 = sortByProperty && currentSort ? [sortByProperty, currentSort] : void 0;
    const isNewFilterCombinationValid = !checkFilterCombination || checkFilterCombination(newFilterValue, newSortBy_0);
    if (!isNewFilterCombinationValid) {
      newFilterValue = filterForProperty ? {
        [column_1.key]: filterForProperty
      } : {};
    }
    if (onFilterUpdate) onFilterUpdate(newFilterValue);
  }, [checkFilterCombination, currentSort, onFilterUpdate, sortByProperty]);
  const empty3 = !loading && ((data == null ? void 0 : data.length) ?? 0) === 0;
  const customView = error2 ? (0, import_jsx_runtime2.jsxs)(CenteredView, { maxWidth: "2xl", className: "flex flex-col gap-2", children: [
    (0, import_jsx_runtime2.jsx)(Typography, { variant: "h6", children: "Error" }),
    (error2 == null ? void 0 : error2.message) && (0, import_jsx_runtime2.jsx)(SafeLinkRenderer, { text: error2.message })
  ] }) : empty3 ? loading ? (0, import_jsx_runtime2.jsx)(CircularProgressCenter, {}) : (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-col overflow-auto items-center justify-center p-2 gap-2 h-full", children: [
    (0, import_jsx_runtime2.jsx)(AssignmentIcon, {}),
    emptyComponent
  ] }) : void 0;
  const virtualListController = {
    data,
    rowHeight,
    cellRenderer,
    columns,
    currentSort,
    onRowClick,
    customView,
    onColumnResize: onColumnResizeInternal,
    onColumnResizeEnd: onColumnResizeEndInternal,
    filter: filterRef.current,
    onColumnSort,
    onFilterUpdate: onFilterUpdateInternal,
    sortByProperty,
    hoverRow: hoverRow ?? false,
    createFilterField: createFilterField2,
    rowClassName,
    endAdornment,
    AddColumnComponent
  };
  if (debug) console.log("VirtualTable render", virtualListController);
  return (0, import_jsx_runtime2.jsx)("div", { ref: measureRef, style: style3, className: cls("h-full w-full", className), children: (0, import_jsx_runtime2.jsx)(VirtualListContext.Provider, { value: virtualListController, children: (0, import_jsx_runtime2.jsx)(MemoizedList, { outerRef: tableRef, width: bounds.width, height: bounds.height, itemCount: ((data == null ? void 0 : data.length) ?? 0) + (endAdornment ? 1 : 0), onScroll, includeAddColumn: Boolean(AddColumnComponent), itemSize: rowHeight }, rowHeight) }) });
}, import_react_fast_compare2.default);
function MemoizedList({
  outerRef,
  width,
  height,
  itemCount,
  onScroll,
  itemSize,
  includeAddColumn
}) {
  const Row = (0, import_react14.useCallback)(({
    index: index2,
    style: style3
  }) => {
    return (0, import_jsx_runtime2.jsx)(VirtualListContext.Consumer, { children: ({
      onRowClick,
      data,
      columns,
      rowHeight = 54,
      cellRenderer,
      hoverRow,
      rowClassName,
      endAdornment
    }) => {
      if (endAdornment && index2 === (data ?? []).length) {
        return (0, import_jsx_runtime2.jsx)("div", { style: {
          ...style3,
          height: "auto",
          position: "sticky",
          bottom: 0,
          zIndex: 1
        }, children: endAdornment });
      }
      const rowData = data && data[index2];
      return (0, import_jsx_runtime2.jsxs)(VirtualTableRow, { rowData, rowIndex: index2, onRowClick, columns, hoverRow, rowClassName, style: {
        ...style3,
        top: `calc(${style3.top}px + 48px)`
      }, rowHeight, children: [
        columns.map((column, columnIndex) => {
          const cellData = rowData && rowData[column.key];
          return (0, import_jsx_runtime2.jsx)(VirtualTableCell, { dataKey: column.key, cellRenderer, column, columns, rowData, cellData, rowIndex: index2, columnIndex }, `cell_${column.key}`);
        }),
        includeAddColumn && (0, import_jsx_runtime2.jsx)("div", { className: "w-20" })
      ] }, `row_${index2}`);
    } });
  }, []);
  return (0, import_jsx_runtime2.jsx)(FixedSizeList, { outerRef, innerElementType, width, height, overscanCount: 4, itemCount, onScroll, itemSize, children: Row });
}
var SafeLinkRenderer = (t0) => {
  const $ = (0, import_react_compiler_runtime3.c)(4);
  const {
    text
  } = t0;
  let t1;
  if ($[0] !== text) {
    const urlRegex = /https?:\/\/[^\s]+/g;
    t1 = text.replace(urlRegex, _temp$i);
    $[0] = text;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const htmlContent = t1;
  let t2;
  if ($[2] !== htmlContent) {
    t2 = (0, import_jsx_runtime2.jsx)("div", { className: "break-all", dangerouslySetInnerHTML: {
      __html: htmlContent
    } });
    $[2] = htmlContent;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  return t2;
};
function _temp$i(url) {
  return `<a href="${url}" class="underline" target="_blank">Link</a><br/>`;
}
var operationLabels$2 = {
  "==": "==",
  "!=": "!=",
  ">": ">",
  "<": "<",
  ">=": ">=",
  "<=": "<=",
  in: "In",
  "not-in": "Not in",
  "array-contains": "Contains",
  "array-contains-any": "Contains Any"
};
var multipleSelectOperations$2 = ["array-contains-any", "in", "not-in"];
function ReferenceFilterField({
  value,
  setValue,
  isArray: isArray2,
  path,
  includeId = true,
  previewProperties,
  setHidden
}) {
  const possibleOperations = isArray2 ? ["array-contains"] : ["==", "!=", ">", "<", ">=", "<="];
  if (isArray2) {
    possibleOperations.push("array-contains-any");
  } else {
    possibleOperations.push("in", "not-in");
  }
  const [fieldOperation, fieldValue] = value || [possibleOperations[0], void 0];
  const [operation, setOperation] = (0, import_react14.useState)(fieldOperation);
  const [internalValue, setInternalValue] = (0, import_react14.useState)(fieldValue);
  const selectedEntityIds = internalValue ? Array.isArray(internalValue) ? internalValue.map((ref2) => {
    if (!((ref2 == null ? void 0 : ref2.isEntityReference) && (ref2 == null ? void 0 : ref2.isEntityReference()))) {
      return null;
    }
    return ref2.id;
  }).filter(Boolean) : [internalValue.id] : [];
  function updateFilter(op, val) {
    const prevOpIsArray = multipleSelectOperations$2.includes(operation);
    const newOpIsArray = multipleSelectOperations$2.includes(op);
    let newValue = val;
    if (prevOpIsArray !== newOpIsArray) {
      newValue = newOpIsArray ? (newValue == null ? void 0 : newValue.isEntityReference) && (newValue == null ? void 0 : newValue.isEntityReference()) ? [newValue] : [] : void 0;
    }
    setOperation(op);
    setInternalValue(newValue);
    const hasNewValue = newValue !== null && Array.isArray(newValue) ? newValue.length > 0 : newValue !== void 0;
    if (op && hasNewValue) {
      setValue([op, newValue]);
    } else {
      setValue(void 0);
    }
  }
  const navigationController = useNavigationController();
  const collection = (0, import_react14.useMemo)(() => {
    return path ? navigationController.getCollection(path) : void 0;
  }, [path]);
  const onSingleEntitySelected = (entity) => {
    updateFilter(operation, getReferenceFrom(entity));
  };
  const onMultipleEntitiesSelected = (entities) => {
    updateFilter(operation, entities.map((e2) => getReferenceFrom(e2)));
  };
  const multiple = multipleSelectOperations$2.includes(operation);
  const referenceDialogController = useReferenceDialog({
    multiselect: multiple,
    path,
    collection,
    onSingleEntitySelected,
    onMultipleEntitiesSelected,
    selectedEntityIds,
    onClose: () => {
      setHidden(false);
    }
  });
  const doOpenDialog = () => {
    setHidden(true);
    referenceDialogController.open();
  };
  const buildEntry = (reference2) => {
    return (0, import_jsx_runtime2.jsx)(ReferencePreview, { disabled: !path, previewProperties, size: "medium", onClick: doOpenDialog, reference: reference2, hover: true, includeId, includeEntityLink: false });
  };
  return (0, import_jsx_runtime2.jsxs)("div", { className: "flex w-[480px] flex-row", children: [
    (0, import_jsx_runtime2.jsx)("div", { className: "w-[140px]", children: (0, import_jsx_runtime2.jsx)(Select, { value: operation, size: "large", fullWidth: true, onValueChange: (value_0) => {
      updateFilter(value_0, internalValue);
    }, renderValue: (op_0) => operationLabels$2[op_0], children: possibleOperations.map((op_1) => (0, import_jsx_runtime2.jsx)(SelectItem, { value: op_1, children: operationLabels$2[op_1] }, op_1)) }) }),
    (0, import_jsx_runtime2.jsxs)("div", { className: "flex-grow ml-2 h-full gap-2 flex flex-col w-[340px]", children: [
      internalValue && Array.isArray(internalValue) && (0, import_jsx_runtime2.jsx)("div", { children: internalValue.map((ref_0, index2) => buildEntry(ref_0)) }),
      internalValue && !Array.isArray(internalValue) && (0, import_jsx_runtime2.jsx)("div", { children: buildEntry(internalValue) }),
      (!internalValue || Array.isArray(internalValue) && internalValue.length === 0) && (0, import_jsx_runtime2.jsx)(Button, { onClick: doOpenDialog, variant: "outlined", size: "large", className: "h-full w-full", children: multiple ? "Select references" : "Select reference" }),
      !isArray2 && (0, import_jsx_runtime2.jsxs)(Label, { className: "border cursor-pointer rounded-md p-2 flex items-center gap-2 [&:has(:checked)]:bg-surface-100 dark:[&:has(:checked)]:bg-surface-800", htmlFor: "null-filter", children: [
        (0, import_jsx_runtime2.jsx)(Checkbox, { id: "null-filter", checked: internalValue === null, size: "small", onCheckedChange: (checked) => {
          if (internalValue !== null) updateFilter(operation, null);
          else updateFilter(operation, void 0);
        } }),
        "Filter for null values"
      ] })
    ] })
  ] });
}
var operationLabels$1 = {
  "==": "==",
  "!=": "!=",
  ">": ">",
  "<": "<",
  ">=": ">=",
  "<=": "<=",
  in: "In",
  "not-in": "Not in",
  "array-contains": "Contains",
  "array-contains-any": "Any"
};
var multipleSelectOperations$1 = ["array-contains-any", "in", "not-in"];
function StringNumberFilterField(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(55);
  const {
    name,
    value,
    setValue,
    dataType,
    isArray: isArray2,
    enumValues
  } = t0;
  let possibleOperations;
  if ($[0] !== enumValues || $[1] !== isArray2) {
    possibleOperations = isArray2 ? ["array-contains"] : ["==", "!=", ">", "<", ">=", "<="];
    if (enumValues) {
      isArray2 ? possibleOperations.push("array-contains-any") : possibleOperations.push("in", "not-in");
    }
    $[0] = enumValues;
    $[1] = isArray2;
    $[2] = possibleOperations;
  } else {
    possibleOperations = $[2];
  }
  let t1;
  if ($[3] !== possibleOperations || $[4] !== value) {
    t1 = value || [possibleOperations[0], void 0];
    $[3] = possibleOperations;
    $[4] = value;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const [fieldOperation, fieldValue] = t1;
  const [operation, setOperation] = (0, import_react14.useState)(fieldOperation);
  const [internalValue, setInternalValue] = (0, import_react14.useState)(fieldValue);
  let t2;
  if ($[6] !== operation || $[7] !== setValue) {
    t2 = function updateFilter2(op, val) {
      let newValue = val;
      const prevOpIsArray = multipleSelectOperations$1.includes(operation);
      const newOpIsArray = multipleSelectOperations$1.includes(op);
      if (prevOpIsArray !== newOpIsArray) {
        newValue = newOpIsArray ? typeof val === "string" || typeof val === "number" ? [val] : [] : void 0;
      }
      if (typeof newValue === "number" && isNaN(newValue)) {
        newValue = void 0;
      }
      setOperation(op);
      setInternalValue(newValue);
      const hasNewValue = newValue !== null && Array.isArray(newValue) ? newValue.length > 0 : newValue !== void 0;
      if (op && hasNewValue) {
        setValue([op, newValue]);
      } else {
        setValue(void 0);
      }
    };
    $[6] = operation;
    $[7] = setValue;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const updateFilter = t2;
  let t3;
  if ($[9] !== operation) {
    t3 = multipleSelectOperations$1.includes(operation);
    $[9] = operation;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  const multiple = t3;
  let t4;
  if ($[11] !== internalValue || $[12] !== updateFilter) {
    t4 = (value_0) => {
      updateFilter(value_0, internalValue);
    };
    $[11] = internalValue;
    $[12] = updateFilter;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== possibleOperations) {
    t5 = possibleOperations.map(_temp2$7);
    $[14] = possibleOperations;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== operation || $[17] !== t4 || $[18] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)("div", { className: "w-[80px]", children: (0, import_jsx_runtime2.jsx)(Select, { value: operation, fullWidth: true, position: "item-aligned", onValueChange: t4, renderValue: _temp$h, children: t5 }) });
    $[16] = operation;
    $[17] = t4;
    $[18] = t5;
    $[19] = t6;
  } else {
    t6 = $[19];
  }
  let t7;
  if ($[20] !== dataType || $[21] !== enumValues || $[22] !== internalValue || $[23] !== operation || $[24] !== updateFilter) {
    t7 = !enumValues && (0, import_jsx_runtime2.jsx)(TextField, { type: dataType === "number" ? "number" : void 0, value: internalValue !== void 0 && internalValue != null ? String(internalValue) : "", onChange: (evt) => {
      const val_0 = dataType === "number" ? parseFloat(evt.target.value) : evt.target.value;
      updateFilter(operation, val_0);
    }, endAdornment: internalValue && (0, import_jsx_runtime2.jsx)(IconButton, { onClick: (e2) => updateFilter(operation, void 0), children: (0, import_jsx_runtime2.jsx)(CloseIcon, {}) }) });
    $[20] = dataType;
    $[21] = enumValues;
    $[22] = internalValue;
    $[23] = operation;
    $[24] = updateFilter;
    $[25] = t7;
  } else {
    t7 = $[25];
  }
  let t8;
  if ($[26] !== dataType || $[27] !== enumValues || $[28] !== internalValue || $[29] !== multiple || $[30] !== name || $[31] !== operation || $[32] !== updateFilter) {
    t8 = enumValues && !multiple && (0, import_jsx_runtime2.jsx)(Select, { position: "item-aligned", fullWidth: true, value: typeof internalValue === "string" ? internalValue : "", onValueChange: (value_1) => {
      if (value_1 !== "") {
        updateFilter(operation, dataType === "number" ? parseInt(value_1) : value_1);
      }
    }, endAdornment: internalValue && (0, import_jsx_runtime2.jsx)(IconButton, { className: "absolute right-2 top-3", onClick: (e_0) => updateFilter(operation, void 0), children: (0, import_jsx_runtime2.jsx)(CloseIcon, {}) }), renderValue: (enumKey) => {
      if (enumKey === null) {
        return "Filter for null values";
      }
      if (enumKey === void 0) {
        return null;
      }
      return (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey, enumValues, size: "small" }, `select_value_${name}_${enumKey}`);
    }, children: enumValues.map((enumConfig) => (0, import_jsx_runtime2.jsx)(SelectItem, { value: String(enumConfig.id), children: (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey: String(enumConfig.id), enumValues, size: "small" }) }, `select_item_${name}_${enumConfig.id}`)) });
    $[26] = dataType;
    $[27] = enumValues;
    $[28] = internalValue;
    $[29] = multiple;
    $[30] = name;
    $[31] = operation;
    $[32] = updateFilter;
    $[33] = t8;
  } else {
    t8 = $[33];
  }
  let t9;
  if ($[34] !== dataType || $[35] !== enumValues || $[36] !== internalValue || $[37] !== multiple || $[38] !== name || $[39] !== operation || $[40] !== updateFilter) {
    t9 = enumValues && multiple && (0, import_jsx_runtime2.jsx)(MultiSelect, { position: "item-aligned", value: Array.isArray(internalValue) ? internalValue.map(_temp3$3) : [], onValueChange: (value_2) => {
      updateFilter(operation, dataType === "number" ? value_2.map(_temp4$2) : value_2);
    }, multiple, endAdornment: internalValue && (0, import_jsx_runtime2.jsx)(IconButton, { className: "absolute right-2 top-3", onClick: (e_2) => updateFilter(operation, void 0), children: (0, import_jsx_runtime2.jsx)(CloseIcon, {}) }), children: enumValues.map((enumConfig_0) => (0, import_jsx_runtime2.jsx)(MultiSelectItem, { value: String(enumConfig_0.id), children: (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey: String(enumConfig_0.id), enumValues, size: "small" }) }, `select_value_${name}_${enumConfig_0.id}`)) });
    $[34] = dataType;
    $[35] = enumValues;
    $[36] = internalValue;
    $[37] = multiple;
    $[38] = name;
    $[39] = operation;
    $[40] = updateFilter;
    $[41] = t9;
  } else {
    t9 = $[41];
  }
  let t10;
  if ($[42] !== internalValue || $[43] !== isArray2 || $[44] !== operation || $[45] !== updateFilter) {
    t10 = !isArray2 && (0, import_jsx_runtime2.jsxs)(Label, { className: "border cursor-pointer rounded-md p-2 flex items-center gap-2 [&:has(:checked)]:bg-surface-100 dark:[&:has(:checked)]:bg-surface-800", htmlFor: "null-filter", children: [
      (0, import_jsx_runtime2.jsx)(Checkbox, { id: "null-filter", checked: internalValue === null, size: "small", onCheckedChange: (checked) => {
        if (internalValue !== null) {
          updateFilter(operation, null);
        } else {
          updateFilter(operation, void 0);
        }
      } }),
      "Filter for null values"
    ] });
    $[42] = internalValue;
    $[43] = isArray2;
    $[44] = operation;
    $[45] = updateFilter;
    $[46] = t10;
  } else {
    t10 = $[46];
  }
  let t11;
  if ($[47] !== t10 || $[48] !== t7 || $[49] !== t8 || $[50] !== t9) {
    t11 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex-grow ml-2 flex flex-col gap-2", children: [
      t7,
      t8,
      t9,
      t10
    ] });
    $[47] = t10;
    $[48] = t7;
    $[49] = t8;
    $[50] = t9;
    $[51] = t11;
  } else {
    t11 = $[51];
  }
  let t12;
  if ($[52] !== t11 || $[53] !== t6) {
    t12 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex w-[440px]", children: [
      t6,
      t11
    ] });
    $[52] = t11;
    $[53] = t6;
    $[54] = t12;
  } else {
    t12 = $[54];
  }
  return t12;
}
function _temp4$2(v) {
  return parseInt(v);
}
function _temp3$3(e_1) {
  return String(e_1);
}
function _temp2$7(op_1) {
  return (0, import_jsx_runtime2.jsx)(SelectItem, { value: op_1, children: operationLabels$1[op_1] }, op_1);
}
function _temp$h(op_0) {
  return operationLabels$1[op_0];
}
function BooleanFilterField(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(8);
  const {
    title,
    value,
    setValue
  } = t0;
  let t1;
  if ($[0] !== setValue) {
    t1 = function updateFilter2(val) {
      if (val !== void 0) {
        setValue(["==", val]);
      } else {
        setValue(void 0);
      }
    };
    $[0] = setValue;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const updateFilter = t1;
  const valueSetToTrue = value && value[1];
  const valueSet = !!value;
  let t2;
  if ($[2] !== updateFilter) {
    t2 = (v) => updateFilter(v === null ? void 0 : v);
    $[2] = updateFilter;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const t3 = !valueSet ? "No filter" : valueSetToTrue ? `${title} is true` : `${title} is false`;
  let t4;
  if ($[4] !== t2 || $[5] !== t3 || $[6] !== valueSetToTrue) {
    t4 = (0, import_jsx_runtime2.jsx)("div", { className: "w-[300px]", children: (0, import_jsx_runtime2.jsx)(BooleanSwitchWithLabel, { value: valueSetToTrue, allowIndeterminate: true, onValueChange: t2, label: t3 }) });
    $[4] = t2;
    $[5] = t3;
    $[6] = valueSetToTrue;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  return t4;
}
var operationLabels = {
  "==": "==",
  "!=": "!=",
  ">": ">",
  "<": "<",
  ">=": ">=",
  "<=": "<=",
  "not-in": "not in",
  in: "in",
  "array-contains": "Contains",
  "array-contains-any": "Any"
};
var multipleSelectOperations = ["array-contains-any", "in"];
function DateTimeFilterField(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(38);
  const {
    isArray: isArray2,
    mode,
    value,
    setValue
  } = t0;
  const {
    locale
  } = useCustomizationController();
  let t1;
  if ($[0] !== isArray2) {
    t1 = isArray2 ? ["array-contains"] : ["==", "!=", ">", "<", ">=", "<="];
    $[0] = isArray2;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const possibleOperations = t1;
  let t2;
  if ($[2] !== possibleOperations || $[3] !== value) {
    t2 = value || [possibleOperations[0], void 0];
    $[2] = possibleOperations;
    $[3] = value;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  const [fieldOperation, fieldValue] = t2;
  const [operation, setOperation] = (0, import_react14.useState)(fieldOperation);
  const [internalValue, setInternalValue] = (0, import_react14.useState)(fieldValue);
  let t3;
  if ($[5] !== operation || $[6] !== setValue) {
    t3 = function updateFilter2(op, val) {
      let newValue = val;
      const prevOpIsArray = multipleSelectOperations.includes(operation);
      const newOpIsArray = multipleSelectOperations.includes(op);
      if (prevOpIsArray !== newOpIsArray) {
        newValue = newOpIsArray ? val ? [val] : [] : "";
      }
      setOperation(op);
      setInternalValue(newValue === null ? void 0 : newValue);
      const hasNewValue = newValue !== null && Array.isArray(newValue) ? newValue.length > 0 : newValue !== void 0;
      if (op && hasNewValue) {
        setValue([op, newValue]);
      } else {
        setValue(void 0);
      }
    };
    $[5] = operation;
    $[6] = setValue;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  const updateFilter = t3;
  let t4;
  if ($[8] !== internalValue || $[9] !== updateFilter) {
    t4 = (value_0) => {
      updateFilter(value_0, internalValue);
    };
    $[8] = internalValue;
    $[9] = updateFilter;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  let t5;
  if ($[11] !== possibleOperations) {
    t5 = possibleOperations.map(_temp2$6);
    $[11] = possibleOperations;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== operation || $[14] !== t4 || $[15] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)("div", { className: "w-[80px]", children: (0, import_jsx_runtime2.jsx)(Select, { value: operation, size: "large", fullWidth: true, onValueChange: t4, renderValue: _temp$g, children: t5 }) });
    $[13] = operation;
    $[14] = t4;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  const t7 = internalValue ?? void 0;
  let t8;
  if ($[17] !== operation || $[18] !== updateFilter) {
    t8 = (dateValue) => {
      updateFilter(operation, dateValue === null ? void 0 : dateValue);
    };
    $[17] = operation;
    $[18] = updateFilter;
    $[19] = t8;
  } else {
    t8 = $[19];
  }
  let t9;
  if ($[20] !== locale || $[21] !== mode || $[22] !== t7 || $[23] !== t8) {
    t9 = (0, import_jsx_runtime2.jsx)(DateTimeField, { mode, size: "large", locale, value: t7, onChange: t8, clearable: true });
    $[20] = locale;
    $[21] = mode;
    $[22] = t7;
    $[23] = t8;
    $[24] = t9;
  } else {
    t9 = $[24];
  }
  const t10 = internalValue === null;
  let t11;
  if ($[25] !== internalValue || $[26] !== operation || $[27] !== updateFilter) {
    t11 = (checked) => {
      if (internalValue !== null) {
        updateFilter(operation, null);
      } else {
        updateFilter(operation, void 0);
      }
    };
    $[25] = internalValue;
    $[26] = operation;
    $[27] = updateFilter;
    $[28] = t11;
  } else {
    t11 = $[28];
  }
  let t12;
  if ($[29] !== t10 || $[30] !== t11) {
    t12 = (0, import_jsx_runtime2.jsxs)(Label, { className: "border cursor-pointer rounded-md p-2 flex items-center gap-2 [&:has(:checked)]:bg-surface-100 dark:[&:has(:checked)]:bg-surface-800", htmlFor: "null-filter", children: [
      (0, import_jsx_runtime2.jsx)(Checkbox, { id: "null-filter", checked: t10, size: "small", onCheckedChange: t11 }),
      "Filter for null values"
    ] });
    $[29] = t10;
    $[30] = t11;
    $[31] = t12;
  } else {
    t12 = $[31];
  }
  let t13;
  if ($[32] !== t12 || $[33] !== t9) {
    t13 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex-grow ml-2 flex flex-col gap-2", children: [
      t9,
      t12
    ] });
    $[32] = t12;
    $[33] = t9;
    $[34] = t13;
  } else {
    t13 = $[34];
  }
  let t14;
  if ($[35] !== t13 || $[36] !== t6) {
    t14 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex w-[440px]", children: [
      t6,
      t13
    ] });
    $[35] = t13;
    $[36] = t6;
    $[37] = t14;
  } else {
    t14 = $[37];
  }
  return t14;
}
function _temp2$6(op_1) {
  return (0, import_jsx_runtime2.jsx)(SelectItem, { value: op_1, children: operationLabels[op_1] }, op_1);
}
function _temp$g(op_0) {
  return operationLabels[op_0];
}
var SelectableTable = import_react14.default.memo(
  function SelectableTable2({
    onValueChange,
    cellRenderer,
    onEntityClick,
    onColumnResize,
    hoverRow = true,
    size: size2 = "m",
    inlineEditing = false,
    tableController: {
      data,
      dataLoading,
      noMoreToLoad,
      dataLoadingError,
      filterValues,
      setFilterValues,
      sortBy,
      setSortBy,
      itemCount,
      setItemCount,
      pageSize = 50,
      paginationEnabled,
      checkFilterCombination,
      setPopupCell
    },
    filterable = true,
    onScroll,
    initialScroll,
    emptyComponent,
    columns,
    forceFilter,
    highlightedRow,
    endAdornment,
    AddColumnComponent
  }) {
    const ref2 = (0, import_react14.useRef)(null);
    const [selectedCell, setSelectedCell] = import_react14.default.useState(void 0);
    const loadNextPage = () => {
      if (!paginationEnabled || dataLoading || noMoreToLoad) return;
      if (itemCount !== void 0) setItemCount == null ? void 0 : setItemCount(itemCount + pageSize);
    };
    const resetPagination = (0, import_react14.useCallback)(() => {
      setItemCount == null ? void 0 : setItemCount(pageSize);
    }, [pageSize]);
    const onRowClick = (0, import_react14.useCallback)(({
      rowData
    }) => {
      if (inlineEditing) return;
      return onEntityClick && onEntityClick(rowData);
    }, [onEntityClick, inlineEditing]);
    useOutsideAlerter(ref2, () => {
      if (selectedCell) {
        unselect();
      }
    }, Boolean(selectedCell));
    (0, import_react14.useEffect)(() => {
      const escFunction = (event) => {
        if (event.keyCode === 27) {
          unselect();
        }
      };
      document.addEventListener("keydown", escFunction, false);
      return () => {
        document.removeEventListener("keydown", escFunction, false);
      };
    });
    const select = (0, import_react14.useCallback)((cell) => {
      setSelectedCell(cell);
    }, []);
    const unselect = (0, import_react14.useCallback)(() => {
      setSelectedCell(void 0);
    }, []);
    const onFilterUpdate = (0, import_react14.useCallback)((updatedFilterValues) => {
      setFilterValues == null ? void 0 : setFilterValues({
        ...updatedFilterValues,
        ...forceFilter
      });
    }, [forceFilter]);
    return (0, import_jsx_runtime2.jsx)(SelectableTableContext.Provider, { value: {
      setPopupCell,
      select,
      onValueChange,
      size: size2 ?? "m",
      selectedCell
    }, children: (0, import_jsx_runtime2.jsx)("div", { className: "h-full w-full flex flex-col bg-white dark:bg-surface-950", ref: ref2, children: (0, import_jsx_runtime2.jsx)(VirtualTable, { data, columns, cellRenderer, onRowClick: inlineEditing ? void 0 : onEntityClick ? onRowClick : void 0, onEndReached: loadNextPage, onResetPagination: resetPagination, error: dataLoadingError, onColumnResize, rowHeight: getRowHeight3(size2), loading: dataLoading, filter: filterValues, onFilterUpdate: setFilterValues ? onFilterUpdate : void 0, sortBy, onSortByUpdate: setSortBy, hoverRow, initialScroll, onScroll, checkFilterCombination, createFilterField: filterable ? createFilterField : void 0, rowClassName: (0, import_react14.useCallback)((entity) => {
      return (highlightedRow == null ? void 0 : highlightedRow(entity)) ? "bg-surface-100 bg-opacity-75 dark:bg-surface-800 dark:bg-opacity-75" : "";
    }, [highlightedRow]), className: "flex-grow", emptyComponent, endAdornment, AddColumnComponent }) }) });
  },
  () => false
  // equal
);
function createFilterField({
  id: id2,
  filterValue,
  setFilterValue,
  column,
  hidden,
  setHidden
}) {
  if (!column.custom) {
    return null;
  }
  const {
    resolvedProperty
  } = column.custom;
  const isArray2 = (resolvedProperty == null ? void 0 : resolvedProperty.dataType) === "array";
  const baseProperty = isArray2 ? resolvedProperty.of : resolvedProperty;
  if (!baseProperty) {
    return null;
  }
  if (baseProperty.dataType === "reference") {
    return (0, import_jsx_runtime2.jsx)(ReferenceFilterField, { value: filterValue, setValue: setFilterValue, name: id2, isArray: isArray2, path: baseProperty.path, title: resolvedProperty == null ? void 0 : resolvedProperty.name, includeId: baseProperty.includeId, previewProperties: baseProperty == null ? void 0 : baseProperty.previewProperties, hidden, setHidden });
  } else if (baseProperty.dataType === "number" || baseProperty.dataType === "string") {
    const name = baseProperty.name;
    const enumValues = baseProperty.enumValues ? enumToObjectEntries(baseProperty.enumValues) : void 0;
    return (0, import_jsx_runtime2.jsx)(StringNumberFilterField, { value: filterValue, setValue: setFilterValue, name: id2, dataType: baseProperty.dataType, isArray: isArray2, enumValues, title: name });
  } else if (baseProperty.dataType === "boolean") {
    const name = baseProperty.name;
    return (0, import_jsx_runtime2.jsx)(BooleanFilterField, { value: filterValue, setValue: setFilterValue, name: id2, title: name });
  } else if (baseProperty.dataType === "date") {
    const title = baseProperty.name;
    return (0, import_jsx_runtime2.jsx)(DateTimeFilterField, { value: filterValue, setValue: setFilterValue, name: id2, mode: baseProperty.mode, isArray: isArray2, title });
  }
  return (0, import_jsx_runtime2.jsx)("div", { children: `Currently the filter field ${resolvedProperty.dataType} is not supported` });
}
var EntityCollectionTable = function EntityCollectionTable2({
  className,
  style: style3,
  forceFilter,
  actionsStart,
  actions,
  title,
  tableRowActionsBuilder,
  uniqueFieldValidator,
  getPropertyFor,
  onValueChange,
  selectionController,
  highlightedEntities,
  onEntityClick,
  onColumnResize,
  initialScroll,
  onScroll,
  onSizeChanged,
  textSearchEnabled = false,
  hoverRow = true,
  inlineEditing = false,
  additionalFields,
  displayedColumnIds,
  defaultSize,
  properties,
  tableController,
  filterable = true,
  sortable = true,
  endAdornment,
  AddColumnComponent,
  AdditionalHeaderWidget,
  additionalIDHeaderWidget,
  emptyComponent,
  getIdColumnWidth,
  onTextSearchClick,
  textSearchLoading,
  enablePopupIcon,
  openEntityMode = "side_panel"
}) {
  var _a, _b;
  const ref2 = (0, import_react14.useRef)(null);
  const largeLayout = useLargeLayout();
  const selectedEntities = (_b = ((_a = selectionController == null ? void 0 : selectionController.selectedEntities) == null ? void 0 : _a.length) > 0 ? selectionController == null ? void 0 : selectionController.selectedEntities : highlightedEntities) == null ? void 0 : _b.filter(Boolean);
  const context = useFireCMSContext();
  const [size2, setSize] = import_react14.default.useState(defaultSize ?? "m");
  const updateSize = (0, import_react14.useCallback)((size_0) => {
    if (onSizeChanged) onSizeChanged(size_0);
    setSize(size_0);
  }, []);
  const onTextSearch = (0, import_react14.useCallback)((newSearchString) => {
    var _a2;
    return (_a2 = tableController.setSearchString) == null ? void 0 : _a2.call(tableController, newSearchString);
  }, []);
  const additionalFieldsMap = (0, import_react14.useMemo)(() => {
    return additionalFields ? additionalFields.map((aC) => ({
      [aC.key]: aC
    })).reduce((a2, b2) => ({
      ...a2,
      ...b2
    }), {}) : {};
  }, [additionalFields]);
  const customFieldValidator = uniqueFieldValidator;
  const propertyCellRenderer = ({
    column,
    columnIndex,
    rowData,
    rowIndex
  }) => {
    var _a2;
    const entity = rowData;
    const propertyKey = column.key;
    let disabled = (_a2 = column.custom) == null ? void 0 : _a2.disabled;
    const property = (getPropertyFor == null ? void 0 : getPropertyFor({
      propertyKey,
      entity
    })) ?? column.custom.resolvedProperty;
    if (!(property == null ? void 0 : property.disabled)) {
      disabled = false;
    }
    if (!property) {
      return null;
    }
    return (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: entity ? (0, import_jsx_runtime2.jsx)(PropertyTableCell, { readonly: !inlineEditing, align: column.align ?? "left", propertyKey, property, value: (entity == null ? void 0 : entity.values) ? getValueInPath(entity.values, propertyKey) : void 0, customFieldValidator, columnIndex, width: column.width, height: getRowHeight3(size2), entity, disabled, enablePopupIcon, path: entity.path }, `property_table_cell_${entity.id}_${propertyKey}`) : renderSkeletonText() });
  };
  const additionalCellRenderer = (0, import_react14.useCallback)(({
    column: column_0,
    rowData: rowData_0,
    width
  }) => {
    var _a2, _b2;
    const entity_0 = rowData_0;
    const additionalField = additionalFieldsMap[column_0.key];
    const value_0 = additionalField.dependencies ? Object.entries(entity_0.values).filter(([key, value]) => additionalField.dependencies.includes(key)).reduce((a_0, b_0) => ({
      ...a_0,
      ...b_0
    }), {}) : entity_0;
    const Builder = additionalField.Builder;
    if (!Builder && !additionalField.value) {
      throw new Error("When using additional fields you need to provide a Builder or a value");
    }
    const child = Builder ? (0, import_jsx_runtime2.jsx)(Builder, { entity: entity_0, context }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (_b2 = (_a2 = additionalField.value) == null ? void 0 : _a2.call(additionalField, {
      entity: entity_0,
      context
    })) == null ? void 0 : _b2.toString() });
    return (0, import_jsx_runtime2.jsx)(EntityTableCell, { width, size: size2, value: value_0, selected: false, disabled: true, align: "left", allowScroll: false, showExpandIcon: false, disabledTooltip: "This column can't be edited directly", children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: child }) }, `additional_table_cell_${entity_0.id}_${column_0.key}`);
  }, [size2]);
  const collectionColumns = (() => {
    const columnsResult = propertiesToColumns({
      properties,
      sortable,
      forceFilter,
      AdditionalHeaderWidget
    });
    const additionalTableColumns = additionalFields ? additionalFields.map((additionalField_0) => ({
      key: additionalField_0.key,
      align: "left",
      sortable: false,
      title: additionalField_0.name,
      width: additionalField_0.width ?? 200
    })) : [];
    return [...columnsResult, ...additionalTableColumns];
  })();
  const idColumn = {
    key: "id_ewcfedcswdf3",
    width: (getIdColumnWidth == null ? void 0 : getIdColumnWidth()) ?? (largeLayout ? 160 : 130),
    title: "ID",
    resizable: false,
    frozen: largeLayout,
    headerAlign: "center",
    align: "center",
    AdditionalHeaderWidget: () => additionalIDHeaderWidget
  };
  const columns = [idColumn, ...displayedColumnIds ? displayedColumnIds.map((p3) => {
    return collectionColumns.find((c22) => c22.key === p3.key);
  }).filter(Boolean) : collectionColumns];
  const cellRenderer = (0, import_react14.useCallback)((props) => {
    const column_1 = props.column;
    const columns_0 = props.columns;
    const columnKey = column_1.key;
    try {
      if (props.columnIndex === 0) {
        if (tableRowActionsBuilder) return tableRowActionsBuilder({
          entity: props.rowData,
          size: size2,
          width: column_1.width,
          frozen: column_1.frozen
        });
        else return (0, import_jsx_runtime2.jsx)(EntityCollectionRowActions, { entity: props.rowData, width: column_1.width, frozen: column_1.frozen, isSelected: false, size: size2, openEntityMode });
      } else if (additionalFieldsMap[columnKey]) {
        return additionalCellRenderer(props);
      } else if (props.columnIndex < columns_0.length + 1) {
        return propertyCellRenderer(props);
      } else {
        throw Error("Internal: columns not mapped properly");
      }
    } catch (e2) {
      console.error("Error rendering cell", e2);
      return (0, import_jsx_runtime2.jsx)(EntityTableCell, { size: size2, width: column_1.width, saved: false, value: null, align: "left", fullHeight: false, disabled: true, children: (0, import_jsx_runtime2.jsx)(ErrorView, { error: e2 }) });
    }
  }, [tableRowActionsBuilder, additionalCellRenderer, propertyCellRenderer, size2]);
  return (0, import_jsx_runtime2.jsxs)("div", { ref: ref2, style: style3, className: cls("h-full w-full flex flex-col bg-white dark:bg-surface-950", className), children: [
    (0, import_jsx_runtime2.jsx)(CollectionTableToolbar, { onTextSearch: textSearchEnabled ? onTextSearch : void 0, textSearchLoading, onTextSearchClick: textSearchEnabled ? onTextSearchClick : void 0, size: size2, onSizeChanged: updateSize, title, actionsStart, actions, loading: tableController.dataLoading }),
    (0, import_jsx_runtime2.jsx)(SelectableTable, { columns, size: size2, inlineEditing, cellRenderer, onEntityClick, highlightedRow: (entity_1) => Boolean(selectedEntities == null ? void 0 : selectedEntities.find((e_0) => e_0.id === entity_1.id && e_0.path === entity_1.path)), tableController, onValueChange, initialScroll, onScroll, onColumnResize, hoverRow, filterable, emptyComponent, endAdornment, AddColumnComponent })
  ] });
};
function useDataOrder({
  data,
  entitiesDisplayedFirst
}) {
  if (!entitiesDisplayedFirst) return data;
  const displayedFirstId = new Set(entitiesDisplayedFirst.map((e2) => e2.id));
  return [...entitiesDisplayedFirst, ...data.filter((e2) => !displayedFirstId.has(e2.id))];
}
function useDebouncedData(data, deps, timeoutMs = 5e3) {
  const [deferredData, setDeferredData] = import_react14.default.useState(data);
  const dataLength = import_react14.default.useRef(deferredData.length ?? 0);
  const pendingUpdate = import_react14.default.useRef(false);
  const currentDeps = import_react14.default.useRef(deps);
  const haveDepsChanged = !(0, import_react_fast_compare2.default)(currentDeps.current, deps);
  const immediateUpdate = data.length >= dataLength.current || haveDepsChanged;
  import_react14.default.useEffect(() => {
    const performUpdate = () => {
      if (!(0, import_react_fast_compare2.default)(deferredData, data)) {
        currentDeps.current = deps;
        dataLength.current = data.length;
        setDeferredData(data);
      }
      pendingUpdate.current = false;
    };
    pendingUpdate.current = true;
    let handler;
    if (immediateUpdate) performUpdate();
    else handler = setTimeout(performUpdate, timeoutMs);
    return () => {
      clearTimeout(handler);
      if (pendingUpdate.current && immediateUpdate) performUpdate();
    };
  }, [data, timeoutMs, deps, immediateUpdate]);
  return immediateUpdate ? data : deferredData;
}
var DEFAULT_PAGE_SIZE = 50;
function useDataSourceTableController({
  fullPath,
  collection,
  scrollRestoration,
  entitiesDisplayedFirst,
  lastDeleteTimestamp,
  forceFilter: forceFilterFromProps,
  updateUrl
}) {
  const {
    initialFilter,
    initialSort,
    forceFilter: forceFilterFromCollection
  } = collection;
  const [popupCell, setPopupCell] = import_react14.default.useState(void 0);
  const navigation = useNavigationController();
  const dataSource = useDataSource();
  const resolvedPath = (0, import_react14.useMemo)(() => navigation.resolveIdsFrom(fullPath), [fullPath, navigation.resolveIdsFrom]);
  const forceFilter = forceFilterFromProps ?? forceFilterFromCollection;
  const paginationEnabled = collection.pagination === void 0 || Boolean(collection.pagination);
  const pageSize = typeof collection.pagination === "number" ? collection.pagination : DEFAULT_PAGE_SIZE;
  const [searchString, setSearchString] = import_react14.default.useState();
  const checkFilterCombination = (0, import_react14.useCallback)((filterValues, sortBy) => {
    if (!dataSource.isFilterCombinationValid) return true;
    return dataSource.isFilterCombinationValid({
      path: resolvedPath,
      collection,
      filterValues,
      sortBy
    });
  }, []);
  const onScroll = ({
    scrollOffset
  }) => {
    if (scrollRestoration) {
      scrollRestoration.updateCollectionScroll({
        fullPath: resolvedPath,
        scrollOffset,
        data: rawData,
        filters: filterValues_0
      });
    }
  };
  const initialSortInternal = (0, import_react14.useMemo)(() => {
    if (initialSort && forceFilter && !checkFilterCombination(forceFilter, initialSort)) {
      console.warn("Initial sort is not compatible with the force filter. Ignoring initial sort");
      return void 0;
    }
    return initialSort;
  }, [initialSort, forceFilter]);
  const {
    filterValues: initialFilterUrl,
    sortBy: initialSortUrl
  } = parseFilterAndSort(window.location.search);
  const [filterValues_0, setFilterValues] = import_react14.default.useState(forceFilter ?? (updateUrl ? initialFilterUrl : void 0) ?? initialFilter ?? void 0);
  const [sortBy_0, setSortBy] = import_react14.default.useState(initialSortUrl ?? initialSortInternal);
  useUpdateUrl(filterValues_0, sortBy_0, searchString, updateUrl);
  const collectionScroll = scrollRestoration == null ? void 0 : scrollRestoration.getCollectionScroll(fullPath, filterValues_0);
  const initialItemCount = (collectionScroll == null ? void 0 : collectionScroll.data.length) ?? pageSize;
  (0, import_react14.useEffect)(() => {
    if (scrollRestoration) {
      scrollRestoration.updateCollectionScroll({
        fullPath: resolvedPath,
        scrollOffset: (collectionScroll == null ? void 0 : collectionScroll.scrollOffset) ?? 0,
        data: rawData,
        filters: filterValues_0
      });
    }
  }, []);
  const [itemCount, setItemCount] = import_react14.default.useState(paginationEnabled ? initialItemCount : void 0);
  const sortByProperty = sortBy_0 ? sortBy_0[0] : void 0;
  const currentSort = sortBy_0 ? sortBy_0[1] : void 0;
  const context = useFireCMSContext();
  const [rawData, setRawData] = (0, import_react14.useState)((collectionScroll == null ? void 0 : collectionScroll.data) ?? []);
  const [dataLoading, setDataLoading] = (0, import_react14.useState)(false);
  const [dataLoadingError, setDataLoadingError] = (0, import_react14.useState)();
  const [noMoreToLoad, setNoMoreToLoad] = (0, import_react14.useState)(false);
  const clearFilter = (0, import_react14.useCallback)(() => setFilterValues(forceFilter ?? void 0), [forceFilter]);
  const updateFilterValues = (0, import_react14.useCallback)((updatedFilter) => {
    if (forceFilter) {
      console.warn("Filter is not compatible with the force filter. Ignoring filter");
      return;
    }
    if (updatedFilter && Object.keys(updatedFilter).length === 0) {
      setFilterValues(void 0);
    } else {
      setFilterValues(updatedFilter);
    }
  }, [forceFilter]);
  (0, import_react14.useEffect)(() => {
    setDataLoading(true);
    const onEntitiesUpdate = async (entities) => {
      var _a;
      if ((_a = collection.callbacks) == null ? void 0 : _a.onFetch) {
        try {
          entities = await Promise.all(entities.map((entity) => collection.callbacks.onFetch({
            collection,
            path: resolvedPath,
            entity,
            context
          })));
        } catch (e2) {
          console.error(e2);
        }
      }
      setDataLoading(false);
      setDataLoadingError(void 0);
      setRawData(entities.map((e_0) => ({
        ...e_0
        // values: sanitizeData(e.values, resolvedCollection.properties)
      })));
      setNoMoreToLoad(!itemCount || entities.length < itemCount);
    };
    const onError = (error2) => {
      console.error("ERROR", error2);
      setDataLoading(false);
      setRawData([]);
      setDataLoadingError(error2);
    };
    if (dataSource.listenCollection) {
      return dataSource.listenCollection({
        path: resolvedPath,
        collection,
        onUpdate: onEntitiesUpdate,
        onError,
        searchString,
        filter: filterValues_0,
        limit: itemCount,
        startAfter: void 0,
        orderBy: sortByProperty,
        order: currentSort
      });
    } else {
      dataSource.fetchCollection({
        path: resolvedPath,
        collection,
        searchString,
        filter: filterValues_0,
        limit: itemCount,
        startAfter: void 0,
        orderBy: sortByProperty,
        order: currentSort
      }).then(onEntitiesUpdate).catch(onError);
      return () => {
      };
    }
  }, [resolvedPath, itemCount, currentSort, sortByProperty, filterValues_0, searchString]);
  const orderedData = useDataOrder({
    data: rawData,
    entitiesDisplayedFirst
  });
  const data = useDebouncedData(orderedData, {
    filterValues: filterValues_0,
    sortBy: sortBy_0,
    searchString,
    lastDeleteTimestamp
  });
  return {
    data,
    dataLoading,
    noMoreToLoad,
    dataLoadingError,
    filterValues: filterValues_0,
    setFilterValues: updateFilterValues,
    sortBy: sortBy_0,
    setSortBy,
    searchString,
    setSearchString,
    clearFilter,
    itemCount,
    setItemCount,
    initialScroll: collectionScroll == null ? void 0 : collectionScroll.scrollOffset,
    onScroll,
    paginationEnabled,
    pageSize,
    checkFilterCombination,
    popupCell,
    setPopupCell
  };
}
function useUpdateUrl(filterValues, sortBy, searchString, updateUrl) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  let t0;
  let t1;
  if ($[0] !== filterValues || $[1] !== searchString || $[2] !== sortBy || $[3] !== updateUrl) {
    t0 = () => {
      if (updateUrl) {
        const newUrl = encodeFilterAndSort(filterValues, sortBy);
        const search2 = searchString ? `&search=${encodeURIComponent(searchString)}` : "";
        const state = `${newUrl}${search2}`;
        const hash22 = window.location.hash;
        if (state === "") {
          window.history.replaceState({}, "", `${window.location.pathname}${hash22}`);
        } else {
          window.history.replaceState({}, "", `?${state}${hash22}`);
        }
      }
    };
    t1 = [filterValues, sortBy, searchString, updateUrl];
    $[0] = filterValues;
    $[1] = searchString;
    $[2] = sortBy;
    $[3] = updateUrl;
    $[4] = t0;
    $[5] = t1;
  } else {
    t0 = $[4];
    t1 = $[5];
  }
  (0, import_react14.useEffect)(t0, t1);
}
function encodeFilterAndSort(filterValues, sortBy) {
  const entries = {};
  if (sortBy) {
    entries["__sort"] = encodeURIComponent(sortBy[0]);
    entries["__sort_order"] = encodeURIComponent(sortBy[1]);
  }
  if (filterValues) {
    Object.entries(filterValues).forEach(([key, value]) => {
      if (value) {
        const [op, val] = value;
        let encodedValue = val;
        try {
          if (typeof val === "object") {
            if (val instanceof Date) {
              encodedValue = val.toISOString();
            } else if (Array.isArray(val)) {
              encodedValue = JSON.stringify(val, (key2, value2) => {
                if (value2 instanceof EntityReference) {
                  return encodeRef(value2);
                }
                return value2;
              });
            } else if (val instanceof EntityReference) {
              encodedValue = encodeRef(val);
            }
          }
        } catch (e2) {
          encodedValue = val;
        }
        if (encodedValue !== void 0) {
          entries[encodeURIComponent(`${key}_op`)] = encodeURIComponent(op);
          entries[encodeURIComponent(`${key}_value`)] = encodeURIComponent(encodedValue.toString());
        }
      }
    });
  }
  if (!Object.keys(entries).length) {
    return "";
  }
  return Object.entries(entries).map(([key, value]) => `${key}=${value}`).join("&");
}
function parseFilterAndSort(search2) {
  const entries = new URLSearchParams(search2);
  const filterValues = {};
  let sortBy = void 0;
  entries.forEach((value, key) => {
    if (key === "__sort") {
      sortBy = [decodeURIComponent(value), entries.get("__sort_order")];
    } else if (key.endsWith("_op")) {
      const field = key.replace("_op", "");
      const filterOp = decodeURIComponent(value);
      const filterValStr = entries.get(`${field}_value`);
      if (filterValStr !== null) {
        filterValues[field] = [filterOp, decodeString(filterValStr)];
      }
    }
  });
  return {
    filterValues: Object.keys(filterValues).length ? filterValues : void 0,
    sortBy
  };
}
function isDate4(dateString) {
  const regexPattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;
  if (!regexPattern.test(dateString)) {
    return false;
  }
  const date2 = new Date(dateString);
  return date2.toISOString() === dateString;
}
function encodeRef(val) {
  return `ref::${val.path}/${val.id}`;
}
function decodeString(val) {
  let parsedFilterVal = val;
  if (isDate4(val)) {
    try {
      parsedFilterVal = new Date(val);
    } catch (e2) {
    }
  }
  if (typeof parsedFilterVal === "string") {
    try {
      parsedFilterVal = JSON.parse(parsedFilterVal, (key, value) => {
        if (typeof value === "string" && value.startsWith("ref::")) {
          const [path, id2] = value.substring(5).split("/");
          return new EntityReference(id2, path);
        }
        return value;
      });
    } catch (e2) {
    }
  }
  if (typeof parsedFilterVal === "string" && parsedFilterVal.startsWith("ref::")) {
    const [path, id2] = parsedFilterVal.substring(5).split("/");
    return new EntityReference(id2, path);
  }
  return parsedFilterVal;
}
function useSelectionController(onSelectionChange) {
  const [selectedEntities, setSelectedEntities] = (0, import_react14.useState)([]);
  const toggleEntitySelection = (0, import_react14.useCallback)((entity, newSelectedState) => {
    let newValue;
    if (newSelectedState === void 0) {
      const isSelected = Boolean(selectedEntities.find((e2) => e2.id === entity.id && e2.path === entity.path));
      if (isSelected) {
        onSelectionChange == null ? void 0 : onSelectionChange(entity, false);
        newValue = selectedEntities.filter((item) => !(item.id === entity.id && item.path === entity.path));
      } else {
        onSelectionChange == null ? void 0 : onSelectionChange(entity, true);
        newValue = [...selectedEntities, entity];
      }
    } else {
      if (newSelectedState) {
        onSelectionChange == null ? void 0 : onSelectionChange(entity, true);
        newValue = [...selectedEntities, entity];
      } else {
        onSelectionChange == null ? void 0 : onSelectionChange(entity, false);
        newValue = selectedEntities.filter((item_0) => !(item_0.id === entity.id && item_0.path === entity.path));
      }
    }
    setSelectedEntities(newValue);
  }, [selectedEntities]);
  const isEntitySelected = (0, import_react14.useCallback)((entity_0) => {
    return Boolean(selectedEntities.find((e_0) => e_0.id === entity_0.id && e_0.path === entity_0.path));
  }, [selectedEntities]);
  return {
    selectedEntities,
    setSelectedEntities,
    isEntitySelected,
    toggleEntitySelection
  };
}
function useTableSearchHelper(t0) {
  var _a, _b, _c;
  const $ = (0, import_react_compiler_runtime3.c)(33);
  const {
    collection,
    fullPath,
    parentCollectionIds
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  const dataSource = useDataSource();
  const [textSearchLoading, setTextSearchLoading] = (0, import_react14.useState)(false);
  const [textSearchInitialised, setTextSearchInitialised] = (0, import_react14.useState)(false);
  let onTextSearchClick;
  let textSearchEnabled;
  if ($[0] !== collection || $[1] !== context || $[2] !== customizationController.plugins || $[3] !== dataSource || $[4] !== fullPath || $[5] !== parentCollectionIds) {
    textSearchEnabled = Boolean(collection.textSearchEnabled);
    let props;
    let t12;
    if ($[8] !== collection || $[9] !== context || $[10] !== customizationController.plugins || $[11] !== fullPath || $[12] !== parentCollectionIds) {
      props = {
        context,
        path: fullPath,
        databaseId: collection.databaseId,
        collection,
        parentCollectionIds
      };
      t12 = (_a = customizationController.plugins) == null ? void 0 : _a.find((p3) => {
        var _a2, _b2;
        return (_b2 = (_a2 = p3.collectionView) == null ? void 0 : _a2.blockSearch) == null ? void 0 : _b2.call(_a2, props);
      });
      $[8] = collection;
      $[9] = context;
      $[10] = customizationController.plugins;
      $[11] = fullPath;
      $[12] = parentCollectionIds;
      $[13] = props;
      $[14] = t12;
    } else {
      props = $[13];
      t12 = $[14];
    }
    const searchBlocked = t12;
    let t2;
    if ($[15] !== customizationController.plugins || $[16] !== (dataSource == null ? void 0 : dataSource.initTextSearch)) {
      t2 = Boolean(dataSource == null ? void 0 : dataSource.initTextSearch) || ((_b = customizationController.plugins) == null ? void 0 : _b.find(_temp$f));
      $[15] = customizationController.plugins;
      $[16] = dataSource == null ? void 0 : dataSource.initTextSearch;
      $[17] = t2;
    } else {
      t2 = $[17];
    }
    const addTextSearchClickListener = t2;
    if (addTextSearchClickListener) {
      let t3;
      if ($[18] !== addTextSearchClickListener || $[19] !== collection || $[20] !== context || $[21] !== customizationController.plugins || $[22] !== dataSource || $[23] !== fullPath || $[24] !== parentCollectionIds || $[25] !== props || $[26] !== searchBlocked) {
        t3 = addTextSearchClickListener ? () => {
          var _a2;
          setTextSearchLoading(true);
          const promises = [];
          if ((dataSource == null ? void 0 : dataSource.initTextSearch) && !searchBlocked) {
            promises.push(dataSource.initTextSearch(props));
          }
          if (searchBlocked) {
            (_a2 = customizationController.plugins) == null ? void 0 : _a2.forEach((p_1) => {
              var _a3;
              if ((_a3 = p_1.collectionView) == null ? void 0 : _a3.onTextSearchClick) {
                promises.push(p_1.collectionView.onTextSearchClick({
                  context,
                  path: fullPath,
                  collection,
                  parentCollectionIds
                }));
              }
            });
          }
          return Promise.all(promises).then((res) => {
            if (res.every(Boolean)) {
              setTextSearchInitialised(true);
            }
          }).finally(() => setTextSearchLoading(false));
        } : void 0;
        $[18] = addTextSearchClickListener;
        $[19] = collection;
        $[20] = context;
        $[21] = customizationController.plugins;
        $[22] = dataSource;
        $[23] = fullPath;
        $[24] = parentCollectionIds;
        $[25] = props;
        $[26] = searchBlocked;
        $[27] = t3;
      } else {
        t3 = $[27];
      }
      onTextSearchClick = t3;
      (_c = customizationController.plugins) == null ? void 0 : _c.forEach((p_2) => {
        var _a2;
        if (!textSearchEnabled) {
          if ((_a2 = p_2.collectionView) == null ? void 0 : _a2.showTextSearchBar) {
            textSearchEnabled = p_2.collectionView.showTextSearchBar({
              context,
              path: fullPath,
              collection,
              parentCollectionIds
            });
          }
        }
      });
    }
    $[0] = collection;
    $[1] = context;
    $[2] = customizationController.plugins;
    $[3] = dataSource;
    $[4] = fullPath;
    $[5] = parentCollectionIds;
    $[6] = textSearchEnabled;
    $[7] = onTextSearchClick;
  } else {
    textSearchEnabled = $[6];
    onTextSearchClick = $[7];
  }
  let t1;
  if ($[28] !== onTextSearchClick || $[29] !== textSearchEnabled || $[30] !== textSearchInitialised || $[31] !== textSearchLoading) {
    t1 = {
      textSearchLoading,
      textSearchInitialised,
      onTextSearchClick,
      textSearchEnabled
    };
    $[28] = onTextSearchClick;
    $[29] = textSearchEnabled;
    $[30] = textSearchInitialised;
    $[31] = textSearchLoading;
    $[32] = t1;
  } else {
    t1 = $[32];
  }
  return t1;
}
function _temp$f(p_0) {
  var _a;
  return Boolean((_a = p_0.collectionView) == null ? void 0 : _a.onTextSearchClick);
}
function DeleteEntityDialog({
  entityOrEntitiesToDelete,
  collection,
  onClose,
  open,
  callbacks,
  onEntityDelete,
  onMultipleEntitiesDelete,
  path
}) {
  const authController = useAuthController();
  const dataSource = useDataSource();
  const customizationController = useCustomizationController();
  const snackbarController = useSnackbarController();
  const [loading, setLoading] = (0, import_react14.useState)(false);
  const context = useFireCMSContext();
  const entityOrEntities = Array.isArray(entityOrEntitiesToDelete) && entityOrEntitiesToDelete.length === 1 ? entityOrEntitiesToDelete[0] : entityOrEntitiesToDelete;
  const multipleEntities = Array.isArray(entityOrEntities);
  const resolvedCollection = (0, import_react14.useMemo)(() => resolveCollection({
    collection,
    path,
    propertyConfigs: customizationController.propertyConfigs,
    authController
  }), [collection, path]);
  const handleCancel = (0, import_react14.useCallback)(() => {
    onClose();
  }, [onClose]);
  const onDeleteSuccess = (0, import_react14.useCallback)((entity) => {
    console.debug("Deleted", entity);
  }, []);
  const onDeleteFailure = (0, import_react14.useCallback)((entity_0, e2) => {
    snackbarController.open({
      type: "error",
      message: "Error deleting: " + (e2 == null ? void 0 : e2.message)
    });
    console.error("Error deleting entity");
    console.error(e2);
  }, [resolvedCollection.name]);
  const onPreDeleteHookError = (0, import_react14.useCallback)((entity_1, e_0) => {
    snackbarController.open({
      type: "error",
      message: "Error before deleting: " + (e_0 == null ? void 0 : e_0.message)
    });
    console.error(e_0);
  }, [resolvedCollection.name]);
  const onDeleteSuccessHookError = (0, import_react14.useCallback)((entity_2, e_1) => {
    snackbarController.open({
      type: "error",
      message: "Error after deleting: " + (e_1 == null ? void 0 : e_1.message)
    });
    console.error(e_1);
  }, [resolvedCollection.name]);
  const performDelete = (0, import_react14.useCallback)((entity_3) => deleteEntityWithCallbacks({
    dataSource,
    entity: entity_3,
    collection: resolvedCollection,
    callbacks,
    onDeleteSuccess,
    onDeleteFailure,
    onPreDeleteHookError,
    onDeleteSuccessHookError,
    context
  }), [dataSource, resolvedCollection, callbacks, onDeleteSuccess, onDeleteFailure, onPreDeleteHookError, onDeleteSuccessHookError, context]);
  const handleOk = (0, import_react14.useCallback)(async () => {
    if (entityOrEntities) {
      setLoading(true);
      if (multipleEntities) {
        Promise.all(entityOrEntities.map(performDelete)).then((results) => {
          setLoading(false);
          if (onMultipleEntitiesDelete && entityOrEntities) onMultipleEntitiesDelete(path, entityOrEntities);
          if (results.every(Boolean)) {
            snackbarController.open({
              type: "success",
              message: `${resolvedCollection.name}: multiple deleted`
            });
          } else if (results.some(Boolean)) {
            snackbarController.open({
              type: "warning",
              message: `${resolvedCollection.name}: Some of the entities have been deleted, but not all`
            });
          } else {
            snackbarController.open({
              type: "error",
              message: `${resolvedCollection.name}: Error deleting entities`
            });
          }
          onClose();
        });
      } else {
        performDelete(entityOrEntities).then((success) => {
          setLoading(false);
          if (success) {
            if (onEntityDelete && entityOrEntities) onEntityDelete(path, entityOrEntities);
            snackbarController.open({
              type: "success",
              message: `${resolvedCollection.singularName ?? resolvedCollection.name} deleted`
            });
            onClose();
          }
        });
      }
    }
  }, [entityOrEntities, multipleEntities, performDelete, onMultipleEntitiesDelete, path, onClose, snackbarController, resolvedCollection.name, onEntityDelete]);
  let content;
  if (entityOrEntities && multipleEntities) {
    content = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: "Multiple entities" });
  } else {
    const entity_4 = entityOrEntities;
    content = entity_4 ? (0, import_jsx_runtime2.jsx)(EntityView, { entity: entity_4, collection, path }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  }
  const dialogTitle = multipleEntities ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)("b", { children: resolvedCollection.name }),
    ": Confirm multiple delete?"
  ] }) : `Would you like to delete this ${resolvedCollection.singularName ?? resolvedCollection.name}?`;
  return (0, import_jsx_runtime2.jsxs)(Dialog, { maxWidth: multipleEntities ? "lg" : "2xl", "aria-labelledby": "delete-dialog", open, onOpenChange: (open_0) => !open_0 ? onClose() : void 0, children: [
    (0, import_jsx_runtime2.jsx)(DialogTitle, { id: "delete-dialog-title", children: dialogTitle }),
    (0, import_jsx_runtime2.jsx)(DialogContent, { fullHeight: true, children: !multipleEntities && (0, import_jsx_runtime2.jsx)("div", { className: "p-4", children: content }) }),
    (0, import_jsx_runtime2.jsxs)(DialogActions, { children: [
      loading && (0, import_jsx_runtime2.jsx)(CircularProgress, { size: "smallest" }),
      (0, import_jsx_runtime2.jsx)(Button, { onClick: handleCancel, disabled: loading, variant: "text", color: "primary", children: "Cancel" }),
      (0, import_jsx_runtime2.jsx)(Button, { autoFocus: true, disabled: loading, onClick: handleOk, variant: "filled", color: "primary", children: "Ok" })
    ] })
  ] });
}
function addRecentId(collectionId, id2) {
  const recentIds = getRecentIds(collectionId);
  const newRecentIds = [id2, ...recentIds.filter((i2) => i2 !== id2)];
  if (newRecentIds.length > 5) {
    newRecentIds.pop();
  }
  saveSearchedIdsLocally(collectionId, newRecentIds);
  return newRecentIds;
}
function saveSearchedIdsLocally(collectionId, ids) {
  localStorage.setItem("recent_id_searches::" + collectionId, JSON.stringify(ids));
}
function getRecentIds(collectionId) {
  const stored = localStorage.getItem("recent_id_searches::" + collectionId);
  if (!stored) return [];
  return JSON.parse(stored);
}
var editEntityAction = {
  icon: (0, import_jsx_runtime2.jsx)(EditIcon, {}),
  key: "edit",
  name: "Edit",
  collapsed: false,
  onClick({
    entity,
    collection,
    fullPath,
    context,
    highlightEntity,
    unhighlightEntity,
    openEntityMode
  }) {
    var _a, _b;
    highlightEntity == null ? void 0 : highlightEntity(entity);
    (_b = (_a = context.analyticsController) == null ? void 0 : _a.onAnalyticsEvent) == null ? void 0 : _b.call(_a, "entity_click", {
      path: entity.path,
      entityId: entity.id
    });
    if (collection) {
      addRecentId(collection.id, entity.id);
    }
    const path = (collection == null ? void 0 : collection.collectionGroup) ? collection.id : fullPath ?? (collection == null ? void 0 : collection.id) ?? entity.path;
    const defaultSelectedView = resolveDefaultSelectedView(collection ? collection.defaultSelectedView : void 0, {
      status: "existing",
      entityId: entity.id
    });
    navigateToEntity({
      openEntityMode,
      collection,
      entityId: entity.id,
      path,
      fullIdPath: path,
      sideEntityController: context.sideEntityController,
      onClose: () => unhighlightEntity == null ? void 0 : unhighlightEntity(entity),
      navigation: context.navigation,
      selectedTab: defaultSelectedView
    });
    return Promise.resolve(void 0);
  }
};
var copyEntityAction = {
  icon: (0, import_jsx_runtime2.jsx)(FileCopyIcon, {}),
  name: "Copy",
  key: "copy",
  onClick({
    entity,
    collection,
    context,
    fullPath,
    highlightEntity,
    unhighlightEntity,
    openEntityMode
  }) {
    var _a, _b;
    highlightEntity == null ? void 0 : highlightEntity(entity);
    (_b = (_a = context.analyticsController) == null ? void 0 : _a.onAnalyticsEvent) == null ? void 0 : _b.call(_a, "copy_entity_click", {
      path: entity.path,
      entityId: entity.id
    });
    const path = (collection == null ? void 0 : collection.collectionGroup) ? collection.id : fullPath ?? (collection == null ? void 0 : collection.id) ?? entity.path;
    navigateToEntity({
      openEntityMode,
      collection,
      entityId: entity.id,
      path,
      fullIdPath: path,
      copy: true,
      sideEntityController: context.sideEntityController,
      onClose: () => unhighlightEntity == null ? void 0 : unhighlightEntity(entity),
      navigation: context.navigation
    });
    return Promise.resolve(void 0);
  }
};
var deleteEntityAction = {
  icon: (0, import_jsx_runtime2.jsx)(DeleteIcon, {}),
  name: "Delete",
  key: "delete",
  onClick({
    entity,
    fullPath,
    collection,
    context,
    selectionController,
    onCollectionChange,
    sideEntityController
  }) {
    const {
      closeDialog
    } = context.dialogsController.open({
      key: "delete_entity_dialog_" + entity.id,
      Component: ({
        open
      }) => {
        if (!collection || !fullPath) throw new Error("deleteEntityAction: Collection is undefined");
        return (0, import_jsx_runtime2.jsx)(DeleteEntityDialog, { entityOrEntitiesToDelete: entity, path: fullPath, collection, callbacks: collection.callbacks, open, onEntityDelete: () => {
          var _a, _b;
          (_b = (_a = context.analyticsController) == null ? void 0 : _a.onAnalyticsEvent) == null ? void 0 : _b.call(_a, "single_entity_deleted", {
            path: fullPath
          });
          selectionController == null ? void 0 : selectionController.setSelectedEntities(selectionController.selectedEntities.filter((e2) => e2.id !== entity.id));
          onCollectionChange == null ? void 0 : onCollectionChange();
          sideEntityController == null ? void 0 : sideEntityController.close();
        }, onClose: closeDialog });
      }
    });
    return Promise.resolve(void 0);
  }
};
function ReferenceSelectionTable({
  onSingleEntitySelected,
  onMultipleEntitiesSelected,
  multiselect,
  collection,
  path: pathInput,
  selectedEntityIds: selectedEntityIdsProp,
  description,
  forceFilter,
  maxSelection
}) {
  const authController = useAuthController();
  const sideDialogContext = useSideDialogContext();
  const sideEntityController = useSideEntityController();
  const navigation = useNavigationController();
  const analyticsController = useAnalyticsController();
  const customizationController = useCustomizationController();
  const fullPath = navigation.resolveIdsFrom(pathInput);
  const dataSource = useDataSource();
  const [entitiesDisplayedFirst, setEntitiesDisplayedFirst] = (0, import_react14.useState)([]);
  const toggleEntitySelection = (entity) => {
    var _a;
    let newValue;
    const selectedEntities = selectionController.selectedEntities;
    (_a = analyticsController.onAnalyticsEvent) == null ? void 0 : _a.call(analyticsController, "reference_selection_toggle", {
      path: fullPath,
      entityId: entity.id
    });
    if (selectedEntities) {
      if (selectedEntities.map((e2) => e2.id).indexOf(entity.id) > -1) {
        newValue = selectedEntities.filter((item) => item.id !== entity.id);
      } else {
        if (maxSelection && selectedEntities.length >= maxSelection) return;
        newValue = [...selectedEntities, entity];
      }
      selectionController.setSelectedEntities(newValue);
      if (onMultipleEntitiesSelected) onMultipleEntitiesSelected(newValue);
    }
  };
  const selectionController = useSelectionController(toggleEntitySelection);
  (0, import_react14.useEffect)(() => {
    let unmounted = false;
    const selectedEntityIds = selectedEntityIdsProp == null ? void 0 : selectedEntityIdsProp.map((id2) => id2 == null ? void 0 : id2.toString()).filter(Boolean);
    if (selectedEntityIds && collection) {
      Promise.all(selectedEntityIds.map((entityId) => dataSource.fetchEntity({
        path: fullPath,
        entityId,
        collection
      }))).then((entities) => {
        if (!unmounted) {
          const result = entities.filter((e_0) => e_0 !== void 0);
          selectionController.setSelectedEntities(result);
          setEntitiesDisplayedFirst(result);
        }
      });
    } else {
      selectionController.setSelectedEntities([]);
      setEntitiesDisplayedFirst([]);
    }
    return () => {
      unmounted = true;
    };
  }, [dataSource, fullPath, selectedEntityIdsProp, collection, selectionController.setSelectedEntities]);
  const onClear = () => {
    var _a;
    (_a = analyticsController.onAnalyticsEvent) == null ? void 0 : _a.call(analyticsController, "reference_selection_clear", {
      path: fullPath
    });
    selectionController.setSelectedEntities([]);
    if (!multiselect && onSingleEntitySelected) {
      onSingleEntitySelected(null);
    } else if (onMultipleEntitiesSelected) {
      onMultipleEntitiesSelected([]);
    }
  };
  const onEntityClick = (entity_0) => {
    var _a;
    if (!multiselect && onSingleEntitySelected) {
      (_a = analyticsController.onAnalyticsEvent) == null ? void 0 : _a.call(analyticsController, "reference_selected_single", {
        path: fullPath,
        entityId: entity_0.id
      });
      onSingleEntitySelected(entity_0);
      sideDialogContext.close(false);
    } else {
      toggleEntitySelection(entity_0);
    }
  };
  const onNewClick = () => {
    var _a;
    (_a = analyticsController.onAnalyticsEvent) == null ? void 0 : _a.call(analyticsController, "reference_selection_new_entity", {
      path: fullPath
    });
    sideEntityController.open({
      path: fullPath,
      collection,
      updateUrl: true,
      onUpdate: ({
        entity: entity_1
      }) => {
        setEntitiesDisplayedFirst([entity_1, ...entitiesDisplayedFirst]);
        onEntityClick(entity_1);
      },
      closeOnSave: true
    });
  };
  const tableRowActionsBuilder = ({
    entity: entity_2,
    size: size2,
    width,
    frozen
  }) => {
    const selectedEntities_0 = selectionController.selectedEntities;
    const isSelected = selectedEntities_0 && selectedEntities_0.map((e_1) => e_1.id).indexOf(entity_2.id) > -1;
    return (0, import_jsx_runtime2.jsx)(EntityCollectionRowActions, { width, frozen, entity: entity_2, size: size2, isSelected, selectionEnabled: multiselect, hideId: collection == null ? void 0 : collection.hideIdFromCollection, fullPath, selectionController, openEntityMode: "side_panel" });
  };
  const onDone = (0, import_react14.useCallback)((event) => {
    event.stopPropagation();
    sideDialogContext.close(false);
  }, [sideDialogContext]);
  if (!collection) {
    return (0, import_jsx_runtime2.jsx)(ErrorView, { error: "Could not find collection with id " + collection });
  }
  const resolvedCollection = (0, import_react14.useMemo)(() => resolveCollection({
    collection,
    path: fullPath,
    values: {},
    propertyConfigs: customizationController.propertyConfigs,
    authController
  }), [collection, customizationController.propertyConfigs, fullPath]);
  const displayedColumnIds = useColumnIds(resolvedCollection, false);
  const tableController = useDataSourceTableController({
    fullPath,
    collection,
    entitiesDisplayedFirst,
    forceFilter,
    updateUrl: false
  });
  const {
    textSearchLoading,
    textSearchInitialised,
    onTextSearchClick,
    textSearchEnabled
  } = useTableSearchHelper({
    collection,
    fullPath
  });
  return (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-col h-full", children: [
    (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow", children: entitiesDisplayedFirst && (0, import_jsx_runtime2.jsx)(EntityCollectionTable, { textSearchLoading, onTextSearchClick: textSearchInitialised ? void 0 : onTextSearchClick, textSearchEnabled, displayedColumnIds, onEntityClick, tableController, enablePopupIcon: false, tableRowActionsBuilder, openEntityMode: "side_panel", title: (0, import_jsx_runtime2.jsxs)(Typography, { variant: "subtitle2", className: "flex flex-row gap-2", children: [
      (0, import_jsx_runtime2.jsx)(IconForView, { size: "small", collectionOrView: collection, className: "text-surface-300 dark:text-surface-600" }),
      collection.singularName ? `Select ${collection.singularName}` : `Select
                                                                                              from ${collection.name}`
    ] }), defaultSize: collection.defaultSize, properties: resolvedCollection.properties, forceFilter, inlineEditing: false, selectionController, actions: (0, import_jsx_runtime2.jsx)(ReferenceDialogActions, { collection, path: fullPath, onNewClick, onClear }) }) }),
    (0, import_jsx_runtime2.jsxs)(DialogActions, { translucent: false, children: [
      description && (0, import_jsx_runtime2.jsx)(Typography, { variant: "body2", className: "flex-grow text-left", children: description }),
      (0, import_jsx_runtime2.jsx)(Button, { onClick: onDone, color: "primary", variant: "filled", children: "Done" })
    ] })
  ] });
}
function ReferenceDialogActions(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(13);
  const {
    collection,
    path,
    onClear,
    onNewClick
  } = t0;
  const authController = useAuthController();
  const largeLayout = useLargeLayout();
  let t1;
  if ($[0] !== onNewClick) {
    t1 = onNewClick ? (e2) => {
      e2.preventDefault();
      onNewClick();
    } : void 0;
    $[0] = onNewClick;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const onClick = t1;
  let t2;
  if ($[2] !== authController || $[3] !== collection || $[4] !== largeLayout || $[5] !== onClick || $[6] !== path) {
    t2 = canCreateEntity(collection, authController, path, null) && onClick && (largeLayout ? (0, import_jsx_runtime2.jsxs)(Button, { onClick, startIcon: (0, import_jsx_runtime2.jsx)(AddIcon, {}), variant: "outlined", color: "primary", children: [
      "Add ",
      collection.singularName ?? collection.name
    ] }) : (0, import_jsx_runtime2.jsx)(Button, { onClick, variant: "outlined", color: "primary", children: (0, import_jsx_runtime2.jsx)(AddIcon, {}) }));
    $[2] = authController;
    $[3] = collection;
    $[4] = largeLayout;
    $[5] = onClick;
    $[6] = path;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  const addButton = t2;
  let t3;
  if ($[8] !== onClear) {
    t3 = (0, import_jsx_runtime2.jsx)(Button, { onClick: onClear, variant: "text", color: "primary", children: "Clear" });
    $[8] = onClear;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  let t4;
  if ($[10] !== addButton || $[11] !== t3) {
    t4 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t3,
      addButton
    ] });
    $[10] = addButton;
    $[11] = t3;
    $[12] = t4;
  } else {
    t4 = $[12];
  }
  return t4;
}
function toArray2(input) {
  return Array.isArray(input) ? input : input ? [input] : [];
}
function NavigationGroup(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(14);
  const {
    children,
    group
  } = t0;
  const userConfigurationPersistence = useUserConfigurationPersistence();
  const t1 = !((userConfigurationPersistence == null ? void 0 : userConfigurationPersistence.collapsedGroups) ?? []).includes(group ?? "ungrouped");
  let t2;
  if ($[0] !== group || $[1] !== userConfigurationPersistence) {
    t2 = (expanded) => {
      if (userConfigurationPersistence) {
        if (!expanded) {
          const paths = (userConfigurationPersistence.collapsedGroups ?? []).concat(group ?? "ungrouped");
          userConfigurationPersistence.setCollapsedGroups(paths);
        } else {
          userConfigurationPersistence.setCollapsedGroups((userConfigurationPersistence.collapsedGroups ?? []).filter((g2) => g2 !== (group ?? "ungrouped")));
        }
      }
    };
    $[0] = group;
    $[1] = userConfigurationPersistence;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== group) {
    t3 = (group == null ? void 0 : group.toUpperCase()) ?? "Views".toUpperCase();
    $[3] = group;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== t3) {
    t4 = (0, import_jsx_runtime2.jsx)(Typography, { color: "secondary", className: "font-medium ml-1", children: t3 });
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== children) {
    t5 = (0, import_jsx_runtime2.jsx)("div", { className: "mb-8", children });
    $[7] = children;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== t1 || $[10] !== t2 || $[11] !== t4 || $[12] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)(ExpandablePanel, { invisible: true, titleClassName: "font-medium text-sm text-surface-600 dark:text-surface-400", innerClassName: "py-4", initiallyExpanded: t1, onExpandedChange: t2, title: t4, children: t5 });
    $[9] = t1;
    $[10] = t2;
    $[11] = t4;
    $[12] = t5;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  return t6;
}
function NavigationCard(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(23);
  const {
    name,
    description,
    icon,
    actions,
    onClick
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = cls("h-full p-4 cursor-pointer min-h-[230px]");
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== onClick) {
    t2 = () => {
      onClick == null ? void 0 : onClick();
    };
    $[1] = onClick;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== actions) {
    t3 = (0, import_jsx_runtime2.jsx)("div", { className: "flex items-center gap-1", onClick: _temp$e, children: actions });
    $[3] = actions;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== icon || $[6] !== t3) {
    t4 = (0, import_jsx_runtime2.jsxs)("div", { className: "h-10 flex items-center w-full justify-between text-surface-300 dark:text-surface-600", children: [
      icon,
      t3
    ] });
    $[5] = icon;
    $[6] = t3;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== name) {
    t5 = (0, import_jsx_runtime2.jsx)(Typography, { gutterBottom: true, variant: "h5", component: "h2", children: name });
    $[8] = name;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  let t6;
  if ($[10] !== description) {
    t6 = description && (0, import_jsx_runtime2.jsx)(Typography, { variant: "body2", color: "secondary", component: "div", children: (0, import_jsx_runtime2.jsx)(Markdown, { source: description, size: "small" }) });
    $[10] = description;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== t4 || $[13] !== t5 || $[14] !== t6) {
    t7 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex-grow w-full", children: [
      t4,
      t5,
      t6
    ] });
    $[12] = t4;
    $[13] = t5;
    $[14] = t6;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  let t8;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = {
      alignSelf: "flex-end"
    };
    $[16] = t8;
  } else {
    t8 = $[16];
  }
  let t9;
  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = (0, import_jsx_runtime2.jsx)("div", { style: t8, children: (0, import_jsx_runtime2.jsx)("div", { className: "p-4", children: (0, import_jsx_runtime2.jsx)(ArrowForwardIcon, { className: "text-primary" }) }) });
    $[17] = t9;
  } else {
    t9 = $[17];
  }
  let t10;
  if ($[18] !== t7) {
    t10 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-col items-start h-full", children: [
      t7,
      t9
    ] });
    $[18] = t7;
    $[19] = t10;
  } else {
    t10 = $[19];
  }
  let t11;
  if ($[20] !== t10 || $[21] !== t2) {
    t11 = (0, import_jsx_runtime2.jsx)(Card, { className: t1, onClick: t2, children: t10 });
    $[20] = t10;
    $[21] = t2;
    $[22] = t11;
  } else {
    t11 = $[22];
  }
  return t11;
}
function _temp$e(event) {
  event.preventDefault();
  event.stopPropagation();
}
function SmallNavigationCard(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(10);
  const {
    name,
    url,
    icon
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = cls(cardMixin, cardClickableMixin, "cursor-pointer flex flex-row items-center px-4 py-2 text-inherit dark:text-inherit visited:text-inherit visited:dark:text-inherit hover:text-inherit hover:dark:text-inherit ");
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  let t2;
  if ($[1] !== name) {
    t2 = (0, import_jsx_runtime2.jsx)(Typography, { gutterBottom: true, variant: "h5", component: "h2", className: "mb-0 ml-4", children: name });
    $[1] = name;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== icon || $[4] !== t2) {
    t3 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-row items-center flex-grow gap-2 ", children: [
      icon,
      t2
    ] });
    $[3] = icon;
    $[4] = t2;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (0, import_jsx_runtime2.jsx)("div", { className: "p-4", children: (0, import_jsx_runtime2.jsx)(ArrowForwardIcon, { color: "primary" }) });
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== t3 || $[8] !== url) {
    t5 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsxs)(Link, { tabIndex: 0, className: t1, to: url, children: [
      t3,
      t4
    ] }) });
    $[7] = t3;
    $[8] = url;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  return t5;
}
function NavigationCardBinding(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(34);
  const {
    path,
    collection,
    view,
    url,
    name,
    description,
    onClick,
    type
  } = t0;
  const userConfigurationPersistence = useUserConfigurationPersistence();
  const t1 = collection ?? view;
  let t2;
  if ($[0] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)(IconForView, { collectionOrView: t1 });
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const collectionIcon = t2;
  const navigate = useNavigate();
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  let t3;
  if ($[2] !== (userConfigurationPersistence == null ? void 0 : userConfigurationPersistence.favouritePaths)) {
    t3 = (userConfigurationPersistence == null ? void 0 : userConfigurationPersistence.favouritePaths) ?? [];
    $[2] = userConfigurationPersistence == null ? void 0 : userConfigurationPersistence.favouritePaths;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== path || $[5] !== t3) {
    t4 = t3.includes(path);
    $[4] = path;
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const favourite = t4;
  let t5;
  if ($[7] !== collection || $[8] !== context || $[9] !== customizationController.plugins || $[10] !== favourite || $[11] !== path || $[12] !== userConfigurationPersistence) {
    const actionsArray = userConfigurationPersistence ? [(0, import_jsx_runtime2.jsx)(IconButton, { onClick: (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      if (favourite) {
        userConfigurationPersistence.setFavouritePaths(userConfigurationPersistence.favouritePaths.filter((p3) => p3 !== path));
      } else {
        userConfigurationPersistence.setFavouritePaths([...userConfigurationPersistence.favouritePaths, path]);
      }
    }, children: (0, import_jsx_runtime2.jsx)(StarIcon, { size: 18, className: favourite ? "text-secondary" : "text-surface-400 dark:text-surface-500" }) }, "favourite")] : [];
    if (customizationController.plugins && collection) {
      let t62;
      if ($[14] !== collection || $[15] !== context || $[16] !== path) {
        t62 = {
          path,
          collection,
          context
        };
        $[14] = collection;
        $[15] = context;
        $[16] = path;
        $[17] = t62;
      } else {
        t62 = $[17];
      }
      const actionProps = t62;
      customizationController.plugins.forEach((plugin, i2) => {
        var _a;
        return actionsArray.push(((_a = plugin.homePage) == null ? void 0 : _a.CollectionActions) ? (0, import_jsx_runtime2.jsx)(plugin.homePage.CollectionActions, { ...actionProps, extraProps: plugin.homePage.extraProps }, `actions_${i2}`) : null);
      });
    }
    t5 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: actionsArray });
    $[7] = collection;
    $[8] = context;
    $[9] = customizationController.plugins;
    $[10] = favourite;
    $[11] = path;
    $[12] = userConfigurationPersistence;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  const actions = t5;
  if (type === "admin") {
    let t62;
    if ($[18] !== collectionIcon || $[19] !== name || $[20] !== url) {
      t62 = (0, import_jsx_runtime2.jsx)(SmallNavigationCard, { icon: collectionIcon, name, url });
      $[18] = collectionIcon;
      $[19] = name;
      $[20] = url;
      $[21] = t62;
    } else {
      t62 = $[21];
    }
    return t62;
  }
  let t6;
  if ($[22] !== navigate || $[23] !== onClick || $[24] !== path || $[25] !== url || $[26] !== userConfigurationPersistence) {
    t6 = () => {
      onClick == null ? void 0 : onClick();
      navigate(url);
      if (userConfigurationPersistence) {
        userConfigurationPersistence.setRecentlyVisitedPaths([path, ...(userConfigurationPersistence.recentlyVisitedPaths ?? []).filter((p_0) => p_0 !== path)]);
      }
    };
    $[22] = navigate;
    $[23] = onClick;
    $[24] = path;
    $[25] = url;
    $[26] = userConfigurationPersistence;
    $[27] = t6;
  } else {
    t6 = $[27];
  }
  let t7;
  if ($[28] !== actions || $[29] !== collectionIcon || $[30] !== description || $[31] !== name || $[32] !== t6) {
    t7 = (0, import_jsx_runtime2.jsx)(NavigationCard, { icon: collectionIcon, name, description, actions, onClick: t6 });
    $[28] = actions;
    $[29] = collectionIcon;
    $[30] = description;
    $[31] = name;
    $[32] = t6;
    $[33] = t7;
  } else {
    t7 = $[33];
  }
  return t7;
}
function NavigationChip(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(18);
  const {
    entry
  } = t0;
  const navigate = useNavigate();
  const userConfigurationPersistence = useUserConfigurationPersistence();
  if (!userConfigurationPersistence) {
    return null;
  }
  let t1;
  if ($[0] !== entry.path || $[1] !== userConfigurationPersistence.favouritePaths) {
    t1 = userConfigurationPersistence.favouritePaths.includes(entry.path);
    $[0] = entry.path;
    $[1] = userConfigurationPersistence.favouritePaths;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const favourite = t1;
  let t2;
  if ($[3] !== entry.path || $[4] !== favourite || $[5] !== userConfigurationPersistence) {
    t2 = (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      if (favourite) {
        userConfigurationPersistence.setFavouritePaths(userConfigurationPersistence.favouritePaths.filter((p3) => p3 !== entry.path));
      } else {
        userConfigurationPersistence.setFavouritePaths([...userConfigurationPersistence.favouritePaths, entry.path]);
      }
    };
    $[3] = entry.path;
    $[4] = favourite;
    $[5] = userConfigurationPersistence;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  const onIconClick = t2;
  let t3;
  if ($[7] !== entry.url || $[8] !== navigate) {
    t3 = () => navigate(entry.url);
    $[7] = entry.url;
    $[8] = navigate;
    $[9] = t3;
  } else {
    t3 = $[9];
  }
  const t4 = favourite ? "text-secondary" : "text-surface-400 dark:text-surface-500";
  let t5;
  if ($[10] !== onIconClick || $[11] !== t4) {
    t5 = (0, import_jsx_runtime2.jsx)(StarIcon, { onClick: onIconClick, size: 18, className: t4 });
    $[10] = onIconClick;
    $[11] = t4;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== entry.name || $[14] !== entry.path || $[15] !== t3 || $[16] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)(Chip, { onClick: t3, icon: t5, children: entry.name }, entry.path);
    $[13] = entry.name;
    $[14] = entry.path;
    $[15] = t3;
    $[16] = t5;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  return t6;
}
function FavouritesView(t0) {
  var _a, _b, _c, _d;
  const $ = (0, import_react_compiler_runtime3.c)(17);
  const navigationController = useNavigationController();
  const userConfigurationPersistence = useUserConfigurationPersistence();
  if (!userConfigurationPersistence) {
    return null;
  }
  let t1;
  if ($[0] !== (userConfigurationPersistence == null ? void 0 : userConfigurationPersistence.favouritePaths)) {
    t1 = (userConfigurationPersistence == null ? void 0 : userConfigurationPersistence.favouritePaths) ?? [];
    $[0] = userConfigurationPersistence == null ? void 0 : userConfigurationPersistence.favouritePaths;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let T0;
  let t2;
  let t3;
  let t4;
  if ($[2] !== ((_a = navigationController.topLevelNavigation) == null ? void 0 : _a.navigationEntries) || $[3] !== t1) {
    let t52;
    if ($[8] !== ((_b = navigationController.topLevelNavigation) == null ? void 0 : _b.navigationEntries)) {
      t52 = (path) => {
        var _a2;
        return (_a2 = navigationController.topLevelNavigation) == null ? void 0 : _a2.navigationEntries.find((entry) => entry.path === path);
      };
      $[8] = (_c = navigationController.topLevelNavigation) == null ? void 0 : _c.navigationEntries;
      $[9] = t52;
    } else {
      t52 = $[9];
    }
    const favouriteCollections = t1.map(t52).filter(Boolean);
    T0 = Collapse;
    t4 = favouriteCollections.length > 0;
    t2 = "flex flex-row flex-wrap gap-2 pb-2 min-h-[32px]";
    t3 = favouriteCollections.map(_temp$d);
    $[2] = (_d = navigationController.topLevelNavigation) == null ? void 0 : _d.navigationEntries;
    $[3] = t1;
    $[4] = T0;
    $[5] = t2;
    $[6] = t3;
    $[7] = t4;
  } else {
    T0 = $[4];
    t2 = $[5];
    t3 = $[6];
    t4 = $[7];
  }
  let t5;
  if ($[10] !== t2 || $[11] !== t3) {
    t5 = (0, import_jsx_runtime2.jsx)("div", { className: t2, children: t3 });
    $[10] = t2;
    $[11] = t3;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== T0 || $[14] !== t4 || $[15] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)(T0, { in: t4, children: t5 });
    $[13] = T0;
    $[14] = t4;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  return t6;
}
function _temp$d(entry_0) {
  return (0, import_jsx_runtime2.jsx)(NavigationChip, { entry: entry_0 }, entry_0.path);
}
var scrollsMap = {};
function useRestoreScroll() {
  const location = useLocation();
  const containerRef = import_react14.default.useRef(null);
  const [scroll2, setScroll] = import_react14.default.useState(0);
  const [direction2, setDirection] = import_react14.default.useState("down");
  const handleScroll = (0, import_react14.useCallback)(() => {
    if (!containerRef.current || !location.key) return;
    scrollsMap[location.key] = containerRef.current.scrollTop;
    setScroll(containerRef.current.scrollTop);
    setDirection(containerRef.current.scrollTop > scroll2 ? "down" : "up");
  }, [containerRef, location.key, scroll2]);
  (0, import_react14.useEffect)(() => {
    const container = containerRef.current;
    if (!container) return;
    container.addEventListener("scroll", handleScroll, {
      passive: true
    });
    return () => {
      if (container) container.removeEventListener("scroll", handleScroll);
    };
  }, [containerRef, handleScroll, location]);
  (0, import_react14.useEffect)(() => {
    if (!containerRef.current || !scrollsMap[location.key]) return;
    containerRef.current.scrollTo({
      top: scrollsMap[location.key],
      behavior: "auto"
    });
  }, [location]);
  return {
    containerRef,
    scroll: scroll2,
    direction: direction2
  };
}
function DefaultHomePage(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(71);
  const {
    additionalActions,
    additionalChildrenStart,
    additionalChildrenEnd
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  const navigationController = useNavigationController();
  const fuse = (0, import_react14.useRef)(null);
  if (!navigationController.topLevelNavigation) {
    throw Error("Navigation not ready in FireCMSHomePage");
  }
  const {
    containerRef,
    direction: direction2
  } = useRestoreScroll();
  const {
    navigationEntries,
    groups
  } = navigationController.topLevelNavigation;
  const [filteredUrls, setFilteredUrls] = (0, import_react14.useState)(null);
  const performingSearch = Boolean(filteredUrls);
  let t1;
  if ($[0] !== filteredUrls || $[1] !== navigationEntries) {
    t1 = filteredUrls ? filteredUrls.map((url) => navigationEntries.find((e2) => e2.url === url)).filter(Boolean) : navigationEntries;
    $[0] = filteredUrls;
    $[1] = navigationEntries;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const filteredNavigationEntries = t1;
  let t2;
  let t3;
  if ($[3] !== navigationEntries) {
    t2 = () => {
      fuse.current = new Fuse(navigationEntries, {
        keys: ["name", "description", "group", "path"]
      });
    };
    t3 = [navigationEntries];
    $[3] = navigationEntries;
    $[4] = t2;
    $[5] = t3;
  } else {
    t2 = $[4];
    t3 = $[5];
  }
  (0, import_react14.useEffect)(t2, t3);
  let t4;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (value) => {
      var _a;
      if (!value || value === "") {
        setFilteredUrls(null);
      } else {
        const searchResult = (_a = fuse.current) == null ? void 0 : _a.search(value);
        if (searchResult) {
          setFilteredUrls(searchResult.map(_temp$c));
        }
      }
    };
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const updateSearchResults = t4;
  let T0;
  let additionalPluginChildrenEnd;
  let additionalPluginSections;
  let t10;
  let t11;
  let t12;
  let t13;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  if ($[7] !== additionalActions || $[8] !== additionalChildrenStart || $[9] !== containerRef || $[10] !== context || $[11] !== customizationController.plugins || $[12] !== direction2 || $[13] !== filteredNavigationEntries || $[14] !== filteredUrls || $[15] !== groups || $[16] !== performingSearch) {
    const filteredGroups = filteredUrls ? filteredNavigationEntries.map(_temp2$5) : [];
    const allGroups = filteredUrls ? filteredGroups.filter((group, index2) => filteredGroups.indexOf(group) === index2) : [...groups];
    if (filteredNavigationEntries.filter(_temp3$2).length > 0 || filteredNavigationEntries.length === 0) {
      allGroups.push(void 0);
    }
    let additionalPluginChildrenStart;
    if (customizationController.plugins) {
      let t143;
      if ($[29] !== context || $[30] !== customizationController.plugins) {
        const sectionProps = {
          context
        };
        t143 = customizationController.plugins.filter(_temp4$1).map((plugin_0, i2) => {
          const section = plugin_0.homePage.includeSection(sectionProps);
          return (0, import_jsx_runtime2.jsx)(NavigationGroup, { group: section.title, children: section.children }, `plugin_section_${plugin_0.key}`);
        });
        $[29] = context;
        $[30] = customizationController.plugins;
        $[31] = t143;
      } else {
        t143 = $[31];
      }
      let t153;
      if ($[32] !== t143) {
        t153 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t143 });
        $[32] = t143;
        $[33] = t153;
      } else {
        t153 = $[33];
      }
      additionalPluginSections = t153;
      let t162;
      if ($[34] !== customizationController.plugins) {
        t162 = customizationController.plugins.filter(_temp5$1).map(_temp6$1);
        $[34] = customizationController.plugins;
        $[35] = t162;
      } else {
        t162 = $[35];
      }
      let t172;
      if ($[36] !== t162) {
        t172 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2", children: t162 });
        $[36] = t162;
        $[37] = t172;
      } else {
        t172 = $[37];
      }
      additionalPluginChildrenStart = t172;
      let t18;
      if ($[38] !== customizationController.plugins) {
        t18 = customizationController.plugins.filter(_temp72).map(_temp82);
        $[38] = customizationController.plugins;
        $[39] = t18;
      } else {
        t18 = $[39];
      }
      let t19;
      if ($[40] !== t18) {
        t19 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2", children: t18 });
        $[40] = t18;
        $[41] = t19;
      } else {
        t19 = $[41];
      }
      additionalPluginChildrenEnd = t19;
    }
    t11 = "home_page";
    t12 = containerRef;
    t13 = "py-2 overflow-auto h-full w-full";
    T0 = Container;
    t5 = "6xl";
    const t142 = direction2 === "down" ? -84 : 0;
    let t152;
    if ($[42] !== t142) {
      t152 = {
        top: t142
      };
      $[42] = t142;
      $[43] = t152;
    } else {
      t152 = $[43];
    }
    let t16;
    if ($[44] === Symbol.for("react.memo_cache_sentinel")) {
      t16 = (0, import_jsx_runtime2.jsx)(SearchBar, { onTextSearch: updateSearchResults, placeholder: "Search collections", large: false, autoFocus: true, innerClassName: "w-full", className: "w-full flex-grow" });
      $[44] = t16;
    } else {
      t16 = $[44];
    }
    if ($[45] !== additionalActions || $[46] !== t152) {
      t6 = (0, import_jsx_runtime2.jsxs)("div", { className: "w-full sticky py-4 transition-all duration-400 ease-in-out top-0 z-10 flex flex-row gap-4", style: t152, children: [
        t16,
        additionalActions
      ] });
      $[45] = additionalActions;
      $[46] = t152;
      $[47] = t6;
    } else {
      t6 = $[47];
    }
    if ($[48] !== performingSearch) {
      t7 = (0, import_jsx_runtime2.jsx)(FavouritesView, { hidden: performingSearch });
      $[48] = performingSearch;
      $[49] = t7;
    } else {
      t7 = $[49];
    }
    t8 = additionalChildrenStart;
    t9 = additionalPluginChildrenStart;
    let t17;
    if ($[50] !== context || $[51] !== customizationController.plugins || $[52] !== filteredNavigationEntries || $[53] !== performingSearch) {
      t17 = (group_0, index_0) => {
        const AdditionalCards = [];
        const actionProps = {
          group: group_0,
          context
        };
        if (customizationController.plugins) {
          customizationController.plugins.forEach((plugin_5) => {
            var _a, _b;
            if ((_a = plugin_5.homePage) == null ? void 0 : _a.AdditionalCards) {
              AdditionalCards.push(...toArray2((_b = plugin_5.homePage) == null ? void 0 : _b.AdditionalCards));
            }
          });
        }
        const thisGroupCollections = filteredNavigationEntries.filter((entry_0) => entry_0.group === group_0 || !entry_0.group && group_0 === void 0);
        if (thisGroupCollections.length === 0 && (AdditionalCards.length === 0 || performingSearch)) {
          return null;
        }
        return (0, import_jsx_runtime2.jsx)(NavigationGroup, { group: group_0, children: (0, import_jsx_runtime2.jsxs)("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4", children: [
          thisGroupCollections.map((entry_1) => (0, import_jsx_runtime2.jsx)("div", { className: "col-span-1", children: (0, import_jsx_runtime2.jsx)(NavigationCardBinding, { ...entry_1, onClick: () => {
            var _a, _b;
            let event;
            if (entry_1.type === "collection") {
              event = "home_navigate_to_collection";
            } else {
              if (entry_1.type === "view") {
                event = "home_navigate_to_view";
              } else {
                if (entry_1.type === "admin") {
                  event = "home_navigate_to_admin_view";
                } else {
                  event = "unmapped_event";
                }
              }
            }
            (_b = (_a = context.analyticsController) == null ? void 0 : _a.onAnalyticsEvent) == null ? void 0 : _b.call(_a, event, {
              path: entry_1.path
            });
          } }) }, `nav_${entry_1.group}_${entry_1.name}`)),
          (group_0 == null ? void 0 : group_0.toLowerCase()) !== "admin" && AdditionalCards && AdditionalCards.map((AdditionalCard, i_2) => (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsx)(AdditionalCard, { ...actionProps }) }, `nav_${group_0}_add_${i_2}`))
        ] }) }, `plugin_section_${group_0}`);
      };
      $[50] = context;
      $[51] = customizationController.plugins;
      $[52] = filteredNavigationEntries;
      $[53] = performingSearch;
      $[54] = t17;
    } else {
      t17 = $[54];
    }
    t10 = allGroups.map(t17);
    $[7] = additionalActions;
    $[8] = additionalChildrenStart;
    $[9] = containerRef;
    $[10] = context;
    $[11] = customizationController.plugins;
    $[12] = direction2;
    $[13] = filteredNavigationEntries;
    $[14] = filteredUrls;
    $[15] = groups;
    $[16] = performingSearch;
    $[17] = T0;
    $[18] = additionalPluginChildrenEnd;
    $[19] = additionalPluginSections;
    $[20] = t10;
    $[21] = t11;
    $[22] = t12;
    $[23] = t13;
    $[24] = t5;
    $[25] = t6;
    $[26] = t7;
    $[27] = t8;
    $[28] = t9;
  } else {
    T0 = $[17];
    additionalPluginChildrenEnd = $[18];
    additionalPluginSections = $[19];
    t10 = $[20];
    t11 = $[21];
    t12 = $[22];
    t13 = $[23];
    t5 = $[24];
    t6 = $[25];
    t7 = $[26];
    t8 = $[27];
    t9 = $[28];
  }
  let t14;
  if ($[55] !== T0 || $[56] !== additionalChildrenEnd || $[57] !== additionalPluginChildrenEnd || $[58] !== additionalPluginSections || $[59] !== t10 || $[60] !== t5 || $[61] !== t6 || $[62] !== t7 || $[63] !== t8 || $[64] !== t9) {
    t14 = (0, import_jsx_runtime2.jsxs)(T0, { maxWidth: t5, children: [
      t6,
      t7,
      t8,
      t9,
      t10,
      additionalPluginSections,
      additionalPluginChildrenEnd,
      additionalChildrenEnd
    ] });
    $[55] = T0;
    $[56] = additionalChildrenEnd;
    $[57] = additionalPluginChildrenEnd;
    $[58] = additionalPluginSections;
    $[59] = t10;
    $[60] = t5;
    $[61] = t6;
    $[62] = t7;
    $[63] = t8;
    $[64] = t9;
    $[65] = t14;
  } else {
    t14 = $[65];
  }
  let t15;
  if ($[66] !== t11 || $[67] !== t12 || $[68] !== t13 || $[69] !== t14) {
    t15 = (0, import_jsx_runtime2.jsx)("div", { id: t11, ref: t12, className: t13, children: t14 });
    $[66] = t11;
    $[67] = t12;
    $[68] = t13;
    $[69] = t14;
    $[70] = t15;
  } else {
    t15 = $[70];
  }
  return t15;
}
function _temp82(plugin_4, i_1) {
  return (0, import_jsx_runtime2.jsx)("div", { children: plugin_4.homePage.additionalChildrenEnd }, `plugin_children_start_${i_1}`);
}
function _temp72(plugin_3) {
  var _a;
  return (_a = plugin_3.homePage) == null ? void 0 : _a.additionalChildrenEnd;
}
function _temp6$1(plugin_2, i_0) {
  return (0, import_jsx_runtime2.jsx)("div", { children: plugin_2.homePage.additionalChildrenStart }, `plugin_children_start_${i_0}`);
}
function _temp5$1(plugin_1) {
  var _a;
  return (_a = plugin_1.homePage) == null ? void 0 : _a.additionalChildrenStart;
}
function _temp4$1(plugin) {
  var _a;
  return (_a = plugin.homePage) == null ? void 0 : _a.includeSection;
}
function _temp3$2(e_1) {
  return !e_1.group;
}
function _temp2$5(entry) {
  return entry.group;
}
function _temp$c(e_0) {
  return e_0.item.url;
}
function EntityCollectionViewActions(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(41);
  const {
    collection,
    relativePath,
    parentCollectionIds,
    onNewClick,
    onMultipleDeleteClick,
    selectionEnabled,
    path,
    selectionController,
    tableController,
    collectionEntitiesCount
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.plugins) {
    t1 = customizationController.plugins ?? [];
    $[0] = customizationController.plugins;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const plugins = t1;
  const authController = useAuthController();
  const largeLayout = useLargeLayout();
  const selectedEntities = selectionController.selectedEntities;
  let t2;
  if ($[2] !== authController || $[3] !== collection || $[4] !== largeLayout || $[5] !== onNewClick || $[6] !== path) {
    t2 = canCreateEntity(collection, authController, path, null) && onNewClick && (largeLayout ? (0, import_jsx_runtime2.jsxs)(Button, { id: `add_entity_${path}`, onClick: onNewClick, startIcon: (0, import_jsx_runtime2.jsx)(AddIcon, {}), variant: "filled", color: "primary", children: [
      "Add ",
      collection.singularName ?? collection.name
    ] }) : (0, import_jsx_runtime2.jsx)(Button, { id: `add_entity_${path}`, onClick: onNewClick, variant: "filled", color: "primary", children: (0, import_jsx_runtime2.jsx)(AddIcon, {}) }));
    $[2] = authController;
    $[3] = collection;
    $[4] = largeLayout;
    $[5] = onNewClick;
    $[6] = path;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  const addButton = t2;
  let t3;
  if ($[8] !== authController || $[9] !== collection || $[10] !== path) {
    t3 = canDeleteEntity(collection, authController, path, null);
    $[8] = authController;
    $[9] = collection;
    $[10] = path;
    $[11] = t3;
  } else {
    t3 = $[11];
  }
  const multipleDeleteEnabled = t3;
  let multipleDeleteButton;
  if (selectionEnabled) {
    let t42;
    if ($[12] !== largeLayout || $[13] !== multipleDeleteEnabled || $[14] !== onMultipleDeleteClick || $[15] !== (selectedEntities == null ? void 0 : selectedEntities.length)) {
      t42 = largeLayout ? (0, import_jsx_runtime2.jsxs)(Button, { variant: "text", disabled: !(selectedEntities == null ? void 0 : selectedEntities.length) || !multipleDeleteEnabled, startIcon: (0, import_jsx_runtime2.jsx)(DeleteIcon, {}), onClick: onMultipleDeleteClick, color: "primary", className: "lg:w-20", children: [
        "(",
        selectedEntities == null ? void 0 : selectedEntities.length,
        ")"
      ] }) : (0, import_jsx_runtime2.jsx)(IconButton, { color: "primary", disabled: !(selectedEntities == null ? void 0 : selectedEntities.length) || !multipleDeleteEnabled, onClick: onMultipleDeleteClick, children: (0, import_jsx_runtime2.jsx)(DeleteIcon, {}) });
      $[12] = largeLayout;
      $[13] = multipleDeleteEnabled;
      $[14] = onMultipleDeleteClick;
      $[15] = selectedEntities == null ? void 0 : selectedEntities.length;
      $[16] = t42;
    } else {
      t42 = $[16];
    }
    const button = t42;
    const t52 = multipleDeleteEnabled ? "Delete" : "You have selected at least one entity you cannot delete";
    let t62;
    if ($[17] !== button || $[18] !== t52) {
      t62 = (0, import_jsx_runtime2.jsx)(Tooltip, { title: t52, children: button });
      $[17] = button;
      $[18] = t52;
      $[19] = t62;
    } else {
      t62 = $[19];
    }
    multipleDeleteButton = t62;
  }
  let t4;
  if ($[20] !== collection || $[21] !== collectionEntitiesCount || $[22] !== context || $[23] !== parentCollectionIds || $[24] !== path || $[25] !== relativePath || $[26] !== selectionController || $[27] !== tableController) {
    t4 = {
      path,
      relativePath,
      parentCollectionIds,
      collection,
      selectionController,
      context,
      tableController,
      collectionEntitiesCount
    };
    $[20] = collection;
    $[21] = collectionEntitiesCount;
    $[22] = context;
    $[23] = parentCollectionIds;
    $[24] = path;
    $[25] = relativePath;
    $[26] = selectionController;
    $[27] = tableController;
    $[28] = t4;
  } else {
    t4 = $[28];
  }
  const actionProps = t4;
  let actions;
  if ($[29] !== actionProps || $[30] !== collection.Actions || $[31] !== plugins) {
    let t52;
    if ($[33] !== actionProps) {
      t52 = (Action2, i2) => (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(Action2, { ...actionProps }) }, `actions_${i2}`);
      $[33] = actionProps;
      $[34] = t52;
    } else {
      t52 = $[34];
    }
    actions = toArray2(collection.Actions).map(t52);
    if (plugins) {
      plugins.forEach((plugin, i_0) => {
        var _a, _b;
        if ((_a = plugin.collectionView) == null ? void 0 : _a.CollectionActions) {
          actions.push(...toArray2((_b = plugin.collectionView) == null ? void 0 : _b.CollectionActions).map((Action_0, j2) => {
            var _a2;
            return (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(Action_0, { ...actionProps, ...(_a2 = plugin.collectionView) == null ? void 0 : _a2.collectionActionsProps }) }, `plugin_actions_${i_0}_${j2}`);
          }));
        }
      });
    }
    $[29] = actionProps;
    $[30] = collection.Actions;
    $[31] = plugins;
    $[32] = actions;
  } else {
    actions = $[32];
  }
  let t5;
  if ($[35] !== actions) {
    t5 = (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: actions });
    $[35] = actions;
    $[36] = t5;
  } else {
    t5 = $[36];
  }
  let t6;
  if ($[37] !== addButton || $[38] !== multipleDeleteButton || $[39] !== t5) {
    t6 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t5,
      multipleDeleteButton,
      addButton
    ] });
    $[37] = addButton;
    $[38] = multipleDeleteButton;
    $[39] = t5;
    $[40] = t6;
  } else {
    t6 = $[40];
  }
  return t6;
}
function useDraggable({
  containerRef,
  innerRef,
  x,
  y,
  onMove
}) {
  let relX = 0;
  let relY = 0;
  const listeningRef = import_react14.default.useRef(false);
  const onMouseDown = (event) => {
    if (event.button !== 0 || !containerRef.current || event.defaultPrevented || event.innerClicked) {
      return;
    }
    const {
      x: x_0,
      y: y_0
    } = containerRef.current.getBoundingClientRect();
    relX = event.screenX - x_0;
    relY = event.screenY - y_0;
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
    document.addEventListener("selectstart", onSelect);
    listeningRef.current = true;
  };
  const onMouseDownInner = (event_0) => {
    event_0.innerClicked = true;
  };
  const onSelect = (event_1) => {
    event_1.preventDefault();
    event_1.stopPropagation();
  };
  const onMouseUp = (event_2) => {
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
    document.removeEventListener("selectstart", onSelect);
    event_2.stopPropagation();
    listeningRef.current = false;
  };
  const onMouseMove = (event_3) => {
    if (event_3.target.localName === "input" || !listeningRef.current) return;
    onMove({
      x: event_3.screenX - relX,
      y: event_3.screenY - relY
    });
    event_3.stopPropagation();
  };
  const update2 = () => {
    if (containerRef.current) {
      containerRef.current.style.top = `${y}px`;
      containerRef.current.style.left = `${x}px`;
    }
  };
  (0, import_react14.useEffect)(() => {
    const current = containerRef.current;
    const innerCurrent = innerRef.current;
    if (!current || !innerCurrent) return;
    if (innerCurrent) innerCurrent.addEventListener("mousedown", onMouseDownInner);
    if (current) current.addEventListener("mousedown", onMouseDown);
    update2();
    return () => {
      if (current) current.removeEventListener("mousedown", onMouseDown);
      if (innerCurrent) innerCurrent.removeEventListener("mousedown", onMouseDownInner);
    };
  });
}
function useWindowSize() {
  const $ = (0, import_react_compiler_runtime3.c)(3);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {
      width: 0,
      height: 0
    };
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [size2, setSize] = (0, import_react14.useState)(t0);
  let t1;
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = () => {
      const updateSize = function updateSize2() {
        setSize({
          width: window.innerWidth,
          height: window.innerHeight
        });
      };
      window.addEventListener("resize", updateSize);
      updateSize();
      return () => window.removeEventListener("resize", updateSize);
    };
    t2 = [];
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  (0, import_react14.useLayoutEffect)(t1, t2);
  return size2;
}
var ElementResizeListener = ({
  onResize
}) => {
  const rafRef = (0, import_react14.useRef)(0);
  const objectRef = (0, import_react14.useRef)(null);
  const onResizeRef = (0, import_react14.useRef)(onResize);
  onResizeRef.current = onResize;
  const _onResize = (0, import_react14.useCallback)((e2) => {
    if (rafRef.current) {
      cancelAnimationFrame(rafRef.current);
    }
    rafRef.current = requestAnimationFrame(() => {
      onResizeRef.current(e2);
    });
  }, []);
  const onLoad = (0, import_react14.useCallback)(() => {
    const obj = objectRef.current;
    if (obj && obj.contentDocument && obj.contentDocument.defaultView) {
      obj.contentDocument.defaultView.addEventListener("resize", _onResize);
    }
  }, [_onResize]);
  (0, import_react14.useEffect)(() => {
    const obj_0 = objectRef.current;
    return () => {
      if (obj_0 && obj_0.contentDocument && obj_0.contentDocument.defaultView) {
        obj_0.contentDocument.defaultView.removeEventListener("resize", _onResize);
      }
    };
  }, [_onResize]);
  return (0, import_jsx_runtime2.jsx)("object", { onLoad, ref: objectRef, tabIndex: -1, type: "text/html", data: "about:blank", title: "", style: {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%",
    pointerEvents: "none",
    zIndex: -1,
    opacity: 0
  } });
};
function CustomIdField({
  customId,
  entityId,
  status,
  onChange,
  error: error2,
  entity,
  loading
}) {
  const {
    errors
  } = useFormex();
  const disabled = status === "existing" || !customId;
  const idSetAutomatically = status !== "existing" && !customId;
  const enumValues = (0, import_react14.useMemo)(() => {
    if (!customId || typeof customId === "boolean" || customId === "optional") return void 0;
    return enumToObjectEntries(customId);
  }, [customId]);
  const snackbarController = useSnackbarController();
  const {
    copy: copy2
  } = useClipboard({
    onSuccess: (text) => snackbarController.open({
      type: "success",
      message: `Copied ${text}`
    })
  });
  const customizationController = useCustomizationController();
  const fieldProps = {
    label: idSetAutomatically ? "ID is set automatically" : "ID",
    disabled: disabled || loading,
    name: "id",
    value: (entity && status === "existing" ? entity.id : entityId) ?? "",
    endAdornment: loading ? (0, import_jsx_runtime2.jsx)(CircularProgress, { size: "small" }) : entity ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Copy", asChild: true, children: (0, import_jsx_runtime2.jsx)(IconButton, { onClick: (e2) => copy2(entity.id), "aria-label": "copy-id", children: (0, import_jsx_runtime2.jsx)(ContentCopyIcon, { size: "small" }) }) }),
      (customizationController == null ? void 0 : customizationController.entityLinkBuilder) && (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Open in the console", asChild: true, children: (0, import_jsx_runtime2.jsx)(IconButton, { component: "a", href: customizationController.entityLinkBuilder({
        entity
      }), rel: "noopener noreferrer", target: "_blank", onClick: (e_0) => e_0.stopPropagation(), "aria-label": "go-to-datasource", children: (0, import_jsx_runtime2.jsx)(OpenInNewIcon, { size: "small" }) }) })
    ] }) : void 0
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    enumValues && (0, import_jsx_runtime2.jsx)(Select, { size: "large", error: error2, fullWidth: true, onValueChange: (v) => onChange(v), ...fieldProps, renderValue: (option) => {
      const enumConfig = enumValues.find((e_1) => e_1.id === option);
      if (!enumConfig) return option;
      return `${enumConfig.id} - ${enumConfig.label}`;
    }, children: enumValues.map((enumConfig_0) => (0, import_jsx_runtime2.jsx)(SelectItem, { value: String(enumConfig_0.id), children: (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey: enumConfig_0.id, enumValues, size: "medium" }) }, enumConfig_0.id)) }),
    !enumValues && (0, import_jsx_runtime2.jsx)(TextField, { ...fieldProps, error: error2, placeholder: customId === "optional" ? "Autogenerated ID, it can be manually changed" : status === "new" || status === "copy" ? "ID of the new document" : "ID of the document", onChange: (event) => {
      let value = event.target.value;
      if (value) value = value.trim();
      return onChange(value.length ? value : void 0);
    } }),
    errors.id && (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", className: "ml-3.5 text-red-500 dark:text-red-500", children: errors.id })
  ] });
}
var ErrorFocus = (t0) => {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    containerRef
  } = t0;
  const {
    isSubmitting,
    isValidating,
    errors
  } = useFormex();
  let t1;
  let t2;
  if ($[0] !== containerRef || $[1] !== errors || $[2] !== isSubmitting || $[3] !== isValidating) {
    t1 = () => {
      var _a;
      const keys2 = Object.keys(errors);
      if (keys2.length > 0 && isSubmitting && !isValidating) {
        const errorElement = (_a = containerRef == null ? void 0 : containerRef.current) == null ? void 0 : _a.querySelector(`#form_field_${keys2[0]}`);
        if (errorElement && (containerRef == null ? void 0 : containerRef.current)) {
          const scrollableParent = getScrollableParent(containerRef.current);
          if (scrollableParent) {
            const top2 = errorElement.getBoundingClientRect().top;
            scrollableParent.scrollTo({
              top: scrollableParent.scrollTop + top2 - 196,
              behavior: "smooth"
            });
          }
          const input = errorElement.querySelector("input");
          if (input) {
            input.focus();
          }
        }
      }
    };
    t2 = [isSubmitting, isValidating, errors, containerRef];
    $[0] = containerRef;
    $[1] = errors;
    $[2] = isSubmitting;
    $[3] = isValidating;
    $[4] = t1;
    $[5] = t2;
  } else {
    t1 = $[4];
    t2 = $[5];
  }
  (0, import_react14.useEffect)(t1, t2);
  return null;
};
var isScrollable = (ele) => {
  const hasScrollableContent = ele && ele.scrollHeight > ele.clientHeight;
  const overflowYStyle = ele ? window.getComputedStyle(ele).overflowY : null;
  const isOverflowHidden = overflowYStyle && overflowYStyle.indexOf("hidden") !== -1;
  return hasScrollableContent && !isOverflowHidden;
};
var getScrollableParent = (ele) => {
  return !ele || ele === document.body ? document.body : isScrollable(ele) ? ele : getScrollableParent(ele.parentNode);
};
function EntityFormActions(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(12);
  const {
    collection,
    entity,
    layout,
    savingError,
    formex,
    disabled,
    status,
    pluginActions,
    openEntityMode
  } = t0;
  const context = useFireCMSContext();
  const sideEntityController = useSideEntityController();
  let t1;
  if ($[0] !== collection || $[1] !== context || $[2] !== disabled || $[3] !== entity || $[4] !== formex.isSubmitting || $[5] !== layout || $[6] !== openEntityMode || $[7] !== pluginActions || $[8] !== savingError || $[9] !== sideEntityController || $[10] !== status) {
    t1 = layout === "bottom" ? buildBottomActions$1({
      savingError,
      entity,
      collection,
      context,
      sideEntityController,
      isSubmitting: formex.isSubmitting,
      disabled,
      status,
      pluginActions,
      openEntityMode
    }) : buildSideActions$1({
      savingError,
      entity,
      collection,
      context,
      sideEntityController,
      isSubmitting: formex.isSubmitting,
      disabled,
      status,
      pluginActions,
      openEntityMode
    });
    $[0] = collection;
    $[1] = context;
    $[2] = disabled;
    $[3] = entity;
    $[4] = formex.isSubmitting;
    $[5] = layout;
    $[6] = openEntityMode;
    $[7] = pluginActions;
    $[8] = savingError;
    $[9] = sideEntityController;
    $[10] = status;
    $[11] = t1;
  } else {
    t1 = $[11];
  }
  return t1;
}
function buildBottomActions$1({
  savingError,
  entity,
  formActions,
  collection,
  context,
  sideEntityController,
  isSubmitting,
  disabled,
  status,
  pluginActions,
  openEntityMode
}) {
  return (0, import_jsx_runtime2.jsxs)(DialogActions, { position: "absolute", children: [
    savingError && (0, import_jsx_runtime2.jsx)("div", { className: "text-right", children: (0, import_jsx_runtime2.jsx)(Typography, { color: "error", children: savingError.message }) }),
    entity && (formActions ?? []).length > 0 && (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow flex overflow-auto no-scrollbar", children: (formActions ?? []).map((action) => (0, import_jsx_runtime2.jsx)(IconButton, { color: "primary", onClick: (event) => {
      event.stopPropagation();
      if (entity) action.onClick({
        entity,
        fullPath: collection.path,
        collection,
        context,
        sideEntityController,
        openEntityMode
      });
    }, children: action.icon }, action.name)) }),
    pluginActions,
    (0, import_jsx_runtime2.jsx)(Button, { variant: "text", disabled: disabled || isSubmitting, type: "reset", children: status === "existing" ? "Discard" : "Clear" }),
    (0, import_jsx_runtime2.jsxs)(Button, { variant: "filled", color: "primary", type: "submit", disabled: disabled || isSubmitting, children: [
      status === "existing" && "Save",
      status === "copy" && "Create copy",
      status === "new" && "Create"
    ] })
  ] });
}
function buildSideActions$1({
  savingError,
  entity,
  formActions,
  collection,
  context,
  sideEntityController,
  isSubmitting,
  disabled,
  status,
  pluginActions
}) {
  return (0, import_jsx_runtime2.jsxs)("div", { className: cls("overflow-auto h-full flex flex-col gap-2 w-80 2xl:w-96 px-4 py-16 sticky top-0 border-l", defaultBorderMixin), children: [
    (0, import_jsx_runtime2.jsxs)(LoadingButton, { fullWidth: true, variant: "filled", color: "primary", type: "submit", size: "large", disabled: disabled || isSubmitting, children: [
      status === "existing" && "Save",
      status === "copy" && "Create copy",
      status === "new" && "Create"
    ] }),
    (0, import_jsx_runtime2.jsx)(Button, { fullWidth: true, variant: "text", disabled: disabled || isSubmitting, type: "reset", children: status === "existing" ? "Discard" : "Clear" }),
    pluginActions,
    savingError && (0, import_jsx_runtime2.jsx)("div", { className: "text-right", children: (0, import_jsx_runtime2.jsx)(Typography, { color: "error", children: savingError.message }) })
  ] });
}
function EntityForm({
  path,
  entityId: entityIdProp,
  collection,
  onValuesModified,
  onIdChange,
  onSaved,
  entity,
  initialDirtyValues,
  onFormContextReady,
  forceActionsAtTheBottom,
  initialStatus,
  className,
  onStatusChange,
  onEntityChange,
  openEntityMode = "full_screen",
  formex: formexProp,
  disabled: disabledProp,
  Builder,
  EntityFormActionsComponent = EntityFormActions,
  showDefaultActions = true,
  showEntityPath = true,
  children
}) {
  var _a;
  if (collection.customId && collection.formAutoSave) {
    console.warn(`The collection ${collection.path} has customId and formAutoSave enabled. This is not supported and formAutoSave will be ignored`);
  }
  const authController = useAuthController();
  const [status, setStatus] = (0, import_react14.useState)(initialStatus);
  const updateStatus = (status_0) => {
    setStatus(status_0);
    onStatusChange == null ? void 0 : onStatusChange(status_0);
  };
  const [valuesToBeSaved, setValuesToBeSaved] = (0, import_react14.useState)(void 0);
  useDebouncedCallback(valuesToBeSaved, () => {
    if (valuesToBeSaved) saveEntity({
      entityId: entityIdProp,
      collection,
      path,
      values: valuesToBeSaved
    });
  }, false, 2e3);
  const dataSource = useDataSource();
  const snackbarController = useSnackbarController();
  const customizationController = useCustomizationController();
  const context = useFireCMSContext();
  const analyticsController = useAnalyticsController();
  const [underlyingChanges, setUnderlyingChanges] = (0, import_react14.useState)({});
  const [customIdLoading, setCustomIdLoading] = (0, import_react14.useState)(false);
  const mustSetCustomId = (status === "new" || status === "copy") && Boolean(collection.customId) && collection.customId !== "optional";
  const initialEntityId = (0, import_react14.useMemo)(() => {
    if (status === "new" || status === "copy") {
      if (mustSetCustomId) {
        return void 0;
      } else {
        return dataSource.generateEntityId(path, collection);
      }
    } else {
      return entityIdProp;
    }
  }, [entityIdProp, status]);
  const [entityId, setEntityId] = (0, import_react14.useState)(initialEntityId);
  const [entityIdError, setEntityIdError] = (0, import_react14.useState)(false);
  const [savingError, setSavingError] = (0, import_react14.useState)();
  const autoSave = collection.formAutoSave && !collection.customId;
  const onSubmit = (values, formexController) => {
    var _a2;
    if (mustSetCustomId && !entityId) {
      console.error("Missing custom Id");
      setEntityIdError(true);
      formexController.setSubmitting(false);
      return;
    }
    setSavingError(void 0);
    setEntityIdError(false);
    if (status === "existing") {
      if (!(entity == null ? void 0 : entity.id)) throw Error("Form misconfiguration when saving, no id for existing entity");
    } else if (status === "new" || status === "copy") {
      if (collection.customId) {
        if (collection.customId !== "optional" && !entityId) {
          throw Error("Form misconfiguration when saving, entityId should be set");
        }
      }
    } else {
      throw Error("New FormType added, check EntityForm");
    }
    return (_a2 = save(values)) == null ? void 0 : _a2.then((_) => {
      formexController.resetForm({
        values,
        submitCount: 0,
        touched: {}
      });
    }).finally(() => {
      formexController.setSubmitting(false);
    });
  };
  const formex = formexProp ?? useCreateFormex({
    initialValues: initialDirtyValues ?? getInitialEntityValues(authController, collection, path, status, entity, customizationController.propertyConfigs),
    initialDirty: Boolean(initialDirtyValues),
    onSubmit,
    onReset: () => {
      clearDirtyCache();
      onValuesModified == null ? void 0 : onValuesModified(false);
    },
    validation: (values_0) => {
      return validationSchema == null ? void 0 : validationSchema.validate(values_0, {
        abortEarly: false
      }).then(() => {
        return {};
      }).catch((e2) => {
        return yupToFormErrors(e2);
      });
    }
  });
  (0, import_react14.useEffect)(() => {
    const handleKeyDown2 = (e_0) => {
      const isUndo = (e_0.metaKey || e_0.ctrlKey) && !e_0.shiftKey && e_0.key.toLowerCase() === "z";
      const isRedo = (e_0.metaKey || e_0.ctrlKey) && e_0.shiftKey && e_0.key.toLowerCase() === "z" || (e_0.metaKey || e_0.ctrlKey) && !e_0.shiftKey && e_0.key.toLowerCase() === "y";
      if (isUndo && formex.canUndo) {
        e_0.preventDefault();
        formex.undo();
      } else if (isRedo && formex.canRedo) {
        e_0.preventDefault();
        formex.redo();
      }
    };
    window.addEventListener("keydown", handleKeyDown2);
    return () => window.removeEventListener("keydown", handleKeyDown2);
  }, [formex]);
  const resolvedCollection = (0, import_react14.useMemo)(() => resolveCollection({
    collection,
    path,
    entityId,
    values: formex.values,
    previousValues: formex.initialValues,
    propertyConfigs: customizationController.propertyConfigs,
    authController
  }), [collection, path, entityId, formex.values, formex.initialValues, customizationController.propertyConfigs]);
  const onPreSaveHookError = (0, import_react14.useCallback)((e_1) => {
    snackbarController.open({
      type: "error",
      message: "Error before saving: " + (e_1 == null ? void 0 : e_1.message)
    });
    console.error(e_1);
  }, [snackbarController]);
  const onSaveSuccessHookError = (0, import_react14.useCallback)((e_2) => {
    snackbarController.open({
      type: "error",
      message: "Error after saving (entity is saved): " + (e_2 == null ? void 0 : e_2.message)
    });
    console.error(e_2);
  }, [snackbarController]);
  function clearDirtyCache() {
    if (status === "new" || status === "copy") {
      removeEntityFromCache(path + "#new");
    } else {
      removeEntityFromCache(path + "/" + entityId);
    }
  }
  const onSaveSuccess = (updatedEntity) => {
    clearDirtyCache();
    onValuesModified == null ? void 0 : onValuesModified(false);
    if (!autoSave) snackbarController.open({
      type: "success",
      message: `${collection.singularName ?? collection.name}: Saved correctly`
    });
    onEntityChange == null ? void 0 : onEntityChange(updatedEntity);
    updateStatus("existing");
    setEntityId(updatedEntity.id);
    if (onSaved) {
      onSaved({
        entity: updatedEntity,
        status,
        path,
        entityId: updatedEntity.id,
        collection
      });
    }
  };
  const onSaveFailure = (0, import_react14.useCallback)((e_3) => {
    snackbarController.open({
      type: "error",
      message: "Error saving: " + (e_3 == null ? void 0 : e_3.message)
    });
    console.error("Error saving entity", path, entityId);
    console.error(e_3);
  }, [entityId, path, snackbarController]);
  const saveEntity = ({
    values: values_1,
    previousValues,
    entityId: entityId_0,
    collection: collection_0,
    path: path_0
  }) => {
    return saveEntityWithCallbacks({
      path: path_0,
      entityId: entityId_0,
      values: values_1,
      previousValues,
      collection: collection_0,
      status,
      dataSource,
      context,
      onSaveSuccess,
      onSaveFailure,
      onPreSaveHookError,
      onSaveSuccessHookError
    }).then();
  };
  const onSaveEntityRequest = async ({
    collection: collection_1,
    path: path_1,
    entityId: entityId_1,
    values: values_2,
    previousValues: previousValues_0,
    autoSave: autoSave_0
  }) => {
    if (!status) return;
    if (autoSave_0) {
      setValuesToBeSaved(values_2);
    } else {
      return saveEntity({
        collection: collection_1,
        path: path_1,
        entityId: entityId_1,
        values: values_2,
        previousValues: previousValues_0
      });
    }
  };
  const lastSavedValues = (0, import_react14.useRef)(entity == null ? void 0 : entity.values);
  const save = (values_3) => {
    lastSavedValues.current = values_3;
    return onSaveEntityRequest({
      collection: resolvedCollection,
      path,
      entityId,
      values: values_3,
      previousValues: entity == null ? void 0 : entity.values,
      autoSave: autoSave ?? false
    }).then((res) => {
      var _a2;
      const eventName = status === "new" ? "new_entity_saved" : status === "copy" ? "entity_copied" : status === "existing" ? "entity_edited" : "unmapped_event";
      (_a2 = analyticsController.onAnalyticsEvent) == null ? void 0 : _a2.call(analyticsController, eventName, {
        path
      });
    }).catch((e_4) => {
      console.error(e_4);
      setSavingError(e_4);
    });
  };
  const disabled = formex.isSubmitting || Boolean(disabledProp);
  const formContext = {
    // @ts-ignore
    setFieldValue: (0, import_react14.useCallback)(formex.setFieldValue, []),
    values: formex.values,
    collection: resolvedCollection,
    entityId,
    path,
    save,
    formex,
    entity,
    savingError,
    status,
    openEntityMode,
    disabled
  };
  (0, import_react14.useEffect)(() => {
    onFormContextReady == null ? void 0 : onFormContextReady(formContext);
  }, [formex.version, resolvedCollection, entityId, path]);
  const onIdUpdateError = (0, import_react14.useCallback)((error2) => {
    snackbarController.open({
      type: "error",
      message: "Error updating id, check the console"
    });
  }, []);
  const pluginActions = [];
  const plugins = customizationController.plugins;
  const actionsDisabled = disabled || formex.isSubmitting || status === "existing" && !formex.dirty || Boolean(disabledProp);
  if (plugins && collection) {
    const actionProps = {
      entityId,
      path,
      status,
      collection,
      context,
      currentEntityId: entityId,
      formContext,
      openEntityMode,
      disabled: actionsDisabled
    };
    pluginActions.push(...plugins.map((plugin) => {
      var _a2;
      return ((_a2 = plugin.form) == null ? void 0 : _a2.Actions) ? (0, import_jsx_runtime2.jsx)(plugin.form.Actions, { ...actionProps }, `actions_${plugin.key}`) : null;
    }).filter(Boolean));
  }
  const titlePropertyKey = getEntityTitlePropertyKey(resolvedCollection, customizationController.propertyConfigs);
  const title = (formex.values && titlePropertyKey ? getValueInPath(formex.values, titlePropertyKey) : void 0) ?? collection.singularName ?? collection.name;
  const onIdUpdate = (_a = collection.callbacks) == null ? void 0 : _a.onIdUpdate;
  const doOnIdUpdate = (0, import_react14.useCallback)(async () => {
    if (onIdUpdate && formex.values && (status === "new" || status === "copy")) {
      setCustomIdLoading(true);
      try {
        const updatedId = await onIdUpdate({
          collection: resolvedCollection,
          path,
          entityId,
          values: formex.values,
          context
        });
        setEntityId(updatedId);
      } catch (e_5) {
        onIdUpdateError == null ? void 0 : onIdUpdateError(e_5);
        console.error(e_5);
      }
      setCustomIdLoading(false);
    }
  }, [entityId, formex.values, status, onIdUpdate, resolvedCollection, path, context, onIdUpdateError]);
  (0, import_react14.useEffect)(() => {
    doOnIdUpdate();
  }, [doOnIdUpdate]);
  (0, import_react14.useEffect)(() => {
    if (!autoSave) {
      onValuesModified == null ? void 0 : onValuesModified(modified);
    }
  }, [formex.dirty]);
  const deferredValues = (0, import_react14.useDeferredValue)(formex.values);
  const modified = formex.dirty;
  const uniqueFieldValidator = (0, import_react14.useCallback)(({
    name,
    value,
    property
  }) => dataSource.checkUniqueField(path, name, value, entityId, collection), [dataSource, path, entityId]);
  const validationSchema = (0, import_react14.useMemo)(() => entityId ? getYupEntitySchema(entityId, resolvedCollection.properties, uniqueFieldValidator) : void 0, [entityId, resolvedCollection.properties, uniqueFieldValidator]);
  (0, import_react14.useEffect)(() => {
    const key = status === "new" || status === "copy" ? path + "#new" : path + "/" + entityId;
    if (modified) {
      saveEntityToCache(key, deferredValues);
    }
  }, [deferredValues, modified, path, entityId, status]);
  useOnAutoSave(autoSave, formex, lastSavedValues, save);
  (0, import_react14.useEffect)(() => {
    if (!autoSave && !formex.isSubmitting && underlyingChanges && entity) {
      Object.entries(underlyingChanges).forEach(([key_0, value_0]) => {
        const formValue = formex.values[key_0];
        if (!(0, import_react_fast_compare2.default)(value_0, formValue) && !formex.touched[key_0]) {
          console.debug("Updated value from the datasource:", key_0, value_0);
          formex.setFieldValue(key_0, value_0 !== void 0 ? value_0 : null);
        }
      });
    }
  }, [formex.isSubmitting, autoSave, underlyingChanges, entity, formex.values, formex.touched, formex.setFieldValue]);
  const formFieldKeys = getFormFieldKeys(resolvedCollection);
  const formFields = () => {
    if (Builder) {
      return (0, import_jsx_runtime2.jsx)(Builder, { collection, entity, modifiedValues: formex.values, formContext });
    }
    return (0, import_jsx_runtime2.jsx)(FormLayout, { children: formFieldKeys.map((key_1) => {
      var _a2, _b, _c;
      const property_0 = resolvedCollection.properties[key_1];
      if (property_0) {
        const underlyingValueHasChanged = !!underlyingChanges && Object.keys(underlyingChanges).includes(key_1) && formex.touched[key_1];
        const disabled_0 = disabledProp || !autoSave && formex.isSubmitting || isReadOnly(property_0) || Boolean(property_0.disabled);
        const hidden = isHidden(property_0);
        if (hidden) return null;
        const widthPercentage = property_0.widthPercentage ?? 100;
        const cmsFormFieldProps = {
          propertyKey: key_1,
          disabled: disabled_0,
          property: property_0,
          includeDescription: property_0.description || property_0.longDescription,
          underlyingValueHasChanged: underlyingValueHasChanged && !autoSave,
          context: formContext,
          partOfArray: false,
          minimalistView: false,
          autoFocus: false
        };
        return (0, import_jsx_runtime2.jsx)(FormEntry, { propertyKey: key_1, widthPercentage, children: (0, import_jsx_runtime2.jsx)(PropertyFieldBinding, { ...cmsFormFieldProps }) }, `field_${key_1}`);
      }
      const additionalField = (_a2 = resolvedCollection.additionalFields) == null ? void 0 : _a2.find((f) => f.key === key_1);
      if (additionalField && entity) {
        const Builder_0 = additionalField.Builder;
        if (!Builder_0 && !additionalField.value) {
          throw new Error("When using additional fields you need to provide a Builder or a value");
        }
        const child = Builder_0 ? (0, import_jsx_runtime2.jsx)(Builder_0, { entity, context }) : (0, import_jsx_runtime2.jsx)("div", { className: "w-full", children: (_c = (_b = additionalField.value) == null ? void 0 : _b.call(additionalField, {
          entity,
          context
        })) == null ? void 0 : _c.toString() });
        return (0, import_jsx_runtime2.jsxs)("div", { className: "w-full", children: [
          (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey: key_1, icon: (0, import_jsx_runtime2.jsx)(NotesIcon, { size: "small" }), title: additionalField.name, className: "text-text-secondary dark:text-text-secondary-dark ml-3.5" }),
          (0, import_jsx_runtime2.jsx)("div", { className: cls(paperMixin, "w-full min-h-14 p-4 md:p-6 overflow-x-scroll no-scrollbar"), children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: child }) })
        ] }, `additional_${key_1}`);
      }
      console.warn(`Property ${key_1} not found in collection ${resolvedCollection.name} in properties or additional fields. Skipping.`);
      return null;
    }).filter(Boolean) });
  };
  const formRef = (0, import_react14.useRef)(null);
  const formView = (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    !Builder && (0, import_jsx_runtime2.jsxs)("div", { className: "w-full py-2 flex flex-col items-start my-4 lg:my-6", children: [
      (0, import_jsx_runtime2.jsx)(Typography, { className: "py-4 flex-grow line-clamp-1 " + (collection.hideIdFromForm ? "mb-2" : "mb-0"), variant: "h4", children: title ?? collection.singularName ?? collection.name }),
      showEntityPath && (0, import_jsx_runtime2.jsx)(Alert, { color: "base", className: "w-full", size: "small", children: (0, import_jsx_runtime2.jsxs)("code", { className: "text-xs select-all text-text-secondary dark:text-text-secondary-dark", children: [
        (entity == null ? void 0 : entity.path) ?? path,
        "/",
        entityId
      ] }) })
    ] }),
    children,
    !Builder && !collection.hideIdFromForm && (0, import_jsx_runtime2.jsx)(CustomIdField, { customId: collection.customId, entityId, status, onChange: setEntityId, error: entityIdError, loading: customIdLoading, entity }),
    entityId && formContext && (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsxs)("div", { className: "mt-12 flex flex-col gap-8", ref: formRef, children: [
      formFields(),
      (0, import_jsx_runtime2.jsx)(ErrorFocus, { containerRef: formRef })
    ] }) }),
    forceActionsAtTheBottom && (0, import_jsx_runtime2.jsx)("div", { className: "h-16" })
  ] }) });
  (0, import_react14.useEffect)(() => {
    if (entityId && onIdChange) onIdChange(entityId);
  }, [entityId, onIdChange]);
  if (!resolvedCollection || !path) {
    throw Error("INTERNAL: Collection and path must be defined in form context");
  }
  const dialogActions = (0, import_jsx_runtime2.jsx)(EntityFormActionsComponent, { collection: resolvedCollection, path, entity, layout: forceActionsAtTheBottom ? "bottom" : "side", savingError, formex, disabled: actionsDisabled, status, pluginActions, openEntityMode, showDefaultActions });
  return (0, import_jsx_runtime2.jsx)(Formex, { value: formex, children: (0, import_jsx_runtime2.jsxs)("form", { onSubmit: formex.handleSubmit, onReset: () => formex.resetForm({
    values: getInitialEntityValues(authController, collection, path, status, entity, customizationController.propertyConfigs)
  }), noValidate: true, className: cls("flex-1 flex flex-row w-full overflow-y-auto justify-center", className), children: [
    (0, import_jsx_runtime2.jsx)("div", { id: `form_${path}`, className: cls("relative flex flex-row max-w-4xl lg:max-w-3xl xl:max-w-4xl 2xl:max-w-6xl w-full h-fit"), children: (0, import_jsx_runtime2.jsxs)("div", { className: cls("flex flex-col w-full pt-12 pb-16 px-4 sm:px-8 md:px-10"), children: [
      formex.dirty ? (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Local unsaved changes", className: "self-end sticky top-4 z-10", children: (0, import_jsx_runtime2.jsx)(Chip, { size: "small", colorScheme: "orangeDarker", children: (0, import_jsx_runtime2.jsx)(EditIcon, { size: "smallest" }) }) }) : (0, import_jsx_runtime2.jsx)(Tooltip, { title: "In sync with the database", className: "self-end sticky top-4 z-10", children: (0, import_jsx_runtime2.jsx)(Chip, { size: "small", children: (0, import_jsx_runtime2.jsx)(CheckIcon, { size: "smallest" }) }) }),
      formView
    ] }) }),
    dialogActions
  ] }) });
}
function getInitialEntityValues(authController, collection, path, status, entity, propertyConfigs) {
  const resolvedCollection = resolveCollection({
    collection,
    path,
    values: entity == null ? void 0 : entity.values,
    propertyConfigs,
    authController
  });
  const properties = resolvedCollection.properties;
  if ((status === "existing" || status === "copy") && entity) {
    if (!collection.alwaysApplyDefaultValues) {
      return entity.values ?? getDefaultValuesFor(properties);
    } else {
      const defaultValues = getDefaultValuesFor(properties);
      return mergeDeep2(defaultValues, entity.values ?? {});
    }
  } else if (status === "new") {
    return getDefaultValuesFor(properties);
  } else {
    console.error({
      status,
      entity
    });
    throw new Error("Form has not been initialised with the correct parameters");
  }
}
function yupToFormErrors(yupError) {
  let errors = {};
  if (yupError.inner) {
    if (yupError.inner.length === 0) {
      return setIn(errors, yupError.path, yupError.message);
    }
    for (const err of yupError.inner) {
      if (!getIn(errors, err.path)) {
        errors = setIn(errors, err.path, err.message);
      }
    }
  }
  return errors;
}
function useOnAutoSave(autoSave, formex, lastSavedValues, save) {
  if (!autoSave) return;
  (0, import_react14.useEffect)(() => {
    if (autoSave) {
      if (formex.values && !(0, import_react_fast_compare2.default)(formex.values, lastSavedValues.current)) {
        save(formex.values);
      }
    }
  }, [formex.values]);
}
function FieldHelperText(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(10);
  const {
    error: error2,
    showError,
    property,
    includeDescription: t1,
    disabled
  } = t0;
  const includeDescription = t1 === void 0 ? true : t1;
  const hasDescription = property.description || property.longDescription;
  if (!(showError && error2) && (!includeDescription || !hasDescription)) {
    return null;
  }
  if (showError && error2) {
    let t22;
    if ($[0] !== error2) {
      t22 = (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", className: "ml-3.5 text-red-500 dark:text-red-500", children: error2 });
      $[0] = error2;
      $[1] = t22;
    } else {
      t22 = $[1];
    }
    return t22;
  }
  const disabledTooltip = typeof property.disabled === "object" ? property.disabled.disabledMessage : void 0;
  const t2 = disabled ? "disabled" : "secondary";
  const t3 = disabledTooltip || property.description;
  let t4;
  if ($[2] !== t2 || $[3] !== t3) {
    t4 = (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", color: t2, className: "flex-grow", children: t3 });
    $[2] = t2;
    $[3] = t3;
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  let t5;
  if ($[5] !== property.longDescription) {
    t5 = property.longDescription && (0, import_jsx_runtime2.jsx)(Tooltip, { title: property.longDescription, side: "bottom", asChild: true, children: (0, import_jsx_runtime2.jsx)(IconButton, { size: "small", className: "self-start", children: (0, import_jsx_runtime2.jsx)(InfoIcon, { color: "disabled", size: "small" }) }) });
    $[5] = property.longDescription;
    $[6] = t5;
  } else {
    t5 = $[6];
  }
  let t6;
  if ($[7] !== t4 || $[8] !== t5) {
    t6 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex ml-3.5 mt-1", children: [
      t4,
      t5
    ] });
    $[7] = t4;
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  return t6;
}
var LabelWithIcon = (0, import_react14.forwardRef)((t0, ref2) => {
  const $ = (0, import_react_compiler_runtime3.c)(11);
  const {
    icon,
    title,
    small,
    className,
    required: required2
  } = t0;
  const t1 = small ? "gap-1" : "gap-2";
  let t2;
  if ($[0] !== className || $[1] !== t1) {
    t2 = cls("inline-flex items-center my-0.5", t1, className);
    $[0] = className;
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const t3 = `text-start font-medium text-${small ? "base" : "sm"} origin-top-left transform ${small ? "translate-x-2 scale-75" : ""}`;
  const t4 = (title ?? "") + (required2 ? " *" : "");
  let t5;
  if ($[3] !== t3 || $[4] !== t4) {
    t5 = (0, import_jsx_runtime2.jsx)("span", { className: t3, children: t4 });
    $[3] = t3;
    $[4] = t4;
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  let t6;
  if ($[6] !== icon || $[7] !== ref2 || $[8] !== t2 || $[9] !== t5) {
    t6 = (0, import_jsx_runtime2.jsxs)("div", { ref: ref2, className: t2, children: [
      icon,
      t5
    ] });
    $[6] = icon;
    $[7] = ref2;
    $[8] = t2;
    $[9] = t5;
    $[10] = t6;
  } else {
    t6 = $[10];
  }
  return t6;
});
LabelWithIcon.displayName = "LabelWithIcon";
function PropertyIdCopyTooltip(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    propertyKey,
    className,
    children
  } = t0;
  let t1;
  if ($[0] !== propertyKey) {
    t1 = (0, import_jsx_runtime2.jsx)(PropertyIdCopyTooltipContent, { propertyKey });
    $[0] = propertyKey;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== children || $[3] !== className || $[4] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)(Tooltip, { title: t1, delayDuration: 800, side: "top", align: "start", sideOffset: 8, className, children });
    $[2] = children;
    $[3] = className;
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
function PropertyIdCopyTooltipContent(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(14);
  const {
    propertyKey
  } = t0;
  const [copied, setCopied] = (0, import_react14.useState)(false);
  const t1 = copied ? "Copied" : "Property ID";
  let t2;
  if ($[0] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", className: "min-w-20 text-surface-accent-400", color: "disabled", children: t1 });
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] !== propertyKey) {
    t3 = (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", className: "text-white", children: (0, import_jsx_runtime2.jsx)("code", { children: propertyKey }) });
    $[2] = propertyKey;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== t2 || $[5] !== t3) {
    t4 = (0, import_jsx_runtime2.jsxs)("div", { children: [
      t2,
      t3
    ] });
    $[4] = t2;
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== propertyKey) {
    t5 = () => {
      navigator.clipboard.writeText(propertyKey);
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
    };
    $[7] = propertyKey;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  const t6 = t5;
  let t7;
  if ($[9] !== t6) {
    t7 = (0, import_jsx_runtime2.jsx)(IconButton, { size: "small", children: (0, import_jsx_runtime2.jsx)(ContentCopyIcon, { size: "smallest", className: "text-white", onClick: t6 }) });
    $[9] = t6;
    $[10] = t7;
  } else {
    t7 = $[10];
  }
  let t8;
  if ($[11] !== t4 || $[12] !== t7) {
    t8 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-row gap-2 items-center justify-center text-white", children: [
      t4,
      t7
    ] });
    $[11] = t4;
    $[12] = t7;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  return t8;
}
function LabelWithIconAndTooltip(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(10);
  let className;
  let propertyKey;
  let props;
  if ($[0] !== t0) {
    ({
      propertyKey,
      className,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = className;
    $[2] = propertyKey;
    $[3] = props;
  } else {
    className = $[1];
    propertyKey = $[2];
    props = $[3];
  }
  let t1;
  if ($[4] !== props) {
    t1 = (0, import_jsx_runtime2.jsx)(LabelWithIcon, { ...props });
    $[4] = props;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  let t2;
  if ($[6] !== className || $[7] !== propertyKey || $[8] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)(PropertyIdCopyTooltip, { propertyKey, className, children: t1 });
    $[6] = className;
    $[7] = propertyKey;
    $[8] = t1;
    $[9] = t2;
  } else {
    t2 = $[9];
  }
  return t2;
}
function FormEntry(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(8);
  const {
    propertyKey,
    widthPercentage: t1,
    children
  } = t0;
  const widthPercentage = t1 === void 0 ? 100 : t1;
  const t2 = `form_field_${propertyKey}`;
  const t3 = widthPercentage === 100 ? "100%" : `calc(${widthPercentage}% - 8px)`;
  let t4;
  if ($[0] !== t3) {
    t4 = {
      width: t3
    };
    $[0] = t3;
    $[1] = t4;
  } else {
    t4 = $[1];
  }
  let t5;
  if ($[2] !== children) {
    t5 = (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children });
    $[2] = children;
    $[3] = t5;
  } else {
    t5 = $[3];
  }
  let t6;
  if ($[4] !== t2 || $[5] !== t4 || $[6] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)("div", { id: t2, className: "relative", style: t4, children: t5 });
    $[4] = t2;
    $[5] = t4;
    $[6] = t5;
    $[7] = t6;
  } else {
    t6 = $[7];
  }
  return t6;
}
function FormLayout(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(5);
  const {
    children,
    className
  } = t0;
  let t1;
  if ($[0] !== className) {
    t1 = cls("flex flex-wrap gap-x-4 w-full space-y-8", className);
    $[0] = className;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== children || $[3] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)("div", { className: t1, children });
    $[2] = children;
    $[3] = t1;
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  return t2;
}
function SelectFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(47);
  const {
    propertyKey,
    value,
    setValue,
    error: error2,
    showError,
    disabled,
    property,
    includeDescription,
    size: t1
  } = t0;
  const size2 = t1 === void 0 ? "large" : t1;
  let t2;
  if ($[0] !== property.enumValues) {
    t2 = property.enumValues ?? [];
    $[0] = property.enumValues;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const enumValues = resolveEnumValues(t2);
  let t3;
  if ($[2] !== property || $[3] !== setValue || $[4] !== value) {
    t3 = {
      property,
      value,
      setValue
    };
    $[2] = property;
    $[3] = setValue;
    $[4] = value;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  useClearRestoreValue(t3);
  let t4;
  if ($[6] !== setValue) {
    t4 = (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      setValue(null);
    };
    $[6] = setValue;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  const handleClearClick = t4;
  const T0 = Select;
  let t5;
  if ($[8] !== value) {
    t5 = value !== void 0 && value != null ? value.toString() : "";
    $[8] = value;
    $[9] = t5;
  } else {
    t5 = $[9];
  }
  const t6 = true;
  const t7 = "item-aligned";
  let t8;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = cls("w-full");
    $[10] = t8;
  } else {
    t8 = $[10];
  }
  let t9;
  if ($[11] !== property) {
    t9 = getIconForProperty(property, "small");
    $[11] = property;
    $[12] = t9;
  } else {
    t9 = $[12];
  }
  const t10 = (_a = property.validation) == null ? void 0 : _a.required;
  let t11;
  if ($[13] !== property.name || $[14] !== t10 || $[15] !== t9) {
    t11 = (0, import_jsx_runtime2.jsx)(LabelWithIcon, { icon: t9, required: t10, title: property.name, className: "h-8 text-text-secondary dark:text-text-secondary-dark ml-3.5 my-0" });
    $[13] = property.name;
    $[14] = t10;
    $[15] = t9;
    $[16] = t11;
  } else {
    t11 = $[16];
  }
  let t12;
  if ($[17] !== propertyKey || $[18] !== t11) {
    t12 = (0, import_jsx_runtime2.jsx)(PropertyIdCopyTooltip, { propertyKey, children: t11 });
    $[17] = propertyKey;
    $[18] = t11;
    $[19] = t12;
  } else {
    t12 = $[19];
  }
  let t13;
  if ($[20] !== disabled || $[21] !== handleClearClick || $[22] !== property.clearable) {
    t13 = property.clearable && !disabled && (0, import_jsx_runtime2.jsx)(IconButton, { onClick: handleClearClick, children: (0, import_jsx_runtime2.jsx)(CloseIcon, {}) });
    $[20] = disabled;
    $[21] = handleClearClick;
    $[22] = property.clearable;
    $[23] = t13;
  } else {
    t13 = $[23];
  }
  let t14;
  if ($[24] !== property.dataType || $[25] !== setValue) {
    t14 = (updatedValue) => {
      const newValue = updatedValue ? property.dataType === "number" ? parseFloat(updatedValue) : updatedValue : null;
      return setValue(newValue);
    };
    $[24] = property.dataType;
    $[25] = setValue;
    $[26] = t14;
  } else {
    t14 = $[26];
  }
  const t15 = (enumKey) => (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey, enumValues, size: size2 });
  const t16 = enumValues && enumValues.map((option) => (0, import_jsx_runtime2.jsx)(SelectItem, { value: String(option.id), children: (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey: String(option.id), enumValues, size: size2 }) }, option.id));
  let t17;
  if ($[27] !== T0 || $[28] !== disabled || $[29] !== size2 || $[30] !== t12 || $[31] !== t13 || $[32] !== t14 || $[33] !== t15 || $[34] !== t16 || $[35] !== t5 || $[36] !== t8) {
    t17 = (0, import_jsx_runtime2.jsx)(T0, { value: t5, disabled, size: size2, fullWidth: t6, position: t7, inputClassName: t8, label: t12, endAdornment: t13, onValueChange: t14, renderValue: t15, children: t16 });
    $[27] = T0;
    $[28] = disabled;
    $[29] = size2;
    $[30] = t12;
    $[31] = t13;
    $[32] = t14;
    $[33] = t15;
    $[34] = t16;
    $[35] = t5;
    $[36] = t8;
    $[37] = t17;
  } else {
    t17 = $[37];
  }
  let t18;
  if ($[38] !== disabled || $[39] !== error2 || $[40] !== includeDescription || $[41] !== property || $[42] !== showError) {
    t18 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property });
    $[38] = disabled;
    $[39] = error2;
    $[40] = includeDescription;
    $[41] = property;
    $[42] = showError;
    $[43] = t18;
  } else {
    t18 = $[43];
  }
  let t19;
  if ($[44] !== t17 || $[45] !== t18) {
    t19 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t17,
      t18
    ] });
    $[44] = t17;
    $[45] = t18;
    $[46] = t19;
  } else {
    t19 = $[46];
  }
  return t19;
}
function MultiSelectFieldBinding({
  propertyKey,
  value,
  setValue,
  error: error2,
  showError,
  disabled,
  property,
  includeDescription,
  size: size2 = "large",
  autoFocus
}) {
  var _a;
  const of = property.of;
  if (!of) {
    throw Error("Using wrong component ArrayEnumSelect");
  }
  if (Array.isArray(of)) {
    throw Error("Using array properties instead of single one in `of` in ArrayProperty");
  }
  if (of.dataType !== "string" && of.dataType !== "number") {
    throw Error("Field misconfiguration: array field of type string or number");
  }
  const enumValues = enumToObjectEntries(of.enumValues);
  if (!enumValues) {
    console.error(property);
    throw Error("Field misconfiguration: array field of type string or number needs to have enumValues");
  }
  useClearRestoreValue({
    property,
    value,
    setValue
  });
  const validValue = !!value && Array.isArray(value);
  const renderValue = (0, import_react14.useCallback)((enumKey, list) => {
    const enumValue = enumKey !== void 0 ? getLabelOrConfigFrom(enumValues, enumKey) : void 0;
    return (0, import_jsx_runtime2.jsxs)(EnumValuesChip, { enumKey, enumValues, size: "medium", children: [
      (enumValue == null ? void 0 : enumValue.label) ?? enumKey,
      !list && (0, import_jsx_runtime2.jsx)("button", { className: "ml-1 ring-offset-background rounded-full outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2", onMouseDown: (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
      }, onClick: (e_0) => {
        e_0.preventDefault();
        e_0.stopPropagation();
        setValue(value.filter((v) => v !== enumKey));
      }, children: (0, import_jsx_runtime2.jsx)(CloseIcon, { size: "smallest" }) })
    ] }, enumKey);
  }, [enumValues, setValue, value]);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(MultiSelect, { className: "w-full mt-2", size: size2, value: validValue ? value.map((v_0) => v_0.toString()) : [], disabled, modalPopover: true, label: (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property, "small"), required: (_a = property.validation) == null ? void 0 : _a.required, title: property.name, className: "h-8 text-text-secondary dark:text-text-secondary-dark ml-3.5" }), onValueChange: (updatedValue) => {
      let newValue;
      if (of && (of == null ? void 0 : of.dataType) === "number") {
        newValue = updatedValue ? updatedValue.map((e_1) => parseFloat(e_1)) : [];
      } else {
        newValue = updatedValue;
      }
      return setValue(newValue);
    }, children: enumValues.map((enumValue_0) => String(enumValue_0.id)).map((enumKey_0) => (0, import_jsx_runtime2.jsx)(MultiSelectItem, { value: enumKey_0, children: renderValue(enumKey_0, true) }, enumKey_0)) }),
    (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property })
  ] });
}
function ArrayOfReferencesFieldBinding({
  propertyKey,
  value,
  error: error2,
  showError,
  disabled,
  isSubmitting,
  minimalistView: minimalistViewProp,
  property,
  includeDescription,
  setValue,
  setFieldValue
}) {
  var _a;
  const minimalistView = minimalistViewProp || property.minimalistView;
  const ofProperty = property.of;
  if (ofProperty.dataType !== "reference") {
    throw Error("ArrayOfReferencesField expected a property containing references");
  }
  const expanded = property.expanded === void 0 ? true : property.expanded;
  const selectedEntityIds = value && Array.isArray(value) ? value.map((ref2) => ref2.id) : [];
  useClearRestoreValue({
    property,
    value,
    setValue
  });
  const navigationController = useNavigationController();
  const collection = (0, import_react14.useMemo)(() => {
    return ofProperty.path ? navigationController.getCollection(ofProperty.path) : void 0;
  }, [ofProperty.path]);
  if (!collection) {
    throw Error(`Couldn't find the corresponding collection for the path: ${ofProperty.path}`);
  }
  const onMultipleEntitiesSelected = (0, import_react14.useCallback)((entities) => {
    setValue(entities.map((e2) => getReferenceFrom(e2)));
  }, [setValue]);
  const referenceDialogController = useReferenceDialog({
    multiselect: true,
    path: ofProperty.path,
    collection,
    onMultipleEntitiesSelected,
    selectedEntityIds,
    forceFilter: ofProperty.forceFilter
  });
  const onEntryClick = (e_0) => {
    e_0.preventDefault();
    referenceDialogController.open();
  };
  const buildEntry = (0, import_react14.useCallback)(({
    index: index2,
    internalId,
    storedProps,
    storeProps
  }) => {
    const entryValue = value && value.length > index2 ? value[index2] : void 0;
    if (!entryValue) return (0, import_jsx_runtime2.jsx)("div", { children: "Internal ERROR" });
    return (0, import_jsx_runtime2.jsx)(ReferencePreview, { disabled: !ofProperty.path, previewProperties: ofProperty.previewProperties, size: "medium", onClick: onEntryClick, hover: !disabled, reference: entryValue, includeId: ofProperty.includeId, includeEntityLink: ofProperty.includeEntityLink }, internalId);
  }, [ofProperty.path, ofProperty.previewProperties, value]);
  const title = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property, "small"), required: (_a = property.validation) == null ? void 0 : _a.required, title: property.name, className: "h-8 flex flex-grow text-text-secondary dark:text-text-secondary-dark" }),
    Array.isArray(value) && (0, import_jsx_runtime2.jsxs)(Typography, { variant: "caption", className: "px-4", children: [
      "(",
      value.length,
      ")"
    ] })
  ] });
  const body = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    !collection && (0, import_jsx_runtime2.jsx)(ErrorView, { error: "The specified collection does not exist. Check console" }),
    collection && (0, import_jsx_runtime2.jsxs)("div", { className: "group", children: [
      (0, import_jsx_runtime2.jsx)(ArrayContainer, { droppableId: propertyKey, value, disabled: isSubmitting, buildEntry, canAddElements: false, addLabel: property.name ? "Add reference to " + property.name : "Add reference", newDefaultEntry: property.of.defaultValue, onValueChange: (value_0) => setFieldValue(propertyKey, value_0) }),
      (0, import_jsx_runtime2.jsxs)(Button, { className: "my-4 justify-center text-left", variant: "text", color: "primary", disabled: isSubmitting, onClick: onEntryClick, children: [
        "Edit ",
        property.name
      ] })
    ] })
  ] });
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    !minimalistView && (0, import_jsx_runtime2.jsx)(ExpandablePanel, { titleClassName: fieldBackgroundMixin, innerClassName: cls("px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", fieldBackgroundMixin), initiallyExpanded: expanded, title, children: body }),
    minimalistView && body,
    (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property })
  ] });
}
function StorageItemPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(21);
  const {
    name,
    property,
    value,
    onRemove,
    disabled,
    size: size2,
    placeholder: placeholder3,
    className
  } = t0;
  const t1 = size2 === "large" ? "min-w-[220px] min-h-[220px] max-w-[220px]" : "min-w-[118px] min-h-[118px] max-w-[118px]";
  let t2;
  if ($[0] !== className || $[1] !== t1) {
    t2 = cls(paperMixin, "relative m-4 border-box flex items-center justify-center", t1, className);
    $[0] = className;
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== disabled || $[4] !== onRemove || $[5] !== placeholder3 || $[6] !== value) {
    t3 = !placeholder3 && !disabled && (0, import_jsx_runtime2.jsx)("div", { className: "absolute rounded-full -top-2 -right-2 z-10 bg-white dark:bg-surface-900", children: (0, import_jsx_runtime2.jsx)(Tooltip, { asChild: true, title: "Remove", children: (0, import_jsx_runtime2.jsx)(IconButton, { size: "small", onClick: (event) => {
      event.stopPropagation();
      onRemove(value);
    }, children: (0, import_jsx_runtime2.jsx)(RemoveIcon, { size: "small" }) }) }) });
    $[3] = disabled;
    $[4] = onRemove;
    $[5] = placeholder3;
    $[6] = value;
    $[7] = t3;
  } else {
    t3 = $[7];
  }
  let t4;
  if ($[8] !== name || $[9] !== placeholder3 || $[10] !== property || $[11] !== size2 || $[12] !== value) {
    t4 = !placeholder3 && value && (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey: name, value, property, interactive: false, size: size2 }) });
    $[8] = name;
    $[9] = placeholder3;
    $[10] = property;
    $[11] = size2;
    $[12] = value;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== placeholder3) {
    t5 = placeholder3 && (0, import_jsx_runtime2.jsx)("div", { onClick: _temp$b, className: "flex flex-col items-center justify-center w-full h-full", children: (0, import_jsx_runtime2.jsx)(DescriptionIcon, { className: "text-surface-700 dark:text-surface-300" }) });
    $[14] = placeholder3;
    $[15] = t5;
  } else {
    t5 = $[15];
  }
  let t6;
  if ($[16] !== t2 || $[17] !== t3 || $[18] !== t4 || $[19] !== t5) {
    t6 = (0, import_jsx_runtime2.jsxs)("div", { className: t2, children: [
      t3,
      t4,
      t5
    ] });
    $[16] = t2;
    $[17] = t3;
    $[18] = t4;
    $[19] = t5;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  return t6;
}
function _temp$b(e2) {
  return e2.stopPropagation();
}
var dropZoneClasses = "box-border relative pt-[2px] items-center border border-transparent min-h-[254px] outline-none rounded-md duration-200 ease-[cubic-bezier(0.4,0,0.2,1)] focus:border-primary-solid";
var disabledClasses = fieldBackgroundDisabledMixin;
var nonActiveDropClasses = fieldBackgroundHoverMixin;
var activeDropClasses = "pt-0 border-2 border-solid";
var acceptDropClasses = "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-2 border-solid border-green-500";
var rejectDropClasses = "transition-colors duration-200 ease-[cubic-bezier(0,0,0.2,1)] border-2 border-solid border-red-500";
function StorageUploadFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(48);
  const {
    propertyKey,
    value,
    setValue,
    error: error2,
    showError,
    autoFocus,
    minimalistView,
    property,
    includeDescription,
    context,
    isSubmitting
  } = t0;
  const authController = useAuthController();
  if (!context.entityId) {
    throw new Error("StorageUploadFieldBinding: Entity id is null");
  }
  const storageSource = useStorageSource(context.collection);
  let t1;
  if ($[0] !== context.disabled || $[1] !== isSubmitting || $[2] !== property) {
    t1 = isReadOnly(property) || !!property.disabled || isSubmitting || context.disabled;
    $[0] = context.disabled;
    $[1] = isSubmitting;
    $[2] = property;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const disabled = t1;
  const t2 = disabled ?? false;
  let t3;
  if ($[4] !== context.entityId || $[5] !== context.path || $[6] !== context.values || $[7] !== property || $[8] !== propertyKey || $[9] !== setValue || $[10] !== storageSource || $[11] !== t2 || $[12] !== value) {
    t3 = {
      entityValues: context.values,
      entityId: context.entityId,
      path: context.path,
      property,
      propertyKey,
      value,
      storageSource,
      disabled: t2,
      onChange: setValue
    };
    $[4] = context.entityId;
    $[5] = context.path;
    $[6] = context.values;
    $[7] = property;
    $[8] = propertyKey;
    $[9] = setValue;
    $[10] = storageSource;
    $[11] = t2;
    $[12] = value;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  const {
    internalValue,
    setInternalValue,
    onFilesAdded,
    storage,
    onFileUploadComplete,
    storagePathBuilder,
    multipleFilesSupported
  } = useStorageUploadController(t3);
  let t4;
  if ($[14] !== property || $[15] !== setValue || $[16] !== value) {
    t4 = {
      property,
      value,
      setValue
    };
    $[14] = property;
    $[15] = setValue;
    $[16] = value;
    $[17] = t4;
  } else {
    t4 = $[17];
  }
  useClearRestoreValue(t4);
  const t5 = property;
  let t6;
  if ($[18] !== authController || $[19] !== t5) {
    t6 = resolveProperty({
      propertyOrBuilder: t5,
      authController
    });
    $[18] = authController;
    $[19] = t5;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  const resolvedProperty = t6;
  let t7;
  if ($[21] !== minimalistView || $[22] !== property || $[23] !== propertyKey) {
    t7 = !minimalistView && (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property, "small"), required: (_a = property.validation) == null ? void 0 : _a.required, title: property.name, className: "h-8text-text-secondary dark:text-text-secondary-dark ml-3.5" });
    $[21] = minimalistView;
    $[22] = property;
    $[23] = propertyKey;
    $[24] = t7;
  } else {
    t7 = $[24];
  }
  const t8 = disabled ?? false;
  const t9 = autoFocus ?? false;
  let t10;
  if ($[25] !== internalValue || $[26] !== multipleFilesSupported || $[27] !== onFileUploadComplete || $[28] !== onFilesAdded || $[29] !== propertyKey || $[30] !== resolvedProperty || $[31] !== setInternalValue || $[32] !== setValue || $[33] !== storage || $[34] !== storagePathBuilder || $[35] !== t8 || $[36] !== t9) {
    t10 = (0, import_jsx_runtime2.jsx)(StorageUpload, { value: internalValue, name: propertyKey, disabled: t8, autoFocus: t9, property: resolvedProperty, onChange: setValue, setInternalValue, onFilesAdded, onFileUploadComplete, storagePathBuilder, storage, multipleFilesSupported });
    $[25] = internalValue;
    $[26] = multipleFilesSupported;
    $[27] = onFileUploadComplete;
    $[28] = onFilesAdded;
    $[29] = propertyKey;
    $[30] = resolvedProperty;
    $[31] = setInternalValue;
    $[32] = setValue;
    $[33] = storage;
    $[34] = storagePathBuilder;
    $[35] = t8;
    $[36] = t9;
    $[37] = t10;
  } else {
    t10 = $[37];
  }
  let t11;
  if ($[38] !== disabled || $[39] !== error2 || $[40] !== includeDescription || $[41] !== property || $[42] !== showError) {
    t11 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property });
    $[38] = disabled;
    $[39] = error2;
    $[40] = includeDescription;
    $[41] = property;
    $[42] = showError;
    $[43] = t11;
  } else {
    t11 = $[43];
  }
  let t12;
  if ($[44] !== t10 || $[45] !== t11 || $[46] !== t7) {
    t12 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t7,
      t10,
      t11
    ] });
    $[44] = t10;
    $[45] = t11;
    $[46] = t7;
    $[47] = t12;
  } else {
    t12 = $[47];
  }
  return t12;
}
function FileDropComponent(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(64);
  const {
    storage,
    disabled,
    isDraggingOver,
    onFilesAdded,
    multipleFilesSupported,
    droppableProvided,
    autoFocus,
    internalValue,
    property,
    onClear,
    metadata,
    storagePathBuilder,
    onFileUploadComplete,
    size: size2,
    name,
    helpText
  } = t0;
  const snackbarContext = useSnackbarController();
  let t1;
  if ($[0] !== storage.acceptedFiles) {
    t1 = storage.acceptedFiles ? storage.acceptedFiles.map(_temp$a).reduce(_temp2$4, {}) : void 0;
    $[0] = storage.acceptedFiles;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const t2 = disabled || isDraggingOver;
  let t3;
  if ($[2] !== snackbarContext || $[3] !== storage.maxSize) {
    t3 = (fileRejections, event) => {
      for (const fileRejection of fileRejections) {
        for (const error2 of fileRejection.errors) {
          console.error("Error uploading file: ", error2);
          if (error2.code === "file-too-large") {
            snackbarContext.open({
              type: "error",
              message: `Error uploading file: File is larger than ${storage.maxSize} bytes`
            });
          } else {
            if (error2.code === "file-invalid-type") {
              snackbarContext.open({
                type: "error",
                message: "Error uploading file: File type is not supported"
              });
            }
          }
        }
      }
    };
    $[2] = snackbarContext;
    $[3] = storage.maxSize;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== onFilesAdded || $[6] !== storage.maxSize || $[7] !== t1 || $[8] !== t2 || $[9] !== t3) {
    t4 = {
      accept: t1,
      disabled: t2,
      noDragEventsBubbling: true,
      maxSize: storage.maxSize,
      onDrop: onFilesAdded,
      onDropRejected: t3
    };
    $[5] = onFilesAdded;
    $[6] = storage.maxSize;
    $[7] = t1;
    $[8] = t2;
    $[9] = t3;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  const {
    getRootProps,
    getInputProps,
    isDragActive,
    isDragAccept,
    isDragReject
  } = useDropzone(t4);
  let t5;
  if ($[11] !== getRootProps) {
    t5 = getRootProps();
    $[11] = getRootProps;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  const t6 = disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin;
  const t7 = disabled ? "text-surface-accent-600 dark:text-surface-accent-500" : "";
  const t8 = multipleFilesSupported && internalValue.length ? "" : "flex";
  const t9 = !isDragActive;
  let t10;
  if ($[13] !== disabled || $[14] !== isDragAccept || $[15] !== isDragActive || $[16] !== isDragReject || $[17] !== t6 || $[18] !== t7 || $[19] !== t8 || $[20] !== t9) {
    t10 = cls(fieldBackgroundMixin, t6, t7, dropZoneClasses, t8, {
      [nonActiveDropClasses]: t9,
      [activeDropClasses]: isDragActive,
      [rejectDropClasses]: isDragReject,
      [acceptDropClasses]: isDragAccept,
      [disabledClasses]: disabled
    });
    $[13] = disabled;
    $[14] = isDragAccept;
    $[15] = isDragActive;
    $[16] = isDragReject;
    $[17] = t6;
    $[18] = t7;
    $[19] = t8;
    $[20] = t9;
    $[21] = t10;
  } else {
    t10 = $[21];
  }
  const t11 = droppableProvided.droppableProps;
  const t12 = droppableProvided.innerRef;
  const t13 = multipleFilesSupported && internalValue.length ? "overflow-auto" : "";
  const t14 = multipleFilesSupported && internalValue.length ? "min-h-[180px]" : "min-h-[250px]";
  let t15;
  if ($[22] !== t13 || $[23] !== t14) {
    t15 = cls("flex items-center p-1 no-scrollbar", t13, t14);
    $[22] = t13;
    $[23] = t14;
    $[24] = t15;
  } else {
    t15 = $[24];
  }
  let t16;
  if ($[25] !== getInputProps) {
    t16 = getInputProps();
    $[25] = getInputProps;
    $[26] = t16;
  } else {
    t16 = $[26];
  }
  let t17;
  if ($[27] !== autoFocus || $[28] !== t16) {
    t17 = (0, import_jsx_runtime2.jsx)("input", { autoFocus, ...t16 });
    $[27] = autoFocus;
    $[28] = t16;
    $[29] = t17;
  } else {
    t17 = $[29];
  }
  let t18;
  if ($[30] !== disabled || $[31] !== internalValue || $[32] !== metadata || $[33] !== name || $[34] !== onClear || $[35] !== onFileUploadComplete || $[36] !== property || $[37] !== size2 || $[38] !== storagePathBuilder) {
    let t192;
    if ($[40] !== disabled || $[41] !== metadata || $[42] !== name || $[43] !== onClear || $[44] !== onFileUploadComplete || $[45] !== property || $[46] !== size2 || $[47] !== storagePathBuilder) {
      t192 = (entry, index2) => {
        let child;
        if (entry.storagePathOrDownloadUrl) {
          child = (0, import_jsx_runtime2.jsx)(StorageItemPreview, { name: `storage_preview_${entry.storagePathOrDownloadUrl}`, property, disabled, value: entry.storagePathOrDownloadUrl, onRemove: onClear, size: entry.size });
        } else {
          if (entry.file) {
            child = (0, import_jsx_runtime2.jsx)(StorageUploadProgress, { entry, metadata, storagePath: storagePathBuilder(entry.file), onFileUploadComplete, imageSize: size2 === "large" ? 220 : 118, simple: false });
          }
        }
        return (0, import_jsx_runtime2.jsx)(PublicDraggable, { draggableId: `array_field_${name}_${entry.id}`, index: index2, children: (provided, snapshot) => (0, import_jsx_runtime2.jsx)("div", { tabIndex: -1, ref: provided.innerRef, ...provided.draggableProps, ...provided.dragHandleProps, className: cls("rounded-md"), style: {
          ...provided.draggableProps.style
        }, children: child }) }, `array_field_${name}_${entry.id}`);
      };
      $[40] = disabled;
      $[41] = metadata;
      $[42] = name;
      $[43] = onClear;
      $[44] = onFileUploadComplete;
      $[45] = property;
      $[46] = size2;
      $[47] = storagePathBuilder;
      $[48] = t192;
    } else {
      t192 = $[48];
    }
    t18 = internalValue.map(t192);
    $[30] = disabled;
    $[31] = internalValue;
    $[32] = metadata;
    $[33] = name;
    $[34] = onClear;
    $[35] = onFileUploadComplete;
    $[36] = property;
    $[37] = size2;
    $[38] = storagePathBuilder;
    $[39] = t18;
  } else {
    t18 = $[39];
  }
  let t19;
  if ($[49] !== droppableProvided.droppableProps || $[50] !== droppableProvided.innerRef || $[51] !== droppableProvided.placeholder || $[52] !== t15 || $[53] !== t17 || $[54] !== t18) {
    t19 = (0, import_jsx_runtime2.jsxs)("div", { ...t11, ref: t12, className: t15, children: [
      t17,
      t18,
      droppableProvided.placeholder
    ] });
    $[49] = droppableProvided.droppableProps;
    $[50] = droppableProvided.innerRef;
    $[51] = droppableProvided.placeholder;
    $[52] = t15;
    $[53] = t17;
    $[54] = t18;
    $[55] = t19;
  } else {
    t19 = $[55];
  }
  const t20 = disabled ? "text-surface-accent-600 dark:text-surface-accent-500" : "";
  let t21;
  if ($[56] !== helpText || $[57] !== t20) {
    t21 = (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow min-h-[38px] box-border m-2 text-center", children: (0, import_jsx_runtime2.jsx)(Typography, { align: "center", variant: "label", className: t20, children: helpText }) });
    $[56] = helpText;
    $[57] = t20;
    $[58] = t21;
  } else {
    t21 = $[58];
  }
  let t22;
  if ($[59] !== t10 || $[60] !== t19 || $[61] !== t21 || $[62] !== t5) {
    t22 = (0, import_jsx_runtime2.jsxs)("div", { ...t5, className: t10, children: [
      t19,
      t21
    ] });
    $[59] = t10;
    $[60] = t19;
    $[61] = t21;
    $[62] = t5;
    $[63] = t22;
  } else {
    t22 = $[63];
  }
  return t22;
}
function _temp2$4(a2, b2) {
  return {
    ...a2,
    ...b2
  };
}
function _temp$a(e2) {
  return {
    [e2]: []
  };
}
function StorageUpload({
  property,
  name,
  value,
  setInternalValue,
  onChange,
  multipleFilesSupported,
  onFileUploadComplete,
  disabled,
  onFilesAdded,
  autoFocus,
  storage,
  storagePathBuilder
}) {
  if (multipleFilesSupported) {
    const arrayProperty = property;
    if (arrayProperty.of) {
      if (Array.isArray(arrayProperty.of)) {
        throw Error("Storage field using array must be of data type string");
      }
      if (arrayProperty.of.dataType !== "string") {
        throw Error("Storage field using array must be of data type string");
      }
    } else {
      throw Error("Storage field using array must be of data type string");
    }
  }
  const metadata = storage == null ? void 0 : storage.metadata;
  const size2 = multipleFilesSupported ? "medium" : "large";
  const moveItem = (0, import_react14.useCallback)((fromIndex, toIndex) => {
    if (!multipleFilesSupported) return;
    const newValue = [...value];
    const item = newValue[fromIndex];
    newValue.splice(fromIndex, 1);
    newValue.splice(toIndex, 0, item);
    setInternalValue(newValue);
    const fieldValue = newValue.filter((e2) => !!e2.storagePathOrDownloadUrl).map((e_0) => e_0.storagePathOrDownloadUrl);
    onChange(fieldValue);
  }, [multipleFilesSupported, onChange, setInternalValue, value]);
  const onDragEnd2 = (0, import_react14.useCallback)((result) => {
    if (!result.destination) {
      return;
    }
    moveItem(result.source.index, result.destination.index);
  }, [moveItem]);
  const onClear = (0, import_react14.useCallback)((clearedStoragePathOrDownloadUrl) => {
    if (multipleFilesSupported) {
      const newValue_0 = value.filter((v) => v.storagePathOrDownloadUrl !== clearedStoragePathOrDownloadUrl);
      onChange(newValue_0.filter((v_0) => !!v_0.storagePathOrDownloadUrl).map((v_1) => v_1.storagePathOrDownloadUrl));
      setInternalValue(newValue_0);
    } else {
      onChange(null);
      setInternalValue([]);
    }
  }, [value, multipleFilesSupported, onChange]);
  const helpText = multipleFilesSupported ? "Drag 'n' drop some files here, or click to select files" : "Drag 'n' drop a file here, or click to select one";
  const renderProperty = multipleFilesSupported ? property.of : property;
  return (0, import_jsx_runtime2.jsx)(DragDropContext, { onDragEnd: onDragEnd2, children: (0, import_jsx_runtime2.jsx)(ConnectedDroppable$1, { droppableId: `droppable_${name}`, direction: "horizontal", renderClone: (provided, snapshot, rubric) => {
    const entry = value[rubric.source.index];
    return (0, import_jsx_runtime2.jsx)("div", { ref: provided.innerRef, ...provided.draggableProps, ...provided.dragHandleProps, style: provided.draggableProps.style, className: "rounded", children: (0, import_jsx_runtime2.jsx)(StorageItemPreview, { name: `storage_preview_${entry.storagePathOrDownloadUrl}`, placeholder: true, property: renderProperty, disabled: true, value: entry.storagePathOrDownloadUrl, onRemove: onClear, size: entry.size }) });
  }, children: (provided_0, snapshot_0) => {
    return (0, import_jsx_runtime2.jsx)(FileDropComponent, { storage, disabled, isDraggingOver: snapshot_0.isDraggingOver, droppableProvided: provided_0, onFilesAdded, multipleFilesSupported, autoFocus, internalValue: value, property: renderProperty, onClear, metadata, storagePathBuilder, onFileUploadComplete, size: size2, name, helpText });
  } }) });
}
function TextFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(52);
  const {
    propertyKey,
    value,
    setValue,
    error: error2,
    showError,
    disabled,
    autoFocus,
    property,
    includeDescription,
    size: t1
  } = t0;
  const size2 = t1 === void 0 ? "large" : t1;
  let multiline;
  let url;
  if (property.dataType === "string") {
    multiline = property.multiline;
    url = property.url;
  }
  let t2;
  if ($[0] !== property || $[1] !== setValue || $[2] !== value) {
    t2 = {
      property,
      value,
      setValue
    };
    $[0] = property;
    $[1] = setValue;
    $[2] = value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  useClearRestoreValue(t2);
  let t3;
  if ($[4] !== setValue) {
    t3 = (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      setValue(null);
    };
    $[4] = setValue;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const handleClearClick = t3;
  let inputType;
  let isMultiline;
  let onChange;
  if ($[6] !== multiline || $[7] !== property.dataType || $[8] !== setValue) {
    onChange = (event) => {
      if (inputType === "number") {
        const numberValue = event.target.value ? parseFloat(event.target.value) : void 0;
        if (numberValue && isNaN(numberValue)) {
          setValue(null);
        } else {
          if (numberValue !== void 0 && numberValue !== null) {
            setValue(numberValue);
          } else {
            setValue(null);
          }
        }
      } else {
        setValue(event.target.value);
      }
    };
    isMultiline = Boolean(multiline);
    inputType = property.dataType === "number" ? "number" : void 0;
    $[6] = multiline;
    $[7] = property.dataType;
    $[8] = setValue;
    $[9] = inputType;
    $[10] = isMultiline;
    $[11] = onChange;
  } else {
    inputType = $[9];
    isMultiline = $[10];
    onChange = $[11];
  }
  const t4 = property.widthPercentage !== void 0 ? "mt-8" : void 0;
  let t5;
  if ($[12] !== property) {
    t5 = getIconForProperty(property, "small");
    $[12] = property;
    $[13] = t5;
  } else {
    t5 = $[13];
  }
  const t6 = (_a = property.validation) == null ? void 0 : _a.required;
  let t7;
  if ($[14] !== property.name || $[15] !== t5 || $[16] !== t6) {
    t7 = (0, import_jsx_runtime2.jsx)(LabelWithIcon, { icon: t5, required: t6, title: property.name });
    $[14] = property.name;
    $[15] = t5;
    $[16] = t6;
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  let t8;
  if ($[18] !== handleClearClick || $[19] !== property.clearable) {
    t8 = property.clearable && (0, import_jsx_runtime2.jsx)(IconButton, { onClick: handleClearClick, children: (0, import_jsx_runtime2.jsx)(CloseIcon, {}) });
    $[18] = handleClearClick;
    $[19] = property.clearable;
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  const t9 = showError ? error2 : void 0;
  const t10 = error2 ? "text-red-500 dark:text-red-600" : "";
  let t11;
  if ($[21] !== autoFocus || $[22] !== disabled || $[23] !== inputType || $[24] !== isMultiline || $[25] !== onChange || $[26] !== size2 || $[27] !== t10 || $[28] !== t4 || $[29] !== t7 || $[30] !== t8 || $[31] !== t9 || $[32] !== value) {
    t11 = (0, import_jsx_runtime2.jsx)(TextField, { size: size2, value, onChange, autoFocus, className: t4, label: t7, type: inputType, multiline: isMultiline, disabled, endAdornment: t8, error: t9, inputClassName: t10 });
    $[21] = autoFocus;
    $[22] = disabled;
    $[23] = inputType;
    $[24] = isMultiline;
    $[25] = onChange;
    $[26] = size2;
    $[27] = t10;
    $[28] = t4;
    $[29] = t7;
    $[30] = t8;
    $[31] = t9;
    $[32] = value;
    $[33] = t11;
  } else {
    t11 = $[33];
  }
  let t12;
  if ($[34] !== propertyKey || $[35] !== t11) {
    t12 = (0, import_jsx_runtime2.jsx)(PropertyIdCopyTooltip, { propertyKey, children: t11 });
    $[34] = propertyKey;
    $[35] = t11;
    $[36] = t12;
  } else {
    t12 = $[36];
  }
  let t13;
  if ($[37] !== disabled || $[38] !== error2 || $[39] !== includeDescription || $[40] !== property || $[41] !== showError) {
    t13 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property });
    $[37] = disabled;
    $[38] = error2;
    $[39] = includeDescription;
    $[40] = property;
    $[41] = showError;
    $[42] = t13;
  } else {
    t13 = $[42];
  }
  let t14;
  if ($[43] !== property || $[44] !== size2 || $[45] !== url || $[46] !== value) {
    t14 = url && (0, import_jsx_runtime2.jsx)(Collapse, { className: "mt-1 ml-1", in: Boolean(value), children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { value, property, size: size2 }) });
    $[43] = property;
    $[44] = size2;
    $[45] = url;
    $[46] = value;
    $[47] = t14;
  } else {
    t14 = $[47];
  }
  let t15;
  if ($[48] !== t12 || $[49] !== t13 || $[50] !== t14) {
    t15 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t12,
      t13,
      t14
    ] });
    $[48] = t12;
    $[49] = t13;
    $[50] = t14;
    $[51] = t15;
  } else {
    t15 = $[51];
  }
  return t15;
}
var SwitchFieldBinding = function SwitchFieldBinding2(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(33);
  const {
    propertyKey,
    value,
    setValue,
    error: error2,
    showError,
    autoFocus,
    disabled,
    size: t1,
    property,
    includeDescription
  } = t0;
  const size2 = t1 === void 0 ? "large" : t1;
  let t2;
  if ($[0] !== property || $[1] !== setValue || $[2] !== value) {
    t2 = {
      property,
      value,
      setValue
    };
    $[0] = property;
    $[1] = setValue;
    $[2] = value;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  useClearRestoreValue(t2);
  let t3;
  if ($[4] !== setValue) {
    t3 = (v) => setValue(v);
    $[4] = setValue;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const t4 = property.widthPercentage !== void 0 ? "mt-8" : void 0;
  let t5;
  if ($[6] !== property) {
    t5 = getIconForProperty(property, "small");
    $[6] = property;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  const t6 = (_a = property.validation) == null ? void 0 : _a.required;
  let t7;
  if ($[8] !== property.name || $[9] !== t5 || $[10] !== t6) {
    t7 = (0, import_jsx_runtime2.jsx)(LabelWithIcon, { icon: t5, required: t6, title: property.name });
    $[8] = property.name;
    $[9] = t5;
    $[10] = t6;
    $[11] = t7;
  } else {
    t7 = $[11];
  }
  let t8;
  if ($[12] !== autoFocus || $[13] !== disabled || $[14] !== showError || $[15] !== size2 || $[16] !== t3 || $[17] !== t4 || $[18] !== t7 || $[19] !== value) {
    t8 = (0, import_jsx_runtime2.jsx)(BooleanSwitchWithLabel, { value, onValueChange: t3, error: showError, className: t4, label: t7, disabled, autoFocus, size: size2 });
    $[12] = autoFocus;
    $[13] = disabled;
    $[14] = showError;
    $[15] = size2;
    $[16] = t3;
    $[17] = t4;
    $[18] = t7;
    $[19] = value;
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  let t9;
  if ($[21] !== propertyKey || $[22] !== t8) {
    t9 = (0, import_jsx_runtime2.jsx)(PropertyIdCopyTooltip, { propertyKey, children: t8 });
    $[21] = propertyKey;
    $[22] = t8;
    $[23] = t9;
  } else {
    t9 = $[23];
  }
  let t10;
  if ($[24] !== disabled || $[25] !== error2 || $[26] !== includeDescription || $[27] !== property || $[28] !== showError) {
    t10 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property });
    $[24] = disabled;
    $[25] = error2;
    $[26] = includeDescription;
    $[27] = property;
    $[28] = showError;
    $[29] = t10;
  } else {
    t10 = $[29];
  }
  let t11;
  if ($[30] !== t10 || $[31] !== t9) {
    t11 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t9,
      t10
    ] });
    $[30] = t10;
    $[31] = t9;
    $[32] = t11;
  } else {
    t11 = $[32];
  }
  return t11;
};
function DateTimeFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(34);
  const {
    propertyKey,
    value,
    setValue,
    error: error2,
    showError,
    disabled,
    property,
    includeDescription
  } = t0;
  const {
    locale
  } = useCustomizationController();
  const internalValue = value || null;
  let t1;
  if ($[0] !== property || $[1] !== setValue || $[2] !== value) {
    t1 = {
      property,
      value,
      setValue
    };
    $[0] = property;
    $[1] = setValue;
    $[2] = value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  useClearRestoreValue(t1);
  let t2;
  if ($[4] !== setValue) {
    t2 = (dateValue) => setValue(dateValue);
    $[4] = setValue;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  const t3 = property.mode;
  const t4 = property.clearable;
  let t5;
  if ($[6] !== property) {
    t5 = getIconForProperty(property, "small");
    $[6] = property;
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  const t6 = (_a = property.validation) == null ? void 0 : _a.required;
  const t7 = showError ? "text-red-500 dark:text-red-500" : "text-text-secondary dark:text-text-secondary-dark";
  let t8;
  if ($[8] !== property.name || $[9] !== t5 || $[10] !== t6 || $[11] !== t7) {
    t8 = (0, import_jsx_runtime2.jsx)(LabelWithIcon, { icon: t5, required: t6, className: t7, title: property.name });
    $[8] = property.name;
    $[9] = t5;
    $[10] = t6;
    $[11] = t7;
    $[12] = t8;
  } else {
    t8 = $[12];
  }
  let t9;
  if ($[13] !== disabled || $[14] !== internalValue || $[15] !== locale || $[16] !== property.clearable || $[17] !== property.mode || $[18] !== showError || $[19] !== t2 || $[20] !== t8) {
    t9 = (0, import_jsx_runtime2.jsx)(DateTimeField, { value: internalValue, onChange: t2, size: "large", mode: t3, clearable: t4, locale, error: showError, disabled, label: t8 });
    $[13] = disabled;
    $[14] = internalValue;
    $[15] = locale;
    $[16] = property.clearable;
    $[17] = property.mode;
    $[18] = showError;
    $[19] = t2;
    $[20] = t8;
    $[21] = t9;
  } else {
    t9 = $[21];
  }
  let t10;
  if ($[22] !== propertyKey || $[23] !== t9) {
    t10 = (0, import_jsx_runtime2.jsx)(PropertyIdCopyTooltip, { propertyKey, children: t9 });
    $[22] = propertyKey;
    $[23] = t9;
    $[24] = t10;
  } else {
    t10 = $[24];
  }
  let t11;
  if ($[25] !== disabled || $[26] !== error2 || $[27] !== includeDescription || $[28] !== property || $[29] !== showError) {
    t11 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property });
    $[25] = disabled;
    $[26] = error2;
    $[27] = includeDescription;
    $[28] = property;
    $[29] = showError;
    $[30] = t11;
  } else {
    t11 = $[30];
  }
  let t12;
  if ($[31] !== t10 || $[32] !== t11) {
    t12 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t10,
      t11
    ] });
    $[31] = t10;
    $[32] = t11;
    $[33] = t12;
  } else {
    t12 = $[33];
  }
  return t12;
}
function ReadOnlyFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(18);
  const {
    propertyKey,
    value,
    error: error2,
    showError,
    minimalistView,
    property,
    includeDescription,
    context
  } = t0;
  if (!context.entityId) {
    throw new Error("ReadOnlyFieldBinding: Entity id is null");
  }
  let t1;
  if ($[0] !== minimalistView || $[1] !== property || $[2] !== propertyKey) {
    t1 = !minimalistView && (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property, "small"), required: (_a = property.validation) == null ? void 0 : _a.required, title: property.name, className: "h-8 text-text-secondary dark:text-text-secondary-dark ml-3.5" });
    $[0] = minimalistView;
    $[1] = property;
    $[2] = propertyKey;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = cls(paperMixin, "w-full min-h-14 p-4 md:p-6 overflow-x-scroll no-scrollbar");
    $[4] = t2;
  } else {
    t2 = $[4];
  }
  let t3;
  if ($[5] !== property || $[6] !== propertyKey || $[7] !== value) {
    t3 = (0, import_jsx_runtime2.jsx)("div", { className: t2, children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyPreview, { propertyKey, value, property, size: "medium" }) }) });
    $[5] = property;
    $[6] = propertyKey;
    $[7] = value;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  let t4;
  if ($[9] !== error2 || $[10] !== includeDescription || $[11] !== property || $[12] !== showError) {
    t4 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, property });
    $[9] = error2;
    $[10] = includeDescription;
    $[11] = property;
    $[12] = showError;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== t1 || $[15] !== t3 || $[16] !== t4) {
    t5 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t1,
      t3,
      t4
    ] });
    $[14] = t1;
    $[15] = t3;
    $[16] = t4;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  return t5;
}
function ReferenceFieldBinding(props) {
  const $ = (0, import_react_compiler_runtime3.c)(4);
  if (typeof props.property.path !== "string") {
    let t02;
    if ($[0] !== props) {
      t02 = (0, import_jsx_runtime2.jsx)(ReadOnlyFieldBinding, { ...props });
      $[0] = props;
      $[1] = t02;
    } else {
      t02 = $[1];
    }
    return t02;
  }
  let t0;
  if ($[2] !== props) {
    t0 = (0, import_jsx_runtime2.jsx)(ReferenceFieldBindingInternal, { ...props });
    $[2] = props;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  return t0;
}
function ReferenceFieldBindingInternal({
  propertyKey,
  value,
  setValue,
  error: error2,
  showError,
  isSubmitting,
  disabled,
  minimalistView,
  touched,
  autoFocus,
  property,
  includeDescription,
  size: size2 = "medium"
}) {
  var _a;
  if (!property.path) {
    throw new Error("Property path is required for ReferenceFieldBinding");
  }
  useClearRestoreValue({
    property,
    value,
    setValue
  });
  const validValue = value && value.isEntityReference && value.isEntityReference();
  const navigationController = useNavigationController();
  const collection = (0, import_react14.useMemo)(() => {
    return property.path ? navigationController.getCollection(property.path) : void 0;
  }, [property.path]);
  if (!collection) {
    throw Error(`Couldn't find the corresponding collection for the path: ${property.path}`);
  }
  const onSingleEntitySelected = (0, import_react14.useCallback)((e2) => {
    setValue(e2 ? getReferenceFrom(e2) : null);
  }, [setValue]);
  const referenceDialogController = useReferenceDialog({
    multiselect: false,
    path: property.path,
    collection,
    onSingleEntitySelected,
    selectedEntityIds: validValue ? [value.id] : void 0,
    forceFilter: property.forceFilter
  });
  const onEntryClick = (e_0) => {
    e_0.preventDefault();
    referenceDialogController.open();
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    !minimalistView && (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property, "small"), required: (_a = property.validation) == null ? void 0 : _a.required, title: property.name, className: "h-8 text-text-secondary dark:text-text-secondary-dark ml-3.5" }),
    !collection && (0, import_jsx_runtime2.jsx)(ErrorView, { error: "The specified collection does not exist. Check console" }),
    collection && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      value && (0, import_jsx_runtime2.jsx)(ReferencePreview, { disabled: !property.path, previewProperties: property.previewProperties, hover: !disabled, size: size2, onClick: disabled || isSubmitting ? void 0 : onEntryClick, reference: value, includeEntityLink: property.includeEntityLink, includeId: property.includeId }),
      !value && (0, import_jsx_runtime2.jsx)("div", { className: "justify-center text-left", children: (0, import_jsx_runtime2.jsxs)(EntityPreviewContainer, { className: cls("px-6 h-16 text-sm font-medium flex items-center gap-6", disabled || isSubmitting ? "text-surface-accent-500" : "cursor-pointer text-surface-accent-700 dark:text-surface-accent-300 hover:bg-surface-accent-50 dark:hover:bg-surface-800 group-hover:bg-surface-accent-50 dark:group-hover:bg-surface-800"), onClick: onEntryClick, size: "medium", children: [
        (0, import_jsx_runtime2.jsx)(IconForView, { collectionOrView: collection, className: "text-surface-300 dark:text-surface-600" }),
        `Edit ${property.name}`.toUpperCase()
      ] }) })
    ] }),
    (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property })
  ] });
}
var PropertyFieldBinding = import_react14.default.memo(PropertyFieldBindingInternal, (a2, b2) => {
  if (a2.propertyKey !== b2.propertyKey) {
    return false;
  }
  if (a2.index !== b2.index) {
    return false;
  }
  if (a2.size !== b2.size) {
    return false;
  }
  const aIsBuilder = isPropertyBuilder(a2.property) || a2.property.fromBuilder;
  const bIsBuilder = isPropertyBuilder(b2.property) || b2.property.fromBuilder;
  const baseCheck = (aIsBuilder === bIsBuilder || (0, import_react_fast_compare2.default)(a2.property, b2.property)) && a2.disabled === b2.disabled;
  if (!baseCheck) {
    return false;
  }
  if (shouldPropertyReRender(b2.property)) {
    return false;
  }
  return false;
});
function PropertyFieldBindingInternal(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(18);
  const {
    propertyKey,
    property,
    context,
    includeDescription,
    underlyingValueHasChanged,
    disabled: disabledProp,
    partOfArray,
    minimalistView,
    autoFocus,
    index: index2,
    size: size2,
    onPropertyChange
  } = t0;
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== authController || $[1] !== autoFocus || $[2] !== context || $[3] !== customizationController.propertyConfigs || $[4] !== disabledProp || $[5] !== includeDescription || $[6] !== index2 || $[7] !== minimalistView || $[8] !== onPropertyChange || $[9] !== partOfArray || $[10] !== property || $[11] !== propertyKey || $[12] !== size2 || $[13] !== underlyingValueHasChanged) {
    t1 = (fieldProps) => {
      let Component3;
      const resolvedProperty = resolveProperty({
        propertyKey,
        propertyOrBuilder: property,
        values: fieldProps.form.values,
        path: context.path,
        entityId: context.entityId,
        propertyConfigs: customizationController.propertyConfigs,
        index: index2,
        authController
      });
      const disabled = disabledProp || isReadOnly(resolvedProperty) || Boolean(resolvedProperty == null ? void 0 : resolvedProperty.disabled) || context.disabled;
      if (resolvedProperty === null || isHidden(resolvedProperty)) {
        return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
      } else {
        if (isReadOnly(resolvedProperty)) {
          Component3 = ReadOnlyFieldBinding;
        } else {
          if (resolvedProperty.Field) {
            if (typeof resolvedProperty.Field === "function") {
              Component3 = resolvedProperty.Field;
            }
          } else {
            const propertyConfig = getFieldConfig(resolvedProperty, customizationController.propertyConfigs);
            if (!propertyConfig) {
              console.log("INTERNAL: Could not find field config for property", {
                propertyKey,
                property,
                resolvedProperty,
                fields: customizationController.propertyConfigs,
                propertyConfig
              });
              throw new Error(`INTERNAL: Could not find field config for property ${propertyKey}`);
            }
            const configProperty = resolveProperty({
              propertyKey,
              propertyOrBuilder: propertyConfig.property,
              values: fieldProps.form.values,
              path: context.path,
              entityId: context.entityId,
              propertyConfigs: customizationController.propertyConfigs,
              index: index2,
              authController
            });
            Component3 = configProperty.Field;
          }
        }
      }
      if (!Component3) {
        console.warn(`No field component found for property ${propertyKey}`);
        console.warn("Property:", property);
        return (0, import_jsx_runtime2.jsx)("div", { className: "w-full", children: `Currently the field ${resolvedProperty.dataType} is not supported` });
      }
      const componentProps = {
        propertyKey,
        property: resolvedProperty,
        includeDescription,
        underlyingValueHasChanged,
        context,
        disabled,
        partOfArray,
        minimalistView,
        autoFocus,
        size: size2,
        onPropertyChange
      };
      return (0, import_jsx_runtime2.jsx)(FieldInternal, { Component: Component3, componentProps, formexFieldProps: fieldProps });
    };
    $[0] = authController;
    $[1] = autoFocus;
    $[2] = context;
    $[3] = customizationController.propertyConfigs;
    $[4] = disabledProp;
    $[5] = includeDescription;
    $[6] = index2;
    $[7] = minimalistView;
    $[8] = onPropertyChange;
    $[9] = partOfArray;
    $[10] = property;
    $[11] = propertyKey;
    $[12] = size2;
    $[13] = underlyingValueHasChanged;
    $[14] = t1;
  } else {
    t1 = $[14];
  }
  let t2;
  if ($[15] !== propertyKey || $[16] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)(Field, { name: propertyKey, children: t1 }, propertyKey);
    $[15] = propertyKey;
    $[16] = t1;
    $[17] = t2;
  } else {
    t2 = $[17];
  }
  return t2;
}
function FieldInternal({
  Component: Component3,
  componentProps: {
    propertyKey,
    property,
    includeDescription,
    underlyingValueHasChanged,
    partOfArray,
    minimalistView,
    autoFocus,
    context,
    disabled,
    size: size2,
    onPropertyChange
  },
  formexFieldProps
}) {
  var _a;
  const {
    plugins
  } = useCustomizationController();
  const customFieldProps = property.customProps;
  const value = formexFieldProps.field.value;
  const error2 = getIn(formexFieldProps.form.errors, propertyKey);
  const touched = getIn(formexFieldProps.form.touched, propertyKey);
  const showError = error2 && (formexFieldProps.form.submitCount > 0 || ((_a = property.validation) == null ? void 0 : _a.unique)) && (!Array.isArray(error2) || !!error2.filter((e2) => !!e2).length);
  const WrappedComponent = useWrappedComponent({
    path: context.path,
    collection: context.collection,
    propertyKey,
    property,
    Component: Component3,
    plugins
  });
  const UsedComponent = WrappedComponent ?? Component3;
  const isSubmitting = formexFieldProps.form.isSubmitting;
  const setValue = (0, import_react14.useCallback)((value_0, shouldValidate) => {
    formexFieldProps.form.setFieldTouched(propertyKey, true, false);
    formexFieldProps.form.setFieldValue(propertyKey, value_0, shouldValidate);
  }, []);
  const setFieldValue = (0, import_react14.useCallback)((otherPropertyKey, value_1, shouldValidate_0) => {
    formexFieldProps.form.setFieldTouched(propertyKey, true, false);
    formexFieldProps.form.setFieldValue(otherPropertyKey, value_1, shouldValidate_0);
  }, []);
  const cmsFieldProps = {
    propertyKey,
    value,
    setValue,
    setFieldValue,
    error: error2,
    touched,
    showError,
    isSubmitting,
    includeDescription: includeDescription ?? true,
    property,
    disabled: disabled ?? false,
    underlyingValueHasChanged: underlyingValueHasChanged ?? false,
    partOfArray: partOfArray ?? false,
    minimalistView: minimalistView ?? false,
    autoFocus: autoFocus ?? false,
    customProps: customFieldProps,
    context,
    size: size2,
    onPropertyChange
  };
  return (0, import_jsx_runtime2.jsxs)(ErrorBoundary2, { children: [
    (0, import_jsx_runtime2.jsx)(UsedComponent, { ...cmsFieldProps }),
    underlyingValueHasChanged && !isSubmitting && (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", className: "ml-3.5", children: "This value has been updated elsewhere" })
  ] });
}
var shouldPropertyReRender = (property, plugins) => {
  var _a;
  if (isPropertyBuilder(property)) {
    return true;
  }
  const defAProperty = property;
  const rerenderThisProperty = Boolean(defAProperty.Field) || "fromBuilder" in defAProperty && defAProperty.fromBuilder;
  if (defAProperty.dataType === "map" && defAProperty.properties) {
    return rerenderThisProperty || Object.values(defAProperty.properties).some((childProperty) => shouldPropertyReRender(childProperty));
  } else if (defAProperty.dataType === "array" && "resolvedProperties" in defAProperty) {
    return rerenderThisProperty || ((_a = defAProperty.resolvedProperties) == null ? void 0 : _a.some((childProperty) => childProperty && shouldPropertyReRender(childProperty)));
  } else {
    return rerenderThisProperty;
  }
};
function useWrappedComponent({
  path,
  collection,
  propertyKey,
  property,
  Component: Component3,
  plugins
}) {
  const wrapperRef = (0, import_react14.useRef)((() => {
    let Wrapper = null;
    if (plugins) {
      plugins.forEach((plugin) => {
        var _a, _b, _c;
        const fieldId = getFieldId(property);
        if (fieldId && ((_a = plugin.form) == null ? void 0 : _a.fieldBuilder)) {
          const params = {
            fieldConfigId: fieldId,
            propertyKey,
            property,
            Field: Component3,
            plugin,
            path,
            collection
          };
          const enabled = (_c = (_b = plugin.form) == null ? void 0 : _b.fieldBuilderEnabled) == null ? void 0 : _c.call(_b, params);
          if (enabled === void 0 || enabled) Wrapper = plugin.form.fieldBuilder(params) || Wrapper;
        }
        if (!fieldId) {
          console.warn("INTERNAL: Field id not found for property", property);
        }
      });
    }
    return Wrapper;
  })());
  return wrapperRef.current;
}
function MapFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(41);
  const {
    propertyKey,
    value,
    showError,
    error: error2,
    disabled,
    property,
    minimalistView: minimalistViewProp,
    includeDescription,
    autoFocus,
    context,
    onPropertyChange
  } = t0;
  const pickOnlySomeKeys = property.pickOnlySomeKeys || false;
  const expanded = property.expanded === void 0 ? true : property.expanded;
  const minimalistView = minimalistViewProp || property.minimalistView;
  if (!property.properties) {
    throw Error(`You need to specify a 'properties' prop (or specify a custom field) in your map property ${propertyKey}`);
  }
  let mapProperties;
  if (pickOnlySomeKeys) {
    if (value) {
      let t12;
      if ($[0] !== property.properties || $[1] !== value) {
        t12 = pick(property.properties, ...Object.keys(value).filter((key) => key in property.properties));
        $[0] = property.properties;
        $[1] = value;
        $[2] = t12;
      } else {
        t12 = $[2];
      }
      mapProperties = t12;
    } else {
      let t12;
      if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
        t12 = {};
        $[3] = t12;
      } else {
        t12 = $[3];
      }
      mapProperties = t12;
    }
  } else {
    mapProperties = property.properties;
  }
  const t1 = minimalistView && property.widthPercentage !== void 0 ? "mt-8" : void 0;
  let t2;
  if ($[4] !== t1) {
    t2 = cls("py-1 flex flex-col space-y-2", t1);
    $[4] = t1;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  let t3;
  if ($[6] !== autoFocus || $[7] !== context || $[8] !== disabled || $[9] !== includeDescription || $[10] !== mapProperties || $[11] !== onPropertyChange || $[12] !== propertyKey) {
    let t42;
    if ($[14] !== autoFocus || $[15] !== context || $[16] !== disabled || $[17] !== includeDescription || $[18] !== onPropertyChange || $[19] !== propertyKey) {
      t42 = (t52, index2) => {
        const [entryKey, childProperty] = t52;
        const thisDisabled = isReadOnly(childProperty) || Boolean(childProperty.disabled);
        const fieldBindingProps = {
          propertyKey: `${propertyKey}.${entryKey}`,
          disabled: disabled || thisDisabled,
          property: childProperty,
          includeDescription,
          context,
          partOfArray: false,
          minimalistView: false,
          autoFocus: autoFocus && index2 === 0,
          onPropertyChange: function(updatedProperty) {
            onPropertyChange == null ? void 0 : onPropertyChange({
              properties: {
                [entryKey]: updatedProperty
              }
            });
          }
        };
        return (0, import_jsx_runtime2.jsx)("div", { className: "relative", children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyFieldBinding, { ...fieldBindingProps }) }) }, `map-${propertyKey}-${index2}`);
      };
      $[14] = autoFocus;
      $[15] = context;
      $[16] = disabled;
      $[17] = includeDescription;
      $[18] = onPropertyChange;
      $[19] = propertyKey;
      $[20] = t42;
    } else {
      t42 = $[20];
    }
    t3 = Object.entries(mapProperties).filter(_temp$9).map(t42);
    $[6] = autoFocus;
    $[7] = context;
    $[8] = disabled;
    $[9] = includeDescription;
    $[10] = mapProperties;
    $[11] = onPropertyChange;
    $[12] = propertyKey;
    $[13] = t3;
  } else {
    t3 = $[13];
  }
  let t4;
  if ($[21] !== t2 || $[22] !== t3) {
    t4 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsx)("div", { className: t2, children: t3 }) });
    $[21] = t2;
    $[22] = t3;
    $[23] = t4;
  } else {
    t4 = $[23];
  }
  const mapFormView = t4;
  let t5;
  if ($[24] !== expanded || $[25] !== mapFormView || $[26] !== minimalistView || $[27] !== onPropertyChange || $[28] !== property || $[29] !== propertyKey) {
    t5 = !minimalistView && (0, import_jsx_runtime2.jsx)(ExpandablePanel, { initiallyExpanded: expanded, onExpandedChange: (expanded_0) => {
      onPropertyChange == null ? void 0 : onPropertyChange({
        expanded: expanded_0
      });
    }, className: property.widthPercentage !== void 0 ? "mt-8" : void 0, innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2 bg-white dark:bg-surface-900", title: (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property, "small"), required: (_a = property.validation) == null ? void 0 : _a.required, title: property.name, className: "text-text-secondary dark:text-text-secondary-dark" }), children: mapFormView });
    $[24] = expanded;
    $[25] = mapFormView;
    $[26] = minimalistView;
    $[27] = onPropertyChange;
    $[28] = property;
    $[29] = propertyKey;
    $[30] = t5;
  } else {
    t5 = $[30];
  }
  const t6 = minimalistView && mapFormView;
  const t7 = showError ?? false;
  const t8 = error2 ? typeof error2 === "string" ? error2 : "A property of this map has an error" : void 0;
  let t9;
  if ($[31] !== disabled || $[32] !== includeDescription || $[33] !== property || $[34] !== t7 || $[35] !== t8) {
    t9 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError: t7, error: t8, disabled, property });
    $[31] = disabled;
    $[32] = includeDescription;
    $[33] = property;
    $[34] = t7;
    $[35] = t8;
    $[36] = t9;
  } else {
    t9 = $[36];
  }
  let t10;
  if ($[37] !== t5 || $[38] !== t6 || $[39] !== t9) {
    t10 = (0, import_jsx_runtime2.jsxs)(ErrorBoundary2, { children: [
      t5,
      t6,
      t9
    ] });
    $[37] = t5;
    $[38] = t6;
    $[39] = t9;
    $[40] = t10;
  } else {
    t10 = $[40];
  }
  return t10;
}
function _temp$9(t0) {
  const [, property_0] = t0;
  return !isHidden(property_0);
}
function KeyValueFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(31);
  const {
    propertyKey,
    value,
    showError,
    error: error2,
    disabled,
    property,
    setValue,
    minimalistView,
    includeDescription,
    autoFocus,
    context
  } = t0;
  const expanded = (property.expanded === void 0 ? true : property.expanded) || autoFocus;
  if (!property.keyValue) {
    throw Error(`Your property ${propertyKey} needs to have the 'keyValue' prop in order to use this field binding`);
  }
  let t1;
  if ($[0] !== context.formex.initialValues || $[1] !== propertyKey) {
    t1 = getIn(context.formex.initialValues, propertyKey);
    $[0] = context.formex.initialValues;
    $[1] = propertyKey;
    $[2] = t1;
  } else {
    t1 = $[2];
  }
  const initialValues = t1;
  const t2 = property.name ?? propertyKey;
  let t3;
  if ($[3] !== disabled || $[4] !== initialValues || $[5] !== setValue || $[6] !== t2 || $[7] !== value) {
    t3 = (0, import_jsx_runtime2.jsx)(MapEditView, { value, setValue, disabled, initialValue: initialValues, fieldName: t2 });
    $[3] = disabled;
    $[4] = initialValues;
    $[5] = setValue;
    $[6] = t2;
    $[7] = value;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const mapFormView = t3;
  let t4;
  if ($[9] !== property) {
    t4 = getIconForProperty(property, "small");
    $[9] = property;
    $[10] = t4;
  } else {
    t4 = $[10];
  }
  const t5 = (_a = property.validation) == null ? void 0 : _a.required;
  let t6;
  if ($[11] !== property.name || $[12] !== propertyKey || $[13] !== t4 || $[14] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: t4, required: t5, title: property.name, className: "text-text-secondary dark:text-text-secondary-dark" });
    $[11] = property.name;
    $[12] = propertyKey;
    $[13] = t4;
    $[14] = t5;
    $[15] = t6;
  } else {
    t6 = $[15];
  }
  const title = t6;
  let t7;
  if ($[16] !== expanded || $[17] !== mapFormView || $[18] !== minimalistView || $[19] !== title) {
    t7 = !minimalistView && (0, import_jsx_runtime2.jsx)(ExpandablePanel, { initiallyExpanded: expanded, title, innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", children: mapFormView });
    $[16] = expanded;
    $[17] = mapFormView;
    $[18] = minimalistView;
    $[19] = title;
    $[20] = t7;
  } else {
    t7 = $[20];
  }
  const t8 = minimalistView && mapFormView;
  let t9;
  if ($[21] !== disabled || $[22] !== error2 || $[23] !== includeDescription || $[24] !== property || $[25] !== showError) {
    t9 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property });
    $[21] = disabled;
    $[22] = error2;
    $[23] = includeDescription;
    $[24] = property;
    $[25] = showError;
    $[26] = t9;
  } else {
    t9 = $[26];
  }
  let t10;
  if ($[27] !== t7 || $[28] !== t8 || $[29] !== t9) {
    t10 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t7,
      t8,
      t9
    ] });
    $[27] = t7;
    $[28] = t8;
    $[29] = t9;
    $[30] = t10;
  } else {
    t10 = $[30];
  }
  return t10;
}
function MapEditView({
  value,
  initialValue,
  setValue,
  fieldName,
  disabled
}) {
  const [internalState, setInternalState] = import_react14.default.useState(Object.keys(initialValue ?? {}).map((key) => [getRandomId$1(), {
    key,
    dataType: getDataType(initialValue == null ? void 0 : initialValue[key]) ?? "string"
  }]));
  (0, import_react14.useEffect)(() => {
    const currentKeys = internalState.map(([id2, {
      key: key_0
    }]) => key_0);
    const newKeys = Object.entries(value ?? {}).filter(([key_1, v]) => v !== void 0).map(([key_2]) => key_2);
    const keysToAdd = newKeys.filter((key_3) => !currentKeys.includes(key_3));
    const keysToRemove = currentKeys.filter((key_4) => !newKeys.includes(key_4));
    const newRowIds = [...internalState];
    keysToAdd.forEach((key_5) => {
      newRowIds.push([getRandomId$1(), {
        key: key_5,
        dataType: getDataType(value == null ? void 0 : value[key_5]) ?? "string"
      }]);
    });
    keysToRemove.forEach((key_6) => {
      const index2 = newRowIds.findIndex(([id_0, {
        key: k2
      }]) => k2 === key_6);
      newRowIds.splice(index2, 1);
    });
    setInternalState(newRowIds);
  }, [value]);
  const updateDataType = (rowId, dataType) => {
    var _a;
    if (!rowId) {
      console.warn("No key selected for data type update");
      return;
    }
    setInternalState(internalState.map((row) => {
      if (row[0] === rowId) {
        return [row[0], {
          key: row[1].key,
          dataType
        }];
      }
      return row;
    }));
    setValue({
      ...value ?? {},
      [((_a = internalState.find((row) => row[0] === rowId)) == null ? void 0 : _a[1].key) ?? ""]: getDefaultValueForDataType(dataType)
    });
  };
  return (0, import_jsx_runtime2.jsxs)("div", { className: "py-1 flex flex-col gap-1", children: [
    internalState.map(([rowId_0, {
      key: fieldKey,
      dataType: dataType_0
    }], index_0) => {
      const entryValue = fieldKey ? value == null ? void 0 : value[fieldKey] : "";
      const onFieldKeyChange = (newKey) => {
        setInternalState(internalState.map((currentRowId) => {
          if (currentRowId[0] === rowId_0) {
            return [rowId_0, {
              key: newKey ?? "",
              dataType: currentRowId[1].dataType
            }];
          }
          return currentRowId;
        }));
        if (typeof value === "object" && newKey in value) {
          return;
        }
        const newValue = {
          ...value ?? {}
        };
        if (typeof initialValue === "object" && fieldKey in initialValue) {
          newValue[fieldKey] = void 0;
        } else {
          delete newValue[fieldKey];
        }
        setValue({
          ...newValue,
          [newKey ?? ""]: entryValue
        });
      };
      return (0, import_jsx_runtime2.jsx)(MapKeyValueRow, { rowId: rowId_0, fieldKey, value: value ?? {}, onDeleteClick: () => {
        const newValue_0 = {
          ...value ?? {}
        };
        if (initialValue && fieldKey in initialValue) {
          newValue_0[fieldKey] = void 0;
        } else {
          delete newValue_0[fieldKey];
        }
        setInternalState(internalState.filter((currentRowId_0) => currentRowId_0[0] !== rowId_0));
        setValue({
          ...newValue_0
        });
      }, onFieldKeyChange, setValue, entryValue, dataType: dataType_0, disabled, updateDataType }, rowId_0);
    }),
    (0, import_jsx_runtime2.jsx)(Button, { variant: "text", size: "small", color: "primary", className: "w-full", disabled, startIcon: (0, import_jsx_runtime2.jsx)(AddIcon, {}), onClick: (e2) => {
      e2.preventDefault();
      setValue({
        ...value ?? {},
        "": null
      });
      setInternalState([...internalState, [getRandomId$1(), {
        key: "",
        dataType: "string"
      }]]);
    }, children: fieldName ? `Add to ${fieldName}` : "Add" })
  ] });
}
function MapKeyValueRow(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(63);
  const {
    rowId,
    fieldKey,
    value,
    onFieldKeyChange,
    onDeleteClick,
    setValue,
    entryValue,
    dataType,
    updateDataType,
    disabled
  } = t0;
  const {
    locale
  } = useCustomizationController();
  let t1;
  if ($[0] !== disabled || $[1] !== locale || $[2] !== rowId || $[3] !== setValue || $[4] !== value) {
    t1 = function buildInput2(entryValue_0, fieldKey_0, dataType_0) {
      if (dataType_0 === "string" || dataType_0 === "number") {
        return (0, import_jsx_runtime2.jsx)(TextField, { placeholder: "value", value: entryValue_0, type: dataType_0 === "number" ? "number" : "text", size: "medium", disabled: disabled || !fieldKey_0, onChange: (event) => {
          if (dataType_0 === "number") {
            const numberValue = event.target.value ? parseFloat(event.target.value) : void 0;
            if (numberValue && isNaN(numberValue)) {
              setValue({
                ...value,
                [fieldKey_0]: null
              });
            } else {
              if (numberValue !== void 0 && numberValue !== null) {
                setValue({
                  ...value,
                  [fieldKey_0]: numberValue
                });
              } else {
                setValue({
                  ...value,
                  [fieldKey_0]: null
                });
              }
            }
          } else {
            setValue({
              ...value,
              [fieldKey_0]: event.target.value
            });
          }
        } }, dataType_0);
      } else {
        if (dataType_0 === "date") {
          return (0, import_jsx_runtime2.jsx)(DateTimeField, { value: entryValue_0, size: "medium", locale, disabled: disabled || !fieldKey_0, onChange: (date2) => {
            setValue({
              ...value,
              [fieldKey_0]: date2
            });
          } });
        } else {
          if (dataType_0 === "boolean") {
            return (0, import_jsx_runtime2.jsx)(BooleanSwitchWithLabel, { value: entryValue_0, size: "medium", position: "start", disabled: disabled || !fieldKey_0, onValueChange: (newValue) => {
              setValue({
                ...value,
                [fieldKey_0]: newValue
              });
            } });
          } else {
            if (dataType_0 === "array") {
              return (0, import_jsx_runtime2.jsx)("div", { className: cls(defaultBorderMixin, "ml-2 pl-2 border-l border-solid"), children: (0, import_jsx_runtime2.jsx)(ArrayContainer, { value: entryValue_0, newDefaultEntry: "", droppableId: rowId.toString(), addLabel: fieldKey_0 ? `Add to ${fieldKey_0}` : "Add", size: "small", disabled: disabled || !fieldKey_0, canAddElements: true, onValueChange: (newValue_0) => {
                setValue({
                  ...value,
                  [fieldKey_0]: newValue_0
                });
              }, buildEntry: (t23) => {
                const {
                  index: index2,
                  internalId
                } = t23;
                return (0, import_jsx_runtime2.jsx)(ArrayKeyValueRow, { index: index2, id: internalId, value: entryValue_0[index2], disabled: disabled || !fieldKey_0, setValue: (newValue_1) => {
                  const newArrayValue = [...entryValue_0];
                  newArrayValue[index2] = newValue_1;
                  setValue({
                    ...value,
                    [fieldKey_0]: newArrayValue
                  });
                } });
              } }) });
            } else {
              if (dataType_0 === "map") {
                return (0, import_jsx_runtime2.jsx)("div", { className: cls(defaultBorderMixin, "ml-2 pl-2 border-l border-solid"), children: (0, import_jsx_runtime2.jsx)(MapEditView, { value: entryValue_0, fieldName: fieldKey_0, setValue: (updatedValue) => {
                  setValue({
                    ...value,
                    [fieldKey_0]: updatedValue
                  });
                } }) });
              } else {
                return (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", children: `Data type ${dataType_0} not supported yet` });
              }
            }
          }
        }
      }
    };
    $[0] = disabled;
    $[1] = locale;
    $[2] = rowId;
    $[3] = setValue;
    $[4] = value;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const buildInput = t1;
  let t2;
  if ($[6] !== rowId || $[7] !== updateDataType) {
    t2 = function doUpdateDataType2(dataType_1) {
      updateDataType(rowId, dataType_1);
    };
    $[6] = rowId;
    $[7] = updateDataType;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  const doUpdateDataType = t2;
  let t3;
  if ($[9] !== rowId) {
    t3 = rowId.toString();
    $[9] = rowId;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  const t4 = disabled || entryValue !== void 0 && entryValue !== null && entryValue !== "";
  let t5;
  if ($[11] !== onFieldKeyChange) {
    t5 = (event_0) => {
      onFieldKeyChange(event_0.target.value);
    };
    $[11] = onFieldKeyChange;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== fieldKey || $[14] !== t4 || $[15] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)("div", { className: "w-[300px] max-w-[30%]", children: (0, import_jsx_runtime2.jsx)(TextField, { value: fieldKey, placeholder: "key", disabled: t4, size: "medium", onChange: t5 }) });
    $[13] = fieldKey;
    $[14] = t4;
    $[15] = t5;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  let t7;
  if ($[17] !== buildInput || $[18] !== dataType || $[19] !== entryValue || $[20] !== fieldKey) {
    t7 = dataType !== "map" && dataType !== "array" && buildInput(entryValue, fieldKey, dataType);
    $[17] = buildInput;
    $[18] = dataType;
    $[19] = entryValue;
    $[20] = fieldKey;
    $[21] = t7;
  } else {
    t7 = $[21];
  }
  let t8;
  if ($[22] !== t7) {
    t8 = (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow", children: t7 });
    $[22] = t7;
    $[23] = t8;
  } else {
    t8 = $[23];
  }
  let t9;
  if ($[24] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = (0, import_jsx_runtime2.jsx)(IconButton, { size: "smallest", children: (0, import_jsx_runtime2.jsx)(ArrowDropDownIcon, { size: "small" }) });
    $[24] = t9;
  } else {
    t9 = $[24];
  }
  let t10;
  if ($[25] !== doUpdateDataType) {
    t10 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("string"), children: "string" });
    $[25] = doUpdateDataType;
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  let t11;
  if ($[27] !== doUpdateDataType) {
    t11 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("number"), children: "number" });
    $[27] = doUpdateDataType;
    $[28] = t11;
  } else {
    t11 = $[28];
  }
  let t12;
  if ($[29] !== doUpdateDataType) {
    t12 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("boolean"), children: "boolean" });
    $[29] = doUpdateDataType;
    $[30] = t12;
  } else {
    t12 = $[30];
  }
  let t13;
  if ($[31] !== doUpdateDataType) {
    t13 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("date"), children: "date" });
    $[31] = doUpdateDataType;
    $[32] = t13;
  } else {
    t13 = $[32];
  }
  let t14;
  if ($[33] !== doUpdateDataType) {
    t14 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("map"), children: "map" });
    $[33] = doUpdateDataType;
    $[34] = t14;
  } else {
    t14 = $[34];
  }
  let t15;
  if ($[35] !== doUpdateDataType) {
    t15 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("array"), children: "array" });
    $[35] = doUpdateDataType;
    $[36] = t15;
  } else {
    t15 = $[36];
  }
  let t16;
  if ($[37] !== t10 || $[38] !== t11 || $[39] !== t12 || $[40] !== t13 || $[41] !== t14 || $[42] !== t15) {
    t16 = (0, import_jsx_runtime2.jsxs)(Menu, { trigger: t9, children: [
      t10,
      t11,
      t12,
      t13,
      t14,
      t15
    ] });
    $[37] = t10;
    $[38] = t11;
    $[39] = t12;
    $[40] = t13;
    $[41] = t14;
    $[42] = t15;
    $[43] = t16;
  } else {
    t16 = $[43];
  }
  let t17;
  if ($[44] === Symbol.for("react.memo_cache_sentinel")) {
    t17 = (0, import_jsx_runtime2.jsx)(RemoveIcon, { size: "smallest" });
    $[44] = t17;
  } else {
    t17 = $[44];
  }
  let t18;
  if ($[45] !== onDeleteClick) {
    t18 = (0, import_jsx_runtime2.jsx)(IconButton, { "aria-label": "delete", size: "smallest", onClick: onDeleteClick, children: t17 });
    $[45] = onDeleteClick;
    $[46] = t18;
  } else {
    t18 = $[46];
  }
  let t19;
  if ($[47] !== t16 || $[48] !== t18) {
    t19 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-col", children: [
      t16,
      t18
    ] });
    $[47] = t16;
    $[48] = t18;
    $[49] = t19;
  } else {
    t19 = $[49];
  }
  let t20;
  if ($[50] !== t19 || $[51] !== t3 || $[52] !== t6 || $[53] !== t8) {
    t20 = (0, import_jsx_runtime2.jsxs)(Typography, { component: "div", className: "font-mono flex flex-row gap-1", children: [
      t6,
      t8,
      t19
    ] }, t3);
    $[50] = t19;
    $[51] = t3;
    $[52] = t6;
    $[53] = t8;
    $[54] = t20;
  } else {
    t20 = $[54];
  }
  let t21;
  if ($[55] !== buildInput || $[56] !== dataType || $[57] !== entryValue || $[58] !== fieldKey) {
    t21 = (dataType === "map" || dataType === "array") && buildInput(entryValue, fieldKey, dataType);
    $[55] = buildInput;
    $[56] = dataType;
    $[57] = entryValue;
    $[58] = fieldKey;
    $[59] = t21;
  } else {
    t21 = $[59];
  }
  let t22;
  if ($[60] !== t20 || $[61] !== t21) {
    t22 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t20,
      t21
    ] });
    $[60] = t20;
    $[61] = t21;
    $[62] = t22;
  } else {
    t22 = $[62];
  }
  return t22;
}
function ArrayKeyValueRow(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(30);
  const {
    id: id2,
    value,
    setValue
  } = t0;
  const {
    locale
  } = useCustomizationController();
  let t1;
  if ($[0] !== value) {
    t1 = getDataType(value) ?? "string";
    $[0] = value;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const [selectedDataType, setSelectedDataType] = (0, import_react14.useState)(t1);
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = function doUpdateDataType2(dataType) {
      setSelectedDataType(dataType);
    };
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const doUpdateDataType = t2;
  let t3;
  if ($[3] !== locale || $[4] !== setValue) {
    t3 = function buildInput2(entryValue, dataType_0) {
      if (dataType_0 === "string" || dataType_0 === "number") {
        return (0, import_jsx_runtime2.jsx)(TextField, { value: entryValue, type: dataType_0 === "number" ? "number" : "text", size: "medium", onChange: (event) => {
          if (dataType_0 === "number") {
            const numberValue = event.target.value ? parseFloat(event.target.value) : void 0;
            if (numberValue && isNaN(numberValue)) {
              setValue(null);
            } else {
              if (numberValue !== void 0 && numberValue !== null) {
                setValue(numberValue);
              } else {
                setValue(null);
              }
            }
          } else {
            setValue(event.target.value);
          }
        } });
      } else {
        if (dataType_0 === "date") {
          return (0, import_jsx_runtime2.jsx)(DateTimeField, { value: entryValue, size: "medium", locale, onChange: (date2) => {
            setValue(date2);
          } });
        } else {
          if (dataType_0 === "boolean") {
            return (0, import_jsx_runtime2.jsx)(BooleanSwitchWithLabel, { value: entryValue, size: "small", position: "start", onValueChange: (v) => {
              setValue(v);
            } });
          } else {
            if (dataType_0 === "array") {
              return (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", children: "Arrays of arrays are not supported." });
            } else {
              if (dataType_0 === "map") {
                return (0, import_jsx_runtime2.jsx)("div", { className: cls(defaultBorderMixin, "ml-2 pl-2 border-l border-solid"), children: (0, import_jsx_runtime2.jsx)(MapEditView, { value: entryValue, setValue: (updatedValue) => {
                  setValue(updatedValue);
                } }) });
              } else {
                return (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", children: `Data type ${dataType_0} not supported yet` });
              }
            }
          }
        }
      }
    };
    $[3] = locale;
    $[4] = setValue;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const buildInput = t3;
  let t4;
  if ($[6] !== id2) {
    t4 = id2.toString();
    $[6] = id2;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== buildInput || $[9] !== selectedDataType || $[10] !== value) {
    t5 = selectedDataType !== "map" && buildInput(value, selectedDataType);
    $[8] = buildInput;
    $[9] = selectedDataType;
    $[10] = value;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  let t6;
  if ($[12] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow", children: t5 });
    $[12] = t5;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  let t7;
  if ($[14] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = (0, import_jsx_runtime2.jsx)(IconButton, { size: "small", className: "h-7 w-7", children: (0, import_jsx_runtime2.jsx)(ArrowDropDownIcon, {}) });
    $[14] = t7;
  } else {
    t7 = $[14];
  }
  let t8;
  if ($[15] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("string"), children: "string" });
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("number"), children: "number" });
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  let t10;
  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("boolean"), children: "boolean" });
    $[17] = t10;
  } else {
    t10 = $[17];
  }
  let t11;
  if ($[18] === Symbol.for("react.memo_cache_sentinel")) {
    t11 = (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("map"), children: "map" });
    $[18] = t11;
  } else {
    t11 = $[18];
  }
  let t12;
  if ($[19] === Symbol.for("react.memo_cache_sentinel")) {
    t12 = (0, import_jsx_runtime2.jsxs)(Menu, { trigger: t7, children: [
      t8,
      t9,
      t10,
      t11,
      (0, import_jsx_runtime2.jsx)(MenuItem, { dense: true, onClick: () => doUpdateDataType("date"), children: "date" })
    ] });
    $[19] = t12;
  } else {
    t12 = $[19];
  }
  let t13;
  if ($[20] !== t4 || $[21] !== t6) {
    t13 = (0, import_jsx_runtime2.jsxs)(Typography, { component: "div", className: "font-mono flex min-h-12 flex-row gap-1 items-center", children: [
      t6,
      t12
    ] }, t4);
    $[20] = t4;
    $[21] = t6;
    $[22] = t13;
  } else {
    t13 = $[22];
  }
  let t14;
  if ($[23] !== buildInput || $[24] !== selectedDataType || $[25] !== value) {
    t14 = selectedDataType === "map" && buildInput(value, selectedDataType);
    $[23] = buildInput;
    $[24] = selectedDataType;
    $[25] = value;
    $[26] = t14;
  } else {
    t14 = $[26];
  }
  let t15;
  if ($[27] !== t13 || $[28] !== t14) {
    t15 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t13,
      t14
    ] });
    $[27] = t13;
    $[28] = t14;
    $[29] = t15;
  } else {
    t15 = $[29];
  }
  return t15;
}
function getRandomId$1() {
  return Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER));
}
function getDataType(value) {
  if (typeof value === "string" || value === null) {
    return "string";
  } else if (typeof value === "number") {
    return "number";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (Array.isArray(value)) {
    return "array";
  } else if (value instanceof Date) {
    return "date";
  } else if ((value == null ? void 0 : value.isEntityReference) && (value == null ? void 0 : value.isEntityReference())) {
    return "reference";
  } else if (value instanceof GeoPoint) {
    return "geopoint";
  } else if (typeof value === "object") {
    return "map";
  }
  return void 0;
}
function RepeatFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(56);
  const {
    propertyKey,
    value,
    error: error2,
    showError,
    isSubmitting,
    setValue,
    setFieldValue,
    minimalistView: minimalistViewProp,
    property,
    includeDescription,
    underlyingValueHasChanged,
    context,
    disabled
  } = t0;
  const authController = useAuthController();
  const minimalistView = minimalistViewProp || property.minimalistView;
  if (!property.of) {
    throw Error("RepeatFieldBinding misconfiguration. Property `of` not set");
  }
  let resolvedProperties;
  resolvedProperties = "resolvedProperties" in property ? property.resolvedProperties : void 0;
  if (!resolvedProperties) {
    resolvedProperties = getArrayResolvedProperties({
      propertyValue: value,
      propertyKey,
      property,
      ignoreMissingFields: false,
      authController
    });
  }
  const expanded = property.expanded === void 0 ? true : property.expanded;
  const ofProperty = property.of;
  const [lastAddedId, setLastAddedId] = (0, import_react14.useState)();
  let t1;
  if ($[0] !== property || $[1] !== setValue || $[2] !== value) {
    t1 = {
      property,
      value,
      setValue
    };
    $[0] = property;
    $[1] = setValue;
    $[2] = value;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  useClearRestoreValue(t1);
  let t2;
  if ($[4] !== context || $[5] !== disabled || $[6] !== includeDescription || $[7] !== lastAddedId || $[8] !== ofProperty || $[9] !== propertyKey || $[10] !== resolvedProperties || $[11] !== underlyingValueHasChanged) {
    t2 = (t32) => {
      const {
        index: index2,
        internalId,
        storedProps,
        storeProps
      } = t32;
      const childProperty = resolvedProperties[index2] ?? ofProperty;
      const fieldProps = {
        propertyKey: `${propertyKey}.${index2}`,
        disabled,
        property: storedProps ? mergeDeep2(childProperty, storedProps) : childProperty,
        onPropertyChange: storeProps,
        includeDescription,
        underlyingValueHasChanged,
        context,
        partOfArray: true,
        minimalistView: false,
        autoFocus: internalId === lastAddedId
      };
      return (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(PropertyFieldBinding, { ...fieldProps, index: index2 }) });
    };
    $[4] = context;
    $[5] = disabled;
    $[6] = includeDescription;
    $[7] = lastAddedId;
    $[8] = ofProperty;
    $[9] = propertyKey;
    $[10] = resolvedProperties;
    $[11] = underlyingValueHasChanged;
    $[12] = t2;
  } else {
    t2 = $[12];
  }
  const buildEntry = t2;
  const canAddElements = !property.disabled && !isSubmitting && !disabled && (property.canAddElements || property.canAddElements === void 0);
  const sortable = property.sortable === void 0 ? true : property.sortable;
  const t3 = property.name ? "Add entry to " + property.name : "Add entry";
  const t4 = isSubmitting || Boolean(property.disabled);
  let t5;
  if ($[13] !== property.of) {
    t5 = getDefaultValueFor(property.of);
    $[13] = property.of;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  let t6;
  if ($[15] !== propertyKey || $[16] !== setFieldValue) {
    t6 = (value_0) => setFieldValue(propertyKey, value_0);
    $[15] = propertyKey;
    $[16] = setFieldValue;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  const t7 = property.widthPercentage !== void 0 ? "mt-8" : void 0;
  let t8;
  if ($[18] !== buildEntry || $[19] !== canAddElements || $[20] !== propertyKey || $[21] !== sortable || $[22] !== t3 || $[23] !== t4 || $[24] !== t5 || $[25] !== t6 || $[26] !== t7 || $[27] !== value) {
    t8 = (0, import_jsx_runtime2.jsx)(ArrayContainer, { droppableId: propertyKey, addLabel: t3, value, buildEntry, onInternalIdAdded: setLastAddedId, disabled: t4, canAddElements, sortable, newDefaultEntry: t5, onValueChange: t6, className: t7 });
    $[18] = buildEntry;
    $[19] = canAddElements;
    $[20] = propertyKey;
    $[21] = sortable;
    $[22] = t3;
    $[23] = t4;
    $[24] = t5;
    $[25] = t6;
    $[26] = t7;
    $[27] = value;
    $[28] = t8;
  } else {
    t8 = $[28];
  }
  const arrayContainer = t8;
  let t9;
  if ($[29] !== property) {
    t9 = getIconForProperty(property, "small");
    $[29] = property;
    $[30] = t9;
  } else {
    t9 = $[30];
  }
  const t10 = (_a = property.validation) == null ? void 0 : _a.required;
  let t11;
  if ($[31] !== property.name || $[32] !== propertyKey || $[33] !== t10 || $[34] !== t9) {
    t11 = (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: t9, required: t10, title: property.name, className: "h-8 flex flex-grow text-text-secondary dark:text-text-secondary-dark" });
    $[31] = property.name;
    $[32] = propertyKey;
    $[33] = t10;
    $[34] = t9;
    $[35] = t11;
  } else {
    t11 = $[35];
  }
  let t12;
  if ($[36] !== value) {
    t12 = Array.isArray(value) && (0, import_jsx_runtime2.jsxs)(Typography, { variant: "caption", className: "px-4", children: [
      "(",
      value.length,
      ")"
    ] });
    $[36] = value;
    $[37] = t12;
  } else {
    t12 = $[37];
  }
  let t13;
  if ($[38] !== t11 || $[39] !== t12) {
    t13 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t11,
      t12
    ] });
    $[38] = t11;
    $[39] = t12;
    $[40] = t13;
  } else {
    t13 = $[40];
  }
  const title = t13;
  let t14;
  if ($[41] !== arrayContainer || $[42] !== expanded || $[43] !== minimalistView || $[44] !== title) {
    t14 = !minimalistView && (0, import_jsx_runtime2.jsx)(ExpandablePanel, { initiallyExpanded: expanded, innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", title, children: arrayContainer });
    $[41] = arrayContainer;
    $[42] = expanded;
    $[43] = minimalistView;
    $[44] = title;
    $[45] = t14;
  } else {
    t14 = $[45];
  }
  const t15 = minimalistView && arrayContainer;
  const t16 = error2 ? typeof error2 === "string" ? error2 : "A property of this array/repeat has an error" : void 0;
  let t17;
  if ($[46] !== disabled || $[47] !== includeDescription || $[48] !== property || $[49] !== showError || $[50] !== t16) {
    t17 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: t16, disabled, property });
    $[46] = disabled;
    $[47] = includeDescription;
    $[48] = property;
    $[49] = showError;
    $[50] = t16;
    $[51] = t17;
  } else {
    t17 = $[51];
  }
  let t18;
  if ($[52] !== t14 || $[53] !== t15 || $[54] !== t17) {
    t18 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t14,
      t15,
      t17
    ] });
    $[52] = t14;
    $[53] = t15;
    $[54] = t17;
    $[55] = t18;
  } else {
    t18 = $[55];
  }
  return t18;
}
function BlockFieldBinding({
  propertyKey,
  value,
  error: error2,
  showError,
  isSubmitting,
  setValue,
  setFieldValue,
  minimalistView: minimalistViewProp,
  property,
  includeDescription,
  underlyingValueHasChanged,
  context,
  disabled
}) {
  var _a;
  const minimalistView = minimalistViewProp || property.minimalistView;
  if (!property.oneOf) throw Error("ArrayOneOfField misconfiguration. Property `oneOf` not set");
  const expanded = property.expanded === void 0 ? true : property.expanded;
  useClearRestoreValue({
    property,
    value,
    setValue
  });
  const [lastAddedId, setLastAddedId] = (0, import_react14.useState)();
  const buildEntry = ({
    index: index2,
    internalId,
    storedProps,
    storeProps
  }) => {
    return (0, import_jsx_runtime2.jsx)(BlockEntry, { name: `${propertyKey}.${index2}`, index: index2, value: value[index2], typeField: property.oneOf.typeField ?? DEFAULT_ONE_OF_TYPE, valueField: property.oneOf.valueField ?? DEFAULT_ONE_OF_VALUE, properties: property.oneOf.properties, autoFocus: internalId === lastAddedId, context, storeProps, storedProps }, `array_one_of_${internalId}`);
  };
  const title = (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property, "small"), required: (_a = property.validation) == null ? void 0 : _a.required, title: property.name, className: "text-text-secondary dark:text-text-secondary-dark" });
  const firstOneOfKey = Object.keys(property.oneOf.properties)[0];
  const body = (0, import_jsx_runtime2.jsx)(ArrayContainer, { value, className: "flex flex-col gap-3", droppableId: propertyKey, addLabel: property.name ? "Add entry to " + property.name : "Add entry", buildEntry, onInternalIdAdded: setLastAddedId, disabled: isSubmitting || Boolean(property.disabled), canAddElements: !property.disabled, onValueChange: (value_0) => setFieldValue(propertyKey, value_0), newDefaultEntry: {
    [property.oneOf.typeField ?? DEFAULT_ONE_OF_TYPE]: firstOneOfKey,
    [property.oneOf.valueField ?? DEFAULT_ONE_OF_VALUE]: getDefaultValueFor(property.oneOf.properties[firstOneOfKey])
  } });
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    !minimalistView && (0, import_jsx_runtime2.jsx)(ExpandablePanel, { innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", initiallyExpanded: expanded, title, children: body }),
    minimalistView && body,
    (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property })
  ] });
}
function BlockEntry(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(31);
  const {
    name,
    value,
    typeField,
    valueField,
    properties,
    autoFocus,
    context,
    storedProps,
    storeProps
  } = t0;
  const type = value && value[typeField];
  const [typeInternal, setTypeInternal] = (0, import_react14.useState)(type ?? void 0);
  const formex = useFormex();
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  (0, import_react14.useEffect)(() => {
    if (!type) {
      updateType(Object.keys(properties)[0]);
    }
  }, t1);
  let t2;
  if ($[1] !== type || $[2] !== typeInternal) {
    t2 = () => {
      if (type !== typeInternal) {
        setTypeInternal(type);
      }
    };
    $[1] = type;
    $[2] = typeInternal;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== type) {
    t3 = [type];
    $[4] = type;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  (0, import_react14.useEffect)(t2, t3);
  const propertyInternal = typeInternal ? properties[typeInternal] : void 0;
  let t4;
  if ($[6] !== propertyInternal || $[7] !== storedProps) {
    t4 = storedProps && typeof propertyInternal === "object" ? mergeDeep2(propertyInternal, storedProps) : propertyInternal;
    $[6] = propertyInternal;
    $[7] = storedProps;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const property = t4;
  let t5;
  if ($[9] !== properties) {
    t5 = Object.entries(properties).map(_temp$8);
    $[9] = properties;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  const enumValuesConfigs = t5;
  const typeFieldName = `${name}.${typeField}`;
  const valueFieldName = `${name}.${valueField}`;
  let t6;
  if ($[11] !== autoFocus || $[12] !== context || $[13] !== property || $[14] !== storeProps || $[15] !== valueFieldName) {
    t6 = property ? {
      propertyKey: valueFieldName,
      property,
      context,
      autoFocus,
      partOfArray: false,
      minimalistView: true,
      onPropertyChange: storeProps
    } : void 0;
    $[11] = autoFocus;
    $[12] = context;
    $[13] = property;
    $[14] = storeProps;
    $[15] = valueFieldName;
    $[16] = t6;
  } else {
    t6 = $[16];
  }
  const fieldProps = t6;
  const updateType = (newType) => {
    const newSelectedProperty = newType ? properties[newType] : void 0;
    setTypeInternal(newType);
    formex.setFieldTouched(typeFieldName, true);
    formex.setFieldValue(typeFieldName, newType);
    formex.setFieldValue(valueFieldName, newSelectedProperty ? getDefaultValueFor(newSelectedProperty) : null);
  };
  let t7;
  if ($[17] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = cls(paperMixin, "bg-transparent p-2");
    $[17] = t7;
  } else {
    t7 = $[17];
  }
  let t8;
  if ($[18] !== enumValuesConfigs || $[19] !== updateType) {
    t8 = (fieldProps_0) => {
      const value1 = fieldProps_0.field.value !== void 0 && fieldProps_0.field.value !== null ? fieldProps_0.field.value : "";
      return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsx)(Select, { className: "mb-2", placeholder: (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", className: "px-4 py-2 font-medium", children: "Type" }), size: "medium", fullWidth: true, position: "item-aligned", value: value1, renderValue: (enumKey) => (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey, enumValues: enumValuesConfigs, size: "small" }), onValueChange: (value_0) => {
        updateType(value_0);
      }, children: enumValuesConfigs.map((enumConfig) => (0, import_jsx_runtime2.jsx)(SelectItem, { value: String(enumConfig.id), children: (0, import_jsx_runtime2.jsx)(EnumValuesChip, { enumKey: enumConfig.id, enumValues: enumValuesConfigs, size: "small" }) }, enumConfig.id)) }) });
    };
    $[18] = enumValuesConfigs;
    $[19] = updateType;
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  let t9;
  if ($[21] !== t8 || $[22] !== typeFieldName) {
    t9 = (0, import_jsx_runtime2.jsx)(Field, { name: typeFieldName, children: t8 });
    $[21] = t8;
    $[22] = typeFieldName;
    $[23] = t9;
  } else {
    t9 = $[23];
  }
  let t10;
  if ($[24] !== fieldProps || $[25] !== name || $[26] !== typeInternal) {
    t10 = fieldProps && (0, import_jsx_runtime2.jsx)(PropertyFieldBinding, { ...fieldProps }, `form_control_${name}_${typeInternal}`);
    $[24] = fieldProps;
    $[25] = name;
    $[26] = typeInternal;
    $[27] = t10;
  } else {
    t10 = $[27];
  }
  let t11;
  if ($[28] !== t10 || $[29] !== t9) {
    t11 = (0, import_jsx_runtime2.jsxs)("div", { className: t7, children: [
      t9,
      t10
    ] });
    $[28] = t10;
    $[29] = t9;
    $[30] = t11;
  } else {
    t11 = $[30];
  }
  return t11;
}
function _temp$8(t0) {
  const [key, property_0] = t0;
  return {
    id: key,
    label: property_0.name ?? key
  };
}
function MarkdownEditorFieldBinding({
  property,
  propertyKey,
  value,
  setValue,
  includeDescription,
  showError,
  error: error2,
  minimalistView,
  disabled: disabledProp,
  isSubmitting,
  context,
  customProps
}) {
  var _a;
  const authController = useAuthController();
  const disabled = disabledProp || isSubmitting;
  const highlight = customProps == null ? void 0 : customProps.highlight;
  const editorProps = customProps == null ? void 0 : customProps.editorProps;
  const storageSource = useStorageSource();
  const storage = property.storage;
  const entityValues = context.values;
  const entityId = context.entityId;
  const path = context.path;
  const [fieldVersion, setFieldVersion] = (0, import_react14.useState)(0);
  const internalValue = (0, import_react14.useRef)(value);
  const onContentChange = (0, import_react14.useCallback)((content) => {
    internalValue.current = content;
    setValue(content);
  }, [setValue]);
  (0, import_react14.useEffect)(() => {
    if (internalValue.current !== value) {
      internalValue.current = value;
      setFieldVersion(fieldVersion + 1);
    }
  }, [value]);
  const resolvedProperty = resolveProperty({
    propertyOrBuilder: property,
    values: entityValues,
    authController
  });
  const fileNameBuilder = (0, import_react14.useCallback)(async (file) => {
    if (storage == null ? void 0 : storage.fileName) {
      const fileName = await resolveStorageFilenameString({
        input: storage.fileName,
        storage,
        values: entityValues,
        entityId,
        path,
        property: resolvedProperty,
        file,
        propertyKey
      });
      if (!fileName || fileName.length === 0) {
        throw Error("You need to return a valid filename");
      }
      return fileName;
    }
    return randomString2() + "_" + file.name;
  }, [entityId, entityValues, path, resolvedProperty, propertyKey, storage]);
  const storagePathBuilder = (0, import_react14.useCallback)((file_0) => {
    if (!storage) return "/";
    const resolvedProperty_0 = resolveProperty({
      propertyOrBuilder: property,
      values: entityValues,
      authController
    });
    return resolveStoragePathString({
      input: storage.storagePath,
      storage,
      values: entityValues,
      entityId,
      path,
      property: resolvedProperty_0,
      file: file_0,
      propertyKey
    }) ?? "/";
  }, [entityId, entityValues, path, property, propertyKey, storage]);
  const editor = (0, import_jsx_runtime2.jsx)(FireCMSEditor, { content: value, onMarkdownContentChange: onContentChange, version: context.formex.version + fieldVersion, highlight, disabled, handleImageUpload: async (file_1) => {
    const storagePath = storagePathBuilder(file_1);
    const fileName_0 = await fileNameBuilder(file_1);
    const result = await storageSource.uploadFile({
      file: file_1,
      fileName: fileName_0,
      path: storagePath
    });
    const downloadConfig = await storageSource.getDownloadURL(result.path);
    const url = downloadConfig.url;
    if (!url) {
      throw new Error("Error uploading image");
    }
    return url;
  }, ...editorProps });
  if (minimalistView) return editor;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: getIconForProperty(property, "small"), required: (_a = property.validation) == null ? void 0 : _a.required, title: property.name, className: "h-8 text-text-secondary dark:text-text-secondary-dark ml-3.5" }),
    (0, import_jsx_runtime2.jsx)("div", { className: cls("rounded-md", fieldBackgroundMixin, disabled ? fieldBackgroundDisabledMixin : fieldBackgroundHoverMixin), children: editor }),
    (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, property })
  ] });
}
function ArrayCustomShapedFieldBinding(t0) {
  var _a;
  const $ = (0, import_react_compiler_runtime3.c)(47);
  const {
    propertyKey,
    value,
    error: error2,
    showError,
    setValue,
    minimalistView: minimalistViewProp,
    property,
    includeDescription,
    context,
    disabled
  } = t0;
  const authController = useAuthController();
  const minimalistView = minimalistViewProp || property.minimalistView;
  let resolvedProperties = "resolvedProperties" in property ? property.resolvedProperties : void 0;
  if (!resolvedProperties) {
    let t12;
    if ($[0] !== authController || $[1] !== property || $[2] !== propertyKey || $[3] !== value) {
      t12 = getArrayResolvedProperties({
        propertyValue: value,
        propertyKey,
        property,
        ignoreMissingFields: false,
        authController
      });
      $[0] = authController;
      $[1] = property;
      $[2] = propertyKey;
      $[3] = value;
      $[4] = t12;
    } else {
      t12 = $[4];
    }
    resolvedProperties = t12;
  }
  const expanded = property.expanded === void 0 ? true : property.expanded;
  let t1;
  if ($[5] !== property || $[6] !== setValue || $[7] !== value) {
    t1 = {
      property,
      value,
      setValue
    };
    $[5] = property;
    $[6] = setValue;
    $[7] = value;
    $[8] = t1;
  } else {
    t1 = $[8];
  }
  useClearRestoreValue(t1);
  let t2;
  if ($[9] !== property) {
    t2 = getIconForProperty(property, "small");
    $[9] = property;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const t3 = (_a = property.validation) == null ? void 0 : _a.required;
  let t4;
  if ($[11] !== property.name || $[12] !== propertyKey || $[13] !== t2 || $[14] !== t3) {
    t4 = (0, import_jsx_runtime2.jsx)(LabelWithIconAndTooltip, { propertyKey, icon: t2, required: t3, title: property.name, className: "h-8 flex-grow text-text-secondary dark:text-text-secondary-dark" });
    $[11] = property.name;
    $[12] = propertyKey;
    $[13] = t2;
    $[14] = t3;
    $[15] = t4;
  } else {
    t4 = $[15];
  }
  let t5;
  if ($[16] !== value) {
    t5 = Array.isArray(value) && (0, import_jsx_runtime2.jsxs)(Typography, { variant: "caption", className: "px-4", children: [
      "(",
      value.length,
      ")"
    ] });
    $[16] = value;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  let t6;
  if ($[18] !== t4 || $[19] !== t5) {
    t6 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t4,
      t5
    ] });
    $[18] = t4;
    $[19] = t5;
    $[20] = t6;
  } else {
    t6 = $[20];
  }
  const title = t6;
  let t7;
  if ($[21] !== context || $[22] !== disabled || $[23] !== includeDescription || $[24] !== propertyKey || $[25] !== resolvedProperties) {
    let t82;
    if ($[27] !== context || $[28] !== disabled || $[29] !== includeDescription || $[30] !== propertyKey) {
      t82 = (childProperty, index2) => {
        const thisDisabled = isReadOnly(childProperty) || Boolean(childProperty.disabled);
        const fieldProps = {
          propertyKey: `${propertyKey}[${index2}]`,
          disabled: disabled || thisDisabled,
          property: childProperty,
          includeDescription,
          context,
          partOfArray: true,
          minimalistView: false,
          autoFocus: false
        };
        return (0, import_jsx_runtime2.jsx)("div", { className: "pb-4", children: (0, import_jsx_runtime2.jsx)(PropertyFieldBinding, { ...fieldProps }) }, `custom_shaped_array_${index2}`);
      };
      $[27] = context;
      $[28] = disabled;
      $[29] = includeDescription;
      $[30] = propertyKey;
      $[31] = t82;
    } else {
      t82 = $[31];
    }
    t7 = resolvedProperties.map(t82);
    $[21] = context;
    $[22] = disabled;
    $[23] = includeDescription;
    $[24] = propertyKey;
    $[25] = resolvedProperties;
    $[26] = t7;
  } else {
    t7 = $[26];
  }
  const body = t7;
  let t8;
  if ($[32] !== body || $[33] !== expanded || $[34] !== minimalistView || $[35] !== title) {
    t8 = !minimalistView && (0, import_jsx_runtime2.jsx)(ExpandablePanel, { initiallyExpanded: expanded, title, innerClassName: "px-2 md:px-4 pb-2 md:pb-4 pt-1 md:pt-2", children: body });
    $[32] = body;
    $[33] = expanded;
    $[34] = minimalistView;
    $[35] = title;
    $[36] = t8;
  } else {
    t8 = $[36];
  }
  const t9 = minimalistView && body;
  let t10;
  if ($[37] !== disabled || $[38] !== error2 || $[39] !== includeDescription || $[40] !== property || $[41] !== showError) {
    t10 = (0, import_jsx_runtime2.jsx)(FieldHelperText, { includeDescription, showError, error: error2, disabled, property });
    $[37] = disabled;
    $[38] = error2;
    $[39] = includeDescription;
    $[40] = property;
    $[41] = showError;
    $[42] = t10;
  } else {
    t10 = $[42];
  }
  let t11;
  if ($[43] !== t10 || $[44] !== t8 || $[45] !== t9) {
    t11 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t8,
      t9,
      t10
    ] });
    $[43] = t10;
    $[44] = t8;
    $[45] = t9;
    $[46] = t11;
  } else {
    t11 = $[46];
  }
  return t11;
}
function PopupFormField(props) {
  const $ = (0, import_react_compiler_runtime3.c)(2);
  if (!props.open) {
    return null;
  }
  let t0;
  if ($[0] !== props) {
    t0 = (0, import_jsx_runtime2.jsx)(PopupFormFieldLoading, { ...props });
    $[0] = props;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  return t0;
}
function PopupFormFieldLoading(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(23);
  const {
    tableKey,
    entityId,
    customFieldValidator,
    propertyKey,
    collection: inputCollection,
    path,
    cellRect,
    open,
    onClose,
    onCellValueChange,
    container
  } = t0;
  const dataSource = useDataSource();
  const [entity, setEntity] = (0, import_react14.useState)(void 0);
  let t1;
  if ($[0] !== dataSource || $[1] !== entityId || $[2] !== inputCollection || $[3] !== path) {
    t1 = () => {
      if (entityId && inputCollection) {
        dataSource.fetchEntity({
          path,
          entityId,
          collection: inputCollection
        }).then(setEntity);
      }
    };
    $[0] = dataSource;
    $[1] = entityId;
    $[2] = inputCollection;
    $[3] = path;
    $[4] = t1;
  } else {
    t1 = $[4];
  }
  let t2;
  if ($[5] !== entityId || $[6] !== inputCollection) {
    t2 = [entityId, inputCollection];
    $[5] = entityId;
    $[6] = inputCollection;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  (0, import_react14.useEffect)(t1, t2);
  if (!entity) {
    return null;
  }
  let t3;
  if ($[8] !== cellRect || $[9] !== container || $[10] !== customFieldValidator || $[11] !== entityId || $[12] !== inputCollection || $[13] !== onCellValueChange || $[14] !== onClose || $[15] !== open || $[16] !== path || $[17] !== propertyKey || $[18] !== tableKey) {
    t3 = {
      tableKey,
      entityId,
      customFieldValidator,
      propertyKey,
      collection: inputCollection,
      path,
      cellRect,
      open,
      onClose,
      onCellValueChange,
      container
    };
    $[8] = cellRect;
    $[9] = container;
    $[10] = customFieldValidator;
    $[11] = entityId;
    $[12] = inputCollection;
    $[13] = onCellValueChange;
    $[14] = onClose;
    $[15] = open;
    $[16] = path;
    $[17] = propertyKey;
    $[18] = tableKey;
    $[19] = t3;
  } else {
    t3 = $[19];
  }
  let t4;
  if ($[20] !== entity || $[21] !== t3) {
    t4 = (0, import_jsx_runtime2.jsx)(PopupFormFieldInternal, { ...t3, entity });
    $[20] = entity;
    $[21] = t3;
    $[22] = t4;
  } else {
    t4 = $[22];
  }
  return t4;
}
function PopupFormFieldInternal({
  tableKey,
  entityId,
  customFieldValidator,
  propertyKey,
  collection: inputCollection,
  path,
  cellRect,
  open,
  onClose,
  onCellValueChange,
  container,
  entity
}) {
  const fireCMSContext = useFireCMSContext();
  const authController = useAuthController();
  const customizationController = useCustomizationController();
  const [savingError, setSavingError] = import_react14.default.useState();
  const [popupLocation, setPopupLocation] = (0, import_react14.useState)();
  const collection = inputCollection ? resolveCollection({
    collection: inputCollection,
    path,
    values: entity == null ? void 0 : entity.values,
    entityId,
    propertyConfigs: customizationController.propertyConfigs,
    authController
  }) : void 0;
  const windowSize = useWindowSize();
  const draggableRef = import_react14.default.useRef(null);
  const innerRef = import_react14.default.useRef(null);
  const initialPositionSet = import_react14.default.useRef(false);
  const getInitialLocation = (0, import_react14.useCallback)(() => {
    if (!cellRect) throw Error("getInitialLocation error");
    return {
      x: cellRect.left < windowSize.width - cellRect.right ? cellRect.x + cellRect.width / 2 : cellRect.x - cellRect.width / 2,
      y: cellRect.top < windowSize.height - cellRect.bottom ? cellRect.y + cellRect.height / 2 : cellRect.y - cellRect.height / 2
    };
  }, [cellRect, windowSize.height, windowSize.width]);
  const normalizePosition = (0, import_react14.useCallback)(({
    x,
    y
  }) => {
    var _a;
    const draggableBoundingRect = (_a = draggableRef.current) == null ? void 0 : _a.getBoundingClientRect();
    if (!draggableBoundingRect) throw Error("normalizePosition called before draggableBoundingRect is set");
    return {
      x: Math.max(0, Math.min(x, windowSize.width - draggableBoundingRect.width)),
      y: Math.max(0, Math.min(y, windowSize.height - draggableBoundingRect.height))
    };
  }, [windowSize]);
  const updatePopupLocation = (0, import_react14.useCallback)((position2) => {
    var _a;
    const draggableBoundingRect_0 = (_a = draggableRef.current) == null ? void 0 : _a.getBoundingClientRect();
    if (!cellRect || !draggableBoundingRect_0) return;
    const newPosition = position2 ?? normalizePosition(getInitialLocation());
    if (!popupLocation || newPosition.x !== popupLocation.x || newPosition.y !== popupLocation.y) setPopupLocation(newPosition);
  }, [cellRect, getInitialLocation, normalizePosition, popupLocation]);
  useDraggable({
    containerRef: draggableRef,
    innerRef,
    x: popupLocation == null ? void 0 : popupLocation.x,
    y: popupLocation == null ? void 0 : popupLocation.y,
    onMove: updatePopupLocation
  });
  (0, import_react14.useEffect)(() => {
    initialPositionSet.current = false;
  }, [propertyKey, entity]);
  (0, import_react14.useLayoutEffect)(() => {
    var _a;
    const draggableBoundingRect_1 = (_a = draggableRef.current) == null ? void 0 : _a.getBoundingClientRect();
    if (!cellRect || !draggableBoundingRect_1 || initialPositionSet.current) return;
    updatePopupLocation();
    initialPositionSet.current = true;
  }, [cellRect, updatePopupLocation, initialPositionSet.current]);
  (0, import_react14.useLayoutEffect)(() => {
    updatePopupLocation(popupLocation);
  }, [windowSize, cellRect]);
  const validationSchema = (0, import_react14.useMemo)(() => {
    if (!collection || !entityId) return;
    return getYupEntitySchema(entityId, propertyKey && collection.properties[propertyKey] ? {
      [propertyKey]: collection.properties[propertyKey]
    } : {}, customFieldValidator);
  }, [collection, entityId, propertyKey, customFieldValidator]);
  const adaptResize = (0, import_react14.useCallback)(() => {
    return updatePopupLocation(popupLocation);
  }, [popupLocation, updatePopupLocation]);
  const saveValue = async (values) => {
    setSavingError(null);
    if (inputCollection && entity && onCellValueChange && propertyKey) {
      return onCellValueChange({
        value: values[propertyKey],
        propertyKey,
        data: entity,
        setError: setSavingError,
        onValueUpdated: () => {
        }
      });
    }
    return Promise.resolve();
  };
  const formex = useCreateFormex({
    initialValues: (entity == null ? void 0 : entity.values) ?? {},
    validation: (values_0) => {
      return validationSchema == null ? void 0 : validationSchema.validate(values_0, {
        abortEarly: false
      }).then(() => ({})).catch(yupToFormErrors);
    },
    validateOnInitialRender: true,
    onSubmit: (values_1, actions) => {
      saveValue(values_1).then(() => {
        formex.resetForm({
          values: values_1
        });
        onClose();
      }).finally(() => actions.setSubmitting(false));
    }
  });
  const {
    values: values_2,
    isSubmitting,
    setFieldValue,
    handleSubmit
  } = formex;
  const disabled = isSubmitting;
  const formContext = {
    collection,
    entityId,
    values: values_2,
    path,
    setFieldValue,
    save: saveValue,
    formex,
    status: "existing",
    openEntityMode: "side_panel",
    disabled: false
  };
  const property = propertyKey && getPropertyInPath((collection == null ? void 0 : collection.properties) ?? {}, propertyKey);
  const fieldProps = propertyKey && property ? {
    propertyKey,
    disabled: isSubmitting || isReadOnly(property) || !!property.disabled,
    property,
    includeDescription: false,
    underlyingValueHasChanged: false,
    context: formContext,
    partOfArray: false,
    minimalistView: false,
    autoFocus: open
  } : void 0;
  let internalForm = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsx)("div", { className: "w-[700px] max-w-full max-h-[85vh]", children: (0, import_jsx_runtime2.jsxs)("form", { onSubmit: handleSubmit, noValidate: true, children: [
    (0, import_jsx_runtime2.jsx)("div", { className: "mb-1 p-4 flex flex-col relative", children: (0, import_jsx_runtime2.jsx)("div", { ref: innerRef, className: "cursor-auto", style: {
      cursor: "auto !important"
    }, children: fieldProps && (0, import_jsx_runtime2.jsx)(PropertyFieldBinding, { ...fieldProps }) }) }),
    (0, import_jsx_runtime2.jsx)(DialogActions, { children: (0, import_jsx_runtime2.jsx)(Button, { variant: "filled", color: "primary", type: "submit", disabled, children: "Save" }) })
  ] }) }, `popup_form_${tableKey}_${entityId}_${propertyKey}`) });
  const plugins = customizationController.plugins;
  if (plugins) {
    plugins.forEach((plugin) => {
      var _a;
      if ((_a = plugin.form) == null ? void 0 : _a.provider) {
        internalForm = (0, import_jsx_runtime2.jsx)(plugin.form.provider.Component, { status: "existing", path, collection, entity, context: fireCMSContext, currentEntityId: entityId, formContext, ...plugin.form.provider.props, children: internalForm });
      }
    });
  }
  const form = (0, import_jsx_runtime2.jsxs)("div", { className: `text-surface-900 dark:text-white overflow-auto rounded rounded-md bg-white dark:bg-surface-950 ${!open ? "hidden" : ""} cursor-grab max-w-[100vw]`, children: [
    internalForm,
    savingError && (0, import_jsx_runtime2.jsx)(Typography, { color: "error", children: savingError.message })
  ] });
  const draggable2 = (0, import_jsx_runtime2.jsxs)("div", { style: {
    boxShadow: "0 0 0 2px rgba(128,128,128,0.2)"
  }, className: `inline-block fixed z-20 shadow-outline rounded-md bg-white dark:bg-surface-950 ${!open ? "invisible" : "visible"} cursor-grab overflow-visible`, ref: draggableRef, children: [
    (0, import_jsx_runtime2.jsx)(ElementResizeListener, { onResize: adaptResize }),
    (0, import_jsx_runtime2.jsxs)("div", { className: "overflow-hidden", children: [
      form,
      (0, import_jsx_runtime2.jsx)("div", { className: "absolute -top-3.5 -right-3.5 bg-surface-500 rounded-full", style: {
        width: "32px",
        height: "32px"
      }, children: (0, import_jsx_runtime2.jsx)(IconButton, { size: "small", onClick: (event) => {
        event.stopPropagation();
        onClose();
      }, children: (0, import_jsx_runtime2.jsx)(CloseIcon, { className: "text-white", size: "small" }) }) })
    ] })
  ] }, `draggable_${propertyKey}_${entityId}_${open}`);
  return (0, import_jsx_runtime2.jsx)(Root, { asChild: true, container, children: (0, import_jsx_runtime2.jsx)(Formex, { value: formex, children: draggable2 }) });
}
function ClearFilterSortButton(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    tableController,
    enabled
  } = t0;
  if (!enabled) {
    return null;
  }
  const filterIsSet = !!tableController.filterValues && Object.keys(tableController.filterValues).length > 0;
  const sortIsSet = !!tableController.sortBy && tableController.sortBy.length > 0;
  if ((filterIsSet || sortIsSet) && (tableController.clearFilter || tableController.setSortBy)) {
    let label;
    if (filterIsSet && sortIsSet) {
      label = "Clear filter and sort";
    } else {
      if (filterIsSet) {
        label = "Clear filter";
      } else {
        label = "Clear sort";
      }
    }
    let t1;
    if ($[0] !== tableController) {
      t1 = () => {
        var _a, _b;
        (_a = tableController.clearFilter) == null ? void 0 : _a.call(tableController);
        (_b = tableController.setSortBy) == null ? void 0 : _b.call(tableController, void 0);
      };
      $[0] = tableController;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    let t2;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = (0, import_jsx_runtime2.jsx)(FilterListOffIcon, {});
      $[2] = t2;
    } else {
      t2 = $[2];
    }
    let t3;
    if ($[3] !== label || $[4] !== t1) {
      t3 = (0, import_jsx_runtime2.jsxs)(Button, { variant: "outlined", className: "h-fit-content", "aria-label": "filter clear", onClick: t1, size: "small", children: [
        t2,
        label
      ] });
      $[3] = label;
      $[4] = t1;
      $[5] = t3;
    } else {
      t3 = $[5];
    }
    return t3;
  }
  return null;
}
function EntityCollectionViewStartActions(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(18);
  const {
    collection,
    relativePath,
    parentCollectionIds,
    path,
    selectionController,
    tableController,
    collectionEntitiesCount
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  let t1;
  if ($[0] !== customizationController.plugins) {
    t1 = customizationController.plugins ?? [];
    $[0] = customizationController.plugins;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const plugins = t1;
  let t2;
  if ($[2] !== collection || $[3] !== collectionEntitiesCount || $[4] !== context || $[5] !== parentCollectionIds || $[6] !== path || $[7] !== relativePath || $[8] !== selectionController || $[9] !== tableController) {
    t2 = {
      path,
      relativePath,
      parentCollectionIds,
      collection,
      selectionController,
      context,
      tableController,
      collectionEntitiesCount
    };
    $[2] = collection;
    $[3] = collectionEntitiesCount;
    $[4] = context;
    $[5] = parentCollectionIds;
    $[6] = path;
    $[7] = relativePath;
    $[8] = selectionController;
    $[9] = tableController;
    $[10] = t2;
  } else {
    t2 = $[10];
  }
  const actionProps = t2;
  const t3 = !collection.forceFilter;
  let t4;
  if ($[11] !== t3 || $[12] !== tableController) {
    t4 = (0, import_jsx_runtime2.jsx)(ClearFilterSortButton, { tableController, enabled: t3 }, "clear_filter");
    $[11] = t3;
    $[12] = tableController;
    $[13] = t4;
  } else {
    t4 = $[13];
  }
  let t5;
  if ($[14] !== actionProps || $[15] !== plugins || $[16] !== t4) {
    const actions = [t4];
    if (plugins) {
      plugins.forEach((plugin, i2) => {
        var _a, _b;
        if ((_a = plugin.collectionView) == null ? void 0 : _a.CollectionActionsStart) {
          actions.push(...toArray2((_b = plugin.collectionView) == null ? void 0 : _b.CollectionActionsStart).map((Action2, j2) => {
            var _a2;
            return (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(Action2, { ...actionProps, ...(_a2 = plugin.collectionView) == null ? void 0 : _a2.collectionActionsStartProps }) }, `plugin_actions_${i2}_${j2}`);
          }));
        }
      });
    }
    t5 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: actions });
    $[14] = actionProps;
    $[15] = plugins;
    $[16] = t4;
    $[17] = t5;
  } else {
    t5 = $[17];
  }
  return t5;
}
var collectionScrollCache = /* @__PURE__ */ new Map();
function useScrollRestoration2() {
  const updateCollectionScroll = ({
    fullPath,
    filters,
    scrollOffset,
    data
  }) => {
    collectionScrollCache.set(createCacheKey(fullPath, filters), {
      scrollOffset,
      data
    });
  };
  const getCollectionScroll = (fullPath, filters) => {
    return collectionScrollCache.get(createCacheKey(fullPath, filters));
  };
  return {
    getCollectionScroll,
    updateCollectionScroll
  };
}
function createCacheKey(fullPath, filters) {
  if (!filters) {
    return fullPath;
  }
  const filtersString = filters ? Object.keys(filters).map((key) => {
    const value = JSON.stringify(filters[key]);
    return `${key}=${value}`;
  }).join("&") : "";
  return `${fullPath}?${filtersString}`;
}
var DEFAULT_ENTITY_OPEN_MODE = "side_panel";
var EntityCollectionView = import_react14.default.memo(function EntityCollectionView2({
  fullPath: fullPathProp,
  fullIdPath,
  parentCollectionIds,
  isSubCollection,
  className,
  updateUrl,
  ...collectionProp
}) {
  var _a, _b;
  const context = useFireCMSContext();
  const navigation = useNavigationController();
  const fullPath = fullPathProp ?? collectionProp.path;
  const dataSource = useDataSource();
  const sideEntityController = useSideEntityController();
  const authController = useAuthController();
  const userConfigPersistence = useUserConfigurationPersistence();
  const analyticsController = useAnalyticsController();
  const customizationController = useCustomizationController();
  const containerRef = import_react14.default.useRef(null);
  const scrollRestoration = useScrollRestoration2();
  const collection = (0, import_react14.useMemo)(() => {
    const userOverride = userConfigPersistence == null ? void 0 : userConfigPersistence.getCollectionConfig(fullPath);
    return userOverride ? mergeDeep2(collectionProp, userOverride) : collectionProp;
  }, [collectionProp, fullPath, userConfigPersistence == null ? void 0 : userConfigPersistence.getCollectionConfig]);
  const openEntityMode = (collection == null ? void 0 : collection.openEntityMode) ?? DEFAULT_ENTITY_OPEN_MODE;
  const collectionRef = import_react14.default.useRef(collection);
  (0, import_react14.useEffect)(() => {
    collectionRef.current = collection;
  }, [collection]);
  const canCreateEntities = canCreateEntity(collection, authController, fullPath, null);
  const [highlightedEntity, setHighlightedEntity] = (0, import_react14.useState)(void 0);
  const [deleteEntityClicked, setDeleteEntityClicked] = import_react14.default.useState(void 0);
  const [lastDeleteTimestamp, setLastDeleteTimestamp] = import_react14.default.useState(0);
  const [docsCount, setDocsCount] = (0, import_react14.useState)(0);
  const unselectNavigatedEntity = (0, import_react14.useCallback)(() => {
    const currentSelection = highlightedEntity;
    setTimeout(() => {
      if (currentSelection === highlightedEntity) setHighlightedEntity(void 0);
    }, 2400);
  }, [highlightedEntity]);
  const checkInlineEditing = (0, import_react14.useCallback)((entity) => {
    const collection_0 = collectionRef.current;
    if (!canEditEntity(collection_0, authController, fullPath, entity ?? null)) {
      return false;
    }
    return collection_0.inlineEditing === void 0 || collection_0.inlineEditing;
  }, [authController, fullPath]);
  const selectionEnabled = collection.selectionEnabled === void 0 || collection.selectionEnabled;
  const hoverRow = !checkInlineEditing();
  const [popOverOpen, setPopOverOpen] = (0, import_react14.useState)(false);
  const selectionController = useSelectionController();
  const usedSelectionController = collection.selectionController ?? selectionController;
  const {
    selectedEntities,
    setSelectedEntities
  } = usedSelectionController;
  const tableController = useDataSourceTableController({
    fullPath,
    collection,
    lastDeleteTimestamp,
    scrollRestoration,
    updateUrl
  });
  const tableKey = import_react14.default.useRef(Math.random().toString(36));
  const popupCell = tableController.popupCell;
  const onPopupClose = (0, import_react14.useCallback)(() => {
    var _a2;
    (_a2 = tableController.setPopupCell) == null ? void 0 : _a2.call(tableController, void 0);
  }, [tableController.setPopupCell]);
  const onEntityClick = (0, import_react14.useCallback)((clickedEntity) => {
    var _a2;
    const collection_1 = collectionRef.current;
    setHighlightedEntity(clickedEntity);
    (_a2 = analyticsController.onAnalyticsEvent) == null ? void 0 : _a2.call(analyticsController, "edit_entity_clicked", {
      path: clickedEntity.path,
      entityId: clickedEntity.id
    });
    if (collection_1) {
      addRecentId(collection_1.id, clickedEntity.id);
    }
    const path = (collection_1 == null ? void 0 : collection_1.collectionGroup) ? clickedEntity.path : fullPath ?? clickedEntity.path;
    navigateToEntity({
      navigation,
      path,
      fullIdPath,
      sideEntityController,
      openEntityMode,
      collection: collection_1,
      entityId: clickedEntity.id
    });
  }, [unselectNavigatedEntity, sideEntityController]);
  const onNewClick = (0, import_react14.useCallback)(() => {
    var _a2;
    const collection_2 = collectionRef.current;
    (_a2 = analyticsController.onAnalyticsEvent) == null ? void 0 : _a2.call(analyticsController, "new_entity_click", {
      path: fullPath
    });
    navigateToEntity({
      openEntityMode,
      collection: collection_2,
      entityId: void 0,
      path: fullPath,
      fullIdPath,
      sideEntityController,
      navigation,
      onClose: unselectNavigatedEntity
    });
  }, [fullPath, sideEntityController]);
  const onMultipleDeleteClick = () => {
    var _a2;
    (_a2 = analyticsController.onAnalyticsEvent) == null ? void 0 : _a2.call(analyticsController, "multiple_delete_dialog_open", {
      path: fullPath
    });
    setDeleteEntityClicked(selectedEntities);
  };
  const internalOnEntityDelete = (_path, entity_0) => {
    var _a2;
    (_a2 = analyticsController.onAnalyticsEvent) == null ? void 0 : _a2.call(analyticsController, "single_entity_deleted", {
      path: fullPath
    });
    setSelectedEntities((selectedEntities_0) => selectedEntities_0.filter((e2) => e2.id !== entity_0.id));
    setLastDeleteTimestamp(Date.now());
  };
  const internalOnMultipleEntitiesDelete = (_path_0, entities) => {
    var _a2;
    (_a2 = analyticsController.onAnalyticsEvent) == null ? void 0 : _a2.call(analyticsController, "multiple_entities_deleted", {
      path: fullPath
    });
    setSelectedEntities([]);
    setDeleteEntityClicked(void 0);
    setLastDeleteTimestamp(Date.now());
  };
  let AddColumnComponent;
  if (customizationController == null ? void 0 : customizationController.plugins) {
    AddColumnComponent = (_b = (_a = customizationController.plugins.find((plugin) => {
      var _a2;
      return (_a2 = plugin.collectionView) == null ? void 0 : _a2.AddColumnComponent;
    })) == null ? void 0 : _a.collectionView) == null ? void 0 : _b.AddColumnComponent;
  }
  const onCollectionModifiedForUser = (0, import_react14.useCallback)((path_0, partialCollection) => {
    if (userConfigPersistence) {
      const currentStoredConfig = userConfigPersistence.getCollectionConfig(path_0);
      const updatedConfig = mergeDeep2(currentStoredConfig, partialCollection);
      userConfigPersistence.onCollectionModified(path_0, updatedConfig);
    }
  }, [userConfigPersistence]);
  const onColumnResize = (0, import_react14.useCallback)(({
    width,
    key
  }) => {
    const collection_3 = collectionRef.current;
    if (!getPropertyInPath(collection_3.properties, key)) return;
    const localCollection = buildPropertyWidthOverwrite(key, width);
    onCollectionModifiedForUser(fullPath, localCollection);
  }, [onCollectionModifiedForUser, fullPath]);
  const onSizeChanged = (0, import_react14.useCallback)((size2) => {
    if (userConfigPersistence) onCollectionModifiedForUser(fullPath, {
      defaultSize: size2
    });
  }, [onCollectionModifiedForUser, fullPath, userConfigPersistence]);
  const createEnabled = canCreateEntity(collection, authController, fullPath, null);
  const uniqueFieldValidator = (0, import_react14.useCallback)(({
    name,
    value,
    property,
    entityId
  }) => dataSource.checkUniqueField(fullPath, name, value, entityId, collection), [fullPath]);
  const onValueChange = ({
    value: value_0,
    propertyKey,
    onValueUpdated,
    setError,
    data: entity_1
  }) => {
    const updatedValues = setIn({
      ...entity_1.values
    }, propertyKey, value_0);
    const saveProps = {
      path: entity_1.path ?? fullPath,
      entityId: entity_1.id,
      values: updatedValues,
      previousValues: entity_1.values,
      collection,
      status: "existing"
    };
    return saveEntityWithCallbacks({
      ...saveProps,
      collection,
      dataSource,
      context,
      onSaveSuccess: () => {
        setError(void 0);
        onValueUpdated();
      },
      onSaveFailure: (e_0) => {
        console.error("Save failure");
        console.error(e_0);
        setError(e_0);
      }
    });
  };
  const resolvedFullPath = navigation.resolveIdsFrom(fullPath);
  const resolvedCollection = (0, import_react14.useMemo)(() => resolveCollection({
    collection,
    path: fullPath,
    propertyConfigs: customizationController.propertyConfigs,
    authController
  }), [collection, fullPath]);
  const getPropertyFor = (0, import_react14.useCallback)(({
    propertyKey: propertyKey_0,
    entity: entity_2
  }) => {
    let propertyOrBuilder = getPropertyInPath(collection.properties, propertyKey_0);
    if (!propertyOrBuilder) {
      propertyOrBuilder = getPropertyInPath(resolvedCollection.properties, propertyKey_0);
    }
    return resolveProperty({
      propertyKey: propertyKey_0,
      propertyOrBuilder,
      path: entity_2.path,
      values: entity_2.values,
      entityId: entity_2.id,
      propertyConfigs: customizationController.propertyConfigs,
      authController
    });
  }, [collection.properties, customizationController.propertyConfigs, resolvedCollection.properties]);
  const displayedColumnIds = useColumnIds(resolvedCollection, true);
  const additionalFields = (0, import_react14.useMemo)(() => {
    var _a2;
    const subcollectionColumns = ((_a2 = collection.subcollections) == null ? void 0 : _a2.map((subcollection) => {
      return {
        key: getSubcollectionColumnId(subcollection),
        name: subcollection.name,
        width: 200,
        dependencies: [],
        Builder: ({
          entity: entity_3
        }) => (0, import_jsx_runtime2.jsx)(Button, { color: "primary", variant: "outlined", startIcon: (0, import_jsx_runtime2.jsx)(KeyboardTabIcon, { size: "small" }), onClick: (event) => {
          event.stopPropagation();
          navigateToEntity({
            openEntityMode,
            collection,
            entityId: entity_3.id,
            selectedTab: subcollection.id ?? subcollection.path,
            path: fullPath,
            fullIdPath,
            navigation,
            sideEntityController
          });
        }, children: subcollection.name })
      };
    })) ?? [];
    const collectionGroupParentCollections = collection.collectionGroup ? [{
      key: COLLECTION_GROUP_PARENT_ID,
      name: "Parent entities",
      width: 260,
      dependencies: [],
      Builder: ({
        entity: entity_4
      }) => {
        const collectionsWithPath = navigation.getParentReferencesFromPath(entity_4.path);
        return (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2 w-full", children: collectionsWithPath.map((reference2) => {
          return (0, import_jsx_runtime2.jsx)(ReferencePreview, { reference: reference2, size: "small" }, reference2.path + "/" + reference2.id);
        }) });
      }
    }] : [];
    return [...collection.additionalFields ?? [], ...subcollectionColumns, ...collectionGroupParentCollections];
  }, [collection, fullPath, sideEntityController]);
  const updateLastDeleteTimestamp = (0, import_react14.useCallback)(() => {
    setLastDeleteTimestamp(Date.now());
  }, []);
  const largeLayout = useLargeLayout();
  const getActionsForEntity = ({
    entity: entity_5,
    customEntityActions
  }) => {
    const deleteEnabled = entity_5 ? canDeleteEntity(collection, authController, fullPath, entity_5) : true;
    const actions = [editEntityAction];
    if (createEnabled) actions.push(copyEntityAction);
    if (deleteEnabled) actions.push(deleteEntityAction);
    if (customEntityActions) return mergeEntityActions(actions, customEntityActions);
    return actions;
  };
  const getIdColumnWidth = () => {
    const entityActions = getActionsForEntity({});
    const collapsedActions = entityActions.filter((a2) => a2.collapsed !== false);
    const uncollapsedActions = entityActions.filter((a_0) => a_0.collapsed === false);
    const actionsWidth = uncollapsedActions.length * (largeLayout ? 40 : 30);
    return (largeLayout ? 80 + actionsWidth : 70 + actionsWidth) + (collapsedActions.length > 0 ? largeLayout ? 40 : 30 : 0);
  };
  const tableRowActionsBuilder = (0, import_react14.useCallback)(({
    entity: entity_6,
    size: size_0,
    width: width_0,
    frozen
  }) => {
    const isSelected = Boolean(usedSelectionController.selectedEntities.find((e_1) => e_1.id == entity_6.id && e_1.path == entity_6.path));
    const actions_0 = getActionsForEntity({
      entity: entity_6,
      customEntityActions: collection.entityActions
    });
    return (0, import_jsx_runtime2.jsx)(EntityCollectionRowActions, { entity: entity_6, width: width_0, frozen, isSelected, selectionEnabled, size: size_0, highlightEntity: setHighlightedEntity, unhighlightEntity: unselectNavigatedEntity, collection, fullPath: fullIdPath ?? fullPath, actions: actions_0, hideId: collection == null ? void 0 : collection.hideIdFromCollection, onCollectionChange: updateLastDeleteTimestamp, selectionController: usedSelectionController, openEntityMode });
  }, [updateLastDeleteTimestamp, usedSelectionController]);
  const title = (0, import_jsx_runtime2.jsx)(Popover, { open: popOverOpen, onOpenChange: setPopOverOpen, enabled: Boolean(collection.description), trigger: (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-col items-start", children: [
    (0, import_jsx_runtime2.jsx)(Typography, { variant: "subtitle1", className: `leading-none truncate max-w-[160px] lg:max-w-[240px] ${collection.description ? "cursor-pointer" : "cursor-auto"}`, onClick: collection.description ? (e_2) => {
      setPopOverOpen(true);
      e_2.stopPropagation();
    } : void 0, children: `${collection.name}` }),
    (0, import_jsx_runtime2.jsx)(EntitiesCount, { fullPath, collection, filter: tableController.filterValues, sortBy: tableController.sortBy, onCountChange: setDocsCount })
  ] }), children: collection.description && (0, import_jsx_runtime2.jsx)("div", { className: "m-4 text-surface-900 dark:text-white", children: (0, import_jsx_runtime2.jsx)(Markdown, { source: collection.description }) }) });
  const buildAdditionalHeaderWidget = (0, import_react14.useCallback)(({
    property: property_0,
    propertyKey: propertyKey_1,
    onHover
  }) => {
    const collection_4 = collectionRef.current;
    if (!customizationController.plugins) return null;
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: customizationController.plugins.filter((plugin_0) => {
      var _a2;
      return (_a2 = plugin_0.collectionView) == null ? void 0 : _a2.HeaderAction;
    }).map((plugin_1, i2) => {
      const HeaderAction = plugin_1.collectionView.HeaderAction;
      return (0, import_jsx_runtime2.jsx)(HeaderAction, { onHover, propertyKey: propertyKey_1, property: property_0, fullPath, collection: collection_4, tableController, parentCollectionIds: parentCollectionIds ?? [] }, `plugin_header_action_${i2}`);
    }) });
  }, [customizationController.plugins, fullPath, parentCollectionIds]);
  const addColumnComponentInternal = AddColumnComponent ? function() {
    if (typeof AddColumnComponent === "function") return (0, import_jsx_runtime2.jsx)(AddColumnComponent, { fullPath, parentCollectionIds: parentCollectionIds ?? [], collection, tableController });
    return null;
  } : void 0;
  const {
    textSearchLoading,
    textSearchInitialised,
    onTextSearchClick,
    textSearchEnabled
  } = useTableSearchHelper({
    collection,
    fullPath: resolvedFullPath,
    parentCollectionIds
  });
  return (0, import_jsx_runtime2.jsxs)("div", { className: cls("overflow-hidden h-full w-full rounded-md", className), ref: containerRef, children: [
    (0, import_jsx_runtime2.jsx)(EntityCollectionTable, { additionalFields, tableController, enablePopupIcon: true, displayedColumnIds, onSizeChanged, onEntityClick, onColumnResize, onValueChange, tableRowActionsBuilder, uniqueFieldValidator, title, selectionController: usedSelectionController, highlightedEntities: highlightedEntity ? [highlightedEntity] : [], defaultSize: collection.defaultSize, properties: resolvedCollection.properties, getPropertyFor, onTextSearchClick: textSearchInitialised ? void 0 : onTextSearchClick, onScroll: tableController.onScroll, initialScroll: tableController.initialScroll, textSearchLoading, textSearchEnabled, actionsStart: (0, import_jsx_runtime2.jsx)(EntityCollectionViewStartActions, { parentCollectionIds: parentCollectionIds ?? [], collection, tableController, path: fullPath, relativePath: collection.path, selectionController: usedSelectionController, collectionEntitiesCount: docsCount }), actions: (0, import_jsx_runtime2.jsx)(EntityCollectionViewActions, { parentCollectionIds: parentCollectionIds ?? [], collection, tableController, onMultipleDeleteClick, onNewClick, path: fullPath, relativePath: collection.path, selectionController: usedSelectionController, selectionEnabled, collectionEntitiesCount: docsCount }), emptyComponent: canCreateEntities && tableController.filterValues === void 0 && tableController.sortBy === void 0 ? (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-col items-center justify-center", children: [
      (0, import_jsx_runtime2.jsx)(Typography, { variant: "subtitle2", children: "So empty..." }),
      (0, import_jsx_runtime2.jsxs)(Button, { color: "primary", variant: "outlined", onClick: onNewClick, className: "mt-4", children: [
        (0, import_jsx_runtime2.jsx)(AddIcon, {}),
        "Create your first entity"
      ] })
    ] }) : (0, import_jsx_runtime2.jsx)(Typography, { variant: "label", children: "No results with the applied filter/sort" }), hoverRow, inlineEditing: checkInlineEditing(), AdditionalHeaderWidget: buildAdditionalHeaderWidget, AddColumnComponent: addColumnComponentInternal, getIdColumnWidth, additionalIDHeaderWidget: (0, import_jsx_runtime2.jsx)(EntityIdHeaderWidget, { path: fullPath, fullIdPath: fullIdPath ?? fullPath, collection }), openEntityMode }, `collection_table_${fullPath}`),
    popupCell && (0, import_jsx_runtime2.jsx)(PopupFormField, { open: Boolean(popupCell), onClose: onPopupClose, cellRect: popupCell == null ? void 0 : popupCell.cellRect, propertyKey: popupCell == null ? void 0 : popupCell.propertyKey, collection, entityId: popupCell.entityId, tableKey: tableKey.current, customFieldValidator: uniqueFieldValidator, path: resolvedFullPath, onCellValueChange: onValueChange, container: containerRef.current }, `popup_form_${popupCell == null ? void 0 : popupCell.propertyKey}_${popupCell == null ? void 0 : popupCell.entityId}`),
    deleteEntityClicked && (0, import_jsx_runtime2.jsx)(DeleteEntityDialog, { entityOrEntitiesToDelete: deleteEntityClicked, path: fullPath, collection, callbacks: collection.callbacks, open: Boolean(deleteEntityClicked), onEntityDelete: internalOnEntityDelete, onMultipleEntitiesDelete: internalOnMultipleEntitiesDelete, onClose: () => setDeleteEntityClicked(void 0) })
  ] });
}, (a2, b2) => {
  return (0, import_react_fast_compare2.default)(a2.path, b2.path) && (0, import_react_fast_compare2.default)(a2.parentCollectionIds, b2.parentCollectionIds) && (0, import_react_fast_compare2.default)(a2.isSubCollection, b2.isSubCollection) && (0, import_react_fast_compare2.default)(a2.className, b2.className) && (0, import_react_fast_compare2.default)(a2.properties, b2.properties) && (0, import_react_fast_compare2.default)(a2.propertiesOrder, b2.propertiesOrder) && (0, import_react_fast_compare2.default)(a2.hideIdFromCollection, b2.hideIdFromCollection) && (0, import_react_fast_compare2.default)(a2.inlineEditing, b2.inlineEditing) && (0, import_react_fast_compare2.default)(a2.selectionEnabled, b2.selectionEnabled) && (0, import_react_fast_compare2.default)(a2.selectionController, b2.selectionController) && (0, import_react_fast_compare2.default)(a2.Actions, b2.Actions) && (0, import_react_fast_compare2.default)(a2.defaultSize, b2.defaultSize) && (0, import_react_fast_compare2.default)(a2.initialFilter, b2.initialFilter) && (0, import_react_fast_compare2.default)(a2.initialSort, b2.initialSort) && (0, import_react_fast_compare2.default)(a2.textSearchEnabled, b2.textSearchEnabled) && (0, import_react_fast_compare2.default)(a2.additionalFields, b2.additionalFields) && (0, import_react_fast_compare2.default)(a2.sideDialogWidth, b2.sideDialogWidth) && (0, import_react_fast_compare2.default)(a2.openEntityMode, b2.openEntityMode) && (0, import_react_fast_compare2.default)(a2.forceFilter, b2.forceFilter);
});
function EntitiesCount({
  fullPath,
  collection,
  filter,
  sortBy,
  onCountChange
}) {
  const dataSource = useDataSource();
  const navigation = useNavigationController();
  const [count, setCount] = (0, import_react14.useState)(void 0);
  const [error2, setError] = (0, import_react14.useState)(void 0);
  const sortByProperty = sortBy ? sortBy[0] : void 0;
  const currentSort = sortBy ? sortBy[1] : void 0;
  const resolvedPath = (0, import_react14.useMemo)(() => navigation.resolveIdsFrom(fullPath), [fullPath, navigation.resolveIdsFrom]);
  (0, import_react14.useEffect)(() => {
    if (dataSource.countEntities) dataSource.countEntities({
      path: resolvedPath,
      collection,
      filter,
      orderBy: sortByProperty,
      order: currentSort
    }).then(setCount).catch(setError);
  }, [fullPath, dataSource.countEntities, resolvedPath, collection, filter, sortByProperty, currentSort]);
  (0, import_react14.useEffect)(() => {
    if (onCountChange) {
      setError(void 0);
      onCountChange(count ?? 0);
    }
  }, [onCountChange, count]);
  if (error2) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(Typography, { className: "w-full text-ellipsis block overflow-hidden whitespace-nowrap max-w-xs text-left w-fit-content", variant: "caption", color: "secondary", children: count !== void 0 ? `${count} entities` : (0, import_jsx_runtime2.jsx)(Skeleton, { className: "w-full max-w-[80px] mt-1" }) });
}
function buildPropertyWidthOverwrite(key, width) {
  if (key.includes(".")) {
    const [parentKey, ...childKey] = key.split(".");
    return {
      properties: {
        [parentKey]: buildPropertyWidthOverwrite(childKey.join("."), width)
      }
    };
  }
  return {
    properties: {
      [key]: {
        columnWidth: width
      }
    }
  };
}
function EntityIdHeaderWidget(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(42);
  const {
    collection,
    path,
    fullIdPath
  } = t0;
  const navigation = useNavigationController();
  const [openPopup, setOpenPopup] = import_react14.default.useState(false);
  const [searchString, setSearchString] = import_react14.default.useState("");
  let t1;
  if ($[0] !== collection.id) {
    t1 = getRecentIds(collection.id);
    $[0] = collection.id;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const [recentIds, setRecentIds] = import_react14.default.useState(t1);
  const sideEntityController = useSideEntityController();
  const openEntityMode = (collection == null ? void 0 : collection.openEntityMode) ?? DEFAULT_ENTITY_OPEN_MODE;
  const t2 = !openPopup ? "Find by ID" : void 0;
  let t3;
  let t4;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime2.jsx)(IconButton, { size: "small", children: (0, import_jsx_runtime2.jsx)(SearchIcon, { size: "small" }) });
    t4 = cls("my-2 rounded-lg bg-surface-50 dark:bg-surface-950 text-surface-900 dark:text-white");
    $[2] = t3;
    $[3] = t4;
  } else {
    t3 = $[2];
    t4 = $[3];
  }
  let t5;
  if ($[4] !== collection || $[5] !== fullIdPath || $[6] !== navigation || $[7] !== openEntityMode || $[8] !== path || $[9] !== searchString || $[10] !== sideEntityController) {
    t5 = (e2) => {
      e2.preventDefault();
      if (!searchString) {
        return;
      }
      setOpenPopup(false);
      const entityId = searchString.trim();
      setRecentIds(addRecentId(collection.id, entityId));
      navigateToEntity({
        openEntityMode,
        collection,
        entityId,
        path,
        fullIdPath,
        sideEntityController,
        navigation
      });
    };
    $[4] = collection;
    $[5] = fullIdPath;
    $[6] = navigation;
    $[7] = openEntityMode;
    $[8] = path;
    $[9] = searchString;
    $[10] = sideEntityController;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  let t6;
  if ($[12] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = (e_0) => {
      setSearchString(e_0.target.value);
    };
    $[12] = t6;
  } else {
    t6 = $[12];
  }
  let t7;
  if ($[13] !== openPopup || $[14] !== searchString) {
    t7 = (0, import_jsx_runtime2.jsx)("input", { autoFocus: openPopup, placeholder: "Find entity by ID", onChange: t6, value: searchString, className: "rounded-lg bg-white dark:bg-surface-800 flex-grow bg-transparent outline-none p-2 " + focusedDisabled });
    $[13] = openPopup;
    $[14] = searchString;
    $[15] = t7;
  } else {
    t7 = $[15];
  }
  const t8 = !searchString.trim();
  let t9;
  if ($[16] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = (0, import_jsx_runtime2.jsx)(KeyboardTabIcon, {});
    $[16] = t9;
  } else {
    t9 = $[16];
  }
  let t10;
  if ($[17] !== t8) {
    t10 = (0, import_jsx_runtime2.jsx)(Button, { variant: "text", disabled: t8, type: "submit", children: t9 });
    $[17] = t8;
    $[18] = t10;
  } else {
    t10 = $[18];
  }
  let t11;
  if ($[19] !== t10 || $[20] !== t7) {
    t11 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex p-2 w-full gap-2", children: [
      t7,
      t10
    ] });
    $[19] = t10;
    $[20] = t7;
    $[21] = t11;
  } else {
    t11 = $[21];
  }
  let t12;
  if ($[22] !== t11 || $[23] !== t5) {
    t12 = (0, import_jsx_runtime2.jsx)("form", { noValidate: true, onSubmit: t5, className: "w-96 max-w-full", children: t11 });
    $[22] = t11;
    $[23] = t5;
    $[24] = t12;
  } else {
    t12 = $[24];
  }
  let t13;
  if ($[25] !== collection || $[26] !== fullIdPath || $[27] !== navigation || $[28] !== openEntityMode || $[29] !== path || $[30] !== recentIds || $[31] !== sideEntityController) {
    t13 = recentIds && recentIds.length > 0 && (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-2 p-2", children: recentIds.map((id2) => (0, import_jsx_runtime2.jsx)(ReferencePreview, { reference: new EntityReference(id2, path), hover: true, onClick: () => {
      setOpenPopup(false);
      navigateToEntity({
        openEntityMode,
        collection,
        entityId: id2,
        path,
        fullIdPath,
        sideEntityController,
        navigation
      });
    }, includeEntityLink: false, size: "small" }, id2)) });
    $[25] = collection;
    $[26] = fullIdPath;
    $[27] = navigation;
    $[28] = openEntityMode;
    $[29] = path;
    $[30] = recentIds;
    $[31] = sideEntityController;
    $[32] = t13;
  } else {
    t13 = $[32];
  }
  let t14;
  if ($[33] !== t12 || $[34] !== t13) {
    t14 = (0, import_jsx_runtime2.jsxs)("div", { className: t4, children: [
      t12,
      t13
    ] });
    $[33] = t12;
    $[34] = t13;
    $[35] = t14;
  } else {
    t14 = $[35];
  }
  let t15;
  if ($[36] !== openPopup || $[37] !== t14) {
    t15 = (0, import_jsx_runtime2.jsx)(Popover, { open: openPopup, onOpenChange: setOpenPopup, sideOffset: 0, align: "start", alignOffset: -117, trigger: t3, children: t14 });
    $[36] = openPopup;
    $[37] = t14;
    $[38] = t15;
  } else {
    t15 = $[38];
  }
  let t16;
  if ($[39] !== t15 || $[40] !== t2) {
    t16 = (0, import_jsx_runtime2.jsx)(Tooltip, { title: t2, asChild: false, children: t15 });
    $[39] = t15;
    $[40] = t2;
    $[41] = t16;
  } else {
    t16 = $[41];
  }
  return t16;
}
function PropertyConfigBadge(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    propertyConfig,
    disabled
  } = t0;
  const classes2 = "h-8 w-8 p-1 rounded-full shadow text-white " + (disabled ? "bg-surface-400 dark:bg-surface-600" : "");
  let t1;
  if ($[0] !== classes2 || $[1] !== disabled || $[2] !== propertyConfig) {
    const defaultPropertyConfig = typeof (propertyConfig == null ? void 0 : propertyConfig.property) === "object" ? getDefaultFieldConfig(propertyConfig.property) : void 0;
    const t2 = !disabled ? (propertyConfig == null ? void 0 : propertyConfig.color) ?? (defaultPropertyConfig == null ? void 0 : defaultPropertyConfig.color) ?? "#888" : void 0;
    let t3;
    if ($[4] !== t2) {
      t3 = {
        background: t2
      };
      $[4] = t2;
      $[5] = t3;
    } else {
      t3 = $[5];
    }
    t1 = (0, import_jsx_runtime2.jsx)("div", { className: classes2, style: t3, children: (propertyConfig == null ? void 0 : propertyConfig.Icon) ? getIconForWidget(propertyConfig, "medium") : getIconForWidget(defaultPropertyConfig, "medium") });
    $[0] = classes2;
    $[1] = disabled;
    $[2] = propertyConfig;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  return t1;
}
function NotFoundPage() {
  const $ = (0, import_react_compiler_runtime3.c)(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (0, import_jsx_runtime2.jsx)("div", { className: "flex w-full h-full", children: (0, import_jsx_runtime2.jsxs)("div", { className: "m-auto flex items-center flex-col", children: [
      (0, import_jsx_runtime2.jsx)(Typography, { variant: "h4", align: "center", gutterBottom: true, children: "Page not found" }),
      (0, import_jsx_runtime2.jsx)(Typography, { align: "center", gutterBottom: true, children: "This page does not exist or you may not have access to it" }),
      (0, import_jsx_runtime2.jsx)(Button, { variant: "text", component: Link, to: "/", children: "Back to home" })
    ] }) });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
}
function ConfirmationDialog(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(20);
  const {
    open,
    onAccept,
    onCancel,
    title,
    loading,
    body
  } = t0;
  let t1;
  if ($[0] !== onCancel) {
    t1 = (open_0) => !open_0 ? onCancel() : void 0;
    $[0] = onCancel;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== title) {
    t2 = (0, import_jsx_runtime2.jsx)(DialogTitle, { variant: "h6", className: "mb-2", children: title });
    $[2] = title;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] !== body) {
    t3 = (0, import_jsx_runtime2.jsx)(DialogContent, { children: body });
    $[4] = body;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] !== onCancel) {
    t4 = (0, import_jsx_runtime2.jsx)(Button, { variant: "text", onClick: onCancel, autoFocus: true, children: "Cancel" });
    $[6] = onCancel;
    $[7] = t4;
  } else {
    t4 = $[7];
  }
  let t5;
  if ($[8] !== loading || $[9] !== onAccept) {
    t5 = (0, import_jsx_runtime2.jsx)(LoadingButton, { color: "primary", type: "submit", loading, onClick: onAccept, children: "Ok" });
    $[8] = loading;
    $[9] = onAccept;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  let t6;
  if ($[11] !== t4 || $[12] !== t5) {
    t6 = (0, import_jsx_runtime2.jsxs)(DialogActions, { children: [
      t4,
      t5
    ] });
    $[11] = t4;
    $[12] = t5;
    $[13] = t6;
  } else {
    t6 = $[13];
  }
  let t7;
  if ($[14] !== open || $[15] !== t1 || $[16] !== t2 || $[17] !== t3 || $[18] !== t6) {
    t7 = (0, import_jsx_runtime2.jsxs)(Dialog, { open, onOpenChange: t1, children: [
      t2,
      t3,
      t6
    ] });
    $[14] = open;
    $[15] = t1;
    $[16] = t2;
    $[17] = t3;
    $[18] = t6;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  return t7;
}
function FireCMSLogo(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(9);
  const {
    width,
    height,
    className,
    style: style3
  } = t0;
  const t1 = width ?? "100%";
  const t2 = height ?? "100%";
  let t3;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime2.jsxs)("radialGradient", { cx: "28.6213569%", cy: "43.1133328%", fx: "28.6213569%", fy: "43.1133328%", r: "71.5003456%", gradientTransform: "translate(0.286214,0.431133),rotate(3.343450),scale(1.000000,0.996175),translate(-0.286214,-0.431133)", id: "radialGradient-1", children: [
      (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#FF5B79", offset: "0%" }),
      (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#FA5574", offset: "28.0930803%" }),
      (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#EC4C51", offset: "44.7242531%" }),
      (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#9543C1", offset: "71.4578165%" }),
      (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#3857B3", offset: "100%" })
    ] });
    $[0] = t3;
  } else {
    t3 = $[0];
  }
  let t4;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (0, import_jsx_runtime2.jsxs)("radialGradient", { cx: "53.6205516%", cy: "47.2473036%", fx: "53.6205516%", fy: "47.2473036%", r: "50.8229649%", gradientTransform: "translate(0.536206,0.472473),rotate(90.000000),scale(1.000000,1.206631),translate(-0.536206,-0.472473)", id: "radialGradient-2", children: [
      (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#68294F", stopOpacity: "0", offset: "0%" }),
      (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#5E2548", stopOpacity: "0.04641108", offset: "75.3503173%" }),
      (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#0D060B", stopOpacity: "0.437431709", offset: "100%" })
    ] });
    $[1] = t4;
  } else {
    t4 = $[1];
  }
  let t5;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = (0, import_jsx_runtime2.jsxs)("defs", { children: [
      t3,
      t4,
      (0, import_jsx_runtime2.jsxs)("radialGradient", { cx: "53.8605015%", cy: "48.1990423%", fx: "53.8605015%", fy: "48.1990423%", r: "59.9151549%", gradientTransform: "translate(0.538605,0.481990),rotate(180.000000),scale(1.000000,0.925027),translate(-0.538605,-0.481990)", id: "radialGradient-3", children: [
        (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#68294F", stopOpacity: "0", offset: "0%" }),
        (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#5E2548", stopOpacity: "0.04641108", offset: "84.0867343%" }),
        (0, import_jsx_runtime2.jsx)("stop", { stopColor: "#FF0000", stopOpacity: "0.567324765", offset: "100%" })
      ] })
    ] });
    $[2] = t5;
  } else {
    t5 = $[2];
  }
  let t6;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = (0, import_jsx_runtime2.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime2.jsxs)("g", { id: "firecms_logo", children: [
      (0, import_jsx_runtime2.jsx)("circle", { fill: "url(#radialGradient-1)", cx: "299.5", cy: "299.5", r: "299.5" }),
      (0, import_jsx_runtime2.jsx)("circle", { fill: "url(#radialGradient-2)", cx: "299.5", cy: "299.5", r: "299.5" }),
      (0, import_jsx_runtime2.jsx)("circle", { fill: "url(#radialGradient-3)", cx: "299.5", cy: "299.5", r: "299.5" })
    ] }) });
    $[3] = t6;
  } else {
    t6 = $[3];
  }
  let t7;
  if ($[4] !== className || $[5] !== style3 || $[6] !== t1 || $[7] !== t2) {
    t7 = (0, import_jsx_runtime2.jsxs)("svg", { width: t1, height: t2, viewBox: "0 0 599 599", version: "1.1", style: style3, className, xmlns: "http://www.w3.org/2000/svg", children: [
      t5,
      t6
    ] });
    $[4] = className;
    $[5] = style3;
    $[6] = t1;
    $[7] = t2;
    $[8] = t7;
  } else {
    t7 = $[8];
  }
  return t7;
}
var AppContext2 = import_react14.default.createContext({
  hasDrawer: false,
  drawerHovered: false,
  drawerOpen: false,
  openDrawer: () => {
    throw new Error("openDrawer not implemented");
  },
  closeDrawer: () => {
    throw new Error("closeDrawer not implemented");
  },
  autoOpenDrawer: false
});
function useApp() {
  return import_react14.default.useContext(AppContext2);
}
var DEFAULT_BREADCRUMBS_CONTROLLER = {
  breadcrumbs: [],
  set: (props) => {
  }
};
var BreadcrumbContext = import_react14.default.createContext(DEFAULT_BREADCRUMBS_CONTROLLER);
var BreadcrumbsProvider = (t0) => {
  const $ = (0, import_react_compiler_runtime3.c)(7);
  const {
    children
  } = t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = [];
    $[0] = t1;
  } else {
    t1 = $[0];
  }
  const [breadcrumbs, setBreadcrumbs] = (0, import_react14.useState)(t1);
  let t2;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (props) => {
      setBreadcrumbs(props.breadcrumbs);
    };
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  const set2 = t2;
  let t3;
  if ($[2] !== breadcrumbs) {
    t3 = {
      breadcrumbs,
      set: set2
    };
    $[2] = breadcrumbs;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== children || $[5] !== t3) {
    t4 = (0, import_jsx_runtime2.jsx)(BreadcrumbContext.Provider, { value: t3, children });
    $[4] = children;
    $[5] = t3;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  return t4;
};
var useBreadcrumbsController = () => {
  return (0, import_react14.useContext)(BreadcrumbContext);
};
var DefaultAppBar = function DefaultAppBar2(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(47);
  const {
    title,
    endAdornment,
    startAdornment,
    dropDownActions,
    includeModeToggle: t1,
    className,
    style: style3,
    user: userProp,
    logo: logoProp
  } = t0;
  const includeModeToggle = t1 === void 0 ? true : t1;
  const {
    hasDrawer,
    drawerOpen,
    logo: appLogo
  } = useApp();
  const logo = logoProp ?? appLogo;
  const navigation = useNavigationController();
  const breadcrumbs = useBreadcrumbsController();
  const authController = useAuthController();
  const {
    mode,
    setMode
  } = useModeController();
  const navigate = useNavigate();
  const largeLayout = useLargeLayout();
  const user = userProp ?? authController.user;
  let avatarComponent;
  if (user) {
    let t22;
    if ($[0] !== user.displayName || $[1] !== user.email) {
      t22 = (user == null ? void 0 : user.displayName) ? user.displayName[0].toUpperCase() : (user == null ? void 0 : user.email) ? user.email[0].toUpperCase() : "A";
      $[0] = user.displayName;
      $[1] = user.email;
      $[2] = t22;
    } else {
      t22 = $[2];
    }
    const initial = t22;
    const t32 = user.photoURL ?? void 0;
    let t42;
    if ($[3] !== initial || $[4] !== t32) {
      t42 = (0, import_jsx_runtime2.jsx)(Avatar, { src: t32, children: initial });
      $[3] = initial;
      $[4] = t32;
      $[5] = t42;
    } else {
      t42 = $[5];
    }
    avatarComponent = t42;
  } else {
    if (user === void 0 || authController.initialLoading) {
      let t22;
      if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
        t22 = (0, import_jsx_runtime2.jsx)("div", { className: "p-1 flex justify-center", children: (0, import_jsx_runtime2.jsx)(Skeleton, { className: "w-10 h-10 rounded-full" }) });
        $[6] = t22;
      } else {
        t22 = $[6];
      }
      avatarComponent = t22;
    } else {
      avatarComponent = null;
    }
  }
  const t2 = drawerOpen && largeLayout;
  const t3 = hasDrawer && !(drawerOpen && largeLayout);
  const t4 = drawerOpen && largeLayout;
  let t5;
  if ($[7] !== className || $[8] !== largeLayout || $[9] !== t2 || $[10] !== t3 || $[11] !== t4) {
    t5 = cls("w-full h-16 transition-all ease-in duration-75 absolute top-0 max-w-full overflow-x-auto no-scrollbar", "flex flex-row gap-2 px-4 items-center", {
      "pl-[19rem]": t2,
      "pl-24": t3,
      "z-10": largeLayout,
      "duration-100": t4
    }, className);
    $[7] = className;
    $[8] = largeLayout;
    $[9] = t2;
    $[10] = t3;
    $[11] = t4;
    $[12] = t5;
  } else {
    t5 = $[12];
  }
  let t6;
  if ($[13] !== hasDrawer || $[14] !== logo || $[15] !== navigation || $[16] !== title) {
    t6 = navigation && (0, import_jsx_runtime2.jsx)("div", { className: "mr-2 hidden lg:block", children: (0, import_jsx_runtime2.jsx)(Link, { className: "visited:text-inherit visited:dark:text-inherit block", to: (navigation == null ? void 0 : navigation.basePath) ?? "/", children: (0, import_jsx_runtime2.jsxs)("div", { className: "flex flex-row gap-4", children: [
      !hasDrawer && (logo ? (0, import_jsx_runtime2.jsx)("img", { src: logo, alt: "Logo", className: cls("w-[32px] h-[32px] object-contain") }) : (0, import_jsx_runtime2.jsx)(FireCMSLogo, { width: "32px", height: "32px" })),
      typeof title === "string" ? (0, import_jsx_runtime2.jsx)(Typography, { variant: "subtitle1", noWrap: true, children: title }) : title
    ] }) }) });
    $[13] = hasDrawer;
    $[14] = logo;
    $[15] = navigation;
    $[16] = title;
    $[17] = t6;
  } else {
    t6 = $[17];
  }
  let t7;
  if ($[18] !== breadcrumbs.breadcrumbs) {
    t7 = (breadcrumbs.breadcrumbs ?? []).length > 0 && (0, import_jsx_runtime2.jsx)("div", { className: "mr-8 hidden lg:block", children: (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-row gap-2", children: breadcrumbs.breadcrumbs.map(_temp$7) }) });
    $[18] = breadcrumbs.breadcrumbs;
    $[19] = t7;
  } else {
    t7 = $[19];
  }
  let t8;
  if ($[20] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow" });
    $[20] = t8;
  } else {
    t8 = $[20];
  }
  let t9;
  if ($[21] !== endAdornment) {
    t9 = endAdornment && (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: endAdornment });
    $[21] = endAdornment;
    $[22] = t9;
  } else {
    t9 = $[22];
  }
  let t10;
  if ($[23] !== includeModeToggle || $[24] !== mode || $[25] !== setMode) {
    t10 = includeModeToggle && (0, import_jsx_runtime2.jsxs)(Menu, { trigger: (0, import_jsx_runtime2.jsx)(IconButton, { color: "inherit", "aria-label": "Open drawer", size: "large", children: mode === "dark" ? (0, import_jsx_runtime2.jsx)(DarkModeIcon, {}) : (0, import_jsx_runtime2.jsx)(LightModeIcon, {}) }), children: [
      (0, import_jsx_runtime2.jsxs)(MenuItem, { onClick: () => setMode("dark"), children: [
        (0, import_jsx_runtime2.jsx)(DarkModeIcon, { size: "smallest" }),
        " Dark"
      ] }),
      (0, import_jsx_runtime2.jsxs)(MenuItem, { onClick: () => setMode("light"), children: [
        (0, import_jsx_runtime2.jsx)(LightModeIcon, { size: "smallest" }),
        " Light "
      ] }),
      (0, import_jsx_runtime2.jsxs)(MenuItem, { onClick: () => setMode("system"), children: [
        " ",
        (0, import_jsx_runtime2.jsx)(BrightnessMediumIcon, { size: "smallest" }),
        "System"
      ] })
    ] });
    $[23] = includeModeToggle;
    $[24] = mode;
    $[25] = setMode;
    $[26] = t10;
  } else {
    t10 = $[26];
  }
  let t11;
  if ($[27] !== user) {
    t11 = user && (0, import_jsx_runtime2.jsxs)("div", { className: "px-4 py-2 mb-2", children: [
      user.displayName && (0, import_jsx_runtime2.jsx)(Typography, { variant: "body1", color: "secondary", children: user.displayName }),
      user.email && (0, import_jsx_runtime2.jsx)(Typography, { variant: "body2", color: "secondary", children: user.email })
    ] });
    $[27] = user;
    $[28] = t11;
  } else {
    t11 = $[28];
  }
  let t12;
  if ($[29] !== authController || $[30] !== dropDownActions || $[31] !== navigate) {
    t12 = !dropDownActions && (0, import_jsx_runtime2.jsxs)(MenuItem, { onClick: async () => {
      await authController.signOut();
      navigate("/");
    }, children: [
      (0, import_jsx_runtime2.jsx)(LogoutIcon, {}),
      "Log Out"
    ] });
    $[29] = authController;
    $[30] = dropDownActions;
    $[31] = navigate;
    $[32] = t12;
  } else {
    t12 = $[32];
  }
  let t13;
  if ($[33] !== avatarComponent || $[34] !== dropDownActions || $[35] !== t11 || $[36] !== t12) {
    t13 = (0, import_jsx_runtime2.jsxs)(Menu, { trigger: avatarComponent, children: [
      t11,
      dropDownActions,
      t12
    ] });
    $[33] = avatarComponent;
    $[34] = dropDownActions;
    $[35] = t11;
    $[36] = t12;
    $[37] = t13;
  } else {
    t13 = $[37];
  }
  let t14;
  if ($[38] !== startAdornment || $[39] !== style3 || $[40] !== t10 || $[41] !== t13 || $[42] !== t5 || $[43] !== t6 || $[44] !== t7 || $[45] !== t9) {
    t14 = (0, import_jsx_runtime2.jsxs)("div", { style: style3, className: t5, children: [
      t6,
      t7,
      startAdornment,
      t8,
      t9,
      t10,
      t13
    ] });
    $[38] = startAdornment;
    $[39] = style3;
    $[40] = t10;
    $[41] = t13;
    $[42] = t5;
    $[43] = t6;
    $[44] = t7;
    $[45] = t9;
    $[46] = t14;
  } else {
    t14 = $[46];
  }
  return t14;
};
function _temp$7(breadcrumb, index2) {
  return (0, import_jsx_runtime2.jsxs)(import_react14.default.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", color: "secondary", children: "/" }),
    (0, import_jsx_runtime2.jsx)(Link, { className: "visited:text-inherit visited:dark:text-inherit block", to: breadcrumb.url, children: (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", color: "secondary", children: breadcrumb.title }) }, index2)
  ] }, breadcrumb.url + "_" + index2);
}
var buildIdsMap = (value) => value && Array.isArray(value) && value.length > 0 ? value.map((v, index2) => {
  if (!v) return {};
  return {
    [getHashValue(v) + index2]: getRandomId()
  };
}).reduce((a2, b2) => ({
  ...a2,
  ...b2
}), {}) : {};
function ArrayContainer({
  droppableId,
  addLabel,
  value,
  disabled = false,
  buildEntry,
  size: size2 = "medium",
  onInternalIdAdded,
  includeAddButton: deprecatedIncludeAddButton,
  canAddElements: canAddElementsProp = true,
  sortable = true,
  newDefaultEntry,
  onValueChange,
  className,
  min: min3 = 0,
  max: max3 = Infinity
}) {
  const canAddElements = (canAddElementsProp || canAddElementsProp === void 0) && (deprecatedIncludeAddButton === void 0 || deprecatedIncludeAddButton);
  const hasValue = value && Array.isArray(value) && value.length > 0;
  const internalIdsRef = (0, import_react14.useRef)(buildIdsMap(value));
  const [internalIds, setInternalIds] = (0, import_react14.useState)(hasValue ? Object.values(internalIdsRef.current) : []);
  const itemCustomPropsRef = (0, import_react14.useRef)({});
  const updateItemCustomProps = (0, import_react14.useCallback)((internalId, customProps) => {
    itemCustomPropsRef.current[internalId] = customProps;
  }, []);
  (0, import_react14.useEffect)(() => {
    if (hasValue && value && value.length !== internalIds.length) {
      const newInternalIds = value.map((v, index2) => {
        const hashValue = getHashValue(v) + index2;
        if (hashValue in internalIdsRef.current) {
          return internalIdsRef.current[hashValue];
        } else {
          const newInternalId = getRandomId();
          internalIdsRef.current[hashValue] = newInternalId;
          return newInternalId;
        }
      });
      setInternalIds(newInternalIds);
    }
  }, [hasValue, internalIds.length, value]);
  const insertInEnd = (e2) => {
    e2.preventDefault();
    if (disabled || (value ?? []).length >= max3) return;
    const id2 = getRandomId();
    const newIds = [...internalIds, id2];
    if (onInternalIdAdded) onInternalIdAdded(id2);
    setInternalIds(newIds);
    onValueChange([...value ?? [], newDefaultEntry]);
  };
  const remove = (index_0) => {
    if ((value ?? []).length <= min3) return;
    const newIds_0 = [...internalIds];
    newIds_0.splice(index_0, 1);
    setInternalIds(newIds_0);
    onValueChange(value.filter((_, i2) => i2 !== index_0));
  };
  const copy2 = (index_1) => {
    if ((value ?? []).length >= max3) return;
    const id_0 = getRandomId();
    const copyingItem = value[index_1];
    const newIds_1 = [...internalIds.slice(0, index_1 + 1), id_0, ...internalIds.slice(index_1 + 1)];
    if (onInternalIdAdded) onInternalIdAdded(id_0);
    setInternalIds(newIds_1);
    onValueChange([...value.slice(0, index_1 + 1), copyingItem, ...value.slice(index_1 + 1)]);
  };
  const addInIndex = (index_2) => {
    if ((value ?? []).length >= max3) return;
    const id_1 = getRandomId();
    const newIds_2 = [...internalIds.slice(0, index_2), id_1, ...internalIds.slice(index_2)];
    if (onInternalIdAdded) onInternalIdAdded(id_1);
    setInternalIds(newIds_2);
    onValueChange([...value.slice(0, index_2), newDefaultEntry, ...value.slice(index_2)]);
  };
  const onDragEnd2 = (result) => {
    if (!result.destination) {
      return;
    }
    const sourceIndex = result.source.index;
    const destinationIndex = result.destination.index;
    const newIds_3 = [...internalIds];
    const temp = newIds_3[sourceIndex];
    newIds_3[sourceIndex] = newIds_3[destinationIndex];
    newIds_3[destinationIndex] = temp;
    setInternalIds(newIds_3);
    onValueChange(arrayMove(value, sourceIndex, destinationIndex));
  };
  return (0, import_jsx_runtime2.jsx)(DragDropContext, { onDragEnd: onDragEnd2, children: (0, import_jsx_runtime2.jsx)(ConnectedDroppable$1, { droppableId, renderClone: (provided, snapshot, rubric) => {
    const index_3 = rubric.source.index;
    const internalId_0 = internalIds[index_3];
    return (0, import_jsx_runtime2.jsx)(ArrayContainerItem, { provided, internalId: internalId_0, index: index_3, size: size2, disabled, buildEntry, remove, copy: copy2, isDragging: snapshot.isDragging, storedProps: itemCustomPropsRef.current[internalId_0], updateItemCustomProps, addInIndex, canAddElements, sortable });
  }, children: (droppableProvided, droppableSnapshot) => (0, import_jsx_runtime2.jsxs)("div", { className: cls("space-y-1", className), ...droppableProvided.droppableProps, ref: droppableProvided.innerRef, children: [
    hasValue && internalIds.map((internalId_1, index_4) => {
      return (0, import_jsx_runtime2.jsx)(PublicDraggable, { draggableId: `array_field_${internalId_1}`, isDragDisabled: disabled || !sortable, index: index_4, children: (provided_0, snapshot_0) => (0, import_jsx_runtime2.jsx)(ArrayContainerItem, { provided: provided_0, internalId: internalId_1, index: index_4, size: size2, disabled, buildEntry, remove, copy: copy2, isDragging: snapshot_0.isDragging, storedProps: itemCustomPropsRef.current[internalId_1], updateItemCustomProps, addInIndex, canAddElements, sortable }) }, `array_field_${internalId_1}`);
    }),
    droppableProvided.placeholder,
    canAddElements && (0, import_jsx_runtime2.jsx)("div", { className: "my-4 justify-center text-left", children: (0, import_jsx_runtime2.jsx)(Button, { variant: "text", size: size2 === "small" ? "small" : "medium", color: "primary", disabled: disabled || (value == null ? void 0 : value.length) >= max3, startIcon: (0, import_jsx_runtime2.jsx)(AddIcon, {}), onClick: insertInEnd, children: addLabel ?? "Add" }) })
  ] }) }) });
}
function ArrayContainerItem(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(30);
  const {
    provided,
    index: index2,
    internalId,
    size: size2,
    disabled,
    buildEntry,
    remove,
    addInIndex,
    canAddElements,
    sortable,
    copy: copy2,
    isDragging: isDragging2,
    storedProps,
    updateItemCustomProps
  } = t0;
  const t1 = provided.innerRef;
  const t2 = provided.draggableProps;
  const t3 = provided.draggableProps.style;
  const t4 = `relative ${!isDragging2 ? "hover:bg-surface-accent-50 dark:hover:bg-surface-800 dark:hover:bg-opacity-20" : ""} rounded-md opacity-100`;
  let t5;
  if ($[0] !== internalId || $[1] !== updateItemCustomProps) {
    t5 = (props) => updateItemCustomProps(internalId, props);
    $[0] = internalId;
    $[1] = updateItemCustomProps;
    $[2] = t5;
  } else {
    t5 = $[2];
  }
  let t6;
  if ($[3] !== buildEntry || $[4] !== index2 || $[5] !== internalId || $[6] !== isDragging2 || $[7] !== storedProps || $[8] !== t5) {
    t6 = buildEntry({
      index: index2,
      internalId,
      isDragging: isDragging2,
      storedProps,
      storeProps: t5
    });
    $[3] = buildEntry;
    $[4] = index2;
    $[5] = internalId;
    $[6] = isDragging2;
    $[7] = storedProps;
    $[8] = t5;
    $[9] = t6;
  } else {
    t6 = $[9];
  }
  let t7;
  if ($[10] !== t6) {
    t7 = (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow w-[calc(100%-48px)] text-text-primary dark:text-text-primary-dark", children: t6 });
    $[10] = t6;
    $[11] = t7;
  } else {
    t7 = $[11];
  }
  const t8 = size2 === "small" ? "row" : "column";
  let t9;
  if ($[12] !== addInIndex || $[13] !== canAddElements || $[14] !== copy2 || $[15] !== disabled || $[16] !== index2 || $[17] !== provided || $[18] !== remove || $[19] !== sortable || $[20] !== t8) {
    t9 = (0, import_jsx_runtime2.jsx)(ArrayItemOptions, { direction: t8, disabled, remove, index: index2, provided, addInIndex, canAddElements, sortable, copy: copy2 });
    $[12] = addInIndex;
    $[13] = canAddElements;
    $[14] = copy2;
    $[15] = disabled;
    $[16] = index2;
    $[17] = provided;
    $[18] = remove;
    $[19] = sortable;
    $[20] = t8;
    $[21] = t9;
  } else {
    t9 = $[21];
  }
  let t10;
  if ($[22] !== t7 || $[23] !== t9) {
    t10 = (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-start", children: [
      t7,
      t9
    ] });
    $[22] = t7;
    $[23] = t9;
    $[24] = t10;
  } else {
    t10 = $[24];
  }
  let t11;
  if ($[25] !== provided.draggableProps || $[26] !== provided.innerRef || $[27] !== t10 || $[28] !== t4) {
    t11 = (0, import_jsx_runtime2.jsx)("div", { ref: t1, ...t2, style: t3, className: t4, children: t10 });
    $[25] = provided.draggableProps;
    $[26] = provided.innerRef;
    $[27] = t10;
    $[28] = t4;
    $[29] = t11;
  } else {
    t11 = $[29];
  }
  return t11;
}
function ArrayItemOptions({
  direction: direction2,
  disabled,
  remove,
  index: index2,
  provided,
  copy: copy2,
  canAddElements,
  sortable,
  addInIndex
}) {
  const [menuOpen, setMenuOpen] = (0, import_react14.useState)(false);
  const iconRef = import_react14.default.useRef(null);
  useOutsideAlerter(iconRef, () => setMenuOpen(false));
  return (0, import_jsx_runtime2.jsx)("div", { className: `pl-2 pt-1 pb-1 flex ${direction2 === "row" ? "flex-row-reverse" : "flex-col"} items-center`, ref: iconRef, ...provided.dragHandleProps, children: (0, import_jsx_runtime2.jsxs)(Tooltip, { delayDuration: 400, open: menuOpen ? false : void 0, side: direction2 === "column" ? "left" : void 0, title: !disabled && sortable ? "Drag to move. Click for more options" : void 0, children: [
    (0, import_jsx_runtime2.jsx)(IconButton, { size: "small", disabled: disabled || !canAddElements, onClick: (e2) => {
      e2.preventDefault();
      setMenuOpen(true);
    }, onDragStart: (e_0) => {
      setMenuOpen(false);
    }, className: disabled || !sortable ? "cursor-inherit" : "cursor-grab", children: (0, import_jsx_runtime2.jsx)(HandleIcon, {}) }),
    (0, import_jsx_runtime2.jsxs)(Menu, { portalContainer: iconRef.current, open: menuOpen, trigger: (0, import_jsx_runtime2.jsx)("div", { tabIndex: -1 }), children: [
      (0, import_jsx_runtime2.jsxs)(MenuItem, { dense: true, onClick: (e_1) => {
        setMenuOpen(false);
        remove(index2);
      }, children: [
        (0, import_jsx_runtime2.jsx)(RemoveIcon, { size: "small" }),
        "Remove"
      ] }),
      (0, import_jsx_runtime2.jsxs)(MenuItem, { dense: true, onClick: () => {
        setMenuOpen(false);
        copy2(index2);
      }, children: [
        (0, import_jsx_runtime2.jsx)(ContentCopyIcon, { size: "small" }),
        "Copy"
      ] }),
      addInIndex && (0, import_jsx_runtime2.jsxs)(MenuItem, { dense: true, onClick: () => {
        setMenuOpen(false);
        addInIndex(index2);
      }, children: [
        (0, import_jsx_runtime2.jsx)(KeyboardArrowUpIcon, { size: "small" }),
        "Add on top"
      ] }),
      addInIndex && (0, import_jsx_runtime2.jsxs)(MenuItem, { dense: true, onClick: () => {
        setMenuOpen(false);
        addInIndex(index2 + 1);
      }, children: [
        (0, import_jsx_runtime2.jsx)(KeyboardArrowDownIcon, { size: "small" }),
        "Add below"
      ] })
    ] })
  ] }) });
}
function arrayMove(value, sourceIndex, destinationIndex) {
  const result = Array.from(value);
  const [removed] = result.splice(sourceIndex, 1);
  result.splice(destinationIndex, 0, removed);
  return result;
}
function getRandomId() {
  return Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER));
}
function ReferenceWidget({
  name,
  multiselect = false,
  path,
  disabled,
  value,
  onReferenceSelected,
  onMultipleReferenceSelected,
  previewProperties,
  forceFilter,
  size: size2,
  className,
  includeId,
  includeEntityLink
}) {
  const navigationController = useNavigationController();
  const collection = (0, import_react14.useMemo)(() => {
    return navigationController.getCollection(path);
  }, [path, navigationController.getCollection]);
  const onSingleEntitySelected = (0, import_react14.useCallback)((entity) => {
    if (disabled) return;
    if (onReferenceSelected) {
      const reference2 = entity ? getReferenceFrom(entity) : null;
      onReferenceSelected == null ? void 0 : onReferenceSelected({
        reference: reference2,
        entity
      });
    }
  }, [disabled, onReferenceSelected]);
  const onMultipleEntitiesSelected = (0, import_react14.useCallback)((entities) => {
    if (disabled) return;
    if (onMultipleReferenceSelected) {
      const references = entities ? entities.map((e2) => getReferenceFrom(e2)) : null;
      onMultipleReferenceSelected({
        references,
        entities
      });
    }
  }, [disabled, onReferenceSelected]);
  const referenceDialogController = useReferenceDialog({
    multiselect,
    path,
    collection,
    onSingleEntitySelected,
    onMultipleEntitiesSelected,
    forceFilter
  });
  (0, import_react14.useCallback)((e_0) => {
    e_0.stopPropagation();
    if (multiselect) {
      onMultipleEntitiesSelected([]);
    } else {
      onSingleEntitySelected(null);
    }
  }, [onReferenceSelected]);
  let child;
  const onEntryClick = () => {
    if (disabled) return;
    referenceDialogController.open();
  };
  if (Array.isArray(value)) {
    child = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col gap-4", children: value.map((ref2, index2) => {
      return (0, import_jsx_runtime2.jsx)(ReferencePreview, { onClick: onEntryClick, reference: ref2, disabled, previewProperties, size: size2, includeId, includeEntityLink }, `reference_preview_${index2}`);
    }) });
  } else if ((value == null ? void 0 : value.isEntityReference) && (value == null ? void 0 : value.isEntityReference())) {
    child = (0, import_jsx_runtime2.jsx)(ReferencePreview, { reference: value, onClick: onEntryClick, disabled, previewProperties, size: size2, includeId, includeEntityLink });
  }
  return (0, import_jsx_runtime2.jsxs)("div", { className: cls("text-sm font-medium", "min-w-80 flex flex-col gap-4", "relative transition-colors duration-200 ease-in rounded font-medium", disabled ? "bg-opacity-50" : "hover:bg-opacity-75", "text-opacity-50 dark:text-white dark:text-opacity-50", className), children: [
    child,
    !value && (0, import_jsx_runtime2.jsx)("div", { className: "justify-center text-left", children: (0, import_jsx_runtime2.jsxs)(Button, { variant: "outlined", color: "primary", disabled, onClick: onEntryClick, children: [
      "Edit ",
      name
    ] }) })
  ] });
}
var UPDATE_SEARCH_INDEX_WAIT_MS = 220;
if (true) {
  Object.keys(iconSynonyms).forEach((icon) => {
    if (!iconKeys.includes(icon)) {
      console.warn(`The icon ${icon} no longer exists. Remove it from \`iconSynonyms\``);
    }
  });
}
function SearchIconsView(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(14);
  const {
    selectedIcon: t1,
    onIconSelected
  } = t0;
  const selectedIcon = t1 === void 0 ? "" : t1;
  const [keys2, setKeys] = import_react14.default.useState(null);
  const [query, setQuery] = import_react14.default.useState("");
  let t2;
  let t3;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = debounce((value) => {
      if (!value || value === "") {
        setKeys(null);
      } else {
        const searchResult = iconsSearch.search(value);
        const limited = searchResult.slice(0, 50);
        setKeys(limited.map(_temp$6));
      }
    }, UPDATE_SEARCH_INDEX_WAIT_MS);
    $[0] = t3;
  } else {
    t3 = $[0];
  }
  t2 = t3;
  const updateSearchResults = t2;
  let t4;
  let t5;
  if ($[1] !== query) {
    t4 = () => {
      updateSearchResults(query);
      return () => {
        updateSearchResults.clear();
      };
    };
    t5 = [query, updateSearchResults];
    $[1] = query;
    $[2] = t4;
    $[3] = t5;
  } else {
    t4 = $[2];
    t5 = $[3];
  }
  import_react14.default.useEffect(t4, t5);
  const icons = keys2 === null ? coolIconKeys : keys2;
  let t6;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = (0, import_jsx_runtime2.jsx)(SearchBar, { autoFocus: false, innerClassName: "w-full sticky top-0 z-10", onTextSearch: (value_0) => setQuery(value_0 ?? ""), placeholder: "Search for more icons…" });
    $[4] = t6;
  } else {
    t6 = $[4];
  }
  let t7;
  if ($[5] !== icons || $[6] !== onIconSelected || $[7] !== selectedIcon) {
    let t82;
    if ($[9] !== onIconSelected || $[10] !== selectedIcon) {
      t82 = (icon) => (0, import_jsx_runtime2.jsx)(Tooltip, { title: icon, asChild: true, children: (0, import_jsx_runtime2.jsx)(IconButton, { shape: "square", toggled: selectedIcon === icon, onClick: onIconSelected ? () => onIconSelected(icon) : void 0, className: "box-content m-1", children: (0, import_jsx_runtime2.jsx)(Icon, { iconKey: icon, size: 24 }) }) }, icon);
      $[9] = onIconSelected;
      $[10] = selectedIcon;
      $[11] = t82;
    } else {
      t82 = $[11];
    }
    t7 = icons.map(t82);
    $[5] = icons;
    $[6] = onIconSelected;
    $[7] = selectedIcon;
    $[8] = t7;
  } else {
    t7 = $[8];
  }
  let t8;
  if ($[12] !== t7) {
    t8 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t6,
      (0, import_jsx_runtime2.jsx)("div", { className: "flex max-w-full flex-wrap mt-4", children: t7 })
    ] });
    $[12] = t7;
    $[13] = t8;
  } else {
    t8 = $[13];
  }
  return t8;
}
function _temp$6(e2) {
  return e2.item.key;
}
function FieldCaption(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(3);
  const {
    error: error2,
    children
  } = t0;
  if (!children) {
    return null;
  }
  const t1 = error2 ? "error" : "secondary";
  let t2;
  if ($[0] !== children || $[1] !== t1) {
    t2 = (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", color: t1, className: "ml-3.5 mt-0.5", children });
    $[0] = children;
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  return t2;
}
function useReferenceDialog(referenceDialogProps) {
  const $ = (0, import_react_compiler_runtime3.c)(9);
  const navigation = useNavigationController();
  const sideDialogsController = useSideDialogsController();
  let t0;
  if ($[0] !== navigation || $[1] !== referenceDialogProps || $[2] !== sideDialogsController) {
    t0 = () => {
      if (referenceDialogProps.path) {
        let usedCollection = referenceDialogProps.collection;
        if (!usedCollection) {
          usedCollection = navigation.getCollection(referenceDialogProps.path);
        }
        if (!usedCollection) {
          throw Error("Not able to resolve the collection in useReferenceDialog. Make sure a collection is registered in path " + referenceDialogProps.path);
        }
        sideDialogsController.open({
          key: `reference_${referenceDialogProps.path}`,
          component: (0, import_jsx_runtime2.jsx)(ReferenceSelectionTable, { collection: usedCollection, ...referenceDialogProps }),
          width: "90vw",
          onClose: () => {
            var _a;
            (_a = referenceDialogProps.onClose) == null ? void 0 : _a.call(referenceDialogProps);
          }
        });
      } else {
        throw Error("useReferenceDialog: You are trying to open a reference dialog, but have not declared the `path`");
      }
    };
    $[0] = navigation;
    $[1] = referenceDialogProps;
    $[2] = sideDialogsController;
    $[3] = t0;
  } else {
    t0 = $[3];
  }
  const open = t0;
  let t1;
  if ($[4] !== sideDialogsController) {
    t1 = () => {
      sideDialogsController.close();
    };
    $[4] = sideDialogsController;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const close2 = t1;
  let t2;
  if ($[6] !== close2 || $[7] !== open) {
    t2 = {
      open,
      close: close2
    };
    $[6] = close2;
    $[7] = open;
    $[8] = t2;
  } else {
    t2 = $[8];
  }
  return t2;
}
var fireCMSLogo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAASAAAAEgARslrPgAAB9pJREFUWMONl12obVUVx39jzLk+9j7nHq9y1QT1qpcbSIaXQFGs24PQl3HroSQyqHwJFJF6qaceCsqQoJdELHoIC6EeJCSKsi/TFLGozGsKXksljRLxnrP3WmvOOUYPa+19zsmPWpux5pxrzTX///Exx5hb+B/X1y+/nuIlVKF5m0v1YbQ55tIcKTQXFerNQkumOZ1oTiXCqUH8saR+74L8ZIWWux7+7JuuL2/04s5jJyhWQlXV71KtbhCtr1WtD6s0KlrjNBRaEi3JGzpv6bymQ0sn9mwv9otB7Ls7kn9Xo+U7D9z8/xG4+bz3cs35SjE/HEK8NWr8RBOrs+tQUUlEtAYaijRkbxmY0fuMzucsfcbSWnZQtiWxJL3Uid09iH0jIM8/1f+d3/zuS29M4PvHrmG+cZA8dMdjiLfNYrx6owrMVKlVUQkgkeI1iYbBJ3A2WPpKNtnx+UQisy29L0gPDGKfrwkPn2bJPfd/Zo0ZVp0fvOOdnLGxheX+A/Mq3nGwqS8/q645o4psxkgbhFqdSgqVJKIkghgqjuDoWh+dlm1AI0gUC3o4C9d04idbmZ06euQDPPHMj3YJ3HnkrZx98Fys2PFZ1dxxsJkdPbOecaBqmcWGqBVBIkEiKkoQJ5IJJBTbY8aRgBMwjxgVJoJJwDScnYUrOy2PBamfv/CS4zz9zE+IAIfPuQQzPzyrmq9u1e3RM+qWeaipNCCiE4DjbjgF94xZQj2htpjeK84ImqlIUpO9JllgEKgJDFpfOoh8paN8chbOeQ4g/OTq97PdLXSz3fjiVjO7/sx6g804ow41QWuCrjQPBB3bkZQgAkpBJOMojmIEjIgRKV6RpaYIZHGKQlK5OIv0L8bul8eOfsxjDJGD8613z6rmhq1qxkY1o9YKFUFEEED2xqoE1MNoWgPBwQZMl2SrSbQM9NQyUMlA5S3Rlcqd6E50RdRvPMvn9yE8qP9+9WWtQvXxzdic8xrwPaJrUYJGoq4sVBM1Ukuiln4UBipJVJrGoHUhrARB0XMQ/cizbSd61uaZlzUhXjuvWmqt9oOyAmUPEabnkSDV2j0Rp2YgksZdQpoCtRBwAiN4cKYdw4m3pNnbY9Tw4SZUh9tQEda+ld1WpmThgoivU8fYDbgEggRcleiZ6BOoFNRXLQQX1Eelggsgh8GPx6DhWB2iRgkj2OTuVX8dBzJtMx93BAKK4hIwUUSEID4BGspecWTfDwSCw+UxqByJoqPf9+xmYWQg7H3u+5Poyk3o5BZDxRBxxH29fdkF3YcBXKHgF+m+hLxn4OvbnnbPzMkjsm/+f5cXec2ye6ZfpO6+OX7pE8TqPj1zcN/7Zu8CDm44Bu6skrKjuOs0FlxWCJNMYxMOqLlR3DAvsAKaZo6t7+u7r6nhjN/5RKIQKESKhykhjeIINgJi+0m4Fiuns2WKZQybtJ2AfAWzGu/ayt0wz5gXimeKQyKSPI4kiCMhDxSgyLiOiY9kxnW2NVs+1ZeBbAmzhLmtgd0d8z1k1mIUTxQbKD5gnkmuDN6QvCF5TaIie0UmkIU1id3WcfwZHUo61eWB3gayDdOiZR+JXUuMWmcbyGWcny2RzOi8obeWwRsGrxm8JlGPBHCyOJmpJkwkHHs09pnfL1L60KLqtBKZtprhU+lVmSq9+xRsBfOMW6L4QLFM7zWdz+l8Ru8tA+10YKlJIiSxkcC6dQqlmJc/xaHIvTuZT7UpHalFUHEqL6iGsfKtM8FEzMdy7J4oXui9mk5CczpGErtEKgacQUZJE3gSwzw/i+dfx2G7e6IcOPALCXIkakGkYx4iwceyq+uENPp+RSI7DN7Q+5ylb7JgJLH0+XRGbOlRerWJwNgmnOwJ83Tvq/7KX2KZb1nJfnfp5YRoda7hFC/MQyGI7Mteow2E4pHkDT2zyfS758HV4bSjolOjF2PYS4KBbN2L5vmHZ7DpsWQnDsvfLj1+Lwufy9LSO2y5M1Mnik8OEJxAoSJRk7xhoKX3+URiztI3WPgGS2/p1OnE6CcSvRQGH+htQfH07dPSP7Lp9ajcNy+9DnG/oMT67qqZHz/QtGxVyjworQqVCIjiPiaaTD1ttZZ+fTIeCXQ+Y6HCQm0tO5LYpmfHlyy9/1nCPi3ICw/99JbxUHrdvxr6Q4depdhTfeGapVeH+imKxwhv6ZnR+5zeN0aNGU2+ZIPON0cX0LBQYSnGQgsLSSzoWdiCHVvQ2fLP2fMtwf2vDz50K6TpVPxj/sn7Ni5iu9l6Tof+yd78yoWFQ0uvWYvVLK1h6e34B8RnY9DZnIW3LAijxpLYkZ6Fd+z4km3bYcd2WNry8ezppsZ5ZMd2+MfTv3xtjbr9/PfwyoFDzPvtq7I2t+Vq/m6pt4hxThVaojao1CANRkORmkwkiTCI00thKYWOzJJR+6V1JE8/z2JfqGgfW9jLPPLg7a9Xe8frHs7j5MVXESxfmLS5KYXmxhQ3z/a4icQNRFtEGlwjJkoRIamTmIKNTE+it57kw0sF+1ah3CkSXkiPf42Htl+3WL/2+vIFJ6ishJ3QXD1o9dEhVCcGbS7ModUcakwrigaKChkoYmQK2XMp5L8V/F7DfuDePYrEcv8f7npdnDcksEvkg9RewquhuayTcHzQeCyJXpFVD2fRzSxCFtkuwqks8mjB/ujYr9y6k0gs9528503X/w/F3eUgyIBI4wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMS0wNS0xMFQxOToyODozMyswMDowMEzeSx4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjEtMDUtMTBUMTk6Mjg6MzMrMDA6MDA9g/OiAAAARnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjcuOC05IDIwMTQtMDUtMTIgUTE2IGh0dHA6Ly93d3cuaW1hZ2VtYWdpY2sub3Jn3IbtAAAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABh0RVh0VGh1bWI6OkltYWdlOjpoZWlnaHQAMTkyDwByhQAAABd0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAAxOTLTrCEIAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADE2MjA2NzQ5MTMk8oswAAAAD3RFWHRUaHVtYjo6U2l6ZQAwQkKUoj7sAAAAVnRFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vbW50bG9nL2Zhdmljb25zLzIwMjEtMDUtMTAvOGIxNDNhYjgwODhkMjBlZThkYmUzOTFhN2NkNmQ3NmQuaWNvLnBuZ9msgG0AAAAASUVORK5CYII=\n";
function useBrowserTitleAndIcon(name, logo) {
  const $ = (0, import_react_compiler_runtime3.c)(4);
  let t0;
  let t1;
  if ($[0] !== logo || $[1] !== name) {
    t0 = () => {
      if (document) {
        document.title = `${name} - FireCMS`;
        let link = document.querySelector("link[rel~='icon']");
        if (!link) {
          link = document.createElement("link");
          link.rel = "icon";
          document.getElementsByTagName("head")[0].appendChild(link);
        }
        link.href = logo ?? fireCMSLogo;
      }
    };
    t1 = [name, logo];
    $[0] = logo;
    $[1] = name;
    $[2] = t0;
    $[3] = t1;
  } else {
    t0 = $[2];
    t1 = $[3];
  }
  (0, import_react14.useEffect)(t0, t1);
}
function getParentReferencesFromPath(props) {
  const {
    path,
    collections = [],
    currentFullPath
  } = props;
  const subpaths = removeInitialAndTrailingSlashes(path).split("/");
  const subpathCombinations = getCollectionPathsCombinations(subpaths);
  const result = [];
  for (let i2 = 0; i2 < subpathCombinations.length; i2++) {
    const subpathCombination = subpathCombinations[i2];
    const collection = collections && collections.find((entry) => entry.id === subpathCombination || entry.path === subpathCombination);
    if (collection) {
      const collectionPath = currentFullPath && currentFullPath.length > 0 ? currentFullPath + "/" + collection.path : collection.path;
      const restOfThePath = removeInitialAndTrailingSlashes(removeInitialAndTrailingSlashes(path).replace(subpathCombination, ""));
      const nextSegments = restOfThePath.length > 0 ? restOfThePath.split("/") : [];
      if (nextSegments.length > 0) {
        const entityId = nextSegments[0];
        const fullPath = collectionPath + "/" + entityId;
        result.push(new EntityReference(entityId, collectionPath));
        if (nextSegments.length > 1) {
          const newPath = nextSegments.slice(1).join("/");
          if (!collection) {
            throw Error("collection not found resolving path: " + collection);
          }
          if (collection.subcollections) {
            result.push(...getParentReferencesFromPath({
              path: newPath,
              collections: collection.subcollections,
              currentFullPath: fullPath
            }));
          }
        }
      }
      break;
    }
  }
  return result;
}
var DEFAULT_BASE_PATH = "/";
var DEFAULT_COLLECTION_PATH = "/c";
function useBuildNavigationController(props) {
  const {
    basePath = DEFAULT_BASE_PATH,
    baseCollectionPath = DEFAULT_COLLECTION_PATH,
    authController,
    collections: collectionsProp,
    collectionPermissions,
    views: viewsProp,
    adminViews: adminViewsProp,
    viewsOrder,
    userConfigPersistence,
    dataSourceDelegate,
    injectCollections,
    disabled
  } = props;
  const navigate = useNavigate();
  const collectionsRef = (0, import_react14.useRef)();
  const viewsRef = (0, import_react14.useRef)();
  const adminViewsRef = (0, import_react14.useRef)();
  const [initialised, setInitialised] = (0, import_react14.useState)(false);
  const [topLevelNavigation, setTopLevelNavigation] = (0, import_react14.useState)(void 0);
  const [navigationLoading, setNavigationLoading] = (0, import_react14.useState)(true);
  const [navigationLoadingError, setNavigationLoadingError] = (0, import_react14.useState)(void 0);
  const cleanBasePath = removeInitialAndTrailingSlashes(basePath);
  const cleanBaseCollectionPath = removeInitialAndTrailingSlashes(baseCollectionPath);
  const homeUrl = cleanBasePath ? `/${cleanBasePath}` : "/";
  const fullCollectionPath = cleanBasePath ? `/${cleanBasePath}/${cleanBaseCollectionPath}` : `/${cleanBaseCollectionPath}`;
  const buildCMSUrlPath = (0, import_react14.useCallback)((path) => cleanBasePath ? `/${cleanBasePath}/${encodePath(path)}` : `/${encodePath(path)}`, [cleanBasePath]);
  const buildUrlCollectionPath = (0, import_react14.useCallback)((path_0) => `${removeInitialAndTrailingSlashes(baseCollectionPath)}/${encodePath(path_0)}`, [baseCollectionPath]);
  const computeTopNavigation = (0, import_react14.useCallback)((collections, views, adminViews, viewsOrder_0) => {
    let navigationEntries = [...(collections ?? []).map((collection) => {
      var _a;
      return !collection.hideFromNavigation ? {
        url: buildUrlCollectionPath(collection.id ?? collection.path),
        type: "collection",
        name: collection.name.trim(),
        path: collection.id ?? collection.path,
        collection,
        description: (_a = collection.description) == null ? void 0 : _a.trim(),
        group: getGroup(collection)
      } : void 0;
    }).filter(Boolean), ...(views ?? []).map((view) => {
      var _a;
      return !view.hideFromNavigation ? {
        url: buildCMSUrlPath(Array.isArray(view.path) ? view.path[0] : view.path),
        name: view.name.trim(),
        type: "view",
        path: view.path,
        view,
        description: (_a = view.description) == null ? void 0 : _a.trim(),
        group: getGroup(view)
      } : void 0;
    }).filter(Boolean), ...(adminViews ?? []).map((view_0) => {
      var _a;
      return !view_0.hideFromNavigation ? {
        url: buildCMSUrlPath(Array.isArray(view_0.path) ? view_0.path[0] : view_0.path),
        name: view_0.name.trim(),
        type: "admin",
        path: view_0.path,
        view: view_0,
        description: (_a = view_0.description) == null ? void 0 : _a.trim(),
        group: "Admin"
      } : void 0;
    }).filter(Boolean)];
    navigationEntries = navigationEntries.sort((a2, b2) => {
      if (a2.group !== "Views" && a2.group !== "Admin" && (b2.group === "Views" || b2.group === "Admin")) {
        return -1;
      }
      if (b2.group !== "Views" && b2.group !== "Admin" && (a2.group === "Views" || a2.group === "Admin")) {
        return 1;
      }
      if (a2.group === "Admin" && b2.group !== "Admin") {
        return 1;
      }
      if (a2.group !== "Admin" && b2.group === "Admin") {
        return -1;
      }
      if (a2.group === "Views" && b2.group !== "Views") {
        return -1;
      }
      if (a2.group !== "Views" && b2.group === "Views") {
        return 1;
      }
      return 0;
    });
    if (viewsOrder_0) {
      navigationEntries = navigationEntries.sort((a_0, b_0) => {
        const aIndex = viewsOrder_0.indexOf(a_0.path);
        const bIndex = viewsOrder_0.indexOf(b_0.path);
        if (aIndex === -1 && bIndex === -1) {
          return 0;
        }
        if (aIndex === -1) {
          return 1;
        }
        if (bIndex === -1) {
          return -1;
        }
        return aIndex - bIndex;
      });
    }
    const groups = Object.values(navigationEntries).map((e2) => e2.group).filter(Boolean).filter((value, index2, array2) => array2.indexOf(value) === index2);
    return {
      navigationEntries,
      groups
    };
  }, [buildCMSUrlPath, buildUrlCollectionPath]);
  const refreshNavigation = (0, import_react14.useCallback)(async () => {
    if (disabled || authController.initialLoading) return;
    console.debug("Refreshing navigation");
    try {
      const [resolvedCollections = [], resolvedViews, resolvedAdminViews = []] = await Promise.all([resolveCollections(collectionsProp, collectionPermissions, authController, dataSourceDelegate, injectCollections), resolveCMSViews(viewsProp, authController, dataSourceDelegate), resolveCMSViews(adminViewsProp, authController, dataSourceDelegate)]);
      let shouldUpdateTopLevelNav = false;
      if (!areCollectionListsEqual(collectionsRef.current ?? [], resolvedCollections)) {
        collectionsRef.current = resolvedCollections;
        console.debug("Collections have changed", resolvedCollections);
        shouldUpdateTopLevelNav = true;
      }
      if (collectionsRef.current === void 0) {
        collectionsRef.current = resolvedCollections;
        shouldUpdateTopLevelNav = true;
      }
      if (!(0, import_react_fast_compare2.default)(viewsRef.current, resolvedViews)) {
        viewsRef.current = resolvedViews;
        shouldUpdateTopLevelNav = true;
      }
      if (!(0, import_react_fast_compare2.default)(adminViewsRef.current, resolvedAdminViews)) {
        adminViewsRef.current = resolvedAdminViews;
        shouldUpdateTopLevelNav = true;
      }
      const computedTopLevelNav = computeTopNavigation(resolvedCollections, resolvedViews, resolvedAdminViews, viewsOrder);
      if (shouldUpdateTopLevelNav && !(0, import_react_fast_compare2.default)(topLevelNavigation, computedTopLevelNav)) {
        setTopLevelNavigation(computedTopLevelNav);
      }
    } catch (e_0) {
      console.error(e_0);
      setNavigationLoadingError(e_0);
    }
    if (navigationLoading) setNavigationLoading(false);
    if (!initialised) setInitialised(true);
  }, [collectionsProp, collectionPermissions, authController.user, authController.initialLoading, disabled, viewsProp, adminViewsProp, computeTopNavigation, injectCollections]);
  (0, import_react14.useEffect)(() => {
    refreshNavigation();
  }, [refreshNavigation]);
  const getCollection = (0, import_react14.useCallback)((idOrPath, includeUserOverride = false) => {
    const collections_0 = collectionsRef.current;
    if (!collections_0) return void 0;
    const baseCollection = getCollectionByPathOrId(removeInitialAndTrailingSlashes(idOrPath), collections_0);
    const userOverride = includeUserOverride ? userConfigPersistence == null ? void 0 : userConfigPersistence.getCollectionConfig(idOrPath) : void 0;
    const overriddenCollection = baseCollection ? mergeDeep2(baseCollection, userOverride ?? {}) : void 0;
    let result = overriddenCollection;
    if (overriddenCollection) {
      const subcollections = overriddenCollection.subcollections;
      const callbacks = overriddenCollection.callbacks;
      const permissions = overriddenCollection.permissions;
      result = {
        ...result,
        subcollections: (result == null ? void 0 : result.subcollections) ?? subcollections,
        callbacks: (result == null ? void 0 : result.callbacks) ?? callbacks,
        permissions: (result == null ? void 0 : result.permissions) ?? permissions
      };
    }
    if (!result) return void 0;
    return {
      ...overriddenCollection,
      ...result
    };
  }, [userConfigPersistence]);
  const getCollectionById = (0, import_react14.useCallback)((id2) => {
    const collections_1 = collectionsRef.current;
    if (collections_1 === void 0) throw Error("getCollectionById: Collections have not been initialised yet");
    const collection_0 = collections_1.find((c22) => c22.id === id2);
    if (!collection_0) return void 0;
    return collection_0;
  }, []);
  const getCollectionFromPaths = (0, import_react14.useCallback)((pathSegments) => {
    const collections_2 = collectionsRef.current;
    if (collections_2 === void 0) throw Error("getCollectionFromPaths: Collections have not been initialised yet");
    let currentCollections = [...collections_2 ?? []];
    for (let i2 = 0; i2 < pathSegments.length; i2++) {
      const pathSegment = pathSegments[i2];
      const collection_1 = currentCollections.find((c_0) => c_0.id === pathSegment || c_0.path === pathSegment);
      if (!collection_1) return void 0;
      currentCollections = collection_1.subcollections;
      if (i2 === pathSegments.length - 1) return collection_1;
    }
    return void 0;
  }, []);
  const getCollectionFromIds = (0, import_react14.useCallback)((ids) => {
    const collections_3 = collectionsRef.current;
    if (collections_3 === void 0) throw Error("getCollectionFromIds: Collections have not been initialised yet");
    let currentCollections_0 = [...collections_3 ?? []];
    for (let i_0 = 0; i_0 < ids.length; i_0++) {
      const id_0 = ids[i_0];
      const collection_2 = currentCollections_0.find((c_1) => c_1.id === id_0);
      if (!collection_2) return void 0;
      currentCollections_0 = collection_2.subcollections;
      if (i_0 === ids.length - 1) return collection_2;
    }
    return void 0;
  }, []);
  const isUrlCollectionPath = (0, import_react14.useCallback)((path_1) => removeInitialAndTrailingSlashes(path_1 + "/").startsWith(removeInitialAndTrailingSlashes(fullCollectionPath) + "/"), [fullCollectionPath]);
  const urlPathToDataPath = (0, import_react14.useCallback)((path_2) => {
    if (path_2.startsWith(fullCollectionPath)) return path_2.replace(fullCollectionPath, "");
    throw Error("Expected path starting with " + fullCollectionPath);
  }, [fullCollectionPath]);
  const resolveIdsFrom = (0, import_react14.useCallback)((path_3) => {
    const collections_4 = collectionsRef.current ?? [];
    return resolveCollectionPathIds(path_3, collections_4);
  }, []);
  const getAllParentReferencesForPath = (0, import_react14.useCallback)((path_4) => {
    const collections_5 = collectionsRef.current ?? [];
    return getParentReferencesFromPath({
      path: path_4,
      collections: collections_5
    });
  }, []);
  const getParentCollectionIds = (0, import_react14.useCallback)((path_5) => {
    const strings = path_5.split("/");
    const oddPathSegments = strings.filter((_, i_1) => i_1 % 2 === 0);
    oddPathSegments.pop();
    const result_0 = [];
    for (let i_2 = 1; i_2 <= oddPathSegments.length; i_2++) {
      result_0.push(oddPathSegments.slice(0, i_2));
    }
    return result_0.map((r2) => {
      var _a;
      return (_a = getCollectionFromPaths(r2)) == null ? void 0 : _a.id;
    }).filter(Boolean);
  }, [getAllParentReferencesForPath]);
  const convertIdsToPaths = (0, import_react14.useCallback)((ids_0) => {
    const collections_6 = collectionsRef.current;
    let currentCollections_1 = collections_6;
    const paths = [];
    for (let i_3 = 0; i_3 < ids_0.length; i_3++) {
      const id_1 = ids_0[i_3];
      const collection_3 = currentCollections_1.find((c_2) => c_2.id === id_1);
      if (!collection_3) throw Error(`Collection with id ${id_1} not found`);
      paths.push(collection_3.path);
      currentCollections_1 = collection_3.subcollections;
    }
    return paths;
  }, [getCollectionFromIds]);
  return {
    collections: collectionsRef.current,
    views: viewsRef.current,
    adminViews: adminViewsRef.current,
    loading: !initialised || navigationLoading,
    navigationLoadingError,
    homeUrl,
    basePath,
    baseCollectionPath,
    initialised,
    getCollection,
    getCollectionById,
    getCollectionFromPaths,
    getCollectionFromIds,
    isUrlCollectionPath,
    urlPathToDataPath,
    buildUrlCollectionPath,
    resolveIdsFrom,
    topLevelNavigation,
    refreshNavigation,
    getParentReferencesFromPath: getAllParentReferencesForPath,
    getParentCollectionIds,
    convertIdsToPaths,
    navigate
  };
}
function encodePath(input) {
  return encodeURIComponent(removeInitialAndTrailingSlashes(input)).replaceAll("%2F", "/").replaceAll("%23", "#");
}
function filterOutNotAllowedCollections(resolvedCollections, authController) {
  return resolvedCollections.filter((c22) => Boolean(c22.path)).filter((c22) => {
    if (!c22.permissions) return true;
    const resolvedPermissions = resolvePermissions(c22, authController, c22.path, null);
    return (resolvedPermissions == null ? void 0 : resolvedPermissions.read) !== false;
  }).map((c22) => {
    if (!c22.subcollections) return c22;
    return {
      ...c22,
      subcollections: filterOutNotAllowedCollections(c22.subcollections, authController)
    };
  });
}
async function resolveCollections(collections, collectionPermissions, authController, dataSource, injectCollections) {
  let resolvedCollections = [];
  if (typeof collections === "function") {
    resolvedCollections = await collections({
      user: authController.user,
      authController,
      dataSource
    });
  } else if (Array.isArray(collections)) {
    resolvedCollections = collections;
  }
  if (injectCollections) {
    resolvedCollections = injectCollections(resolvedCollections ?? []);
  }
  resolvedCollections = applyPermissionsFunctionIfEmpty(resolvedCollections, collectionPermissions);
  resolvedCollections = filterOutNotAllowedCollections(resolvedCollections, authController);
  return resolvedCollections;
}
async function resolveCMSViews(baseViews, authController, dataSource) {
  let resolvedViews = [];
  if (typeof baseViews === "function") {
    resolvedViews = await baseViews({
      user: authController.user,
      authController,
      dataSource
    });
  } else if (Array.isArray(baseViews)) {
    resolvedViews = baseViews;
  }
  return resolvedViews;
}
function getGroup(collectionOrView) {
  var _a;
  const trimmed = (_a = collectionOrView.group) == null ? void 0 : _a.trim();
  if (!trimmed || trimmed === "") {
    return "Views";
  }
  return trimmed ?? "Views";
}
function areCollectionListsEqual(a2, b2) {
  if (a2.length !== b2.length) {
    return false;
  }
  const aCopy = [...a2];
  const bCopy = [...b2];
  const aSorted = aCopy.sort((x, y) => x.id.localeCompare(y.id));
  const bSorted = bCopy.sort((x, y) => x.id.localeCompare(y.id));
  return aSorted.every((value, index2) => areCollectionsEqual(value, bSorted[index2]));
}
function areCollectionsEqual(a2, b2) {
  const {
    subcollections: subcollectionsA,
    ...restA
  } = a2;
  const {
    subcollections: subcollectionsB,
    ...restB
  } = b2;
  if (!areCollectionListsEqual(subcollectionsA ?? [], subcollectionsB ?? [])) {
    return false;
  }
  return (0, import_react_fast_compare2.default)(removeFunctions(restA), removeFunctions(restB));
}
function useBuildLocalConfigurationPersistence() {
  const $ = (0, import_react_compiler_runtime3.c)(15);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = {};
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const configCache = (0, import_react14.useRef)(t0);
  const getCollectionFromStorage = _temp$5;
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = (path) => {
      const storageKey_0 = `collection_config::${stripCollectionPath(path)}`;
      if (configCache.current[storageKey_0]) {
        return configCache.current[storageKey_0];
      }
      return getCollectionFromStorage(storageKey_0);
    };
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const getCollectionConfig = t1;
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (path_0, data) => {
      const storageKey_1 = `collection_config::${stripCollectionPath(path_0)}`;
      localStorage.setItem(storageKey_1, JSON.stringify(data));
      const cachedConfig = configCache.current[storageKey_1];
      const newConfig = mergeDeep2(cachedConfig ?? getCollectionFromStorage(path_0), data);
      configCache.current[storageKey_1] = mergeDeep2(configCache.current[storageKey_1], newConfig);
    };
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const onCollectionModified = t2;
  let t3;
  if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = [];
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const [recentlyVisitedPaths, _setRecentlyVisitedPaths] = (0, import_react14.useState)(t3);
  let t4;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = [];
    $[4] = t4;
  } else {
    t4 = $[4];
  }
  const [favouritePaths, _setFavouritePaths] = (0, import_react14.useState)(t4);
  let t5;
  if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = [];
    $[5] = t5;
  } else {
    t5 = $[5];
  }
  const [collapsedGroups, _setCollapsedGroups] = (0, import_react14.useState)(t5);
  let t6;
  let t7;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = () => {
      _setRecentlyVisitedPaths(localStorage.getItem("recently_visited_paths") ? JSON.parse(localStorage.getItem("recently_visited_paths")) : []);
      _setFavouritePaths(localStorage.getItem("favourite_paths") ? JSON.parse(localStorage.getItem("favourite_paths")) : []);
      _setCollapsedGroups(localStorage.getItem("collapsed_groups") ? JSON.parse(localStorage.getItem("collapsed_groups")) : []);
    };
    t7 = [];
    $[6] = t6;
    $[7] = t7;
  } else {
    t6 = $[6];
    t7 = $[7];
  }
  (0, import_react14.useEffect)(t6, t7);
  let t8;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t8 = (paths) => {
      localStorage.setItem("recently_visited_paths", JSON.stringify(paths));
      _setRecentlyVisitedPaths(paths);
    };
    $[8] = t8;
  } else {
    t8 = $[8];
  }
  const setRecentlyVisitedPaths = t8;
  let t9;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t9 = (paths_0) => {
      localStorage.setItem("favourite_paths", JSON.stringify(paths_0));
      _setFavouritePaths(paths_0);
    };
    $[9] = t9;
  } else {
    t9 = $[9];
  }
  const setFavouritePaths = t9;
  let t10;
  if ($[10] === Symbol.for("react.memo_cache_sentinel")) {
    t10 = (paths_1) => {
      localStorage.setItem("collapsed_groups", JSON.stringify(paths_1));
      _setCollapsedGroups(paths_1);
    };
    $[10] = t10;
  } else {
    t10 = $[10];
  }
  const setCollapsedGroups = t10;
  let t11;
  if ($[11] !== collapsedGroups || $[12] !== favouritePaths || $[13] !== recentlyVisitedPaths) {
    t11 = {
      onCollectionModified,
      getCollectionConfig,
      recentlyVisitedPaths,
      setRecentlyVisitedPaths,
      favouritePaths,
      setFavouritePaths,
      collapsedGroups,
      setCollapsedGroups
    };
    $[11] = collapsedGroups;
    $[12] = favouritePaths;
    $[13] = recentlyVisitedPaths;
    $[14] = t11;
  } else {
    t11 = $[14];
  }
  return t11;
}
function _temp$5(storageKey) {
  const item = localStorage.getItem(storageKey);
  return item ? JSON.parse(item) : {};
}
function useBuildModeController() {
  const prefersDarkModeQuery = (0, import_react14.useCallback)(() => {
    if (typeof window === "undefined") return false;
    const mediaQueryList = window.matchMedia("(prefers-color-scheme: dark)");
    return mediaQueryList.matches;
  }, []);
  const prefersDarkModeStorage = localStorage.getItem("prefers-dark-mode") != null ? localStorage.getItem("prefers-dark-mode") === "true" : null;
  const prefersDarkMode = prefersDarkModeStorage ?? prefersDarkModeQuery();
  const [mode, setMode] = (0, import_react14.useState)(prefersDarkMode ? "dark" : "light");
  (0, import_react14.useEffect)(() => {
    setMode(prefersDarkMode ? "dark" : "light");
    setDocumentMode(prefersDarkMode ? "dark" : "light");
  }, [prefersDarkMode]);
  const setDocumentMode = (mode_0) => {
    document.body.style.setProperty("color-scheme", mode_0);
    document.documentElement.dataset.theme = mode_0;
  };
  const setModeInternal = (0, import_react14.useCallback)((mode_1) => {
    if (mode_1 === "light") {
      setDocumentMode("light");
      localStorage.setItem("prefers-dark-mode", "false");
      setMode("light");
    } else if (mode_1 === "dark") {
      setDocumentMode("dark");
      localStorage.setItem("prefers-dark-mode", "true");
      setMode("dark");
    } else {
      const preferredMode = prefersDarkModeQuery() ? "dark" : "light";
      setDocumentMode(preferredMode);
      localStorage.removeItem("prefers-dark-mode");
      setMode(preferredMode);
    }
  }, [prefersDarkModeQuery]);
  return {
    mode,
    setMode: setModeInternal
  };
}
function useValidateAuthenticator(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(17);
  const {
    disabled,
    authController,
    authenticator,
    storageSource,
    dataSourceDelegate
  } = t0;
  const authenticationEnabled = Boolean(authenticator);
  const [authLoading, setAuthLoading] = (0, import_react14.useState)(authenticationEnabled);
  const [notAllowedError, setNotAllowedError] = (0, import_react14.useState)(false);
  const [authVerified, setAuthVerified] = (0, import_react14.useState)(!authenticationEnabled || Boolean(authController.loginSkipped));
  const canAccessMainView = authVerified && (!authenticationEnabled || Boolean(authController.user) || Boolean(authController.loginSkipped)) && !notAllowedError;
  let t1;
  let t2;
  if ($[0] !== authController.loginSkipped) {
    t1 = () => {
      if (authController.loginSkipped) {
        setAuthVerified(true);
      }
    };
    t2 = [authController.loginSkipped];
    $[0] = authController.loginSkipped;
    $[1] = t1;
    $[2] = t2;
  } else {
    t1 = $[1];
    t2 = $[2];
  }
  (0, import_react14.useEffect)(t1, t2);
  const checkedUserRef = (0, import_react14.useRef)();
  let t3;
  if ($[3] !== authController || $[4] !== authenticator || $[5] !== dataSourceDelegate || $[6] !== disabled || $[7] !== storageSource) {
    t3 = async () => {
      var _a;
      if (disabled) {
        return;
      }
      if (authController.initialLoading) {
        return;
      }
      if (!authController.user && !authController.loginSkipped) {
        checkedUserRef.current = void 0;
        setAuthLoading(false);
        setAuthVerified(false);
        return;
      }
      const delegateUser = authController.user;
      if (authenticator instanceof Function && delegateUser && !(0, import_react_fast_compare2.default)((_a = checkedUserRef.current) == null ? void 0 : _a.uid, delegateUser.uid)) {
        setAuthLoading(true);
        try {
          const allowed = await authenticator({
            user: delegateUser,
            authController,
            dataSourceDelegate,
            storageSource
          });
          if (!allowed) {
            authController.signOut();
            setNotAllowedError(true);
          }
        } catch (t42) {
          const e2 = t42;
          setNotAllowedError(e2);
          authController.signOut();
        }
        setAuthLoading(false);
        setAuthVerified(true);
        checkedUserRef.current = delegateUser;
      } else {
        setAuthLoading(false);
      }
      if (!authController.initialLoading && !delegateUser) {
        setAuthVerified(true);
      }
    };
    $[3] = authController;
    $[4] = authenticator;
    $[5] = dataSourceDelegate;
    $[6] = disabled;
    $[7] = storageSource;
    $[8] = t3;
  } else {
    t3 = $[8];
  }
  const checkAuthentication = t3;
  let t4;
  let t5;
  if ($[9] !== checkAuthentication) {
    t4 = () => {
      checkAuthentication();
    };
    t5 = [checkAuthentication];
    $[9] = checkAuthentication;
    $[10] = t4;
    $[11] = t5;
  } else {
    t4 = $[10];
    t5 = $[11];
  }
  (0, import_react14.useEffect)(t4, t5);
  const t6 = authenticationEnabled && authLoading;
  let t7;
  if ($[12] !== authVerified || $[13] !== canAccessMainView || $[14] !== notAllowedError || $[15] !== t6) {
    t7 = {
      canAccessMainView,
      authLoading: t6,
      notAllowedError,
      authVerified
    };
    $[12] = authVerified;
    $[13] = canAccessMainView;
    $[14] = notAllowedError;
    $[15] = t6;
    $[16] = t7;
  } else {
    t7 = $[16];
  }
  return t7;
}
function useNavigationUnsavedChangesDialog(when, onSuccess) {
  const [isDialogOpen, setIsDialogOpen] = (0, import_react14.useState)(false);
  const [pendingNavigation, setPendingNavigation] = (0, import_react14.useState)(null);
  const handleCancel = (0, import_react14.useCallback)(() => {
    setIsDialogOpen(false);
    setPendingNavigation(null);
  }, []);
  const handleOk = (0, import_react14.useCallback)(() => {
    setIsDialogOpen(false);
    if (pendingNavigation) {
      onSuccess();
      if (pendingNavigation.type === "popstate") {
        window.history.go(pendingNavigation.delta);
      } else if (pendingNavigation.type === "link") {
        window.location.href = pendingNavigation.href;
      }
      setPendingNavigation(null);
    }
  }, [onSuccess, pendingNavigation]);
  const handleBeforeUnload = (0, import_react14.useCallback)((e2) => {
    if (when) {
      e2.preventDefault();
      e2.returnValue = "";
    }
  }, [when]);
  const handlePopState = (0, import_react14.useCallback)((e_0) => {
    if (when) {
      e_0.preventDefault();
      setPendingNavigation({
        type: "popstate",
        delta: -1
      });
      setIsDialogOpen(true);
    }
  }, [when]);
  const handleLinkClick = (0, import_react14.useCallback)((e_1) => {
    if (!when) return;
    const target = e_1.target;
    const anchor = target.closest("a[href]");
    if (anchor && anchor.host === window.location.host) {
      e_1.preventDefault();
      const href = anchor.getAttribute("href");
      if (href) {
        setPendingNavigation({
          type: "link",
          href
        });
        setIsDialogOpen(true);
      }
    }
  }, [when]);
  (0, import_react14.useEffect)(() => {
    if (when) {
      window.addEventListener("beforeunload", handleBeforeUnload);
      window.addEventListener("popstate", handlePopState);
      document.addEventListener("click", handleLinkClick);
    } else {
      window.removeEventListener("beforeunload", handleBeforeUnload);
      window.removeEventListener("popstate", handlePopState);
      document.removeEventListener("click", handleLinkClick);
    }
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
      window.removeEventListener("popstate", handlePopState);
      document.removeEventListener("click", handleLinkClick);
    };
  }, [when, handleBeforeUnload, handlePopState, handleLinkClick]);
  return {
    navigationWasBlocked: isDialogOpen,
    handleCancel,
    handleOk
  };
}
function UnsavedChangesDialog(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(20);
  const {
    open,
    handleOk,
    handleCancel,
    body,
    title
  } = t0;
  let t1;
  if ($[0] !== handleCancel) {
    t1 = () => {
      handleCancel();
    };
    $[0] = handleCancel;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] !== title) {
    t2 = (0, import_jsx_runtime2.jsx)(DialogTitle, { variant: "h6", children: title });
    $[2] = title;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  let t3;
  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (0, import_jsx_runtime2.jsx)(Typography, { children: "Are you sure you want to leave this page?" });
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== body) {
    t4 = (0, import_jsx_runtime2.jsxs)(DialogContent, { children: [
      body,
      t3
    ] });
    $[5] = body;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== handleCancel) {
    t5 = (0, import_jsx_runtime2.jsx)(Button, { variant: "text", onClick: handleCancel, autoFocus: true, children: " Cancel " });
    $[7] = handleCancel;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== handleOk) {
    t6 = (0, import_jsx_runtime2.jsx)(Button, { onClick: handleOk, children: " Ok " });
    $[9] = handleOk;
    $[10] = t6;
  } else {
    t6 = $[10];
  }
  let t7;
  if ($[11] !== t5 || $[12] !== t6) {
    t7 = (0, import_jsx_runtime2.jsxs)(DialogActions, { children: [
      t5,
      t6
    ] });
    $[11] = t5;
    $[12] = t6;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  let t8;
  if ($[14] !== open || $[15] !== t1 || $[16] !== t2 || $[17] !== t4 || $[18] !== t7) {
    t8 = (0, import_jsx_runtime2.jsxs)(Dialog, { onEscapeKeyDown: t1, open, children: [
      t2,
      t4,
      t7
    ] });
    $[14] = open;
    $[15] = t1;
    $[16] = t2;
    $[17] = t4;
    $[18] = t7;
    $[19] = t8;
  } else {
    t8 = $[19];
  }
  return t8;
}
var SideDialogContext = import_react14.default.createContext({
  width: "",
  blocked: false,
  setBlocked: (blocked) => {
  },
  setBlockedNavigationMessage: (message2) => {
  },
  close: () => {
  },
  pendingClose: false,
  setPendingClose: () => {
  }
});
var useSideDialogContext = () => {
  return (0, import_react14.useContext)(SideDialogContext);
};
function SideDialogs() {
  const $ = (0, import_react_compiler_runtime3.c)(5);
  const sideDialogsController = useSideDialogsController();
  const sidePanels = sideDialogsController.sidePanels;
  let panels;
  if ($[0] !== sidePanels) {
    panels = [...sidePanels];
    panels.push(void 0);
    $[0] = sidePanels;
    $[1] = panels;
  } else {
    panels = $[1];
  }
  let t0;
  if ($[2] !== panels || $[3] !== sidePanels.length) {
    t0 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: panels.map((panel, index2) => (0, import_jsx_runtime2.jsx)(SideDialogView, { panel, offsetPosition: sidePanels.length - index2 - 1 }, `side_dialog_${index2}`)) });
    $[2] = panels;
    $[3] = sidePanels.length;
    $[4] = t0;
  } else {
    t0 = $[4];
  }
  return t0;
}
function SideDialogView({
  offsetPosition,
  panel
}) {
  const [drawerCloseRequested, setDrawerCloseRequested] = (0, import_react14.useState)(false);
  const [blocked, setBlocked] = (0, import_react14.useState)(false);
  const [blockedNavigationMessage, setBlockedNavigationMessage] = (0, import_react14.useState)();
  const [pendingClose, setPendingClose] = (0, import_react14.useState)(false);
  const widthRef = import_react14.default.useRef(panel == null ? void 0 : panel.width);
  const width = widthRef.current;
  const sideDialogsController = useSideDialogsController();
  const {
    navigationWasBlocked,
    handleOk: handleNavigationOk,
    handleCancel: handleNavigationCancel
  } = useNavigationUnsavedChangesDialog(blocked && !drawerCloseRequested, () => setBlocked(false));
  (0, import_react14.useEffect)(() => {
    if (panel) widthRef.current = panel.width;
  }, [panel]);
  const handleDrawerCloseOk = () => {
    var _a;
    setBlocked(false);
    setDrawerCloseRequested(false);
    sideDialogsController.close();
    (_a = panel == null ? void 0 : panel.onClose) == null ? void 0 : _a.call(panel);
  };
  const handleDrawerCloseCancel = () => {
    setDrawerCloseRequested(false);
  };
  const onCloseRequest = (force) => {
    var _a;
    if (blocked && !force) {
      setDrawerCloseRequested(true);
    } else {
      sideDialogsController.close();
      (_a = panel == null ? void 0 : panel.onClose) == null ? void 0 : _a.call(panel);
    }
  };
  return (0, import_jsx_runtime2.jsxs)(SideDialogContext.Provider, { value: {
    blocked,
    setBlocked,
    setBlockedNavigationMessage,
    width,
    close: onCloseRequest,
    pendingClose,
    setPendingClose
  }, children: [
    (0, import_jsx_runtime2.jsxs)(Sheet, { open: Boolean(panel), onOpenChange: (open) => !open && onCloseRequest(), title: "Side dialog " + (panel == null ? void 0 : panel.key), children: [
      panel && (0, import_jsx_runtime2.jsx)("div", { className: "transform max-w-[100vw] lg:max-w-[95vw] flex flex-col h-full transition-all duration-250 ease-in-out bg-white dark:bg-surface-900 ", style: {
        width: panel.width,
        transform: `translateX(-${offsetPosition * 200}px)`
      }, children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: panel.component }) }),
      !panel && (0, import_jsx_runtime2.jsx)("div", { style: {
        width
      } })
    ] }),
    (0, import_jsx_runtime2.jsx)(UnsavedChangesDialog, { open: drawerCloseRequested, handleOk: drawerCloseRequested ? handleDrawerCloseOk : handleNavigationOk, handleCancel: drawerCloseRequested ? handleDrawerCloseCancel : handleNavigationCancel, body: blockedNavigationMessage })
  ] });
}
function EntityEditViewFormActions({
  collection,
  path,
  entity,
  layout,
  savingError,
  formex,
  disabled,
  status,
  pluginActions,
  openEntityMode,
  showDefaultActions = true
}) {
  const authController = useAuthController();
  const context = useFireCMSContext();
  const sideEntityController = useSideEntityController();
  const sideDialogContext = useSideDialogContext();
  const entityActions = (0, import_react14.useMemo)(() => {
    const customEntityActions = collection.entityActions;
    const createEnabled = canCreateEntity(collection, authController, path, null);
    const deleteEnabled = entity ? canDeleteEntity(collection, authController, path, entity) : false;
    const actions = [];
    if (createEnabled) actions.push(copyEntityAction);
    if (deleteEnabled) actions.push(deleteEntityAction);
    if (customEntityActions) return mergeEntityActions(actions, customEntityActions);
    return actions;
  }, [authController, collection, path]);
  const formActions = showDefaultActions ? entityActions.filter((a2) => a2.includeInForm === void 0 || a2.includeInForm) : [];
  return layout === "bottom" ? buildBottomActions({
    savingError,
    entity,
    formActions,
    collection,
    context,
    sideEntityController,
    isSubmitting: formex.isSubmitting,
    disabled,
    status,
    sideDialogContext,
    pluginActions,
    openEntityMode
  }) : buildSideActions({
    savingError,
    entity,
    formActions,
    collection,
    context,
    sideEntityController,
    isSubmitting: formex.isSubmitting,
    sideDialogContext,
    disabled,
    status,
    pluginActions,
    openEntityMode
  });
}
function buildBottomActions({
  savingError,
  entity,
  formActions,
  collection,
  context,
  sideEntityController,
  isSubmitting,
  disabled,
  status,
  sideDialogContext,
  pluginActions,
  openEntityMode
}) {
  const canClose = openEntityMode === "side_panel";
  return (0, import_jsx_runtime2.jsxs)(DialogActions, { position: "absolute", children: [
    savingError && (0, import_jsx_runtime2.jsx)("div", { className: "text-right", children: (0, import_jsx_runtime2.jsx)(Typography, { color: "error", children: savingError.message }) }),
    entity && formActions.length > 0 && (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow flex overflow-auto no-scrollbar", children: formActions.map((action) => (0, import_jsx_runtime2.jsx)(IconButton, { color: "primary", onClick: (event) => {
      event.stopPropagation();
      if (entity) action.onClick({
        entity,
        fullPath: collection.path,
        collection,
        context,
        sideEntityController,
        openEntityMode
      });
    }, children: action.icon }, action.name)) }),
    pluginActions,
    (0, import_jsx_runtime2.jsx)(Button, { variant: "text", disabled: disabled || isSubmitting, type: "reset", children: status === "existing" ? "Discard" : "Clear" }),
    (0, import_jsx_runtime2.jsxs)(Button, { variant: canClose ? "text" : "filled", color: "primary", type: "submit", disabled: disabled || isSubmitting, onClick: () => {
      sideDialogContext.setPendingClose(false);
    }, children: [
      status === "existing" && "Save",
      status === "copy" && "Create copy",
      status === "new" && "Create"
    ] }),
    canClose && (0, import_jsx_runtime2.jsxs)(LoadingButton, { variant: "filled", color: "primary", type: "submit", loading: isSubmitting, disabled, onClick: () => {
      var _a;
      (_a = sideDialogContext.setPendingClose) == null ? void 0 : _a.call(sideDialogContext, true);
    }, children: [
      status === "existing" && "Save and close",
      status === "copy" && "Create copy and close",
      status === "new" && "Create and close"
    ] })
  ] });
}
function buildSideActions({
  savingError,
  entity,
  formActions,
  collection,
  context,
  sideEntityController,
  isSubmitting,
  disabled,
  status,
  sideDialogContext,
  pluginActions
}) {
  return (0, import_jsx_runtime2.jsxs)("div", { className: cls("overflow-auto h-full flex flex-col gap-2 w-80 2xl:w-96 px-4 py-16 sticky top-0 border-l", defaultBorderMixin), children: [
    (0, import_jsx_runtime2.jsxs)(LoadingButton, { fullWidth: true, variant: "filled", color: "primary", type: "submit", size: "large", disabled: disabled || isSubmitting, onClick: () => {
      var _a;
      (_a = sideDialogContext.setPendingClose) == null ? void 0 : _a.call(sideDialogContext, false);
    }, children: [
      status === "existing" && "Save",
      status === "copy" && "Create copy",
      status === "new" && "Create"
    ] }),
    (0, import_jsx_runtime2.jsx)(Button, { fullWidth: true, variant: "text", disabled: disabled || isSubmitting, type: "reset", children: status === "existing" ? "Discard" : "Clear" }),
    pluginActions,
    savingError && (0, import_jsx_runtime2.jsx)("div", { className: "text-right", children: (0, import_jsx_runtime2.jsx)(Typography, { color: "error", children: savingError.message }) })
  ] });
}
function EntityJsonPreview(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    values
  } = t0;
  let t1;
  if ($[0] !== values) {
    t1 = JSON.stringify(values, null, "	");
    $[0] = values;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const code2 = t1;
  const {
    mode
  } = useModeController();
  const preRef = (0, import_react14.useRef)(null);
  const t2 = mode === "dark" ? themes_exports.vsDark : themes_exports.github;
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = (t42) => {
      const {
        style: style3,
        tokens,
        getLineProps,
        getTokenProps
      } = t42;
      return (0, import_jsx_runtime2.jsx)("pre", { ref: preRef, style: {
        ...style3,
        backgroundColor: "inherit"
      }, className: "max-w-6xl mx-auto p-8 rounded text-sm", children: tokens.map((line, i2) => (0, import_jsx_runtime2.jsx)("div", { ...getLineProps({
        line
      }), className: "text-wrap", children: line.map((token, key) => (0, import_jsx_runtime2.jsx)("span", { ...getTokenProps({
        token
      }), className: "word-break" }, key)) }, i2)) });
    };
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  let t4;
  if ($[3] !== code2 || $[4] !== t2) {
    t4 = (0, import_jsx_runtime2.jsx)(Highlight22, { theme: t2, code: code2, language: "json", children: t3 });
    $[3] = code2;
    $[4] = t2;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  return t4;
}
function createFormexStub(values) {
  const errorMessage = "You are in a read-only context. You cannot modify the formex controller.";
  return {
    values,
    initialValues: values,
    touched: {},
    dirty: false,
    errors: {},
    submitCount: 0,
    isSubmitting: false,
    isValidating: false,
    version: 0,
    canUndo: false,
    canRedo: false,
    setValues: () => {
      throw new Error(errorMessage);
    },
    setFieldValue: () => {
      throw new Error(errorMessage);
    },
    setFieldTouched: () => {
      throw new Error(errorMessage);
    },
    setDirty: () => {
      throw new Error(errorMessage);
    },
    setSubmitCount: () => {
      throw new Error(errorMessage);
    },
    setFieldError: () => {
      throw new Error(errorMessage);
    },
    handleChange: () => {
      throw new Error(errorMessage);
    },
    handleBlur: () => {
      throw new Error(errorMessage);
    },
    handleSubmit: () => {
      throw new Error(errorMessage);
    },
    validate: () => {
      throw new Error(errorMessage);
    },
    resetForm: () => {
      throw new Error(errorMessage);
    },
    setSubmitting: () => {
      throw new Error(errorMessage);
    },
    undo: () => {
      throw new Error(errorMessage);
    },
    redo: () => {
      throw new Error(errorMessage);
    }
  };
}
var MAIN_TAB_VALUE = "__main_##Q$SC^#S6";
var JSON_TAB_VALUE = "__json";
function EntityEditView({
  entityId,
  ...props
}) {
  const {
    entity,
    dataLoading,
    // eslint-disable-next-line no-unused-vars
    dataLoadingError
  } = useEntityFetch({
    path: props.path,
    entityId,
    collection: props.collection,
    databaseId: props.databaseId,
    useCache: false
  });
  const cachedValues = entityId ? getEntityFromCache(props.path + "/" + entityId) : getEntityFromCache(props.path + "#new");
  const authController = useAuthController();
  const initialStatus = props.copy ? "copy" : entityId ? "existing" : "new";
  const [status, setStatus] = (0, import_react14.useState)(initialStatus);
  const canEdit = (0, import_react14.useMemo)(() => {
    if (status === "new" || status === "copy") {
      return true;
    } else {
      return entity ? canEditEntity(props.collection, authController, props.path, entity ?? null) : void 0;
    }
  }, [authController, entity, status]);
  if (dataLoading && !cachedValues || (!entity || canEdit === void 0) && (status === "existing" || status === "copy")) {
    return (0, import_jsx_runtime2.jsx)(CircularProgressCenter, {});
  }
  if (entityId && !entity && !cachedValues) {
    console.error(`Entity with id ${entityId} not found in collection ${props.path}`);
  }
  return (0, import_jsx_runtime2.jsx)(EntityEditViewInner, { ...props, entityId, entity, cachedDirtyValues: cachedValues, dataLoading, status, setStatus, canEdit });
}
function EntityEditViewInner({
  path,
  fullIdPath,
  entityId,
  selectedTab: selectedTabProp,
  collection,
  parentCollectionIds,
  onValuesModified,
  onSaved,
  onTabChange,
  entity,
  cachedDirtyValues,
  dataLoading,
  layout = "side_panel",
  barActions,
  status,
  setStatus,
  formProps,
  canEdit
}) {
  const context = useFireCMSContext();
  const [usedEntity, setUsedEntity] = (0, import_react14.useState)(entity);
  (0, import_react14.useEffect)(() => {
    if (entity) setUsedEntity(entity);
  }, [entity]);
  const [formContext, setFormContext] = (0, import_react14.useState)(void 0);
  const largeLayout = useLargeLayout();
  const customizationController = useCustomizationController();
  const defaultSelectedView = (0, import_react14.useMemo)(() => resolveDefaultSelectedView(collection ? collection.defaultSelectedView : void 0, {
    status,
    entityId
  }), []);
  const [selectedTab, setSelectedTab] = (0, import_react14.useState)(selectedTabProp ?? defaultSelectedView ?? MAIN_TAB_VALUE);
  (0, import_react14.useEffect)(() => {
    if ((selectedTabProp ?? defaultSelectedView ?? MAIN_TAB_VALUE) !== selectedTab) {
      setSelectedTab(selectedTabProp ?? defaultSelectedView ?? MAIN_TAB_VALUE);
    }
  }, [selectedTabProp]);
  const subcollections = (collection.subcollections ?? []).filter((c22) => !c22.hideFromNavigation);
  const subcollectionsCount = (subcollections == null ? void 0 : subcollections.length) ?? 0;
  const customViews = collection.entityViews;
  const customViewsCount = (customViews == null ? void 0 : customViews.length) ?? 0;
  const includeJsonView = collection.includeJsonView === void 0 ? true : collection.includeJsonView;
  const hasAdditionalViews = customViewsCount > 0 || subcollectionsCount > 0 || includeJsonView;
  const {
    resolvedEntityViews,
    selectedEntityView,
    selectedSecondaryForm
  } = resolvedSelectedEntityView(customViews, customizationController, selectedTab);
  const actionsAtTheBottom = !largeLayout || layout === "side_panel" || (selectedEntityView == null ? void 0 : selectedEntityView.includeActions) === "bottom";
  const mainViewVisible = selectedTab === MAIN_TAB_VALUE || Boolean(selectedSecondaryForm);
  const authController = useAuthController();
  const customViewsView = customViews && resolvedEntityViews.filter((e2) => !e2.includeActions).map((customView) => {
    var _a;
    if (!customView) return null;
    const Builder = customView.Builder;
    if (!Builder) {
      console.error("INTERNAL: customView.Builder is not defined");
      return null;
    }
    if (!entityId) {
      console.error("INTERNAL: entityId is not defined");
      return null;
    }
    const formexStub = createFormexStub((usedEntity == null ? void 0 : usedEntity.values) ?? {});
    const usedFormContext = formContext ?? {
      entityId,
      disabled: false,
      openEntityMode: layout,
      status,
      values: (usedEntity == null ? void 0 : usedEntity.values) ?? {},
      setFieldValue: (key, value) => {
        throw new Error("You can't update values in read only mode");
      },
      save: () => {
        throw new Error("You can't save in read only mode");
      },
      collection: resolveCollection({
        collection,
        path,
        entityId,
        values: (usedEntity == null ? void 0 : usedEntity.values) ?? {},
        previousValues: (usedEntity == null ? void 0 : usedEntity.values) ?? {},
        propertyConfigs: customizationController.propertyConfigs,
        authController
      }),
      path,
      entity: usedEntity,
      savingError: void 0,
      formex: formexStub
    };
    return (0, import_jsx_runtime2.jsx)("div", { className: cls(defaultBorderMixin, "relative flex-1 w-full h-full overflow-auto", {
      "hidden": selectedTab !== customView.key
    }), role: "tabpanel", children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: usedFormContext && (0, import_jsx_runtime2.jsx)(Builder, { collection, entity: usedEntity, modifiedValues: ((_a = usedFormContext == null ? void 0 : usedFormContext.formex) == null ? void 0 : _a.values) ?? (usedEntity == null ? void 0 : usedEntity.values), formContext: usedFormContext }) }) }, `custom_view_${customView.key}`);
  }).filter(Boolean);
  const globalLoading = dataLoading && !usedEntity;
  const jsonView = (0, import_jsx_runtime2.jsx)("div", { className: cls("relative flex-1 h-full overflow-auto w-full", {
    "hidden": selectedTab !== JSON_TAB_VALUE
  }), role: "tabpanel", children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(EntityJsonPreview, { values: (formContext == null ? void 0 : formContext.values) ?? (entity == null ? void 0 : entity.values) ?? {} }) }) }, "json_view");
  const subCollectionsViews = subcollections && subcollections.map((subcollection) => {
    const subcollectionId = subcollection.id ?? subcollection.path;
    const newFullPath = usedEntity ? `${path}/${usedEntity == null ? void 0 : usedEntity.id}/${removeInitialAndTrailingSlashes(subcollectionId)}` : void 0;
    const newFullIdPath = fullIdPath ? `${fullIdPath}/${usedEntity == null ? void 0 : usedEntity.id}/${removeInitialAndTrailingSlashes(subcollectionId)}` : void 0;
    if (selectedTab !== subcollectionId) return null;
    return (0, import_jsx_runtime2.jsxs)("div", { className: "relative flex-1 h-full overflow-auto w-full", role: "tabpanel", children: [
      globalLoading && (0, import_jsx_runtime2.jsx)(CircularProgressCenter, {}),
      !globalLoading && (usedEntity && newFullPath ? (0, import_jsx_runtime2.jsx)(EntityCollectionView, { fullPath: newFullPath, fullIdPath: newFullIdPath, parentCollectionIds: [...parentCollectionIds, collection.id], isSubCollection: true, updateUrl: false, ...subcollection, openEntityMode: layout }) : (0, import_jsx_runtime2.jsx)("div", { className: "flex items-center justify-center w-full h-full p-3", children: (0, import_jsx_runtime2.jsx)(Typography, { variant: "label", children: "You need to save your entity before adding additional collections" }) }))
    ] }, `subcol_${subcollectionId}`);
  }).filter(Boolean);
  const onSideTabClick = (value_0) => {
    setSelectedTab(value_0);
    if (status === "existing") {
      onTabChange == null ? void 0 : onTabChange({
        path: fullIdPath ?? path,
        entityId,
        selectedTab: value_0 === MAIN_TAB_VALUE ? void 0 : value_0,
        collection
      });
    }
  };
  const entityReadOnlyView = !canEdit && entity ? (0, import_jsx_runtime2.jsx)("div", { className: cls("flex-1 flex flex-row w-full overflow-y-auto justify-center", canEdit || !mainViewVisible || selectedSecondaryForm ? "hidden" : ""), children: (0, import_jsx_runtime2.jsxs)("div", { className: cls("relative flex flex-col max-w-4xl lg:max-w-3xl xl:max-w-4xl 2xl:max-w-6xl w-full h-fit"), children: [
    (0, import_jsx_runtime2.jsx)(Typography, { className: "mt-16 mb-8 mx-8", variant: "h4", children: collection.singularName ?? collection.name }),
    (0, import_jsx_runtime2.jsx)(EntityView, { className: "px-8 h-full overflow-auto", entity, path, collection })
  ] }) }) : null;
  const entityView = (0, import_jsx_runtime2.jsx)(EntityForm, { collection, path, entityId: entityId ?? (usedEntity == null ? void 0 : usedEntity.id), onValuesModified, entity, initialDirtyValues: cachedDirtyValues, openEntityMode: layout, forceActionsAtTheBottom: actionsAtTheBottom, initialStatus: status, className: cls((!mainViewVisible || !canEdit) && !selectedSecondaryForm ? "hidden" : "", formProps == null ? void 0 : formProps.className), EntityFormActionsComponent: EntityEditViewFormActions, disabled: !canEdit, ...formProps, onEntityChange: (entity_0) => {
    var _a;
    setUsedEntity(entity_0);
    (_a = formProps == null ? void 0 : formProps.onEntityChange) == null ? void 0 : _a.call(formProps, entity_0);
  }, onStatusChange: (status_0) => {
    var _a;
    setStatus(status_0);
    (_a = formProps == null ? void 0 : formProps.onStatusChange) == null ? void 0 : _a.call(formProps, status_0);
  }, onFormContextReady: (formContext_0) => {
    var _a;
    setFormContext(formContext_0);
    (_a = formProps == null ? void 0 : formProps.onFormContextReady) == null ? void 0 : _a.call(formProps, formContext_0);
  }, onSaved: (params) => {
    var _a;
    const res = {
      ...params,
      selectedTab: MAIN_TAB_VALUE === selectedTab ? void 0 : selectedTab
    };
    onSaved == null ? void 0 : onSaved(res);
    (_a = formProps == null ? void 0 : formProps.onSaved) == null ? void 0 : _a.call(formProps, res);
  }, Builder: selectedSecondaryForm == null ? void 0 : selectedSecondaryForm.Builder });
  const subcollectionTabs = subcollections && subcollections.map((subcollection_0) => (0, import_jsx_runtime2.jsx)(Tab, { className: "text-sm min-w-[120px]", value: subcollection_0.id, children: subcollection_0.name }, `entity_detail_collection_tab_${subcollection_0.name}`));
  const customViewTabs = resolvedEntityViews.map((view) => (0, import_jsx_runtime2.jsx)(Tab, { className: "text-sm min-w-[120px]", value: view.key, children: view.name }, `entity_detail_collection_tab_${view.name}`));
  const shouldShowTopBar = Boolean(barActions) || hasAdditionalViews;
  let result = (0, import_jsx_runtime2.jsxs)("div", { className: "relative flex flex-col h-full w-full bg-white dark:bg-surface-900", children: [
    shouldShowTopBar && (0, import_jsx_runtime2.jsxs)("div", { className: cls("h-14 flex overflow-visible overflow-x-scroll w-full no-scrollbar h-14 border-b pl-2 pr-2 pt-1 flex items-end bg-surface-50 dark:bg-surface-900", defaultBorderMixin), children: [
      barActions,
      (0, import_jsx_runtime2.jsx)("div", { className: "flex-grow" }),
      globalLoading && (0, import_jsx_runtime2.jsx)("div", { className: "self-center", children: (0, import_jsx_runtime2.jsx)(CircularProgress, { size: "small" }) }),
      hasAdditionalViews && (0, import_jsx_runtime2.jsxs)(Tabs, { value: selectedTab, onValueChange: (value_1) => {
        onSideTabClick(value_1);
      }, children: [
        includeJsonView && (0, import_jsx_runtime2.jsx)(Tab, { disabled: !hasAdditionalViews, value: JSON_TAB_VALUE, innerClassName: "block", className: "text-sm", children: (0, import_jsx_runtime2.jsx)(CodeIcon, { size: "small" }) }),
        (0, import_jsx_runtime2.jsx)(Tab, { disabled: !hasAdditionalViews, value: MAIN_TAB_VALUE, className: "text-sm min-w-[120px]", children: collection.singularName ?? collection.name }),
        customViewTabs,
        subcollectionTabs
      ] })
    ] }),
    globalLoading ? (0, import_jsx_runtime2.jsx)("div", { className: "w-full pt-12 pb-16 px-4 sm:px-8 md:px-10", children: (0, import_jsx_runtime2.jsx)(CircularProgressCenter, {}) }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      entityReadOnlyView,
      entityView
    ] }),
    jsonView,
    customViewsView,
    subCollectionsViews
  ] });
  const plugins = customizationController.plugins;
  if (plugins) {
    plugins.forEach((plugin) => {
      var _a;
      if ((_a = plugin.form) == null ? void 0 : _a.provider) {
        result = (0, import_jsx_runtime2.jsx)(plugin.form.provider.Component, { status, path, collection, entity: usedEntity, context, formContext, ...plugin.form.provider.props, children: result });
      }
    });
  }
  return result;
}
function EntitySidePanel(props) {
  const {
    blocked,
    setBlocked,
    setBlockedNavigationMessage,
    close: close2
  } = useSideDialogContext();
  const navigate = useNavigate();
  const location = useLocation();
  const sideEntityController = useSideEntityController();
  const navigationController = useNavigationController();
  const sideDialogsController = useSideDialogContext();
  const onClose = () => {
    if (props.onClose) {
      props.onClose();
    }
    setBlocked(false);
    close2(true);
  };
  const onUpdate = (params) => {
    if (props.onUpdate) {
      props.onUpdate(params);
    }
    if (params.status !== "existing") {
      sideEntityController.replace({
        path: params.path,
        entityId: params.entityId,
        selectedTab: params.selectedTab,
        updateUrl: true,
        collection: params.collection
      });
    }
    if (sideDialogsController.pendingClose) {
      sideDialogsController.setPendingClose(false);
      onClose();
    }
  };
  const parentCollectionIds = (0, import_react14.useMemo)(() => {
    return navigationController.getParentCollectionIds(props.path);
  }, [navigationController, props.path]);
  const collection = (0, import_react14.useMemo)(() => {
    if (props.collection) {
      return props.collection;
    }
    const registryCollection = navigationController.getCollection(props.path);
    if (registryCollection) {
      return registryCollection;
    }
    console.error("ERROR: No collection found in path `", props.path, "`. Entity id: ", props.entityId);
    throw Error("ERROR: No collection found in path `" + props.path + "`. Make sure you have defined a collection for this path in the root navigation.");
  }, [navigationController, props.collection]);
  (0, import_react14.useEffect)(() => {
    function beforeunload(e2) {
      if (blocked && collection) {
        e2.preventDefault();
        e2.returnValue = `You have unsaved changes in this ${collection.name}. Are you sure you want to leave this page?`;
      }
    }
    if (typeof window !== "undefined") window.addEventListener("beforeunload", beforeunload);
    return () => {
      if (typeof window !== "undefined") window.removeEventListener("beforeunload", beforeunload);
    };
  }, [blocked, collection]);
  const onValuesModified = (0, import_react14.useCallback)((modified) => {
    setBlockedNavigationMessage(modified ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      " You have unsaved changes in this ",
      (0, import_jsx_runtime2.jsx)("b", { children: (collection == null ? void 0 : collection.singularName) ?? (collection == null ? void 0 : collection.name) }),
      "."
    ] }) : void 0);
    setBlocked(modified);
  }, [collection == null ? void 0 : collection.name, setBlocked, setBlockedNavigationMessage]);
  if (!props || !collection) {
    return (0, import_jsx_runtime2.jsx)("div", { className: "w-full" });
  }
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(EntityEditView, { ...props, layout: "side_panel", collection, parentCollectionIds, onValuesModified, onSaved: onUpdate, barActions: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(IconButton, { className: "self-center", onClick: onClose, children: (0, import_jsx_runtime2.jsx)(CloseIcon, { size: "small" }) }),
    (0, import_jsx_runtime2.jsx)(IconButton, { className: "self-center", onClick: () => {
      if (props.entityId) navigate(location.pathname);
      else navigate(location.pathname + "#new");
    }, children: (0, import_jsx_runtime2.jsx)(OpenInFullIcon, { size: "small" }) })
  ] }), onTabChange: ({
    path,
    entityId,
    selectedTab,
    collection: collection_0
  }) => {
    sideEntityController.replace({
      path,
      entityId,
      selectedTab,
      updateUrl: true,
      collection: collection_0
    });
  }, formProps: props.formProps }) }) });
}
var NEW_URL_HASH = "new_side";
var SIDE_URL_HASH = "side";
function getEntityViewWidth(props, small, customizationController, authController) {
  var _a, _b;
  if (small) return CONTAINER_FULL_WIDTH;
  const {
    selectedSecondaryForm
  } = resolvedSelectedEntityView((_a = props.collection) == null ? void 0 : _a.entityViews, customizationController, props.selectedTab);
  const shouldUseSmallLayout = !props.selectedTab || props.selectedTab === JSON_TAB_VALUE || Boolean(selectedSecondaryForm);
  let resolvedWidth;
  if (props.width) {
    resolvedWidth = typeof props.width === "number" ? `${props.width}px` : props.width;
  } else if ((_b = props.collection) == null ? void 0 : _b.sideDialogWidth) {
    resolvedWidth = typeof props.collection.sideDialogWidth === "number" ? `${props.collection.sideDialogWidth}px` : props.collection.sideDialogWidth;
  }
  if (!shouldUseSmallLayout) {
    return `calc(${ADDITIONAL_TAB_WIDTH} + ${resolvedWidth ?? FORM_CONTAINER_WIDTH})`;
  } else {
    if (resolvedWidth) {
      return resolvedWidth;
    } else if (!props.collection) {
      return FORM_CONTAINER_WIDTH;
    } else {
      return calculateCollectionDesiredWidth(props.collection, authController);
    }
  }
}
var collectionViewWidthCache = {};
function calculateCollectionDesiredWidth(collection, authController) {
  if (collectionViewWidthCache[collection.id]) {
    return collectionViewWidthCache[collection.id];
  }
  const resolvedCollection = resolveCollection({
    collection,
    path: "__ignored",
    ignoreMissingFields: true,
    authController
  });
  let result = FORM_CONTAINER_WIDTH;
  if (resolvedCollection == null ? void 0 : resolvedCollection.properties) {
    const values = Object.values(resolvedCollection.properties).map((p3) => getNestedPropertiesDepth(p3));
    const maxDepth = Math.max(...values);
    if (maxDepth < 3) {
      result = FORM_CONTAINER_WIDTH;
    } else {
      result = 768 + 32 * (maxDepth - 2) + "px";
    }
  }
  collectionViewWidthCache[collection.id] = result;
  return result;
}
function getNestedPropertiesDepth(property, accumulator = 0) {
  if (property.dataType === "map" && property.properties) {
    const values = Object.values(property.properties).flatMap((property2) => getNestedPropertiesDepth(property2, accumulator + 1));
    return Math.max(...values);
  } else if (property.dataType === "array" && property.oneOf) {
    return accumulator + 3;
  } else if (property.dataType === "array" && property.of) {
    if (Array.isArray(property.of)) {
      return Math.max(...property.of.map((p3) => getNestedPropertiesDepth(p3, accumulator + 1)));
    } else {
      return getNestedPropertiesDepth(property.of, accumulator + 1);
    }
  } else {
    return accumulator + 1;
  }
}
var useBuildSideEntityController = (navigation, sideDialogsController, authController) => {
  const location = useLocation();
  const initialised = (0, import_react14.useRef)(false);
  const customizationController = useCustomizationController();
  const smallLayout = !useLargeLayout();
  (0, import_react14.useEffect)(() => {
    const newFlag = location.hash === `#${NEW_URL_HASH}`;
    const sideFlag = location.hash === `#${SIDE_URL_HASH}`;
    if (!navigation.loading) {
      if ((newFlag || sideFlag) && navigation.isUrlCollectionPath(location.pathname)) {
        const entityOrCollectionPath = navigation.urlPathToDataPath(location.pathname);
        const panelsFromUrl = buildSidePanelsFromUrl(entityOrCollectionPath, navigation.collections ?? [], newFlag);
        for (let i2 = 0; i2 < panelsFromUrl.length; i2++) {
          const props = panelsFromUrl[i2];
          if (i2 === 0) sideDialogsController.replace(propsToSidePanel(props, navigation.buildUrlCollectionPath, navigation.resolveIdsFrom, smallLayout, customizationController, authController));
          else sideDialogsController.open(propsToSidePanel(props, navigation.buildUrlCollectionPath, navigation.resolveIdsFrom, smallLayout, customizationController, authController));
        }
      }
      initialised.current = true;
    }
  }, [navigation.loading]);
  const currentPanelKeys = sideDialogsController.sidePanels.map((p3) => p3.key);
  (0, import_react14.useEffect)(() => {
    if (initialised.current) {
      const sideFlag_0 = location.hash === `#${SIDE_URL_HASH}`;
      if (sideFlag_0) {
        const entityOrCollectionPath_0 = navigation.urlPathToDataPath(location.pathname);
        const panelsFromUrl_0 = buildSidePanelsFromUrl(entityOrCollectionPath_0, navigation.collections ?? [], false);
        if (panelsFromUrl_0.length <= currentPanelKeys.length) {
          return;
        }
        const lastPanel = panelsFromUrl_0[panelsFromUrl_0.length - 1];
        const panelProps = propsToSidePanel(lastPanel, navigation.buildUrlCollectionPath, navigation.resolveIdsFrom, smallLayout, customizationController, authController);
        const lastCurrentPanel = currentPanelKeys.length > 0 ? currentPanelKeys[currentPanelKeys.length - 1] : void 0;
        if (!lastCurrentPanel || lastCurrentPanel !== panelProps.key) {
          sideDialogsController.replace(panelProps);
        }
      }
    }
  }, [location.pathname, location.hash, currentPanelKeys]);
  (0, import_react14.useEffect)(() => {
    const updatedSidePanels = sideDialogsController.sidePanels.map((sidePanelProps) => {
      if (sidePanelProps.additional) {
        return propsToSidePanel(sidePanelProps.additional, navigation.buildUrlCollectionPath, navigation.resolveIdsFrom, smallLayout, customizationController, authController);
      }
      return sidePanelProps;
    });
    sideDialogsController.setSidePanels(updatedSidePanels);
  }, [smallLayout]);
  const close2 = (0, import_react14.useCallback)(() => {
    sideDialogsController.close();
  }, [sideDialogsController]);
  const open = (0, import_react14.useCallback)((props_0) => {
    if (props_0.copy && !props_0.entityId) {
      throw Error("If you want to copy an entity you need to provide an entityId");
    }
    const defaultSelectedView = resolveDefaultSelectedView(props_0.collection ? props_0.collection.defaultSelectedView : void 0, {
      status: props_0.copy ? "copy" : props_0.entityId ? "existing" : "new",
      entityId: props_0.entityId
    });
    sideDialogsController.open(propsToSidePanel({
      selectedTab: defaultSelectedView,
      ...props_0
    }, navigation.buildUrlCollectionPath, navigation.resolveIdsFrom, smallLayout, customizationController, authController));
  }, [sideDialogsController, navigation.buildUrlCollectionPath, navigation.resolveIdsFrom, smallLayout, authController.user]);
  const replace3 = (0, import_react14.useCallback)((props_1) => {
    if (props_1.copy && !props_1.entityId) {
      throw Error("If you want to copy an entity you need to provide an entityId");
    }
    sideDialogsController.replace(propsToSidePanel(props_1, navigation.buildUrlCollectionPath, navigation.resolveIdsFrom, smallLayout, customizationController, authController));
  }, [navigation.buildUrlCollectionPath, navigation.resolveIdsFrom, sideDialogsController, smallLayout, authController.user]);
  return {
    close: close2,
    open,
    replace: replace3
  };
};
function buildSidePanelsFromUrl(path, collections, newFlag) {
  var _a;
  const navigationViewsForPath = getNavigationEntriesFromPath({
    path,
    collections
  });
  let sidePanel = void 0;
  let lastCollectionPath = "";
  for (let i2 = 0; i2 < navigationViewsForPath.length; i2++) {
    const navigationEntry = navigationViewsForPath[i2];
    if (navigationEntry.type === "collection") {
      lastCollectionPath = navigationEntry.path;
    }
    const previousEntry = navigationViewsForPath[i2 - 1];
    if (navigationEntry.type === "entity") {
      sidePanel = {
        path: navigationEntry.path,
        // fullIdPath: navigationEntry.path,
        entityId: navigationEntry.entityId,
        copy: false,
        width: (_a = navigationEntry.parentCollection) == null ? void 0 : _a.sideDialogWidth
      };
    } else if (navigationEntry.type === "custom_view") {
      if ((previousEntry == null ? void 0 : previousEntry.type) === "entity") {
        if (sidePanel) sidePanel.selectedTab = navigationEntry.view.key;
      }
    } else if (navigationEntry.type === "collection") {
      if ((previousEntry == null ? void 0 : previousEntry.type) === "entity") {
        if (sidePanel) sidePanel.selectedTab = navigationEntry.collection.id ?? navigationEntry.collection.path;
      }
    }
  }
  if (newFlag) {
    sidePanel = {
      path: lastCollectionPath,
      // fullIdPath: lastCollectionPath,
      copy: false
    };
  }
  return sidePanel ? [sidePanel] : [];
}
var propsToSidePanel = (props, buildUrlCollectionPath, resolveIdsFrom, smallLayout, customizationController, authController) => {
  const collectionPath = removeInitialAndTrailingSlashes(props.path);
  const newPath = props.entityId ? buildUrlCollectionPath(`${collectionPath}/${props.entityId}${props.selectedTab ? "/" + props.selectedTab : ""}#${SIDE_URL_HASH}`) : buildUrlCollectionPath(`${collectionPath}#${NEW_URL_HASH}`);
  const resolvedPanelProps = {
    ...props,
    formProps: props.formProps
  };
  const entityViewWidth = getEntityViewWidth(props, smallLayout, customizationController, authController);
  return {
    key: `${props.path}/${props.entityId}`,
    component: (0, import_jsx_runtime2.jsx)(EntitySidePanel, { ...resolvedPanelProps }),
    urlPath: newPath,
    parentUrlPath: buildUrlCollectionPath(collectionPath),
    width: entityViewWidth,
    onClose: props.onClose,
    additional: props
  };
};
function useBuildSideDialogsController() {
  const $ = (0, import_react_compiler_runtime3.c)(24);
  const location = useLocation();
  const navigate = useNavigate();
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = [];
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  const [sidePanels, setSidePanels] = (0, import_react14.useState)(t0);
  const sidePanelsRef = (0, import_react14.useRef)(sidePanels);
  let t1;
  if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
    t1 = {};
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const routesStore = (0, import_react14.useRef)(t1);
  const routesCount = (0, import_react14.useRef)(0);
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = (newPanels) => {
      sidePanelsRef.current = newPanels;
      setSidePanels(newPanels);
    };
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  const updateSidePanels = t2;
  let t3;
  if ($[3] !== location.state) {
    t3 = () => {
      const state = location.state;
      const panelKeys = (state == null ? void 0 : state.panels) ?? [];
      const newPanels_0 = panelKeys.map((key) => routesStore.current[key]).filter(_temp$4);
      if (!(0, import_react_fast_compare2.default)(sidePanelsRef.current.map(_temp2$3), newPanels_0.map(_temp3$1))) {
        updateSidePanels(newPanels_0);
      }
    };
    $[3] = location.state;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  let t4;
  if ($[5] !== location) {
    t4 = [location];
    $[5] = location;
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  (0, import_react14.useEffect)(t3, t4);
  let t5;
  if ($[7] !== location || $[8] !== navigate || $[9] !== sidePanels) {
    t5 = () => {
      var _a;
      if (sidePanels.length === 0) {
        return;
      }
      const lastSidePanel = sidePanels[sidePanels.length - 1];
      const updatedPanels = [...sidePanels.slice(0, -1)];
      updateSidePanels(updatedPanels);
      if (routesCount.current > 0) {
        if (lastSidePanel.urlPath) {
          navigate(-1);
        }
        routesCount.current = routesCount.current - 1;
      } else {
        if (lastSidePanel.parentUrlPath) {
          const baseLocation = ((_a = location.state) == null ? void 0 : _a.base_location) ?? location;
          navigate(lastSidePanel.parentUrlPath, {
            replace: true,
            state: {
              base_location: baseLocation,
              panels: updatedPanels.map(_temp42)
            }
          });
        }
      }
    };
    $[7] = location;
    $[8] = navigate;
    $[9] = sidePanels;
    $[10] = t5;
  } else {
    t5 = $[10];
  }
  const close2 = t5;
  let t6;
  if ($[11] !== location || $[12] !== navigate || $[13] !== sidePanels) {
    t6 = (panelProps) => {
      var _a;
      const newPanels_1 = Array.isArray(panelProps) ? panelProps : [panelProps];
      newPanels_1.forEach((panel) => {
        routesStore.current[panel.key] = panel;
      });
      routesCount.current = routesCount.current + newPanels_1.length;
      const baseLocation_0 = ((_a = location.state) == null ? void 0 : _a.base_location) ?? location;
      const updatedPanels_0 = [...sidePanels, ...newPanels_1];
      updateSidePanels(updatedPanels_0);
      newPanels_1.forEach((panel_0) => {
        if (panel_0.urlPath) {
          navigate(panel_0.urlPath, {
            state: {
              base_location: baseLocation_0,
              panels: updatedPanels_0.map(_temp52)
            }
          });
        }
      });
    };
    $[11] = location;
    $[12] = navigate;
    $[13] = sidePanels;
    $[14] = t6;
  } else {
    t6 = $[14];
  }
  const open = t6;
  let t7;
  if ($[15] !== location || $[16] !== navigate || $[17] !== sidePanels) {
    t7 = (panelProps_0) => {
      var _a;
      const newPanels_2 = Array.isArray(panelProps_0) ? panelProps_0 : [panelProps_0];
      newPanels_2.forEach((panel_1) => {
        routesStore.current[panel_1.key] = panel_1;
      });
      const baseLocation_1 = ((_a = location.state) == null ? void 0 : _a.base_location) ?? location;
      const updatedPanels_1 = [...sidePanels.slice(0, -newPanels_2.length), ...newPanels_2];
      updateSidePanels(updatedPanels_1);
      newPanels_2.forEach((panel_2) => {
        if (panel_2.urlPath) {
          navigate(panel_2.urlPath, {
            replace: true,
            state: {
              base_location: baseLocation_1,
              panels: updatedPanels_1.map(_temp62)
            }
          });
        }
      });
    };
    $[15] = location;
    $[16] = navigate;
    $[17] = sidePanels;
    $[18] = t7;
  } else {
    t7 = $[18];
  }
  const replace3 = t7;
  let t8;
  if ($[19] !== close2 || $[20] !== open || $[21] !== replace3 || $[22] !== sidePanels) {
    t8 = {
      sidePanels,
      setSidePanels: updateSidePanels,
      close: close2,
      open,
      replace: replace3
    };
    $[19] = close2;
    $[20] = open;
    $[21] = replace3;
    $[22] = sidePanels;
    $[23] = t8;
  } else {
    t8 = $[23];
  }
  return t8;
}
function _temp62(p_4) {
  return p_4.key;
}
function _temp52(p_3) {
  return p_3.key;
}
function _temp42(p_2) {
  return p_2.key;
}
function _temp3$1(p_1) {
  return p_1.key;
}
function _temp2$3(p_0) {
  return p_0.key;
}
function _temp$4(p3) {
  return Boolean(p3);
}
function useBuildDataSource({
  delegate,
  propertyConfigs,
  navigationController,
  authController
}) {
  return {
    /**
     * Fetch entities in a Firestore path
     * @param path
     * @param collection
     * @param filter
     * @param limit
     * @param startAfter
     * @param searchString
     * @param orderBy
     * @param order
     * @return Function to cancel subscription
     * @see useCollectionFetch if you need this functionality implemented as a hook
     * @group Firestore
     */
    fetchCollection: (0, import_react14.useCallback)(({
      path,
      collection,
      filter,
      limit,
      startAfter,
      searchString,
      orderBy,
      order: order2
    }) => {
      var _a;
      const usedDelegate = ((_a = collection == null ? void 0 : collection.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      return usedDelegate.fetchCollection({
        path,
        filter,
        limit,
        startAfter,
        searchString,
        orderBy,
        order: order2,
        collection
      });
    }, [delegate]),
    /**
     * Listen to a entities in a given path
     * @param path
     * @param collection
     * @param onError
     * @param filter
     * @param limit
     * @param startAfter
     * @param searchString
     * @param orderBy
     * @param order
     * @param onUpdate
     * @return Function to cancel subscription
     * @see useCollectionFetch if you need this functionality implemented as a hook
     * @group Firestore
     */
    listenCollection: delegate.listenCollection ? (0, import_react14.useCallback)(({
      path: path_0,
      collection: collectionProp,
      filter: filter_0,
      limit: limit_0,
      startAfter: startAfter_0,
      searchString: searchString_0,
      orderBy: orderBy_0,
      order: order_0,
      onUpdate,
      onError
    }) => {
      var _a;
      const collection_0 = collectionProp ?? navigationController.getCollection(path_0);
      const usedDelegate_0 = ((_a = collection_0 == null ? void 0 : collection_0.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      if (!usedDelegate_0.listenCollection) throw Error("useBuildDataSource delegate not initialised");
      return usedDelegate_0.listenCollection({
        path: path_0,
        filter: filter_0,
        limit: limit_0,
        startAfter: startAfter_0,
        searchString: searchString_0,
        orderBy: orderBy_0,
        order: order_0,
        onUpdate,
        onError,
        collection: collection_0
      });
    }, [delegate, navigationController.getCollection]) : void 0,
    /**
     * Retrieve an entity given a path and a collection
     * @param path
     * @param entityId
     * @param collection
     * @group Firestore
     */
    fetchEntity: (0, import_react14.useCallback)(({
      path: path_1,
      entityId,
      collection: collection_1
    }) => {
      var _a;
      const usedDelegate_1 = ((_a = collection_1 == null ? void 0 : collection_1.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      return usedDelegate_1.fetchEntity({
        path: path_1,
        entityId,
        collection: collection_1
      });
    }, [delegate.fetchEntity]),
    /**
     *
     * @param path
     * @param entityId
     * @param collection
     * @param onUpdate
     * @param onError
     * @return Function to cancel subscription
     * @group Firestore
     */
    listenEntity: delegate.listenEntity ? (0, import_react14.useCallback)(({
      path: path_2,
      entityId: entityId_0,
      collection: collection_2,
      onUpdate: onUpdate_0,
      onError: onError_0
    }) => {
      var _a;
      const usedDelegate_2 = ((_a = collection_2 == null ? void 0 : collection_2.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      if (!usedDelegate_2.listenEntity) throw Error("useBuildDataSource delegate not initialised");
      return usedDelegate_2.listenEntity({
        path: path_2,
        entityId: entityId_0,
        onUpdate: onUpdate_0,
        onError: onError_0,
        collection: collection_2
      });
    }, [delegate.listenEntity]) : void 0,
    /**
     * Save entity to the specified path. Note that Firestore does not allow
     * undefined values.
     * @param path
     * @param entityId
     * @param values
     * @param schemaId
     * @param collection
     * @param status
     * @group Firestore
     */
    saveEntity: (0, import_react14.useCallback)(({
      path: path_3,
      entityId: entityId_1,
      values,
      collection: collectionProp_0,
      status
    }) => {
      var _a, _b;
      const collection_3 = collectionProp_0 ?? navigationController.getCollection(path_3);
      const usedDelegate_3 = ((_a = collection_3 == null ? void 0 : collection_3.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      const resolvedCollection = collection_3 ? resolveCollection({
        collection: collection_3,
        path: path_3,
        entityId: entityId_1,
        propertyConfigs,
        authController
      }) : void 0;
      const properties = resolvedCollection == null ? void 0 : resolvedCollection.properties;
      const delegateValues = usedDelegate_3.cmsToDelegateModel(values);
      const updatedValues = properties ? updateDateAutoValues({
        inputValues: delegateValues,
        properties,
        status,
        timestampNowValue: ((_b = usedDelegate_3.currentTime) == null ? void 0 : _b.call(usedDelegate_3)) ?? /* @__PURE__ */ new Date(),
        setDateToMidnight: usedDelegate_3.setDateToMidnight
      }) : delegateValues;
      return usedDelegate_3.saveEntity({
        path: path_3,
        collection: collection_3,
        entityId: entityId_1,
        values: updatedValues,
        status
      }).then((res) => {
        return {
          id: res.id,
          path: res.path,
          values: usedDelegate_3.delegateToCMSModel(updatedValues)
        };
      });
    }, [delegate.saveEntity, navigationController.getCollection]),
    /**
     * Delete an entity
     * @param entity
     * @param collection
     * @group Firestore
     */
    deleteEntity: (0, import_react14.useCallback)(({
      entity,
      collection: collection_4
    }) => {
      var _a;
      const usedDelegate_4 = ((_a = collection_4 == null ? void 0 : collection_4.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      return usedDelegate_4.deleteEntity({
        entity,
        collection: collection_4
      });
    }, [delegate.deleteEntity]),
    /**
     * Check if the given property is unique in the given collection
     * @param path Collection path
     * @param name of the property
     * @param value
     * @param property
     * @param entityId
     * @return `true` if there are no other fields besides the given entity
     * @group Firestore
     */
    checkUniqueField: (0, import_react14.useCallback)((path_4, name, value, entityId_2, collection_5) => {
      var _a;
      const usedDelegate_5 = ((_a = collection_5 == null ? void 0 : collection_5.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      return usedDelegate_5.checkUniqueField(path_4, name, value, entityId_2, collection_5);
    }, [delegate.checkUniqueField]),
    generateEntityId: (0, import_react14.useCallback)((path_5, collection_6) => {
      var _a;
      const usedDelegate_6 = ((_a = collection_6 == null ? void 0 : collection_6.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      return usedDelegate_6.generateEntityId(path_5, collection_6);
    }, [delegate.generateEntityId]),
    countEntities: delegate.countEntities ? async ({
      path: path_6,
      collection: collection_7,
      filter: filter_1,
      order: order_1,
      orderBy: orderBy_1
    }) => {
      var _a;
      const usedDelegate_7 = ((_a = collection_7 == null ? void 0 : collection_7.overrides) == null ? void 0 : _a.dataSourceDelegate) ?? delegate;
      return usedDelegate_7.countEntities({
        path: path_6,
        filter: filter_1,
        orderBy: orderBy_1,
        order: order_1,
        collection: collection_7
      });
    } : void 0,
    isFilterCombinationValid: (0, import_react14.useCallback)(({
      path: path_7,
      databaseId,
      filterValues,
      sortBy
    }) => {
      if (!delegate.isFilterCombinationValid) return true;
      return delegate.isFilterCombinationValid({
        path: path_7,
        databaseId,
        filterValues,
        sortBy
      });
    }, [delegate.isFilterCombinationValid]),
    initTextSearch: (0, import_react14.useCallback)(async (props) => {
      var _a, _b;
      const usedDelegate_8 = ((_b = (_a = props.collection) == null ? void 0 : _a.overrides) == null ? void 0 : _b.dataSourceDelegate) ?? delegate;
      if (!usedDelegate_8.initTextSearch) return false;
      return usedDelegate_8.initTextSearch(props);
    }, [delegate.initTextSearch])
  };
}
var DEFAULT_SERVER = "https://api-drplyi3b6q-ey.a.run.app";
async function makeRequest(authController, dataSourceKey, pluginKeys, apiKey) {
  var _a;
  let idToken;
  try {
    idToken = await authController.getAuthToken();
  } catch (e2) {
    idToken = null;
  }
  return fetch(DEFAULT_SERVER + "/access_log", {
    // mode: "no-cors",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Basic ${idToken}`
    },
    body: JSON.stringify({
      apiKey,
      email: ((_a = authController.user) == null ? void 0 : _a.email) ?? null,
      datasource: dataSourceKey,
      plugins: pluginKeys
    })
  }).then(async (res) => {
    return res.json();
  });
}
function useProjectLog(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(11);
  const {
    authController,
    dataSourceDelegate,
    plugins,
    apiKey
  } = t0;
  const [accessResponse, setAccessResponse] = (0, import_react14.useState)(null);
  const accessedUserRef = (0, import_react14.useRef)(null);
  const dataSourceKey = dataSourceDelegate.key;
  let t1;
  if ($[0] !== plugins) {
    t1 = plugins == null ? void 0 : plugins.map(_temp$3);
    $[0] = plugins;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const pluginKeys = t1;
  let t2;
  if ($[2] !== apiKey || $[3] !== authController || $[4] !== dataSourceKey || $[5] !== pluginKeys) {
    t2 = () => {
      if (authController.user && authController.user.uid !== accessedUserRef.current && !authController.initialLoading) {
        makeRequest(authController, dataSourceKey, pluginKeys, apiKey).then(setAccessResponse);
        accessedUserRef.current = authController.user.uid;
      }
    };
    $[2] = apiKey;
    $[3] = authController;
    $[4] = dataSourceKey;
    $[5] = pluginKeys;
    $[6] = t2;
  } else {
    t2 = $[6];
  }
  let t3;
  if ($[7] !== authController || $[8] !== dataSourceKey || $[9] !== pluginKeys) {
    t3 = [authController, dataSourceKey, pluginKeys];
    $[7] = authController;
    $[8] = dataSourceKey;
    $[9] = pluginKeys;
    $[10] = t3;
  } else {
    t3 = $[10];
  }
  (0, import_react14.useEffect)(t2, t3);
  return accessResponse;
}
function _temp$3(plugin) {
  return plugin.key;
}
function FireCMS(props) {
  const {
    children,
    entityLinkBuilder,
    userConfigPersistence,
    dateTimeFormat,
    locale,
    authController,
    storageSource,
    dataSourceDelegate,
    plugins,
    onAnalyticsEvent,
    propertyConfigs,
    entityViews,
    components,
    navigationController,
    apiKey
  } = props;
  const sideDialogsController = useBuildSideDialogsController();
  const sideEntityController = useBuildSideEntityController(navigationController, sideDialogsController, authController);
  const pluginsLoading = (plugins == null ? void 0 : plugins.some((p3) => p3.loading)) ?? false;
  const loading = authController.initialLoading || navigationController.loading || pluginsLoading;
  const customizationController = {
    dateTimeFormat,
    locale,
    entityLinkBuilder,
    plugins,
    entityViews: entityViews ?? [],
    propertyConfigs: propertyConfigs ?? {},
    components
  };
  const analyticsController = (0, import_react14.useMemo)(() => ({
    onAnalyticsEvent
  }), []);
  const accessResponse = useProjectLog({
    apiKey,
    authController,
    dataSourceDelegate,
    plugins
  });
  const dataSource = useBuildDataSource({
    delegate: dataSourceDelegate,
    propertyConfigs,
    navigationController,
    authController
  });
  if (accessResponse == null ? void 0 : accessResponse.message) {
    console.warn(accessResponse.message);
  }
  if (navigationController.navigationLoadingError) {
    return (0, import_jsx_runtime2.jsx)(CenteredView, { maxWidth: "md", children: (0, import_jsx_runtime2.jsx)(ErrorView, { title: "Error loading navigation", error: navigationController.navigationLoadingError }) });
  }
  if (authController.authError) {
    return (0, import_jsx_runtime2.jsx)(CenteredView, { maxWidth: "md", children: (0, import_jsx_runtime2.jsx)(ErrorView, { title: "Error loading auth", error: authController.authError }) });
  }
  if (accessResponse == null ? void 0 : accessResponse.blocked) {
    return (0, import_jsx_runtime2.jsxs)(CenteredView, { maxWidth: "md", fullScreen: true, className: "flex flex-col gap-2", children: [
      (0, import_jsx_runtime2.jsx)(Typography, { variant: "h4", gutterBottom: true, children: "License needed" }),
      (0, import_jsx_runtime2.jsxs)(Typography, { children: [
        "You need a valid license to use FireCMS PRO. Please reach out at ",
        (0, import_jsx_runtime2.jsx)("a", { href: "mailto:hello@firecms.co", children: "hello@firecms.co" }),
        " for more information."
      ] }),
      (accessResponse == null ? void 0 : accessResponse.message) && (0, import_jsx_runtime2.jsx)(Typography, { children: accessResponse == null ? void 0 : accessResponse.message })
    ] });
  }
  return (0, import_jsx_runtime2.jsx)(AnalyticsContext.Provider, { value: analyticsController, children: (0, import_jsx_runtime2.jsx)(CustomizationControllerContext.Provider, { value: customizationController, children: (0, import_jsx_runtime2.jsx)(UserConfigurationPersistenceContext.Provider, { value: userConfigPersistence, children: (0, import_jsx_runtime2.jsx)(StorageSourceContext.Provider, { value: storageSource, children: (0, import_jsx_runtime2.jsx)(DataSourceContext.Provider, { value: dataSource, children: (0, import_jsx_runtime2.jsx)(AuthControllerContext.Provider, { value: authController, children: (0, import_jsx_runtime2.jsx)(SideDialogsControllerContext.Provider, { value: sideDialogsController, children: (0, import_jsx_runtime2.jsx)(SideEntityControllerContext.Provider, { value: sideEntityController, children: (0, import_jsx_runtime2.jsx)(NavigationContext2.Provider, { value: navigationController, children: (0, import_jsx_runtime2.jsx)(DialogsProvider, { children: (0, import_jsx_runtime2.jsx)(BreadcrumbsProvider, { children: (0, import_jsx_runtime2.jsx)(FireCMSInternal, { loading, children }) }) }) }) }) }) }) }) }) }) }) });
}
function FireCMSInternal(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(7);
  const {
    loading,
    children
  } = t0;
  const context = useFireCMSContext();
  const customizationController = useCustomizationController();
  let childrenResult;
  if ($[0] !== children || $[1] !== context || $[2] !== customizationController.plugins || $[3] !== loading) {
    childrenResult = children({
      context,
      loading
    });
    const plugins = customizationController.plugins;
    if (!loading && plugins) {
      plugins.forEach((plugin) => {
        if (plugin.provider) {
          childrenResult = (0, import_jsx_runtime2.jsx)(plugin.provider.Component, { ...plugin.provider.props, context, children: childrenResult });
        }
      });
    }
    $[0] = children;
    $[1] = context;
    $[2] = customizationController.plugins;
    $[3] = loading;
    $[4] = childrenResult;
  } else {
    childrenResult = $[4];
  }
  let t1;
  if ($[5] !== childrenResult) {
    t1 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: childrenResult });
    $[5] = childrenResult;
    $[6] = t1;
  } else {
    t1 = $[6];
  }
  return t1;
}
function DrawerNavigationItem(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(24);
  const {
    name,
    icon,
    drawerOpen,
    adminMenuOpen,
    tooltipsOpen,
    url,
    onClick
  } = t0;
  let t1;
  if ($[0] !== icon) {
    t1 = (0, import_jsx_runtime2.jsx)("div", { className: "text-text-secondary dark:text-text-secondary-dark", children: icon });
    $[0] = icon;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const iconWrap = t1;
  const t2 = drawerOpen ? "width 150ms ease-in" : void 0;
  let t3;
  if ($[2] !== t2) {
    t3 = {
      width: "100%",
      transition: t2
    };
    $[2] = t2;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  let t4;
  if ($[4] !== drawerOpen) {
    t4 = (t52) => {
      const {
        isActive: isActive3
      } = t52;
      return cls("rounded-lg truncate", "hover:bg-surface-accent-300 hover:bg-opacity-75 dark:hover:bg-surface-accent-800 dark:hover:bg-opacity-75 text-text-primary dark:text-surface-200 hover:text-surface-900 hover:dark:text-white", "flex flex-row items-center mr-8", drawerOpen ? "pl-4 h-12" : "pl-4 h-11", "font-semibold text-xs", isActive3 ? "bg-surface-accent-200 bg-opacity-60 dark:bg-surface-800 dark:bg-opacity-50" : "");
    };
    $[4] = drawerOpen;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  const t5 = drawerOpen ? "opacity-100" : "opacity-0 hidden";
  let t6;
  if ($[6] !== t5) {
    t6 = cls(t5, "ml-4 font-inherit text-inherit");
    $[6] = t5;
    $[7] = t6;
  } else {
    t6 = $[7];
  }
  let t7;
  if ($[8] !== name) {
    t7 = name.toUpperCase();
    $[8] = name;
    $[9] = t7;
  } else {
    t7 = $[9];
  }
  let t8;
  if ($[10] !== t6 || $[11] !== t7) {
    t8 = (0, import_jsx_runtime2.jsx)("div", { className: t6, children: t7 });
    $[10] = t6;
    $[11] = t7;
    $[12] = t8;
  } else {
    t8 = $[12];
  }
  let t9;
  if ($[13] !== iconWrap || $[14] !== onClick || $[15] !== t3 || $[16] !== t4 || $[17] !== t8 || $[18] !== url) {
    t9 = (0, import_jsx_runtime2.jsx)("div", { children: (0, import_jsx_runtime2.jsxs)(NavLink, { onClick, style: t3, className: t4, to: url, children: [
      iconWrap,
      t8
    ] }) });
    $[13] = iconWrap;
    $[14] = onClick;
    $[15] = t3;
    $[16] = t4;
    $[17] = t8;
    $[18] = url;
    $[19] = t9;
  } else {
    t9 = $[19];
  }
  const listItem2 = t9;
  const t10 = drawerOpen || adminMenuOpen ? false : tooltipsOpen;
  let t11;
  if ($[20] !== listItem2 || $[21] !== name || $[22] !== t10) {
    t11 = (0, import_jsx_runtime2.jsx)(Tooltip, { open: t10, side: "right", title: name, children: listItem2 });
    $[20] = listItem2;
    $[21] = name;
    $[22] = t10;
    $[23] = t11;
  } else {
    t11 = $[23];
  }
  return t11;
}
function DefaultDrawer(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(52);
  const {
    className,
    style: style3
  } = t0;
  const {
    drawerHovered,
    drawerOpen,
    closeDrawer,
    logo
  } = useApp();
  const [adminMenuOpen, setAdminMenuOpen] = import_react14.default.useState(false);
  const analyticsController = useAnalyticsController();
  const navigation = useNavigationController();
  const tooltipsOpen = drawerHovered && !drawerOpen && !adminMenuOpen;
  const largeLayout = useLargeLayout();
  const navigate = useNavigate();
  if (!navigation.topLevelNavigation) {
    throw Error("Navigation not ready in Drawer");
  }
  const {
    navigationEntries,
    groups
  } = navigation.topLevelNavigation;
  let t1;
  if ($[0] !== adminMenuOpen || $[1] !== analyticsController || $[2] !== className || $[3] !== closeDrawer || $[4] !== drawerOpen || $[5] !== groups || $[6] !== largeLayout || $[7] !== logo || $[8] !== navigate || $[9] !== navigationEntries || $[10] !== style3 || $[11] !== tooltipsOpen) {
    const adminViews = navigationEntries.filter(_temp$2) ?? [];
    let t2;
    let t3;
    let t4;
    let t5;
    let t6;
    let t7;
    if ($[13] !== adminMenuOpen || $[14] !== analyticsController || $[15] !== className || $[16] !== closeDrawer || $[17] !== drawerOpen || $[18] !== groups || $[19] !== largeLayout || $[20] !== logo || $[21] !== navigationEntries || $[22] !== style3 || $[23] !== tooltipsOpen) {
      const groupsWithoutAdmin = groups.filter(_temp2$2);
      let t82;
      if ($[30] !== drawerOpen) {
        t82 = (group) => {
          if (!drawerOpen) {
            return (0, import_jsx_runtime2.jsx)("div", { className: "w-full" });
          }
          return (0, import_jsx_runtime2.jsx)("div", { className: "pl-6 pr-8 py-4 flex flex-row items-center", children: (0, import_jsx_runtime2.jsx)(Typography, { variant: "caption", color: "secondary", className: "font-medium flex-grow line-clamp-1", children: group ? group.toUpperCase() : "Views".toUpperCase() }) });
        };
        $[30] = drawerOpen;
        $[31] = t82;
      } else {
        t82 = $[31];
      }
      const buildGroupHeader = t82;
      let t9;
      if ($[32] !== analyticsController || $[33] !== closeDrawer || $[34] !== largeLayout) {
        t9 = (view) => {
          var _a;
          const eventName = view.type === "collection" ? "drawer_navigate_to_collection" : view.type === "view" ? "drawer_navigate_to_view" : "unmapped_event";
          (_a = analyticsController.onAnalyticsEvent) == null ? void 0 : _a.call(analyticsController, eventName, {
            url: view.url
          });
          if (!largeLayout) {
            closeDrawer();
          }
        };
        $[32] = analyticsController;
        $[33] = closeDrawer;
        $[34] = largeLayout;
        $[35] = t9;
      } else {
        t9 = $[35];
      }
      const onClick = t9;
      if ($[36] !== className) {
        t5 = cls("flex flex-col h-full relative flex-grow w-full", className);
        $[36] = className;
        $[37] = t5;
      } else {
        t5 = $[37];
      }
      t6 = style3;
      if ($[38] !== logo) {
        t7 = (0, import_jsx_runtime2.jsx)(DrawerLogo, { logo });
        $[38] = logo;
        $[39] = t7;
      } else {
        t7 = $[39];
      }
      t2 = "mt-4 flex-grow overflow-scroll no-scrollbar";
      if ($[40] === Symbol.for("react.memo_cache_sentinel")) {
        t3 = {
          maskImage: "linear-gradient(to bottom, transparent 0, black 20px, black calc(100% - 20px), transparent 100%)"
        };
        $[40] = t3;
      } else {
        t3 = $[40];
      }
      let t10;
      if ($[41] !== adminMenuOpen || $[42] !== buildGroupHeader || $[43] !== drawerOpen || $[44] !== navigationEntries || $[45] !== onClick || $[46] !== tooltipsOpen) {
        t10 = (group_0) => (0, import_jsx_runtime2.jsxs)("div", { className: "bg-surface-50 dark:bg-surface-800 dark:bg-opacity-30 my-4 rounded-lg ml-3 mr-1", children: [
          buildGroupHeader(group_0),
          Object.values(navigationEntries).filter((e_0) => e_0.group === group_0).map((view_0, index2) => (0, import_jsx_runtime2.jsx)(DrawerNavigationItem, { icon: (0, import_jsx_runtime2.jsx)(IconForView, { collectionOrView: view_0.collection ?? view_0.view, size: "small" }), tooltipsOpen, adminMenuOpen, drawerOpen, onClick: () => onClick(view_0), url: view_0.url, name: view_0.name }, `navigation_${index2}`))
        ] }, `drawer_group_${group_0}`);
        $[41] = adminMenuOpen;
        $[42] = buildGroupHeader;
        $[43] = drawerOpen;
        $[44] = navigationEntries;
        $[45] = onClick;
        $[46] = tooltipsOpen;
        $[47] = t10;
      } else {
        t10 = $[47];
      }
      t4 = groupsWithoutAdmin.map(t10);
      $[13] = adminMenuOpen;
      $[14] = analyticsController;
      $[15] = className;
      $[16] = closeDrawer;
      $[17] = drawerOpen;
      $[18] = groups;
      $[19] = largeLayout;
      $[20] = logo;
      $[21] = navigationEntries;
      $[22] = style3;
      $[23] = tooltipsOpen;
      $[24] = t2;
      $[25] = t3;
      $[26] = t4;
      $[27] = t5;
      $[28] = t6;
      $[29] = t7;
    } else {
      t2 = $[24];
      t3 = $[25];
      t4 = $[26];
      t5 = $[27];
      t6 = $[28];
      t7 = $[29];
    }
    let t8;
    if ($[48] !== t2 || $[49] !== t3 || $[50] !== t4) {
      t8 = (0, import_jsx_runtime2.jsx)("div", { className: t2, style: t3, children: t4 });
      $[48] = t2;
      $[49] = t3;
      $[50] = t4;
      $[51] = t8;
    } else {
      t8 = $[51];
    }
    t1 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsxs)("div", { className: t5, style: t6, children: [
      t7,
      t8,
      adminViews.length > 0 && (0, import_jsx_runtime2.jsx)(Menu, { side: "right", open: adminMenuOpen, onOpenChange: setAdminMenuOpen, trigger: (0, import_jsx_runtime2.jsxs)(IconButton, { shape: "square", className: "m-4 text-surface-900 dark:text-white w-fit", children: [
        (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Admin", open: tooltipsOpen, side: "right", sideOffset: 28, children: (0, import_jsx_runtime2.jsx)(MoreVertIcon, {}) }),
        drawerOpen && (0, import_jsx_runtime2.jsx)("div", { className: cls(drawerOpen ? "opacity-100" : "opacity-0 hidden", "mx-4 font-inherit text-inherit"), children: "ADMIN" })
      ] }), children: adminViews.map((entry, index_0) => (0, import_jsx_runtime2.jsxs)(MenuItem, { onClick: (event) => {
        event.preventDefault();
        navigate(entry.path);
      }, children: [
        (0, import_jsx_runtime2.jsx)(IconForView, { collectionOrView: entry.view }),
        entry.name
      ] }, `navigation_${index_0}`)) })
    ] }) });
    $[0] = adminMenuOpen;
    $[1] = analyticsController;
    $[2] = className;
    $[3] = closeDrawer;
    $[4] = drawerOpen;
    $[5] = groups;
    $[6] = largeLayout;
    $[7] = logo;
    $[8] = navigate;
    $[9] = navigationEntries;
    $[10] = style3;
    $[11] = tooltipsOpen;
    $[12] = t1;
  } else {
    t1 = $[12];
  }
  return t1;
}
function _temp2$2(g2) {
  return g2 !== "Admin";
}
function _temp$2(e2) {
  return e2.type === "admin";
}
function DrawerLogo(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(12);
  const {
    logo
  } = t0;
  const navigation = useNavigationController();
  const {
    drawerOpen
  } = useApp();
  const t1 = drawerOpen ? "32px 144px 0px 24px" : "72px 12px 0px 12px";
  let t2;
  if ($[0] !== t1) {
    t2 = {
      transition: "padding 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms",
      padding: t1
    };
    $[0] = t1;
    $[1] = t2;
  } else {
    t2 = $[1];
  }
  let t3;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t3 = cls("cursor-pointer rounded ml-3 mr-1");
    $[2] = t3;
  } else {
    t3 = $[2];
  }
  let t4;
  if ($[3] !== drawerOpen || $[4] !== logo) {
    t4 = logo ? (0, import_jsx_runtime2.jsx)("img", { src: logo, alt: "Logo", className: cls("max-w-full max-h-full transition-all object-contain", drawerOpen ? "w-[96px] h-[96px]" : "w-[32px] h-[32px]") }) : (0, import_jsx_runtime2.jsx)(FireCMSLogo, {});
    $[3] = drawerOpen;
    $[4] = logo;
    $[5] = t4;
  } else {
    t4 = $[5];
  }
  let t5;
  if ($[6] !== navigation.basePath || $[7] !== t4) {
    t5 = (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Home", sideOffset: 20, side: "right", children: (0, import_jsx_runtime2.jsx)(Link, { className: "block", to: navigation.basePath, children: t4 }) });
    $[6] = navigation.basePath;
    $[7] = t4;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== t2 || $[10] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)("div", { style: t2, className: t3, children: t5 });
    $[9] = t2;
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  return t6;
}
function isDefaultFieldConfigId(id2) {
  return Object.keys(DEFAULT_FIELD_CONFIGS).includes(id2);
}
var DEFAULT_FIELD_CONFIGS = {
  text_field: {
    key: "text_field",
    name: "Text field",
    description: "Simple short text",
    Icon: ShortTextIcon,
    color: "#2d7ff9",
    property: {
      dataType: "string",
      Field: TextFieldBinding
    }
  },
  multiline: {
    key: "multiline",
    name: "Multiline",
    description: "Text with multiple lines",
    Icon: SubjectIcon,
    color: "#2d7ff9",
    property: {
      dataType: "string",
      multiline: true,
      Field: TextFieldBinding
    }
  },
  markdown: {
    key: "markdown",
    name: "Markdown",
    description: "Text with advanced markdown syntax",
    Icon: FormatQuoteIcon,
    color: "#2d7ff9",
    property: {
      dataType: "string",
      markdown: true,
      Field: MarkdownEditorFieldBinding
    }
  },
  url: {
    key: "url",
    name: "Url",
    description: "Text with URL validation",
    Icon: HttpIcon,
    color: "#154fb3",
    property: {
      dataType: "string",
      url: true,
      Field: TextFieldBinding
    }
  },
  email: {
    key: "email",
    name: "Email",
    description: "Text with email validation",
    Icon: MailIcon,
    color: "#154fb3",
    property: {
      dataType: "string",
      email: true,
      Field: TextFieldBinding
    }
  },
  switch: {
    key: "switch",
    name: "Switch",
    description: "Boolean true or false field (or yes or no, 0 or 1...)",
    Icon: FlagIcon,
    color: "#20d9d2",
    property: {
      dataType: "boolean",
      Field: SwitchFieldBinding
    }
  },
  select: {
    key: "select",
    name: "Select/enum",
    description: "Select one text value from within an enumeration",
    Icon: ListIcon,
    color: "#4223c9",
    property: {
      dataType: "string",
      enumValues: [],
      Field: SelectFieldBinding
    }
  },
  multi_select: {
    key: "multi_select",
    name: "Multi select (enum)",
    description: "Select multiple text values from within an enumeration",
    Icon: ListAltIcon,
    color: "#4223c9",
    property: {
      dataType: "array",
      of: {
        dataType: "string",
        enumValues: []
      },
      Field: MultiSelectFieldBinding
    }
  },
  number_input: {
    key: "number_input",
    name: "Number input",
    description: "Simple number field with validation",
    Icon: NumbersIcon,
    color: "#bec920",
    property: {
      dataType: "number",
      Field: TextFieldBinding
    }
  },
  number_select: {
    key: "number_select",
    name: "Number select",
    description: "Select a number value from within an enumeration",
    Icon: FormatListNumberedIcon,
    color: "#bec920",
    property: {
      dataType: "number",
      enumValues: [],
      Field: SelectFieldBinding
    }
  },
  multi_number_select: {
    key: "multi_number_select",
    name: "Multiple number select",
    description: "Select multiple number values from within an enumeration",
    Icon: FormatListNumberedIcon,
    color: "#bec920",
    property: {
      dataType: "array",
      of: {
        dataType: "number",
        enumValues: []
      },
      Field: MultiSelectFieldBinding
    }
  },
  file_upload: {
    key: "file_upload",
    name: "File upload",
    description: "Input for uploading single files",
    Icon: UploadFileIcon,
    color: "#f92d9a",
    property: {
      dataType: "string",
      storage: {
        storagePath: "{path}"
      },
      Field: StorageUploadFieldBinding
    }
  },
  multi_file_upload: {
    key: "multi_file_upload",
    name: "Multiple file upload",
    description: "Input for uploading multiple files",
    Icon: DriveFolderUploadIcon,
    color: "#f92d9a",
    property: {
      dataType: "array",
      of: {
        dataType: "string",
        storage: {
          storagePath: "{path}"
        }
      },
      Field: StorageUploadFieldBinding
    }
  },
  reference: {
    key: "reference",
    name: "Reference",
    description: "The value refers to a different collection",
    Icon: LinkIcon,
    color: "#ff0042",
    property: {
      dataType: "reference",
      Field: ReferenceFieldBinding
    }
  },
  multi_references: {
    key: "multi_references",
    name: "Multiple references",
    description: "Multiple values that refer to a different collection",
    Icon: AddLinkIcon,
    color: "#ff0042",
    property: {
      dataType: "array",
      of: {
        dataType: "reference"
      },
      Field: ArrayOfReferencesFieldBinding
    }
  },
  date_time: {
    key: "date_time",
    name: "Date/time",
    description: "A date time select field",
    Icon: ScheduleIcon,
    color: "#8b46ff",
    property: {
      dataType: "date",
      Field: DateTimeFieldBinding
    }
  },
  group: {
    key: "group",
    name: "Group",
    description: "Group of multiple fields",
    Icon: BallotIcon,
    color: "#ff9408",
    property: {
      dataType: "map",
      properties: {},
      Field: MapFieldBinding
    }
  },
  key_value: {
    key: "key_value",
    name: "Key-value",
    description: "Flexible field that allows the user to add multiple key-value pairs",
    Icon: BallotIcon,
    color: "#ff9408",
    property: {
      dataType: "map",
      keyValue: true,
      Field: KeyValueFieldBinding
    }
  },
  repeat: {
    key: "repeat",
    name: "Repeat/list",
    description: "A field that gets repeated multiple times (e.g. multiple text fields)",
    Icon: RepeatIcon,
    color: "#ff9408",
    property: {
      dataType: "array",
      of: {
        dataType: "string"
      },
      Field: RepeatFieldBinding
    }
  },
  custom_array: {
    key: "custom_array",
    name: "Custom array",
    description: "A field that saved its value as an array of custom objects",
    Icon: RepeatIcon,
    color: "#ff9408",
    property: {
      dataType: "array",
      of: [],
      Field: ArrayCustomShapedFieldBinding
    }
  },
  block: {
    key: "block",
    name: "Block",
    description: "A complex field that allows the user to compose different fields together, with a key/value format",
    Icon: ViewStreamIcon,
    color: "#ff9408",
    property: {
      dataType: "array",
      oneOf: {
        properties: {}
      },
      Field: BlockFieldBinding
    }
  }
};
function getDefaultFieldConfig(property) {
  const fieldId = getDefaultFieldId(property);
  if (!fieldId) {
    console.error("No field id found for property", property);
    return void 0;
  }
  return DEFAULT_FIELD_CONFIGS[fieldId];
}
function getFieldConfig(property, propertyConfigs) {
  const fieldId = getFieldId(property);
  const defaultFieldId = getDefaultFieldId(property);
  if (!defaultFieldId) {
    console.error("No field id found for property", property);
    return void 0;
  }
  const defaultFieldConfig = DEFAULT_FIELD_CONFIGS[defaultFieldId];
  const customField = fieldId ? propertyConfigs[fieldId] : void 0;
  return mergeDeep2(defaultFieldConfig ?? {}, customField ?? {});
}
function getDefaultFieldId(property) {
  if (property.dataType === "string") {
    if (property.multiline) {
      return "multiline";
    } else if (property.markdown) {
      return "markdown";
    } else if (property.storage) {
      return "file_upload";
    } else if (property.url) {
      return "url";
    } else if (property.email) {
      return "email";
    } else if (property.enumValues) {
      return "select";
    } else {
      return "text_field";
    }
  } else if (property.dataType === "number") {
    if (property.enumValues) {
      return "number_select";
    }
    return "number_input";
  } else if (property.dataType === "map") {
    if (property.keyValue) return "key_value";
    return "group";
  } else if (property.dataType === "array") {
    const of = property.of;
    const oneOf = property.oneOf;
    if (oneOf) {
      return "block";
    } else if (Array.isArray(of)) {
      return "custom_array";
    } else if (isPropertyBuilder(of)) {
      return "repeat";
    } else if ((of == null ? void 0 : of.dataType) === "string" && of.enumValues) {
      return "multi_select";
    } else if ((of == null ? void 0 : of.dataType) === "number" && of.enumValues) {
      return "multi_number_select";
    } else if ((of == null ? void 0 : of.dataType) === "string" && of.storage) {
      return "multi_file_upload";
    } else if ((of == null ? void 0 : of.dataType) === "reference") {
      return "multi_references";
    } else {
      return "repeat";
    }
  } else if (property.dataType === "boolean") {
    return "switch";
  } else if (property.dataType === "date") {
    return "date_time";
  } else if (property.dataType === "reference") {
    return "reference";
  }
  console.error("Unsupported field config mapping", property);
  return void 0;
}
function getFieldId(property) {
  if (property.propertyConfig) return property.propertyConfig;
  return getDefaultFieldId(property);
}
function FireCMSRoute() {
  const $ = (0, import_react_compiler_runtime3.c)(33);
  const location = useLocation();
  const navigation = useNavigationController();
  const breadcrumbs = useBreadcrumbsController();
  const hash22 = location.hash;
  const isSidePanel = hash22.includes("#side");
  let t0;
  if ($[0] !== hash22) {
    t0 = hash22.includes("#new") || hash22.includes("#new_side");
    $[0] = hash22;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const isNew = t0;
  let t1;
  if ($[2] !== hash22) {
    t1 = hash22.includes("#copy");
    $[2] = hash22;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const isCopy = t1;
  const pathname = location.pathname;
  let navigationEntries;
  let t2;
  let t3;
  let t4;
  if ($[4] !== breadcrumbs || $[5] !== navigation || $[6] !== pathname) {
    const navigationPath = navigation.urlPathToDataPath(pathname);
    let t52;
    if ($[11] !== navigation.collections) {
      t52 = navigation.collections ?? [];
      $[11] = navigation.collections;
      $[12] = t52;
    } else {
      t52 = $[12];
    }
    navigationEntries = getNavigationEntriesFromPath({
      path: navigationPath,
      collections: t52
    });
    t3 = import_react14.useEffect;
    t4 = () => {
      breadcrumbs.set({
        breadcrumbs: navigationEntries.map((entry) => {
          if (entry.type === "entity") {
            return {
              title: entry.entityId,
              url: navigation.buildUrlCollectionPath(entry.fullPath)
            };
          } else {
            if (entry.type === "custom_view") {
              return {
                title: entry.view.name,
                url: navigation.buildUrlCollectionPath(entry.fullPath)
              };
            } else {
              if (entry.type === "collection") {
                return {
                  title: entry.collection.name,
                  url: navigation.buildUrlCollectionPath(entry.fullPath)
                };
              } else {
                throw new Error("Unexpected navigation entry type");
              }
            }
          }
        })
      });
    };
    t2 = navigationEntries.map(_temp$12).join(",");
    $[4] = breadcrumbs;
    $[5] = navigation;
    $[6] = pathname;
    $[7] = navigationEntries;
    $[8] = t2;
    $[9] = t3;
    $[10] = t4;
  } else {
    navigationEntries = $[7];
    t2 = $[8];
    t3 = $[9];
    t4 = $[10];
  }
  let t5;
  if ($[13] !== t2) {
    t5 = [t2];
    $[13] = t2;
    $[14] = t5;
  } else {
    t5 = $[14];
  }
  t3(t4, t5);
  if (isNew) {
    let t62;
    if ($[15] !== navigationEntries || $[16] !== pathname) {
      t62 = (0, import_jsx_runtime2.jsx)(EntityFullScreenRoute, { pathname, navigationEntries, isNew: true, isCopy: false });
      $[15] = navigationEntries;
      $[16] = pathname;
      $[17] = t62;
    } else {
      t62 = $[17];
    }
    return t62;
  }
  if (navigationEntries.length === 1 && navigationEntries[0].type === "collection") {
    let t62;
    let t7;
    if ($[18] !== navigation || $[19] !== navigationEntries) {
      t7 = Symbol.for("react.early_return_sentinel");
      bb0: {
        let collection;
        collection = navigation.getCollectionById(navigationEntries[0].id);
        if (!collection) {
          collection = navigation.getCollection(navigationEntries[0].path);
        }
        if (!collection) {
          t7 = null;
          break bb0;
        }
        let t8;
        if ($[22] === Symbol.for("react.memo_cache_sentinel")) {
          t8 = [];
          $[22] = t8;
        } else {
          t8 = $[22];
        }
        t62 = (0, import_jsx_runtime2.jsx)(EntityCollectionView, { isSubCollection: false, parentCollectionIds: t8, fullPath: collection.id, updateUrl: true, ...collection, Actions: toArray2(collection.Actions) }, `collection_view_${collection.id ?? collection.path}`);
      }
      $[18] = navigation;
      $[19] = navigationEntries;
      $[20] = t62;
      $[21] = t7;
    } else {
      t62 = $[20];
      t7 = $[21];
    }
    if (t7 !== Symbol.for("react.early_return_sentinel")) {
      return t7;
    }
    return t62;
  }
  if (isSidePanel) {
    const lastCollectionEntry = navigationEntries.findLast(_temp2$1);
    if (lastCollectionEntry) {
      let t62;
      let t7;
      if ($[23] !== navigation || $[24] !== navigationEntries) {
        t7 = Symbol.for("react.early_return_sentinel");
        bb1: {
          let collection_0;
          const firstEntry = navigationEntries[0];
          collection_0 = navigation.getCollectionById(firstEntry.id);
          if (!collection_0) {
            collection_0 = navigation.getCollection(firstEntry.path);
          }
          if (!collection_0) {
            t7 = null;
            break bb1;
          }
          let t8;
          if ($[27] === Symbol.for("react.memo_cache_sentinel")) {
            t8 = [];
            $[27] = t8;
          } else {
            t8 = $[27];
          }
          t62 = (0, import_jsx_runtime2.jsx)(EntityCollectionView, { fullIdPath: collection_0.id, isSubCollection: false, parentCollectionIds: t8, fullPath: collection_0.id, updateUrl: true, ...collection_0, Actions: toArray2(collection_0.Actions) }, `collection_view_${collection_0.id ?? collection_0.path}`);
        }
        $[23] = navigation;
        $[24] = navigationEntries;
        $[25] = t62;
        $[26] = t7;
      } else {
        t62 = $[25];
        t7 = $[26];
      }
      if (t7 !== Symbol.for("react.early_return_sentinel")) {
        return t7;
      }
      return t62;
    }
  }
  let t6;
  if ($[28] !== isCopy || $[29] !== isNew || $[30] !== navigationEntries || $[31] !== pathname) {
    t6 = (0, import_jsx_runtime2.jsx)(EntityFullScreenRoute, { pathname, navigationEntries, isNew, isCopy });
    $[28] = isCopy;
    $[29] = isNew;
    $[30] = navigationEntries;
    $[31] = pathname;
    $[32] = t6;
  } else {
    t6 = $[32];
  }
  return t6;
}
function _temp2$1(entry_1) {
  return entry_1.type === "collection";
}
function _temp$12(entry_0) {
  return entry_0.path;
}
function getSelectedTabFromUrl(isNew, lastCustomView) {
  if (isNew) {
    return void 0;
  } else if (lastCustomView) {
    if (lastCustomView.type === "custom_view") {
      return lastCustomView.view.key;
    } else if (lastCustomView.type === "collection") {
      return lastCustomView.id ?? lastCustomView.path;
    }
  }
  return void 0;
}
function EntityFullScreenRoute({
  pathname,
  navigationEntries,
  isNew,
  isCopy
}) {
  const navigation = useNavigationController();
  const navigate = useNavigate();
  const navigationPath = navigation.urlPathToDataPath(pathname);
  const blocked = (0, import_react14.useRef)(false);
  const lastEntityEntry = navigationEntries.findLast((entry) => entry.type === "entity");
  const navigationEntriesAfterEntity = lastEntityEntry ? navigationEntries.slice(navigationEntries.indexOf(lastEntityEntry) + 1) : [];
  const lastCustomView = navigationEntriesAfterEntity.findLast((entry_0) => entry_0.type === "custom_view" || entry_0.type === "collection");
  const entityId = lastEntityEntry == null ? void 0 : lastEntityEntry.entityId;
  const urlTab = getSelectedTabFromUrl(isNew, lastCustomView);
  const [selectedTab, setSelectedTab] = (0, import_react14.useState)(urlTab);
  const parentCollectionIds = navigation.getParentCollectionIds(navigationPath);
  (0, import_react14.useEffect)(() => {
    if (urlTab !== selectedTab) {
      setSelectedTab(urlTab);
    }
  }, [urlTab]);
  const basePath = !entityId || isNew ? pathname : pathname.substring(0, pathname.lastIndexOf(`/${entityId}`));
  const entityPath = basePath + `/${entityId}`;
  let blocker = void 0;
  try {
    blocker = useBlocker(({
      nextLocation
    }) => {
      if (nextLocation.pathname.startsWith(entityPath)) return false;
      return blocked.current;
    });
  } catch (e2) {
  }
  const lastCollectionEntry = navigationEntries.findLast((entry_1) => entry_1.type === "collection");
  if (isNew && !lastCollectionEntry) {
    throw new Error("INTERNAL: No collection found in the navigation");
  }
  if (!isNew && !lastEntityEntry) {
    return (0, import_jsx_runtime2.jsx)(NotFoundPage, {});
  }
  const collection = isNew ? lastCollectionEntry.collection : lastEntityEntry.parentCollection;
  const fullIdPath = isNew ? lastCollectionEntry.path : lastEntityEntry.path;
  const collectionPath = navigation.resolveIdsFrom(fullIdPath);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(EntityEditView, { entityId: isNew ? void 0 : entityId, fullIdPath, collection, layout: "full_screen", path: collectionPath, copy: isCopy, selectedTab: selectedTab ?? void 0, onValuesModified: (modified) => blocked.current = modified, onSaved: (params) => {
      const newSelectedTab = params.selectedTab;
      const newEntityId = params.entityId;
      if (newSelectedTab) {
        navigate(`${basePath}/${newEntityId}/${newSelectedTab}`, {
          replace: true
        });
      } else {
        navigate(`${basePath}/${newEntityId}`, {
          replace: true
        });
      }
    }, onTabChange: (params_0) => {
      setSelectedTab(params_0.selectedTab);
      if (isNew) {
        return;
      }
      const newSelectedTab_0 = params_0.selectedTab;
      if (newSelectedTab_0) {
        navigate(`${basePath}/${entityId}/${newSelectedTab_0}`, {
          replace: true
        });
      } else {
        navigate(`${basePath}/${entityId}`, {
          replace: true
        });
      }
    }, parentCollectionIds }, collection.id + "_" + (isNew ? "new" : isCopy ? entityId + "_copy" : entityId)),
    (0, import_jsx_runtime2.jsx)(UnsavedChangesDialog, { open: (blocker == null ? void 0 : blocker.state) === "blocked", handleOk: () => {
      var _a;
      return (_a = blocker == null ? void 0 : blocker.proceed) == null ? void 0 : _a.call(blocker);
    }, handleCancel: () => {
      var _a;
      return (_a = blocker == null ? void 0 : blocker.reset) == null ? void 0 : _a.call(blocker);
    }, body: "You have unsaved changes in this entity." })
  ] });
}
function CustomCMSRoute(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    cmsView
  } = t0;
  const breadcrumbs = useBreadcrumbsController();
  let t1;
  if ($[0] !== breadcrumbs || $[1] !== cmsView.name || $[2] !== cmsView.path) {
    t1 = () => {
      breadcrumbs.set({
        breadcrumbs: [{
          title: cmsView.name,
          url: cmsView.path
        }]
      });
    };
    $[0] = breadcrumbs;
    $[1] = cmsView.name;
    $[2] = cmsView.path;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  let t2;
  if ($[4] !== cmsView.path) {
    t2 = [cmsView.path];
    $[4] = cmsView.path;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  (0, import_react14.useEffect)(t1, t2);
  return cmsView.view;
}
function HomePageRoute(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(3);
  const {
    children
  } = t0;
  const breadcrumbs = useBreadcrumbsController();
  let t1;
  if ($[0] !== breadcrumbs) {
    t1 = () => {
      breadcrumbs.set({
        breadcrumbs: []
      });
    };
    $[0] = breadcrumbs;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  let t2;
  if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = [];
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  (0, import_react14.useEffect)(t1, t2);
  return children;
}
var NavigationRoutes = import_react14.default.memo(function NavigationRoutes2({
  homePage = (0, import_jsx_runtime2.jsx)(DefaultHomePage, {}),
  children
}) {
  const location = useLocation();
  const navigation = useNavigationController();
  if (!navigation) return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
  const state = location.state;
  const baseLocation = state && state.base_location ? state.base_location : location;
  const cmsViews = [];
  if (navigation.views) {
    navigation.views.forEach((cmsView) => {
      if (Array.isArray(cmsView.path)) cmsViews.push(...cmsView.path.map((path) => buildCMSViewRoute(path, cmsView)));
      else cmsViews.push(buildCMSViewRoute(cmsView.path, cmsView));
    });
  }
  if (navigation.adminViews) {
    navigation.adminViews.forEach((cmsView_0) => {
      if (Array.isArray(cmsView_0.path)) cmsViews.push(...cmsView_0.path.map((path_0) => buildCMSViewRoute(path_0, cmsView_0)));
      else cmsViews.push(buildCMSViewRoute(cmsView_0.path, cmsView_0));
    });
  }
  const collectionUrlPath = navigation.buildUrlCollectionPath("");
  const collectionRoute = (0, import_jsx_runtime2.jsx)(Route, { path: collectionUrlPath + "/*", element: (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: (0, import_jsx_runtime2.jsx)(FireCMSRoute, {}) }) }, `navigation_entity`);
  const homeRoute = (0, import_jsx_runtime2.jsx)(Route, { path: "/", element: (0, import_jsx_runtime2.jsx)(HomePageRoute, { children: homePage }) });
  const notFoundRoute = (0, import_jsx_runtime2.jsx)(Route, { path: "*", element: (0, import_jsx_runtime2.jsx)(NotFoundPage, {}) });
  return (0, import_jsx_runtime2.jsxs)(Routes, { location: baseLocation, children: [
    collectionRoute,
    cmsViews,
    homeRoute,
    notFoundRoute,
    children
  ] });
});
var buildCMSViewRoute = (path, cmsView) => {
  return (0, import_jsx_runtime2.jsx)(Route, { path, element: (0, import_jsx_runtime2.jsx)(CustomCMSRoute, { cmsView }) }, "navigation_view_" + path);
};
function FireCMSRouter(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(5);
  const {
    children,
    basePath
  } = t0;
  const t1 = basePath ? `${removeInitialAndTrailingSlashes(basePath)}/*` : "/*";
  let t2;
  if ($[0] !== children || $[1] !== t1) {
    t2 = createBrowserRouter([{
      path: t1,
      element: children
    }]);
    $[0] = children;
    $[1] = t1;
    $[2] = t2;
  } else {
    t2 = $[2];
  }
  let t3;
  if ($[3] !== t2) {
    t3 = (0, import_jsx_runtime2.jsx)(RouterProvider, { router: t2 });
    $[3] = t2;
    $[4] = t3;
  } else {
    t3 = $[4];
  }
  return t3;
}
function Drawer(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(6);
  const {
    children,
    className,
    style: style3
  } = t0;
  let t1;
  if ($[0] !== children || $[1] !== className || $[2] !== style3) {
    t1 = children ?? (0, import_jsx_runtime2.jsx)(DefaultDrawer, { className, style: style3 });
    $[0] = children;
    $[1] = className;
    $[2] = style3;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const usedChildren = t1;
  let t2;
  if ($[4] !== usedChildren) {
    t2 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: usedChildren });
    $[4] = usedChildren;
    $[5] = t2;
  } else {
    t2 = $[5];
  }
  return t2;
}
Drawer.componentType = "Drawer";
function AppBar(t0) {
  const $ = (0, import_react_compiler_runtime3.c)(8);
  let children;
  let props;
  if ($[0] !== t0) {
    ({
      children,
      ...props
    } = t0);
    $[0] = t0;
    $[1] = children;
    $[2] = props;
  } else {
    children = $[1];
    props = $[2];
  }
  let t1;
  if ($[3] !== children || $[4] !== props) {
    t1 = children ?? (0, import_jsx_runtime2.jsx)(DefaultAppBar, { ...props });
    $[3] = children;
    $[4] = props;
    $[5] = t1;
  } else {
    t1 = $[5];
  }
  const usedChildren = t1;
  let t2;
  if ($[6] !== usedChildren) {
    t2 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: usedChildren });
    $[6] = usedChildren;
    $[7] = t2;
  } else {
    t2 = $[7];
  }
  return t2;
}
AppBar.componentType = "AppBar";
var DRAWER_WIDTH = 280;
var Scaffold = import_react14.default.memo(function Scaffold2(props) {
  const $ = (0, import_react_compiler_runtime3.c)(48);
  const {
    children,
    autoOpenDrawer,
    logo,
    className,
    style: style3,
    padding: t0
  } = props;
  const padding = t0 === void 0 ? true : t0;
  let t1;
  if ($[0] !== children) {
    t1 = import_react14.default.Children.toArray(children).filter(_temp11);
    $[0] = children;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const drawerChildren = t1;
  if (drawerChildren.length > 1) {
    throw Error("Only one Drawer component is allowed in Scaffold");
  }
  let t2;
  if ($[2] !== children) {
    t2 = import_react14.default.Children.toArray(children).filter(_temp22);
    $[2] = children;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  const appBarChildren = t2;
  if (appBarChildren.length > 1) {
    throw Error("Only one AppBar component is allowed in Scaffold");
  }
  let t3;
  if ($[4] !== children) {
    t3 = import_react14.default.Children.toArray(children).filter(_temp32);
    $[4] = children;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  const otherChildren = t3;
  const includeDrawer = drawerChildren.length > 0;
  const largeLayout = useLargeLayout();
  const [drawerOpen, setDrawerOpen] = import_react14.default.useState(false);
  const [onHover, setOnHover] = import_react14.default.useState(false);
  let t4;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = () => setOnHover(true);
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  const setOnHoverTrue = t4;
  let t5;
  if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
    t5 = () => setOnHover(false);
    $[7] = t5;
  } else {
    t5 = $[7];
  }
  const setOnHoverFalse = t5;
  let t6;
  if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
    t6 = () => {
      setDrawerOpen(true);
    };
    $[8] = t6;
  } else {
    t6 = $[8];
  }
  const handleDrawerOpen = t6;
  let t7;
  if ($[9] === Symbol.for("react.memo_cache_sentinel")) {
    t7 = () => {
      setDrawerOpen(false);
    };
    $[9] = t7;
  } else {
    t7 = $[9];
  }
  const handleDrawerClose = t7;
  const computedDrawerOpen = drawerOpen || Boolean(largeLayout && autoOpenDrawer && onHover);
  const hasAppBar = Boolean(appBarChildren.length > 0);
  let t8;
  if ($[10] !== autoOpenDrawer || $[11] !== computedDrawerOpen || $[12] !== includeDrawer || $[13] !== logo || $[14] !== onHover) {
    t8 = {
      logo,
      hasDrawer: includeDrawer,
      drawerHovered: onHover,
      drawerOpen: computedDrawerOpen,
      closeDrawer: handleDrawerClose,
      openDrawer: handleDrawerOpen,
      autoOpenDrawer
    };
    $[10] = autoOpenDrawer;
    $[11] = computedDrawerOpen;
    $[12] = includeDrawer;
    $[13] = logo;
    $[14] = onHover;
    $[15] = t8;
  } else {
    t8 = $[15];
  }
  let t9;
  if ($[16] !== className) {
    t9 = cls("flex h-screen w-screen bg-surface-50 dark:bg-surface-900 text-surface-900 dark:text-white overflow-hidden", className);
    $[16] = className;
    $[17] = t9;
  } else {
    t9 = $[17];
  }
  let t10;
  if ($[18] !== style3) {
    t10 = {
      paddingTop: "env(safe-area-inset-top)",
      paddingLeft: "env(safe-area-inset-left)",
      paddingRight: "env(safe-area-inset-right)",
      paddingBottom: "env(safe-area-inset-bottom)",
      height: "100dvh",
      ...style3
    };
    $[18] = style3;
    $[19] = t10;
  } else {
    t10 = $[19];
  }
  const t11 = includeDrawer && drawerChildren;
  let t12;
  if ($[20] !== computedDrawerOpen || $[21] !== includeDrawer || $[22] !== onHover || $[23] !== t11) {
    t12 = (0, import_jsx_runtime2.jsx)(DrawerWrapper, { displayed: includeDrawer, onMouseEnter: setOnHoverTrue, onMouseMove: setOnHoverTrue, onMouseLeave: setOnHoverFalse, open: computedDrawerOpen, hovered: onHover, setDrawerOpen, children: t11 });
    $[20] = computedDrawerOpen;
    $[21] = includeDrawer;
    $[22] = onHover;
    $[23] = t11;
    $[24] = t12;
  } else {
    t12 = $[24];
  }
  let t13;
  if ($[25] !== hasAppBar) {
    t13 = hasAppBar && (0, import_jsx_runtime2.jsx)(DrawerHeader, {});
    $[25] = hasAppBar;
    $[26] = t13;
  } else {
    t13 = $[26];
  }
  const t14 = !hasAppBar;
  const t15 = hasAppBar && !padding;
  let t16;
  if ($[27] !== padding || $[28] !== t14 || $[29] !== t15) {
    t16 = cls(defaultBorderMixin, "flex-grow overflow-auto m-0 ", {
      "lg:mt-4": t14,
      "mt-1 lg:m-0 lg:mx-4 lg:mb-4 lg:rounded-lg lg:border lg:border-solid": padding,
      "border-t": t15
    });
    $[27] = padding;
    $[28] = t14;
    $[29] = t15;
    $[30] = t16;
  } else {
    t16 = $[30];
  }
  let t17;
  if ($[31] !== otherChildren) {
    t17 = (0, import_jsx_runtime2.jsx)(ErrorBoundary2, { children: otherChildren });
    $[31] = otherChildren;
    $[32] = t17;
  } else {
    t17 = $[32];
  }
  let t18;
  if ($[33] !== t16 || $[34] !== t17) {
    t18 = (0, import_jsx_runtime2.jsx)("div", { className: t16, children: t17 });
    $[33] = t16;
    $[34] = t17;
    $[35] = t18;
  } else {
    t18 = $[35];
  }
  let t19;
  if ($[36] !== t13 || $[37] !== t18) {
    t19 = (0, import_jsx_runtime2.jsxs)("main", { className: "flex flex-col flex-grow overflow-auto", children: [
      t13,
      t18
    ] });
    $[36] = t13;
    $[37] = t18;
    $[38] = t19;
  } else {
    t19 = $[38];
  }
  let t20;
  if ($[39] !== appBarChildren || $[40] !== t10 || $[41] !== t12 || $[42] !== t19 || $[43] !== t9) {
    t20 = (0, import_jsx_runtime2.jsxs)("div", { className: t9, style: t10, children: [
      appBarChildren,
      t12,
      t19
    ] });
    $[39] = appBarChildren;
    $[40] = t10;
    $[41] = t12;
    $[42] = t19;
    $[43] = t9;
    $[44] = t20;
  } else {
    t20 = $[44];
  }
  let t21;
  if ($[45] !== t20 || $[46] !== t8) {
    t21 = (0, import_jsx_runtime2.jsx)(AppContext2.Provider, { value: t8, children: t20 });
    $[45] = t20;
    $[46] = t8;
    $[47] = t21;
  } else {
    t21 = $[47];
  }
  return t21;
}, import_react_fast_compare2.default);
var DrawerHeader = () => {
  const $ = (0, import_react_compiler_runtime3.c)(1);
  let t0;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col min-h-16" });
    $[0] = t0;
  } else {
    t0 = $[0];
  }
  return t0;
};
function DrawerWrapper(props) {
  const $ = (0, import_react_compiler_runtime3.c)(39);
  const width = !props.displayed ? 0 : props.open ? DRAWER_WIDTH : 72;
  let t0;
  if ($[0] !== width) {
    t0 = {
      width,
      transition: "left 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms, opacity 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms, width 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms"
    };
    $[0] = width;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  let t1;
  if ($[2] !== props) {
    t1 = !props.open && props.displayed && (0, import_jsx_runtime2.jsx)(Tooltip, { title: "Open menu", side: "right", sideOffset: 12, asChild: true, children: (0, import_jsx_runtime2.jsx)("div", { className: "ml-2 fixed top-1 left-2 sm:top-2 sm:left-2 !bg-surface-50 dark:!bg-surface-900 rounded-full w-fit z-20", children: (0, import_jsx_runtime2.jsx)(IconButton, { color: "inherit", "aria-label": "Open menu", onClick: () => props.setDrawerOpen(true), size: "large", children: (0, import_jsx_runtime2.jsx)(MenuIcon, {}) }) }) });
    $[2] = props;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const t2 = `z-20 absolute right-0 top-4 ${props.open ? "opacity-100" : "opacity-0 invisible"} transition-opacity duration-200 ease-in-out`;
  let t3;
  if ($[4] !== props) {
    t3 = () => props.setDrawerOpen(false);
    $[4] = props;
    $[5] = t3;
  } else {
    t3 = $[5];
  }
  let t4;
  if ($[6] === Symbol.for("react.memo_cache_sentinel")) {
    t4 = (0, import_jsx_runtime2.jsx)(ChevronLeftIcon, {});
    $[6] = t4;
  } else {
    t4 = $[6];
  }
  let t5;
  if ($[7] !== t3) {
    t5 = (0, import_jsx_runtime2.jsx)(IconButton, { "aria-label": "Close drawer", onClick: t3, children: t4 });
    $[7] = t3;
    $[8] = t5;
  } else {
    t5 = $[8];
  }
  let t6;
  if ($[9] !== t2 || $[10] !== t5) {
    t6 = (0, import_jsx_runtime2.jsx)("div", { className: t2, children: t5 });
    $[9] = t2;
    $[10] = t5;
    $[11] = t6;
  } else {
    t6 = $[11];
  }
  let t7;
  if ($[12] !== props.children) {
    t7 = (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-col h-full", children: props.children });
    $[12] = props.children;
    $[13] = t7;
  } else {
    t7 = $[13];
  }
  let t8;
  if ($[14] !== t0 || $[15] !== t1 || $[16] !== t6 || $[17] !== t7) {
    t8 = (0, import_jsx_runtime2.jsxs)("div", { className: "relative h-full no-scrollbar overflow-y-auto overflow-x-hidden", style: t0, children: [
      t1,
      t6,
      t7
    ] });
    $[14] = t0;
    $[15] = t1;
    $[16] = t6;
    $[17] = t7;
    $[18] = t8;
  } else {
    t8 = $[18];
  }
  const innerDrawer = t8;
  const largeLayout = useLargeLayout();
  if (!largeLayout) {
    if (!props.displayed) {
      return null;
    }
    let t92;
    if ($[19] !== props) {
      t92 = () => props.setDrawerOpen(true);
      $[19] = props;
      $[20] = t92;
    } else {
      t92 = $[20];
    }
    let t102;
    if ($[21] === Symbol.for("react.memo_cache_sentinel")) {
      t102 = (0, import_jsx_runtime2.jsx)(MenuIcon, {});
      $[21] = t102;
    } else {
      t102 = $[21];
    }
    let t11;
    if ($[22] !== t92) {
      t11 = (0, import_jsx_runtime2.jsx)(IconButton, { color: "inherit", "aria-label": "Open drawer", onClick: t92, size: "large", className: "absolute sm:top-2 sm:left-4 top-1 left-2", children: t102 });
      $[22] = t92;
      $[23] = t11;
    } else {
      t11 = $[23];
    }
    let t12;
    if ($[24] !== innerDrawer || $[25] !== props.open || $[26] !== props.setDrawerOpen) {
      t12 = (0, import_jsx_runtime2.jsx)(Sheet, { side: "left", transparent: true, open: props.open, onOpenChange: props.setDrawerOpen, title: "Navigation drawer", overlayClassName: "bg-white bg-opacity-80", children: innerDrawer });
      $[24] = innerDrawer;
      $[25] = props.open;
      $[26] = props.setDrawerOpen;
      $[27] = t12;
    } else {
      t12 = $[27];
    }
    let t13;
    if ($[28] !== t11 || $[29] !== t12) {
      t13 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
        t11,
        t12
      ] });
      $[28] = t11;
      $[29] = t12;
      $[30] = t13;
    } else {
      t13 = $[30];
    }
    return t13;
  }
  let t9;
  if ($[31] !== width) {
    t9 = {
      width,
      transition: "left 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms, opacity 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms, width 100ms cubic-bezier(0.4, 0, 0.6, 1) 0ms"
    };
    $[31] = width;
    $[32] = t9;
  } else {
    t9 = $[32];
  }
  let t10;
  if ($[33] !== innerDrawer || $[34] !== props.onMouseEnter || $[35] !== props.onMouseLeave || $[36] !== props.onMouseMove || $[37] !== t9) {
    t10 = (0, import_jsx_runtime2.jsx)("div", { className: "z-20 relative", onMouseEnter: props.onMouseEnter, onMouseMove: props.onMouseMove, onMouseLeave: props.onMouseLeave, style: t9, children: innerDrawer });
    $[33] = innerDrawer;
    $[34] = props.onMouseEnter;
    $[35] = props.onMouseLeave;
    $[36] = props.onMouseMove;
    $[37] = t9;
    $[38] = t10;
  } else {
    t10 = $[38];
  }
  return t10;
}
function _temp11(child) {
  return child.type.componentType === "Drawer";
}
function _temp22(child_0) {
  return child_0.type.componentType === "AppBar";
}
function _temp32(child_1) {
  return child_1.type.componentType !== "Drawer" && child_1.type.componentType !== "AppBar";
}

export {
  Fuse,
  SnackbarProvider2 as SnackbarProvider,
  ModeControllerContext,
  ModeControllerProvider,
  AuthControllerContext,
  removeInitialAndTrailingSlashes,
  removeInitialSlash,
  removeTrailingSlash,
  addInitialSlash,
  getLastSegment,
  resolveCollectionPathIds,
  getCollectionByPathOrId,
  getCollectionPathsCombinations,
  navigateToEntity,
  EntityReference,
  GeoPoint,
  Vector,
  pick,
  isObject4 as isObject,
  mergeDeep2 as mergeDeep,
  getValueInPath,
  removeInPath,
  removeFunctions,
  getHashValue,
  removeUndefined,
  removeNulls,
  isEmptyObject2 as isEmptyObject,
  removePropsIfExisting,
  isReadOnly,
  isHidden,
  isPropertyBuilder,
  getDefaultValuesFor,
  getDefaultValueFor,
  getDefaultValueForDataType,
  updateDateAutoValues,
  sanitizeData,
  getReferenceFrom,
  traverseValuesProperties,
  traverseValueProperty,
  enumToObjectEntries,
  getLabelOrConfigFrom,
  getColorScheme,
  isEnumValueDisabled,
  buildEnumLabel,
  resolveCollection,
  resolveProperty,
  getArrayResolvedProperties,
  resolveArrayProperty,
  resolveProperties,
  resolvePropertyEnum,
  resolveEnumValues,
  resolveEntityView,
  resolvedSelectedEntityView,
  sortProperties,
  resolveDefaultSelectedView,
  applyPermissionsFunctionIfEmpty,
  toKebabCase,
  toSnakeCase,
  randomString2 as randomString,
  randomColor,
  slugify,
  unslugify,
  defaultDateFormat,
  COLLECTION_PATH_SEPARATOR,
  stripCollectionPath,
  segmentsToStrippedPath,
  fullPathToCollectionSegments,
  serializeRegExp,
  hydrateRegExp,
  isValidRegExp,
  mergeEntityActions,
  useDebouncedCallback,
  isReferenceProperty,
  getIdIcon,
  getIconForWidget,
  getIconForProperty,
  getColorForProperty,
  getPropertyInPath,
  getResolvedPropertyInPath,
  getBracketNotation,
  getPropertiesWithPropertiesOrder,
  getDefaultPropertiesOrder,
  resolvePermissions,
  canEditEntity,
  canCreateEntity,
  canDeleteEntity,
  iconSynonyms,
  iconsSearch,
  getIcon,
  IconForView,
  plural,
  singular,
  getEntityPreviewKeys,
  getEntityTitlePropertyKey,
  getEntityImagePreviewPropertyKey,
  flattenObject,
  getArrayValuesCount,
  makePropertiesEditable,
  makePropertiesNonEditable,
  joinCollectionLists,
  mergeCollection,
  buildCollection,
  buildProperty,
  buildProperties,
  buildPropertiesOrBuilder,
  buildEnumValues,
  buildEnumValueConfig,
  buildEntityCallbacks,
  buildAdditionalFieldDelegate,
  buildFieldConfig,
  printChanged,
  useTraceUpdate,
  resolveStorageFilenameString,
  resolveStoragePathString,
  useDataSource,
  useNavigationController,
  useAuthController,
  useSideDialogsController,
  useSideEntityController,
  useStorageSource,
  useSnackbarController,
  useDialogsController,
  useCustomizationController,
  useFireCMSContext,
  useCollectionFetch,
  useEntityFetch,
  saveEntityWithCallbacks,
  deleteEntityWithCallbacks,
  resolveNavigationFrom,
  useResolvedNavigationFrom,
  useModeController,
  useClipboard,
  useLargeLayout,
  ErrorView,
  EmptyValue,
  ImagePreview,
  UrlComponentPreview,
  SkeletonPropertyComponent,
  renderSkeletonImageThumbnail,
  renderSkeletonText,
  renderSkeletonCaptionText,
  renderSkeletonIcon,
  StorageThumbnail,
  StorageThumbnailInternal,
  EnumValuesChip,
  StringPropertyPreview,
  ArrayPropertyPreview,
  ReferencePreview,
  ArrayOfReferencesPreview,
  ArrayOfStorageComponentsPreview,
  ArrayEnumPreview,
  ArrayPropertyEnumPreview,
  ArrayOfStringsPreview,
  ArrayOneOfPreview,
  MapPropertyPreview,
  KeyValuePreview,
  DatePreview,
  BooleanPreview,
  NumberPropertyPreview,
  PropertyPreview,
  ArrayOfMapsPreview,
  AsyncPreviewComponent,
  EntityView,
  ErrorBoundary2 as ErrorBoundary,
  SelectableTableContext,
  useSelectableTableController,
  useClearRestoreValue,
  PropertyTableCell,
  EntityCollectionRowActions,
  COLLECTION_GROUP_PARENT_ID,
  useColumnIds,
  getColumnKeysForProperty,
  getFormFieldKeys,
  buildIdColumn,
  propertiesToColumns,
  CircularProgressCenter,
  VirtualTable,
  SelectableTable,
  EntityCollectionTable,
  useDebouncedData,
  useDataSourceTableController,
  useSelectionController,
  useTableSearchHelper,
  editEntityAction,
  copyEntityAction,
  deleteEntityAction,
  ReferenceSelectionTable,
  NavigationGroup,
  NavigationCard,
  SmallNavigationCard,
  NavigationCardBinding,
  DefaultHomePage,
  EntityCollectionViewActions,
  EntityForm,
  yupToFormErrors,
  FieldHelperText,
  LabelWithIcon,
  PropertyIdCopyTooltip,
  PropertyIdCopyTooltipContent,
  LabelWithIconAndTooltip,
  FormEntry,
  FormLayout,
  SelectFieldBinding,
  MultiSelectFieldBinding,
  ArrayOfReferencesFieldBinding,
  StorageUploadFieldBinding,
  TextFieldBinding,
  SwitchFieldBinding,
  DateTimeFieldBinding,
  ReadOnlyFieldBinding,
  ReferenceFieldBinding,
  PropertyFieldBinding,
  MapFieldBinding,
  KeyValueFieldBinding,
  RepeatFieldBinding,
  BlockFieldBinding,
  MarkdownEditorFieldBinding,
  ArrayCustomShapedFieldBinding,
  EntityCollectionView,
  PropertyConfigBadge,
  NotFoundPage,
  ConfirmationDialog,
  FireCMSLogo,
  AppContext2 as AppContext,
  useApp,
  DefaultAppBar,
  ArrayContainer,
  ArrayContainerItem,
  ArrayItemOptions,
  getRandomId,
  ReferenceWidget,
  SearchIconsView,
  FieldCaption,
  useReferenceDialog,
  useBrowserTitleAndIcon,
  useBuildNavigationController,
  useBuildLocalConfigurationPersistence,
  useBuildModeController,
  useValidateAuthenticator,
  useSideDialogContext,
  SideDialogs,
  FireCMS,
  DrawerNavigationItem,
  DefaultDrawer,
  DrawerLogo,
  isDefaultFieldConfigId,
  DEFAULT_FIELD_CONFIGS,
  getDefaultFieldConfig,
  getFieldConfig,
  getDefaultFieldId,
  getFieldId,
  NavigationRoutes,
  FireCMSRouter,
  Drawer,
  AppBar,
  DRAWER_WIDTH,
  Scaffold
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.23.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/index.js:
  (**
   * React Router v6.30.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.30.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

prism-react-renderer/dist/index.mjs:
  (*! Bundled license information:
  
  prismjs/prism.js:
    (**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     *)
  *)
*/
//# sourceMappingURL=chunk-7PVLFHES.js.map
